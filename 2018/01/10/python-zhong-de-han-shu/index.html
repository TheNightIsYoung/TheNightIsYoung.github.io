<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Python 中的函数 - When Art Meets Tech</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="When Art Meets Tech"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="When Art Meets Tech"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta description="程序语言中的，编写代码要不断追求简洁和易读。换句话说，我们要尽量避免写重复的代码，少复制粘贴，也就是所谓的 DRY 原则（Don’t Repeat Yourself）。而 函数 的作用就是用来 提高程序的模块性，和代码的重复利用率。接下来我们详细解读 Python 中函数的使用。"><meta property="og:type" content="blog"><meta property="og:title" content="Python 中的函数"><meta property="og:url" content="https://www.orangeshare.cn/2018/01/10/python-zhong-de-han-shu/"><meta property="og:site_name" content="When Art Meets Tech"><meta property="og:description" content="程序语言中的，编写代码要不断追求简洁和易读。换句话说，我们要尽量避免写重复的代码，少复制粘贴，也就是所谓的 DRY 原则（Don’t Repeat Yourself）。而 函数 的作用就是用来 提高程序的模块性，和代码的重复利用率。接下来我们详细解读 Python 中函数的使用。"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://www.orangeshare.cn/img/og_image.png"><meta property="article:published_time" content="2018-01-10T07:40:29.000Z"><meta property="article:modified_time" content="2022-03-20T06:12:28.392Z"><meta property="article:author" content="Waldeinsamkeit"><meta property="article:tag" content="Python"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.orangeshare.cn/2018/01/10/python-zhong-de-han-shu/"},"headline":"When Art Meets Tech","image":["https://www.orangeshare.cn/img/og_image.png"],"datePublished":"2018-01-10T07:40:29.000Z","dateModified":"2022-03-20T06:12:28.392Z","author":{"@type":"Person","name":"Waldeinsamkeit"},"description":"程序语言中的，编写代码要不断追求简洁和易读。换句话说，我们要尽量避免写重复的代码，少复制粘贴，也就是所谓的 DRY 原则（Don’t Repeat Yourself）。而 函数 的作用就是用来 提高程序的模块性，和代码的重复利用率。接下来我们详细解读 Python 中函数的使用。"}</script><link rel="canonical" href="https://www.orangeshare.cn/2018/01/10/python-zhong-de-han-shu/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Oxanium:wght@300;400;600&amp;family=Roboto+Mono"><link rel="stylesheet" href="/css/cyberpunk.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/cookieconsent/3.1.1/cookieconsent.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/pace/1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.2.0"></head>    <body class="is-3-column">    <nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="When Art Meets Tech" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Hexo Search" href="https://hexo.io/zh-cn/"><i class="fab fa-hotjar"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="Catalogue" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal"><i class="fas fa-angle-double-right"></i>Python 中的函数</h1><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><i class="far fa-calendar-alt"> </i><time dateTime="${date_xml(page.date)}" title="${date_xml(page.date)}">2018-01-10</time></span><span class="level-item is-hidden-mobile"><i class="far fa-calendar-check"> </i><time dateTime="${date_xml(page.updated)}" title="${date_xml(page.updated)}">2022-03-20</time></span><span class="level-item"><a class="link-muted" href="/categories/Python/">Python</a></span><span class="level-item">an hour read (About 12001 words)</span></div></div><div class="content"><p>程序语言中的，编写代码要不断追求简洁和易读。换句话说，我们要尽量避免写重复的代码，少复制粘贴，也就是所谓的 DRY 原则（Don’t Repeat Yourself）。而 <strong>函数</strong> 的作用就是用来 <strong>提高程序的模块性，和代码的重复利用率</strong>。接下来我们详细解读 Python 中函数的使用。</p>
<a id="more"></a>

<p><strong>引言 &gt;&gt;&gt;&gt;</strong></p>
<p>事实上，前面我们在介绍 Python 基本数据结构时，就已经学习过 Python 中提供的许多内建（内置）函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># input() print() len() type() id() str() ...</span></span><br></pre></td></tr></table></figure>

<p>对于 Python 支持的内建函数，可以直接从 Python 的官方网站查看更详细的文档说明 –&gt; <a target="_blank" rel="noopener" href="https://docs.python.org/zh-cn/3.10/library/functions.html">Python 内置函数（v3.10.3）</a>。</p>
<hr>
<p>当然，根据我们的任务需要自由、灵活、快速的定制我们自己的函数（自定义函数）也是必要的！！！</p>
<p>Python 支持自定义函数（Function），即将一段有规律的、可重复使用的代码封装成函数，从而达到一次编写、多次调用的目的。</p>
<p>不难理解，<strong>函数的本质 &gt;&gt;&gt;&gt;</strong> </p>
<p>是一段有特定功能、可以重复使用的代码，这段代码已经被提前编写好了，并且为其起一个“好听”的名字。在后续编写程序过程中，如果需要同样的功能，直接通过起好的名字就可以调用这段代码。</p>
<hr>
<p>那么，Python 中如何定义一个函数呢 ↓↓↓↓↓</p>
<h2 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h2><p>当我们需要定制一个特定功能的函数时，Python 中需要用 def 关键字实现，具体的语法格式如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> 函数名 (<span class="params">参数列表</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27; 函数说明文档：函数功能说明 &#x27;&#x27;&#x27;</span></span><br><span class="line">    函数体</span><br><span class="line">    [<span class="keyword">return</span> [返回值]]</span><br></pre></td></tr></table></figure>

<p>此格式中，各部分参数的含义如下：</p>
<ul>
<li>函数名：一个符合 Python 语法的标识符，但不建议使用 a、b、c 这类简单的标识符作为函数名，函数名最好能够体现出该函数的功能；</li>
<li>形参列表：设置该函数可以接收多少个参数，多个参数之间用逗号（ , ）分隔；</li>
<li>函数说明文档：函数的第一行语句可以选择性地使用文档字符串用于函数功能说明，非必须（推荐）；</li>
<li>函数体：实现特定功能的多行代码；</li>
<li>return [返回值]：返回可选，可返回值也可返回表达式，函数一旦执行到 <code>return</code> 时，就执行完毕，并将表达式结果返回。如果没有 <code>return</code> 语句或不带表达式的 <code>return</code>，结果相都当于返回 <code>None</code>。</li>
</ul>
<blockquote>
<p>注意，在创建函数时，即使函数不需要参数，也必须保留一对空的 <code>()</code>，否则 Python 解释器将提示 <code>invaild syntax</code> 错误。</p>
</blockquote>
<p>给出一个用于计算矩形面积的函数定义实例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">area</span>(<span class="params">width, height</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; Fun: Calculate the area of ​​a rectangle &quot;&quot;&quot;</span></span><br><span class="line">    print(<span class="string">&quot;width: %d, height: %d&quot;</span> % (width, height)) </span><br><span class="line">    <span class="keyword">return</span> width * height</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="空函数沙发"><a href="#空函数沙发" class="headerlink" title="空函数沙发"></a>空函数沙发</h3><p>要实现一个功能，我还没想好怎么做，先占个沙发以待后续补充开发（借助 pass 函数）:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">nop</span>():</span></span><br><span class="line">    <span class="comment">#TODO balabala</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>这样可以保证代码结构完整性，让代码能运行起来。如果不加会报错：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; def nop():</span></span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 3</span><br><span class="line">    ^</span><br><span class="line">IndentationError: expected an indented block</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="函数文档说明支持"><a href="#函数文档说明支持" class="headerlink" title="函数文档说明支持"></a>函数文档说明支持</h3><p>函数的说明文档，本质就是放于函数内的一段字符串注释。</p>
<p>只不过作为说明文档，字符串的放置位置是有讲究的，函数的说明文档通常位于函数内部、所有代码的最前面 –&gt; 见函数语法规则中的函数说明文档。</p>
<p>这样的话，你可以通过 Python 的 <code>help()</code> 内置函数或者 <code>funName.__doc__</code> 进行查看：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">area</span>(<span class="params">width, height</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot; Fun: Calculate the area of ​​a rectangle &quot;&quot;&quot;</span></span><br><span class="line">    print(<span class="string">&quot;width: %d, height: %d&quot;</span> % (width, height)) </span><br><span class="line">    <span class="keyword">return</span> width * height</span><br><span class="line"></span><br><span class="line"><span class="built_in">help</span>(area)</span><br><span class="line">print(area.__doc__)</span><br></pre></td></tr></table></figure>

<p>输出如下信息：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Help on function area <span class="keyword">in</span> module __main__:</span><br><span class="line"></span><br><span class="line">area(width, height)</span><br><span class="line">    Fun: Calculate the area of ​​a rectangle</span><br><span class="line"></span><br><span class="line"> Fun: Calculate the area of ​​a rectangle</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h2><p>不管是 Python 中提供的内建函数，亦或是上面自定义的函数，只是将特定的功能代码封装了起来，一切都是为了等待调用的。</p>
<p>这就像是神奇宝贝里的精灵球安静地待着，只有听见你的召唤时才会出场，为你所用。</p>
<p>Python 中函数的调用规则都是一样，要想调用一个函数，需要知道函数的名称和需要的参数（出来吧，皮卡丘~）:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[返回值] = 函数名([形参值])</span><br></pre></td></tr></table></figure>

<p>其中，函数名即指的是要调用的函数的名称；形参值指的是当初创建函数时要求传入的各个形参的值。如果该函数有返回值，我们可以通过一个变量来接收该值，当然也可以不接受。</p>
<p>以上面定义好的面积函数来说明 Python 中的函数调用：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">graph_width = <span class="number">10</span></span><br><span class="line">graph_height = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">graph_area = area(graph_width, graph_height)</span><br><span class="line">print(<span class="string">&quot;The area of graph is &quot;</span>,graph_area)</span><br><span class="line"><span class="comment"># Output: The area of graph is  50</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 既可以传递数值，也可以将变量作为参数进行传递</span></span><br><span class="line">area1 = area(<span class="number">10</span>,<span class="number">50</span>)</span><br><span class="line">print(area1)</span><br><span class="line"><span class="comment"># Output: 500</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>需要注意的是，创建函数有多少个形参，那么调用时就需要传入多少个值；并且默认情况下，调用函数时传入的参数（<strong>实参列表</strong>）和参数列表（<strong>形参列表</strong>）会按函数声明中定义的顺序匹配起来（故，形参也被称为 <strong>位置参数</strong>）。即便该函数没有参数，函数名后的小括号也不能省略。</p>
</blockquote>
<hr>
<h3 id="深入理解函数名称"><a href="#深入理解函数名称" class="headerlink" title="深入理解函数名称"></a>深入理解函数名称</h3><p>以我们熟悉的， Python 内置的求绝对值的函数 <code>abs()</code> 为例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; abs(-10)</span></span><br><span class="line">10</span><br></pre></td></tr></table></figure>
<p>你需要使用 <code>abs()</code> 的形式进行函数调用。但你想过没有，如果只写 <code>abs</code> 呢？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">abs</span></span><br><span class="line">&lt;built-<span class="keyword">in</span> function <span class="built_in">abs</span>&gt;</span><br></pre></td></tr></table></figure>

<p>输出信息显示：<code>abs 是一个内置函数</code>。可见，<code>abs()</code> 是函数调用，而 <code>abs</code> 是函数本身。</p>
<p><strong>[1] &gt;&gt;&gt;&gt; 函数别名</strong></p>
<p>由变量可以指向函数调用的返回值，很自然的可以想到，如果把函数本身（函数名）赋值给变量是什么情况？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>fun_test = <span class="built_in">abs</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fun_test</span><br><span class="line">&lt;built-<span class="keyword">in</span> function <span class="built_in">abs</span>&gt;</span><br></pre></td></tr></table></figure>

<p>哎！把函数名赋值给变量后（变量指向函数本身），好像给这个函数起了一个 <strong>“别名”</strong>。</p>
<p>同理的话，验证一下 &gt;&gt;&gt;&gt; 是否可以通过该变量来调用这个函数</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>fun_test = <span class="built_in">abs</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fun_test(-<span class="number">10</span>)</span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure>

<p>成功！直接调用 <code>abs()</code> 函数和调用 <code>fun_test()</code> 完全相同。突然又有了个想法：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; id(fun_test)</span></span><br><span class="line">3038282253312</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; id(abs)</span></span><br><span class="line">3038282253312</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; abs</span></span><br></pre></td></tr></table></figure>

<p>哦哦~~~经过小心验证，你可以大胆猜测了 &gt;&gt;&gt;&gt; 函数名其实就是指向一个函数对象的引用</p>
<p><strong>[2] &gt;&gt;&gt;&gt; 函数名是指向函数对象的一个引用</strong></p>
<p>所以，上面完全可以把函数名赋给一个变量，让它们指向同一个函数对象引用，这相当于给这个函数起了一个<strong>“别名”</strong>，但一般禁止这么使用，容易混淆。</p>
<p>又来了个奇怪的想法，既然函数名是一个引用，不就相当于一个变量吗？如果把 <code>abs </code> 指向其他对象，会有什么情况发生？</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">abs</span> = <span class="string">&quot;test&quot;</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">abs</span>(-<span class="number">10</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: <span class="string">&#x27;str&#x27;</span> <span class="built_in">object</span> <span class="keyword">is</span> <span class="keyword">not</span> <span class="built_in">callable</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">abs</span></span><br><span class="line"><span class="string">&#x27;test&#x27;</span></span><br></pre></td></tr></table></figure>

<p>果然，和猜想的差不多！<code>abs </code> 已经不再是指向求绝对值函数对象的引用了，而是变为一个普通的变量了！</p>
<p>当然实际代码绝对不能这么写，这里是为了对比函数调用（<code>abs()</code>）和函数名（<code>abs</code>）的区别。要恢复 <code>abs </code>函数，请重启 Python 交互环境。</p>
<hr>
<h3 id="形参（位置参数）-amp-amp-实参"><a href="#形参（位置参数）-amp-amp-实参" class="headerlink" title="形参（位置参数） &amp;&amp; 实参"></a>形参（位置参数） &amp;&amp; 实参</h3><p>函数调用中有提到，实参列表、形参列表，以及位置参数的说法，到底怎么区分：</p>
<p>形式参数（形参） &gt;&gt;&gt;&gt; 定义函数时，函数名后面括号中的参数就是形式参数（形式上要求的）。</p>
<p>实际参数（实参） &gt;&gt;&gt;&gt; 调用函数时，函数名后面括号中的参数就是形式参数（实际使用时传入的）。</p>
<p>调用函数时，传入的实参列表和函数的形参列表，会按函数声明中定义的顺序匹配起来，故形参也被称为位置参数。</p>
<hr>
<h3 id="参数检查机制"><a href="#参数检查机制" class="headerlink" title="参数检查机制"></a>参数检查机制</h3><p>函数调用时，Python 会自动检查传入参数数量是否正确？传入参数类型是否正确？你需要检查传入参数的顺序是否和形成一致？</p>
<p><strong>[1] &gt;&gt;&gt;&gt; 参数个数检查</strong></p>
<p>调用函数时，必须保证实参和形参数量必须一致。如果参数个数不对，Python 解释器会自动检查出来，并抛出<code>TypeError</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>area(<span class="number">2</span>,<span class="number">3</span>,<span class="number">5</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: area() takes <span class="number">2</span> positional arguments but <span class="number">3</span> were given</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>area(<span class="number">2</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: area() missing <span class="number">1</span> required positional argument: <span class="string">&#x27;height&#x27;</span></span><br></pre></td></tr></table></figure>

<p>可以看到，提示你多出/缺少必要的位置参数。</p>
<p><strong>[2] &gt;&gt;&gt;&gt; 参数位置检查</strong></p>
<p>调用函数时，必须确保实参位置和形式位置顺序一一对应，否则会产生以下 2 种结果：</p>
<p><strong>1）–&gt;</strong> 位置一致，但传入实参类型和形参不匹配，抛出 <code>TypeError</code></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>area(<span class="string">&quot;Google&quot;</span>, <span class="number">12</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">2</span>, <span class="keyword">in</span> area</span><br><span class="line">TypeError: %d <span class="built_in">format</span>: a number <span class="keyword">is</span> required, <span class="keyword">not</span> <span class="built_in">str</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">abs</span>(<span class="string">&quot;A&quot;</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: bad operand <span class="built_in">type</span> <span class="keyword">for</span> <span class="built_in">abs</span>(): <span class="string">&#x27;str&#x27;</span></span><br></pre></td></tr></table></figure>

<p><strong>2）–&gt;</strong> 传入实参类型和形参类型一致，位置不一致，导致函数计算结果和预期不符</p>
<p>这是由于实参和形参会函数声明中定义的顺序进行匹配，此时实参类型和形参类型一致，无法检查出错误，但会导致运行结果和预期不符：</p>
<p>例如，设计一个求梯形面积的函数，并利用此函数求上底为 4cm，下底为 3cm，高为 5cm 的梯形的面积。但如果交互高和下低参数的传入位置，计算结果将导致错误：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">area</span>(<span class="params">upper_base,lower_bottom,height</span>):</span></span><br><span class="line">    <span class="keyword">return</span> (upper_base + lower_bottom)*height/<span class="number">2</span></span><br><span class="line">print(<span class="string">&quot;正确结果为：&quot;</span>, area(<span class="number">4</span>,<span class="number">3</span>,<span class="number">5</span>))</span><br><span class="line">print(<span class="string">&quot;错误结果为：&quot;</span>, area(<span class="number">4</span>,<span class="number">5</span>,<span class="number">3</span>))</span><br></pre></td></tr></table></figure>

<p>也就是说，参数个数以及参数类型 Python 解释器自动会帮你检查，但参数位置需要你自己确保！！！</p>
<p><strong>[3] &gt;&gt;&gt;&gt; 自定义函数参数类型检查</strong></p>
<p>自定义函数时，可以设置对传入参数的类型进行强制检查，只允许符合我们要求的参数传入，这可以防止其他人调用我们自定义的函数时引发类型异常，增强代码的健壮性。</p>
<p>假如只允许整数的参数。数据类型检查可以用内置函数 <code>isinstance()</code> 实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">area</span>(<span class="params">width, height</span>):</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(width, <span class="built_in">int</span>) <span class="keyword">or</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(height,<span class="built_in">int</span>):</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">raise</span> TypeError(<span class="string">&quot;bad operand type for area(int，int)&quot;</span>)</span><br><span class="line"><span class="meta">... </span>    print(<span class="string">&quot;width: %d, height: %d&quot;</span> % (width, height))</span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> width * height</span><br><span class="line">...</span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure>

<p>添加了参数检查后，如果传入错误的参数类型，函数就可以抛出一个错误：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>area(<span class="number">12.0</span>,<span class="number">10</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">3</span>, <span class="keyword">in</span> area</span><br><span class="line">TypeError: bad operand <span class="built_in">type</span> <span class="keyword">for</span> area(<span class="built_in">int</span>，<span class="built_in">int</span>)</span><br></pre></td></tr></table></figure>

<p>关于错误和异常处理将在后续讲到，这里不用深究。</p>
<hr>
<h3 id="参数传递机制"><a href="#参数传递机制" class="headerlink" title="参数传递机制"></a>参数传递机制</h3><p>大多数的编程语言中，说到函数中的参数传递，就会谈到值传递 &amp;&amp; 引用传递，关于 Python 中的参数传递机制也是众说纷纭，但主流有两种想法：</p>
<p><strong>[1] &gt;&gt;&gt;&gt;</strong> 值传递和引用（地址）传递</p>
<ul>
<li>值传递：适用于实参类型为不可变类型（字符串、数字、元组）；</li>
<li>引用（地址）传递：适用于实参类型为可变类型（列表，字典）。</li>
</ul>
<p>值传递和引用传递理解和 C/C++、Java 类似，函数参数进行值传递后，若形参的值发生改变，不会影响实参的值；而函数参数继续引用传递后，改变形参的值，实参的值也会一同改变。</p>
<p><strong>[2] &gt;&gt;&gt;&gt; 引用传递（个人理解）</strong></p>
<p>基本数据类型时就提过，Python 中一切皆对象，变量是没有类型的，类型属于对象（变量所指向的内存数据）。例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">test = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">test = <span class="string">&quot;HelloPython&quot;</span></span><br></pre></td></tr></table></figure>

<p>以上代码中，<code>[1,2,3]</code> 是 List 类型，<code>&quot;HelloPython&quot;</code> 是 String 类型，而变量 <code>test</code> 是没有类型，它仅仅是一个对象的引用（一个指针），可以是指向 List 类型对象，也可以是指向 String 类型对象。</p>
<p>所以，变量参数传递时，就是引用的传递，不同的是，由于指向内存单元数据对象类型（可变与不可变对象）的不同导致不同的结果：</p>
<ul>
<li><p>可变对象：由于引用指向列表，字典，集合等可变对象，故改变形参的值，实参的值也会一同改变；</p>
</li>
<li><p>不可变对象：由于引用指向字符串、数字、元组等可变对象，故改变形参的值，实参的值不受影响。</p>
</li>
</ul>
<p>实例印证：</p>
<p>传递不可变对象实例 &gt;&gt;&gt;&gt;</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">ChangeInt</span>(<span class="params">test</span>):</span></span><br><span class="line"><span class="meta">... </span>    test = <span class="number">10</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>test = <span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>ChangeInt(test)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(test)</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>

<p>传递可变对象实例 &gt;&gt;&gt;&gt;</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">changeme</span>(<span class="params"> mylist </span>):</span></span><br><span class="line"><span class="meta">... </span>   <span class="string">&quot;修改传入的列表&quot;</span></span><br><span class="line"><span class="meta">... </span>   mylist.append([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>])</span><br><span class="line"><span class="meta">... </span>   <span class="built_in">print</span> (<span class="string">&quot;函数内取值: &quot;</span>, mylist)</span><br><span class="line"><span class="meta">... </span>   <span class="keyword">return</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>mylist = [<span class="number">10</span>,<span class="number">20</span>,<span class="number">30</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>changeme( mylist )</span><br><span class="line">函数内取值:  [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">print</span> (<span class="string">&quot;函数外取值: &quot;</span>, mylist)</span><br><span class="line">函数外取值:  [<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>]]</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="return-表达式"><a href="#return-表达式" class="headerlink" title="return [表达式]"></a>return [表达式]</h3><p>我们知道，当程序执行到 <code>return [表达式]</code> 时标志函数执行完成，用于将表达式结果（任意数据类型）进行返回。</p>
<blockquote>
<p>需要注意的是，return 语句在同一函数中可以出现多次，但只要有一个得到执行，就会直接结束函数的执行。</p>
</blockquote>
<p><strong>[1] &gt;&gt;&gt;&gt; return None 隐含机制</strong></p>
<p>如果函数中没有 <code>return [表达式]</code> 语句或者单独的 <code>return</code> 或者 <code>return None</code>，函数都返回是一个 None。</p>
<p>也就说没有返回值语句时，Python 解释器会自动帮你返回 <code>None</code>。</p>
<p>–&gt; 思考，函数可以返回多个值吗？答案是肯定的。</p>
<p><strong>[2] &gt;&gt;&gt;&gt; return 返回多个值</strong></p>
<p>实现 Python 函数返回多个值，有以下 2 种方式：</p>
<ul>
<li>在函数中，提前将要返回的多个值存储到一个列表或元组中，然后函数返回该列表或元组；</li>
<li>函数直接返回多个值，之间用逗号（ , ）分隔，Python 会自动将多个值封装到一个元组中，其返回值仍是一个元组。</li>
</ul>
<p>程序演示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">retu_list</span>():</span></span><br><span class="line">    add = [<span class="string">&quot;Python&quot;</span>, <span class="string">&quot;C/C++&quot;</span>, <span class="string">&quot;Java&quot;</span>]</span><br><span class="line">    <span class="keyword">return</span> add</span><br><span class="line">print(<span class="string">&quot;retu_list: &quot;</span>, retu_list())</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">retu_tuple</span>():</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Python&quot;</span>, <span class="string">&quot;C/C++&quot;</span>, <span class="string">&quot;Java&quot;</span></span><br><span class="line">print(<span class="string">&quot;retu_tuple: &quot;</span>, retu_tuple())</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># retu_list:  [&#x27;Python&#x27;, &#x27;C/C++&#x27;, &#x27;Java&#x27;]</span></span><br><span class="line"><span class="comment"># retu_tuple:  (&#x27;Python&#x27;, &#x27;C/C++&#x27;, &#x27;Java&#x27;)</span></span><br></pre></td></tr></table></figure>

<p>序列解包方式接收多个返回值 &gt;&gt;&gt;&gt;</p>
<p>可以直接使用序列元素个数对应数量的变量，接收函数返回列表或元组中的多个值：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">retu_tuple</span>():</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Python&quot;</span>, <span class="string">&quot;C/C++&quot;</span>, <span class="string">&quot;Java&quot;</span></span><br><span class="line"></span><br><span class="line">p,c,j = retu_tuple()</span><br><span class="line">print(<span class="string">&quot;retu_tuple: ( %s, %s, %s&quot;</span> % (p,c,j), <span class="string">&quot;)&quot;</span>)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="函数参数列表详解"><a href="#函数参数列表详解" class="headerlink" title="函数参数列表详解"></a>函数参数列表详解</h2><p>Python 的函数定义非常简单，但由于参数列表的多种定义方式，灵活度却非常大。参数列表支持的参数类型定义：</p>
<ul>
<li>位置参数</li>
<li>关键字参数</li>
<li>默认参数</li>
<li>不定长参数</li>
</ul>
<p>这些参数形式的引入，使得不仅能处理比较复杂的参数使用场景，还可以极大的简化调用者的代码。</p>
<h3 id="位置参数"><a href="#位置参数" class="headerlink" title="位置参数"></a>位置参数</h3><p>位置参数详细说明可见 【形参（位置参数） &amp;&amp; 实参】 和 【参数检查机制】 小节说明。</p>
<p>目前，我们调用函数时所用的参数都是位置参数，即传入函数的实际参数必须与形式参数的数量和位置必须一一对应（需要人为参与）。</p>
<p>不知道你有没有这种感觉，按顺序给参数传入数值总是感觉不太靠谱，一旦疏忽搞错怎么办？ &gt;&gt;&gt;&gt; 关键字参数。</p>
<hr>
<h3 id="关键字参数"><a href="#关键字参数" class="headerlink" title="关键字参数"></a>关键字参数</h3><p>关键字参数，是指使用形式列表中参数的名字来 “绑定” 实参列表中输入的参数值。</p>
<p>通过此方式指定函数实参时，不再需要与形参的位置完全一致，只要将参数名写正确即可。</p>
<p><strong>[1] 使用关键字参数传参 &gt;&gt;&gt;&gt;</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; def move(start_x, start_y, step):</span></span><br><span class="line">...     end_x = start_x + step</span><br><span class="line">...     end_y = start_y + step</span><br><span class="line">...     return end_x, end_y</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; move(start_x=2, start_y=3, step=2)</span></span><br><span class="line">(4, 5)</span><br></pre></td></tr></table></figure>

<p><strong>[2] 使用位置 &amp;&amp; 关键字参数混合传参 &gt;&gt;&gt;&gt;</strong></p>
<p>你还可以使用位置参数和关键字参数混合传参的方式：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; move(2,3, step=2)</span></span><br><span class="line">(4, 5)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 这样是不允许的：（move(2,1, start_y=3)）</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 认为你传入了两个 start_y</span></span><br></pre></td></tr></table></figure>

<p>需要注意，混合传参时 <strong>关键字参数必须位于所有的位置参数之后</strong> 。否则，会产生错误：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SyntaxError: positional argument follows keyword argument</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><p>如果函数参数列表中的某个参数的值很少发生变化，为了避免每次都传同样的值，可以使用默认参数（函数定义时给出参数默认值），以达到简化函数调用的目的。语法规则如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> 函数名(<span class="params">...，形参名，形参名=默认值</span>)：</span></span><br><span class="line"><span class="function">    代码块</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，使用此格式定义函数时，指定有默认值的形式参数必须在所有没默认值参数的最后，否则会产生语法错误。</p>
</blockquote>
<p>以下实例中，<strong>step</strong> 为默认参数，调用时如果没有传入 <code>step</code> 参数，则使用默默认值：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; def move(start_x, start_y, step=1):</span></span><br><span class="line">...     end_x = start_x + step</span><br><span class="line">...     end_y = start_y + step</span><br><span class="line">...     return end_x, end_y</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; move(2,3)</span></span><br><span class="line">(3, 4)</span><br></pre></td></tr></table></figure>

<p>这样，当我们调用 <code>move(2, 3)</code> 时，相当于调用了 <code>move(2, 3，1)</code>。</p>
<p>使用默认参数时，也要符合位置参数 &amp;&amp; 关键字参数规则：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; move(2,3)</span></span><br><span class="line"><span class="meta">&gt;</span></span><br><span class="line"><span class="bash">&gt;&gt;&gt; move(2,1,start_y=3) <span class="comment"># 这是不允许的</span></span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</span><br><span class="line">TypeError: move() got multiple values for argument &#x27;start_y&#x27;</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; move(start_x=2,start_y=3,step=1)</span></span><br><span class="line">(3, 4)</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; move(2,3,step=1)</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">(3, 4)</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="默认参数设置原则"><a href="#默认参数设置原则" class="headerlink" title="默认参数设置原则"></a>默认参数设置原则</h4><p>使用默认参数时，要注意：</p>
<ul>
<li>有默认值的形式参数必须在所有没默认值参数的最后，否则会产生语法错误；</li>
<li>当函数有多个参数时，把变化大的参数放前面，变化小的参数放后面。变化小的参数就可以作为默认参数。</li>
</ul>
<p>来看一个运用实例：</p>
<p>写个北京市一年级小学生注册的函数，需要传入名字和性别两个参数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">enroll</span>(<span class="params">name, gender</span>):</span></span><br><span class="line">    print(<span class="string">&#x27;name:&#x27;</span>, name)</span><br><span class="line">    print(<span class="string">&#x27;gender:&#x27;</span>, gender)</span><br></pre></td></tr></table></figure>

<p>如果要继续传入年龄、城市等信息怎么办？这样会使得调用函数的复杂度大大增加。此时，我们可以把年龄和城市设为默认参数（变化小）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">enroll</span>(<span class="params">name, gender, age=<span class="number">8</span>, city=<span class="string">&#x27;Beijing&#x27;</span></span>):</span></span><br><span class="line">    print(<span class="string">&#x27;name:&#x27;</span>, name)</span><br><span class="line">    print(<span class="string">&#x27;gender:&#x27;</span>, gender)</span><br><span class="line">    print(<span class="string">&#x27;age:&#x27;</span>, age)</span><br><span class="line">    print(<span class="string">&#x27;city:&#x27;</span>, city)</span><br></pre></td></tr></table></figure>

<p>这样，大多数学生注册时不需要提供年龄和城市，只提供必须的两个参数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>enroll(<span class="string">&#x27;Sarah&#x27;</span>, <span class="string">&#x27;F&#x27;</span>)</span><br><span class="line">name: Sarah</span><br><span class="line">gender: F</span><br><span class="line">age: <span class="number">8</span></span><br><span class="line">city: Beijing</span><br></pre></td></tr></table></figure>

<p>只有与默认参数不符（飞北京，不是 8 岁入学）的学生才需要提供额外的信息：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">enroll(<span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="number">7</span>)</span><br><span class="line">enroll(<span class="string">&#x27;Adam&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, city=<span class="string">&#x27;Tianjin&#x27;</span>)</span><br><span class="line">enroll(<span class="string">&#x27;Adam&#x27;</span>, <span class="string">&#x27;M&#x27;</span>, <span class="number">9</span>, city=<span class="string">&#x27;Tianjin&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>可见，默认参数降低了函数调用的难度，而一旦需要更复杂的调用时，又可以传递更多的参数来实现。无论是简单调用还是复杂调用，函数只需要定义一个。</p>
<hr>
<h4 id="默认参数必须指向不可变对象"><a href="#默认参数必须指向不可变对象" class="headerlink" title="默认参数必须指向不可变对象"></a>默认参数必须指向不可变对象</h4><p>默认参数的很有用，但使用不当，也会掉坑里….默认参数有个最大的坑</p>
<p>先定义一个带有默认参数空 <code>list</code> 的函数，调用方法会添加一个 <code>END</code> 再返回:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_end</span>(<span class="params">L=[]</span>):</span></span><br><span class="line">    L.append(<span class="string">&#x27;END&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> L</span><br></pre></td></tr></table></figure>

<p>当你正常调用时，结果似乎不错：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>add_end([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="string">&#x27;END&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>add_end([<span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;z&#x27;</span>])</span><br><span class="line">[<span class="string">&#x27;x&#x27;</span>, <span class="string">&#x27;y&#x27;</span>, <span class="string">&#x27;z&#x27;</span>, <span class="string">&#x27;END&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>当你使用默认参数调用时，一开始结果也是对的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>add_end()</span><br><span class="line">[<span class="string">&#x27;END&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>但是，再次调用<code>add_end()</code>时，结果就不对了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>add_end()</span><br><span class="line">[<span class="string">&#x27;END&#x27;</span>, <span class="string">&#x27;END&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>add_end()</span><br><span class="line">[<span class="string">&#x27;END&#x27;</span>, <span class="string">&#x27;END&#x27;</span>, <span class="string">&#x27;END&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>很多初学者很疑惑，默认参数是<code>[]</code>，但是函数似乎每次都“记住了”上次添加了 <code>&#39;END&#39;</code> 后的 list。还记得我们前面在参数传递中说过的可变类型对象的传递么？原因正在这里。</p>
<p>定义默认参数要牢记一点：默认参数必须指向不变对象！要修改上面的例子，我们可以用 <code>None</code> 这个不变对象来实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_end</span>(<span class="params">L=<span class="literal">None</span></span>):</span></span><br><span class="line">    <span class="keyword">if</span> L <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        L = []</span><br><span class="line">    L.append(<span class="string">&#x27;END&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> L</span><br></pre></td></tr></table></figure>

<p>现在，无论调用多少次，都不会有问题：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>add_end()</span><br><span class="line">[<span class="string">&#x27;END&#x27;</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>add_end()</span><br><span class="line">[<span class="string">&#x27;END&#x27;</span>]</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="不定长参数"><a href="#不定长参数" class="headerlink" title="不定长参数"></a>不定长参数</h3><p>有些时候，你可能需要一个函数能够处理比当初声明时更多的参数，也就是说，定义时我们无法明确参数的个数。</p>
<p>以一个计算 <code>a1 + a2 + a3 + …… +a_n</code>（n 个数的和）的样例来说明：</p>
<p>要定义出这个函数，按照之前的规则，我们必须确定输入的参数。但由于参数个数不确定（不知道具体要算几个数的和），所以我们首先想到可以把 <code>a1，a2，a3……</code> 作为一个 list  或 tuple 传进来，这样，函数可以定义如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc</span>(<span class="params">numbers</span>):</span></span><br><span class="line">    <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> numbers:</span><br><span class="line">        <span class="built_in">sum</span> = <span class="built_in">sum</span> + n * n</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span></span><br></pre></td></tr></table></figure>

<p>这种方法，调用的时候，我们需要先组装出一个 list 或 tuple，然后传入 <code>calc</code> 函数，比较麻烦以及浪费资源的。</p>
<p>在 Python 中，支持定义可变参数（不定长参数）的函数，即传入函数中的实际参数可以是任意多个。</p>
<p>Python 定义不定长，有以下 2 种形式（名字自己起的哈）:</p>
<ul>
<li>元组型不定长非关键字实参；</li>
<li>字典型不定长关键字实参。</li>
</ul>
<hr>
<h4 id="元组型不定长非关键字实参"><a href="#元组型不定长非关键字实参" class="headerlink" title="元组型不定长非关键字实参"></a>元组型不定长非关键字实参</h4><p>此种形式的语法格式如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*args</span><br></pre></td></tr></table></figure>

<p>*args 表示创建一个名为 args 的空元组，该元组可接受任意多个（不定长）外界传入的非关键字实参。</p>
<p>程序演示了如何定义一个参数可变的函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc</span>(<span class="params">arg1, *numbers</span>):</span></span><br><span class="line">    <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> numbers:</span><br><span class="line">        <span class="built_in">sum</span> = <span class="built_in">sum</span> + n * n</span><br><span class="line">    print(arg1)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span></span><br></pre></td></tr></table></figure>

<p>上面程序中，calc() 函数的最后一个参数就是 numbers 元组，这样在调用该函数时，除了前面位置参数接收对应位置的实参外，其它非关键字参数都会由 numbers 元组接收。</p>
<p>当然，可变参数并不一定必须为最后一个函数参数，例如修改 calc() 函数为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calc</span>(<span class="params">*numbers, arg1</span>):</span></span><br><span class="line">    <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> n <span class="keyword">in</span> numbers:</span><br><span class="line">        <span class="built_in">sum</span> = <span class="built_in">sum</span> + n * n</span><br><span class="line">    print(arg1)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span></span><br></pre></td></tr></table></figure>

<p>numbers 可变参数作为 calc() 函数的第一个参数。需要注意的是，在调用该函数时，必须以关键字参数的形式给普通参数传值，否则 Python 解释器会把所有参数都优先传给可变参数，如果普通参数没有默认值，就会报错。</p>
<p>| &gt;&gt;&gt;&gt; =======================================================</p>
<p>重新认识 print() 函数，查看 print() 函数文档：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(*objects, sep = <span class="string">&#x27; &#x27;</span>, end = <span class="string">&#x27;\n&#x27;</span>, file = sys.stdout, flush = <span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<p>可以看到第一个参数 <strong>objects</strong> 带了 * 号，为不定长参数 –&gt; 这也是为什么 print() 函数可以传递任意数量的参数。其余四个为默认参数，我们可以通过修改默认值来改变参数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">&#x27;金枪鱼&#x27;</span>, <span class="string">&#x27;三文鱼&#x27;</span>, <span class="string">&#x27;鲷鱼&#x27;</span>, sep = <span class="string">&#x27;+&#x27;</span>, end = <span class="string">&#x27;=?&#x27;</span>)</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="字典型不定长关键字实参"><a href="#字典型不定长关键字实参" class="headerlink" title="字典型不定长关键字实参"></a>字典型不定长关键字实参</h4><p>此种形式的语法格式如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">**kwargs</span><br></pre></td></tr></table></figure>

<p>**kwargs 表示创建一个名为 kwargs 的空字典，该字典可接受任意多个（不定长）外界传入以关键字参数赋值的实参。</p>
<p>这种方法允许你传入 0 个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个 dict。请看示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">person</span>(<span class="params">name, age, **vardict</span>):</span></span><br><span class="line"><span class="meta">... </span>    print(<span class="string">&#x27;name:&#x27;</span>, name, <span class="string">&#x27;age:&#x27;</span>, age, <span class="string">&#x27;other:&#x27;</span>, vardict)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>函数 <code>person</code> 除了位置参数 <code>name</code> 和 <code>age</code> 外，还接受关键字参数 <code>vardict</code>。在调用该函数时，可以只传入位置参数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>person(<span class="string">&quot;Opera&quot;</span>,<span class="number">35</span>)</span><br><span class="line">name: Opera age: <span class="number">35</span> other: &#123;&#125;</span><br></pre></td></tr></table></figure>

<p>也可以同时传入任意个数的关键字实参：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>person(<span class="string">&quot;Google&quot;</span>,<span class="number">23</span>,city=<span class="string">&quot;Beijing&quot;</span>,job=<span class="string">&quot;IT&quot;</span>)</span><br><span class="line">name: Google age: <span class="number">23</span> other: &#123;<span class="string">&#x27;city&#x27;</span>: <span class="string">&#x27;Beijing&#x27;</span>, <span class="string">&#x27;job&#x27;</span>: <span class="string">&#x27;IT&#x27;</span>&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="参数混合"><a href="#参数混合" class="headerlink" title="参数混合"></a>参数混合</h3><p>在 Python 中定义函数，可以使用位置参数、默认参数、、关键字参数、不定长参数，并且这 4 种参数都可以组合使用，例如如下代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义了支持参数收集的函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dis_str</span>(<span class="params">home,*<span class="built_in">str</span>,**course</span>) :</span></span><br><span class="line">    print(home)</span><br><span class="line">    print(<span class="built_in">str</span>)</span><br><span class="line">    print(course)</span><br><span class="line"><span class="comment">#调用函数</span></span><br><span class="line">dis_str(<span class="string">&quot;home_test&quot;</span>,\</span><br><span class="line">        <span class="string">&quot;str_1&quot;</span>,\</span><br><span class="line">        <span class="string">&quot;str_2&quot;</span>,\</span><br><span class="line">        shell=<span class="string">&quot;course_1&quot;</span>,\</span><br><span class="line">        go=<span class="string">&quot;course_2&quot;</span>,\</span><br><span class="line">        java=<span class="string">&quot;course_1&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>程序输出结果为：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">home_test</span><br><span class="line">(&#x27;str_1&#x27;, &#x27;str_2&#x27;)</span><br><span class="line">&#123;&#x27;shell&#x27;: &#x27;course_1&#x27;, &#x27;go&#x27;: &#x27;course_2&#x27;, &#x27;java&#x27;: &#x27;course_1&#x27;&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="序列支持向函数传参"><a href="#序列支持向函数传参" class="headerlink" title="序列支持向函数传参"></a>序列支持向函数传参</h3><p>我们知道，Python 支持定义具有可变参数的函数，即该函数可以接收任意多个参数，其中非关键字参数会集中存储到元组参数（*args）中，而关键字参数则集中存储到字典参数（**kwargs）中，这个过程可称为参数收集。</p>
<p>不仅如此，Python 还支持逆向参数收集，即直接将列表、元组、字典作为函数参数，Python 会将其进行拆分，把其中存储的元素按照次序分给函数中的各个形参。</p>
<p>在以逆向参数收集的方式向函数参数传值时，Pyhon 语法规定，当传入列表或元组时，其名称前要带一个 <code>*</code> 号，当传入字典时，其名称前要带有 2 个 <code>*</code> 号。</p>
<p><strong>[1] &gt;&gt;&gt;&gt; 向定长形参列表传参</strong></p>
<p>举个例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dis_str</span>(<span class="params">name,add</span>) :</span></span><br><span class="line">    print(<span class="string">&quot;name:&quot;</span>,name)</span><br><span class="line">    print(<span class="string">&quot;add&quot;</span>,add)</span><br><span class="line">data = [<span class="string">&quot;Python教程&quot;</span>,<span class="string">&quot;http://c.biancheng.net/python/&quot;</span>]</span><br><span class="line"><span class="comment"># 使用逆向参数收集方式传值</span></span><br><span class="line">dis_str(*data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"><span class="comment"># name: Python教程</span></span><br><span class="line"><span class="comment"># add http://c.biancheng.net/python/</span></span><br></pre></td></tr></table></figure>

<p><strong>[2] &gt;&gt;&gt;&gt; 向不定长形参列表传参</strong></p>
<p>以逆向参数收集的方式，还可以给拥有可变参数的函数传参，例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dis_str</span>(<span class="params">name,*add</span>) :</span></span><br><span class="line">    print(<span class="string">&quot;name:&quot;</span>,name)</span><br><span class="line">    print(<span class="string">&quot;add:&quot;</span>,add)</span><br><span class="line">data = [<span class="string">&quot;http://c.biancheng.net/python/&quot;</span>,\</span><br><span class="line">        <span class="string">&quot;http://c.biancheng.net/shell/&quot;</span>,\</span><br><span class="line">        <span class="string">&quot;http://c.biancheng.net/golang/&quot;</span>]</span><br><span class="line"><span class="comment">#使用逆向参数收集方式传值</span></span><br><span class="line">dis_str(<span class="string">&quot;Python教程&quot;</span>,*data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"><span class="comment"># name: Python教程</span></span><br><span class="line"><span class="comment"># add: (&#x27;http://c.biancheng.net/python/&#x27;, &#x27;http://c.biancheng.net/shell/&#x27;, &#x27;http://c.biancheng.net/golang/&#x27;)</span></span><br></pre></td></tr></table></figure>

<p>同样的，你可以执行下面代码，可上述输出一样（比较一下差别）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dis_str</span>(<span class="params">name,*add</span>) :</span></span><br><span class="line">    print(<span class="string">&quot;name:&quot;</span>,name)</span><br><span class="line">    print(<span class="string">&quot;add:&quot;</span>,add)</span><br><span class="line">data = [<span class="string">&quot;Python教程&quot;</span>,\</span><br><span class="line">        <span class="string">&quot;http://c.biancheng.net/python/&quot;</span>,\</span><br><span class="line">        <span class="string">&quot;http://c.biancheng.net/shell/&quot;</span>,\</span><br><span class="line">        <span class="string">&quot;http://c.biancheng.net/golang/&quot;</span>]</span><br><span class="line"><span class="comment">#使用逆向参数收集方式传值</span></span><br><span class="line">dis_str(*data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"><span class="comment"># name: Python教程</span></span><br><span class="line"><span class="comment"># add: (&#x27;http://c.biancheng.net/python/&#x27;, &#x27;http://c.biancheng.net/shell/&#x27;, &#x27;http://c.biancheng.net/golang/&#x27;)</span></span><br></pre></td></tr></table></figure>

<p>| &gt;&gt;&gt;&gt; ======================================================</p>
<p>使用逆向参数收集的方式，必须注意 <code>*</code> 号的添加。以逆向收集列表列表为例，如果传参时其列表名前不带 <code>*</code> 号，则 Python 解释器会将整个列表作为参数传递给一个参数。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">dis_str</span>(<span class="params">name,*add</span>) :</span></span><br><span class="line">    print(<span class="string">&quot;name:&quot;</span>,name)</span><br><span class="line">    print(<span class="string">&quot;add:&quot;</span>,add)</span><br><span class="line">data = [<span class="string">&quot;Python教程&quot;</span>,\</span><br><span class="line">        <span class="string">&quot;http://c.biancheng.net/python/&quot;</span>,\</span><br><span class="line">        <span class="string">&quot;http://c.biancheng.net/shell/&quot;</span>,\</span><br><span class="line">        <span class="string">&quot;http://c.biancheng.net/golang/&quot;</span>]</span><br><span class="line">dis_str(data)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出</span></span><br><span class="line"><span class="comment"># name: [&#x27;Python教程&#x27;, &#x27;http://c.biancheng.net/python/&#x27;, &#x27;http://c.biancheng.net/shell/&#x27;, &#x27;http://c.biancheng.net/golang/&#x27;]</span></span><br><span class="line"><span class="comment"># add: ()</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="函数间协作"><a href="#函数间协作" class="headerlink" title="函数间协作"></a>函数间协作</h2><p>上面，我们使用函数来封装具有独立功能的代码模块，实际编程时，一个程序往往是通过多个函数的配合来实现的。</p>
<h3 id="浅析变量作用域"><a href="#浅析变量作用域" class="headerlink" title="浅析变量作用域"></a>浅析变量作用域</h3><p>当多个函数同时运行时，就涉及函数中一个非常重要的概念 —— 变量作用域（Vars Scope）。</p>
<h4 id="全局变量-amp-amp-局部变量"><a href="#全局变量-amp-amp-局部变量" class="headerlink" title="全局变量 &amp;&amp; 局部变量"></a>全局变量 &amp;&amp; 局部变量</h4><p>先来看一个例子：</p>
<p>月底了，身为老板的你要核算成本来调整经营策略，假设餐馆的成本是由固定成本（租金）和变动成本（水电费 + 食材成本）构成的。</p>
<p>那么我们可以分别编写一个计算变动成本的函数和一个计算总成本的函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">rent = <span class="number">3000</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cost</span>():</span></span><br><span class="line">    utilities = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入本月的水电费用&#x27;</span>))</span><br><span class="line">    food_cost = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入本月的食材费用&#x27;</span>))</span><br><span class="line">    variable_cost = utilities + food_cost</span><br><span class="line">    print(<span class="string">&#x27;本月的变动成本费用是&#x27;</span> + <span class="built_in">str</span>(variable_cost))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum_cost</span>():</span></span><br><span class="line">    <span class="built_in">sum</span> = rent + variable_cost</span><br><span class="line">    print(<span class="string">&#x27;本月的总成本是&#x27;</span> + <span class="built_in">str</span>(<span class="built_in">sum</span>))</span><br><span class="line"></span><br><span class="line">cost()</span><br><span class="line">sum_cost()</span><br></pre></td></tr></table></figure>

<p>乍一看代码好像没有什么问题，但是一旦运行，终端就会报错：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">line <span class="number">10</span>, <span class="keyword">in</span> sum_cost</span><br><span class="line">    <span class="built_in">sum</span> = rent + variable_cost</span><br><span class="line">NameError: name <span class="string">&#x27;variable_cost&#x27;</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br></pre></td></tr></table></figure>

<p>可以发现，第一个函数 cost() 运行没有问题，报错信息指出问题出在 <code>sum_cost()</code> 函数内的变量 <code>variable_cost</code> 没有被定义。</p>
<p><strong>这就涉及一个变量作用域的问题</strong> &gt;&gt;&gt;&gt;</p>
<p>程序中的变量并不是在哪个位置都可以被使用的，它是有作用域。</p>
<p>变量的作用域指的是变量的有效范围，就是变量可以在哪个范围以内使用。它由变量的定义位置决定，在不同位置定义的变量，它的作用域是不一样的。</p>
<p>目前我们只需要掌握下面两点即可：</p>
<ol>
<li><p>一个在函数内部赋值的变量仅能在该函数内部使用（局部作用域），它们被称作 <strong>局部变量</strong>，如 <code>cost()</code> 函数里的 <code>variable_cost</code>；</p>
</li>
<li><p>在所有函数之外赋值的变量，可以在程序的任何位置使用（全局作用域），它们被称作 <strong>全局变量</strong>，如程序第一行定义的变量 <code>rent=3000</code>。</p>
</li>
</ol>
<p>上述例子中，变量 <code>rent</code> 是在函数外被赋值的，所以它是全局变量，能被 <code>sum_cost()</code> 函数直接使用。而变量 <code>variable_cost</code> 是在 <code>cost()</code> 函数内定义的，属于局部变量，其余函数内部如 <code>sum_cost()</code> 无法访问。</p>
<p>事实上，当 cost() 函数调用执行完毕，在这个函数内定义的变量都会”消失”。</p>
<p><strong>函数中局部变量是调用生成，调用结束后释放的</strong> &gt;&gt;&gt;&gt;</p>
<p>def 语句后的代码块只是封装了函数的功能，如果没有被调用，那么 def 语句后面的代码永远不会被执行。当函数被调用时，Python 会为其分配一块临时的存储空间，所有在函数内部定义的变量，都会存储在这块空间中。而在函数执行完毕后，这块临时存储空间随即会被释放并回收，该空间中存储的变量自然也就无法再被使用。</p>
<hr>
<h4 id="获取指定作用域范围中的变量"><a href="#获取指定作用域范围中的变量" class="headerlink" title="获取指定作用域范围中的变量"></a>获取指定作用域范围中的变量</h4><p>在一些特定场景中，我们可能需要获取某个作用域内（全局范围内或者局部范围内）所有的变量，Python 提供了以下 3 种方式：</p>
<p><strong>[1] &gt;&gt;&gt;&gt; globals()</strong></p>
<p>globals() 函数为 Python 的内置函数，它可以返回一个包含全局范围内所有变量的字典，该字典中的每个键值对，键为变量名，值为该变量的值。</p>
<p>举个例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 全局变量</span></span><br><span class="line">Pyname = <span class="string">&quot;Python 教程&quot;</span></span><br><span class="line">Pyadd = <span class="string">&quot;http://orangeshare.cn/python&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">text</span>():</span></span><br><span class="line">    <span class="comment"># 局部变量</span></span><br><span class="line">    Shename = <span class="string">&quot;shell 教程&quot;</span></span><br><span class="line">    Sheadd= <span class="string">&quot;http://orangeshare.cn/shell&quot;</span></span><br><span class="line">print(<span class="built_in">globals</span>())</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output：</span></span><br><span class="line"><span class="comment"># &#123; ...... , &#x27;Pyname&#x27;: &#x27;Python 教程&#x27;, &#x27;Pyadd&#x27;: &#x27;http://orangeshare.cn/python&#x27;, ......&#125;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，globals() 函数返回的字典中，会默认包含有很多变量，这些都是 Python 主程序内置的，读者暂时不用理会它们。</p>
</blockquote>
<p>并且，通过该字典，我们还可以访问指定变量，甚至如果需要，还可以修改它的值。例如，在上面程序的基础上，添加如下语句：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="built_in">globals</span>()[<span class="string">&#x27;Pyname&#x27;</span>])</span><br><span class="line"><span class="built_in">globals</span>()[<span class="string">&#x27;Pyname&#x27;</span>] = <span class="string">&quot;Python 入门教程&quot;</span></span><br><span class="line">print(Pyname)</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>[2] &gt;&gt;&gt;&gt; locals()</strong></p>
<p>locals() 函数也是 Python 内置函数之一，通过调用该函数，我们可以得到一个包含当前作用域内所有变量的字典。</p>
<p>这里所谓的 【当前作用域】 指的是，在函数内部调用 locals() 函数，会获得包含所有局部变量的字典；而在全局范文内调用 locals() 函数，其功能和 globals() 函数相同。</p>
<p>举个例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 全局变量</span></span><br><span class="line">Pyname = <span class="string">&quot;Python 教程&quot;</span></span><br><span class="line">Pyadd = <span class="string">&quot;http://orangeshare.cn/python&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">text</span>():</span></span><br><span class="line">    <span class="comment">#局部变量</span></span><br><span class="line">    Shename = <span class="string">&quot;shell 教程&quot;</span></span><br><span class="line">    Sheadd= <span class="string">&quot;http://orangeshare.cn/shell/&quot;</span></span><br><span class="line">    print(<span class="string">&quot;函数内部的 locals:&quot;</span>)</span><br><span class="line">    print(<span class="built_in">locals</span>())</span><br><span class="line">text()</span><br><span class="line">print(<span class="string">&quot;函数外部的 locals:&quot;</span>)</span><br><span class="line">print(<span class="built_in">locals</span>())</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output：</span></span><br><span class="line"><span class="comment"># 函数内部的 locals:</span></span><br><span class="line"><span class="comment"># &#123;&#x27;Sheadd&#x27;: &#x27;http://orangeshare.cn/shell/&#x27;, &#x27;Shename&#x27;: &#x27;shell 教程&#x27;&#125;</span></span><br><span class="line"><span class="comment"># 函数外部的 locals:</span></span><br><span class="line"><span class="comment"># &#123;...... , &#x27;Pyname&#x27;: &#x27;Python 教程&#x27;, &#x27;Pyadd&#x27;: &#x27;http://orangeshare.cn/python/&#x27;, ...... &#125;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>当使用 locals() 函数获取所有全局变量时，和 globals() 函数一样，其返回的字典中会默认包含有很多变量，这些都是 Python 主程序内置的，读者暂时不用理会它们。</p>
</blockquote>
<p>注意，当使用 locals() 函数获得所有局部变量组成的字典时，可以向 globals() 函数那样，通过指定键访问对应的变量值，但无法对变量值做修改。</p>
<hr>
<p><strong>[3] &gt;&gt;&gt;&gt; vars(object)</strong></p>
<p>vars() 函数也是 Python 内置函数，其功能是返回一个指定 object 对象范围内所有变量组成的字典。如果不传入object 参数，vars() 和 locals() 的作用完全相同。</p>
<blockquote>
<p>由于目前读者还未学习 Python 类和对象，因此初学者可先跳过该函数的学习，等学完 Python 类和对象之后，再回过头来学习该函数。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 全局变量</span></span><br><span class="line">Pyname = <span class="string">&quot;Python 教程&quot;</span></span><br><span class="line">Pyadd = <span class="string">&quot;http://orangeshare.cn/python/&quot;</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Demo</span>:</span></span><br><span class="line">    name = <span class="string">&quot;Python 教程&quot;</span></span><br><span class="line">    add = <span class="string">&quot;http://orangeshare.cn/python/&quot;</span></span><br><span class="line">print(<span class="string">&quot;有 object：&quot;</span>)</span><br><span class="line">print(<span class="built_in">vars</span>(Demo))</span><br><span class="line">print(<span class="string">&quot;无 object：&quot;</span>)</span><br><span class="line">print(<span class="built_in">vars</span>())</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"><span class="comment"># 有 object：</span></span><br><span class="line"><span class="comment"># &#123;...... , &#x27;name&#x27;: &#x27;Python 教程&#x27;, &#x27;add&#x27;: &#x27;http://c.biancheng.net/python/&#x27;, ......&#125;</span></span><br><span class="line"><span class="comment"># 无 object：</span></span><br><span class="line"><span class="comment"># &#123;...... , &#x27;Pyname&#x27;: &#x27;Python教程&#x27;, &#x27;Pyadd&#x27;: &#x27;http://c.biancheng.net/python/&#x27;, ...... &#125;</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="函数中使用同名全局变量"><a href="#函数中使用同名全局变量" class="headerlink" title="函数中使用同名全局变量"></a>函数中使用同名全局变量</h4><p>当函数内部的局部变量和函数外部的全局变量同名时，在函数内部，局部变量会“遮蔽”同名的全局变量。</p>
<p>这时，无论是访问还是修改该同名变量，操作的都是局部变量，而不再是全局变量。</p>
<p>这里举个实例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">&quot;Python 教程&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">demo</span> ():</span></span><br><span class="line">    <span class="comment"># 访问全局变量</span></span><br><span class="line">    print(name)</span><br><span class="line">demo()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"><span class="comment"># Python 教程</span></span><br></pre></td></tr></table></figure>

<p>上面程序中，<code>print(name)</code> 直接访问 <code>name</code> 变量，这是允许的。在上面程序的基础上，在函数内部添加一行代码，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">&quot;Python教程&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">demo</span> ():</span></span><br><span class="line">    <span class="comment"># 访问全局变量</span></span><br><span class="line">    print(name)</span><br><span class="line">    name = <span class="string">&quot;shell教程&quot;</span></span><br><span class="line">demo()</span><br></pre></td></tr></table></figure>

<p>执行此程序，Python 解释器报如下错误：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UnboundLocalError: local variable &#x27;name&#x27; referenced before assignment</span><br></pre></td></tr></table></figure>

<p>发生什么了？！！ &gt;&gt;&gt;&gt;</p>
<p>由于函数中局部变量名和全局变量名 name 同名（触发屏蔽机制），局部 name 变量就会“遮蔽”全局 name 变量，再加上局部变量 <code>name</code> 在 <code>print(name)</code> 后才被初始化，违反了“先定义后使用”的原则，因此程序会报错。</p>
<p>如果就是想在函数中访问甚至修改被“遮蔽”的变量，怎么办呢？</p>
<p>这时候 <strong>global</strong> 语句就能派上用场了，它可以将局部变量声明为全局变量，作如下修改：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">&quot;Python 教程&quot;</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">demo</span> ():</span></span><br><span class="line">    <span class="keyword">global</span> name</span><br><span class="line">    <span class="comment"># 访问全局name变量</span></span><br><span class="line">    print(name)</span><br><span class="line">    <span class="comment"># 修改全局 name 变量的值</span></span><br><span class="line">    name = <span class="string">&quot;shell 教程&quot;</span></span><br><span class="line">demo()</span><br><span class="line">print(name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"><span class="comment"># Python 教程</span></span><br><span class="line"><span class="comment"># shell 教程</span></span><br></pre></td></tr></table></figure>

<p>增加了 <code>global name</code> 声明之后，程序会把 <code>name</code> 变量当成全局变量，这意味着 <code>demo()</code> 函数后面对 <code>name</code> 赋值的语句只是对全局变量赋值，而不是重新定义局部变量。</p>
<hr>
<h3 id="局部函数"><a href="#局部函数" class="headerlink" title="局部函数"></a>局部函数</h3><p>我们知道，Python 函数内部可以定义变量，这样就产生了局部变量，有读者可能会问，Python 函数内部能定义函数吗？答案是肯定的。</p>
<p>Python 支持在函数内部定义函数，此类函数又称为 <strong>局部函数</strong>。</p>
<p>和局部变量一样，<strong>默认情况下局部函数只能在其所在函数的作用域内使用。</strong></p>
<p>举个例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#全局函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outdef</span> ():</span></span><br><span class="line">    <span class="comment"># 局部函数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">indef</span>():</span></span><br><span class="line">        print(<span class="string">&quot;http://orangeshare.cn/python/&quot;</span>)</span><br><span class="line">    <span class="comment"># 调用局部函数（该函数只在当前作用域可见）</span></span><br><span class="line">    indef()</span><br><span class="line"></span><br><span class="line"><span class="comment"># indef() 不能直接调用，内部函数在当前作用域内不可见</span></span><br><span class="line"><span class="comment"># 调用全局函数</span></span><br><span class="line">outdef()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"><span class="comment"># http://orangeshare.cn/python/</span></span><br></pre></td></tr></table></figure>

<p>可以看到，<code>indef</code> 函数定义于 <code>outdef</code> 函数中，所以其作用域就是 <code>outdef</code> 函数内。想要执行局部函数，只能在其作用域（<code>outdef</code> 函数）中进行调用。</p>
<hr>
<p><strong>[1] &gt;&gt;&gt;&gt; 局部函数变量同名“遮蔽”问题</strong></p>
<p>需要注意，如果局部函数中定义有和所在函数中变量同名的变量，也会发生“遮蔽”的问题。</p>
<p>例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 全局函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outdef</span> ():</span></span><br><span class="line">    name = <span class="string">&quot;所在函数中定义的 name 变量&quot;</span></span><br><span class="line">    <span class="comment"># 局部函数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">indef</span>():</span></span><br><span class="line">        print(name)</span><br><span class="line">        name = <span class="string">&quot;局部函数中定义的 name 变量&quot;</span></span><br><span class="line">    indef()</span><br><span class="line"><span class="comment"># 调用全局函数</span></span><br><span class="line">outdef()</span><br></pre></td></tr></table></figure>

<p>执行此程序，Python 解释器会报如下错误：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">UnboundLocalError: local variable &#x27;name&#x27; referenced before assignment</span><br></pre></td></tr></table></figure>

<p>怎么办？！！</p>
<p>由于这里的 name 变量是局部变量，<code>globals</code> 关键字，并不适用于解决此问题。</p>
<p>这里可以使用 Python 提供的 <code>nonlocal</code> 关键字。例如，修改上面程序为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 全局函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outdef</span> ():</span></span><br><span class="line">    name = <span class="string">&quot;所在函数中定义的 name 变量&quot;</span></span><br><span class="line">    <span class="comment"># 局部函数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">indef</span>():</span></span><br><span class="line">        <span class="keyword">nonlocal</span> name</span><br><span class="line">        print(name)</span><br><span class="line">        <span class="comment"># 修改 name 变量的值</span></span><br><span class="line">        name = <span class="string">&quot;局部函数中定义的 name 变量&quot;</span></span><br><span class="line">    indef()</span><br><span class="line"><span class="comment"># 调用全局函数</span></span><br><span class="line">outdef()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"><span class="comment"># 所在函数中定义的 name 变量</span></span><br></pre></td></tr></table></figure>

<hr>
<p><strong>[2] &gt;&gt;&gt;&gt; 函数作为返回值，扩大局部函数作用域</strong></p>
<p>就如同全局函数返回其局部变量，就可以扩大该变量的作用域一样；通过将局部函数作为所在函数的返回值，也可以扩大局部函数的使用范围。例如，修改上面程序为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 全局函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">outdef</span> ():</span></span><br><span class="line">    name = <span class="string">&quot;局部函数所在外部函数中定义的 name 变量&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 局部函数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">indef</span>():</span></span><br><span class="line">        <span class="keyword">nonlocal</span> name</span><br><span class="line">        print(name)</span><br><span class="line">    <span class="comment"># 调用局部函数</span></span><br><span class="line">    <span class="keyword">return</span> indef</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用全局函数</span></span><br><span class="line">new_indef = outdef()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用全局函数中的局部函数</span></span><br><span class="line">new_indef()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"><span class="comment"># 调用局部函数</span></span><br></pre></td></tr></table></figure>

<p>也就是说：如果所在函数没有返回局部函数，则局部函数的可用范围仅限于所在函数内部；反之，如果所在函数将局部函数作为返回值，则局部函数的作用域就会扩大，既可以在所在函数内部使用，也可以在所在函数的作用域中使用。</p>
<p>哎？连续调用了两回？怎么理解在全局作用域中调用局部函数？</p>
<p>这是由于 <code>outdef()</code> 外部函数返回的是一个其内部函数的引用，还记得前面关于函数名称的解读么？所以调用 <code>outdef()</code> 外部函数其返回值相当于其内部函数（局部函数）的一个别名，然后就可以全局作用域中调用局部函数。</p>
<p><strong>带来的好处 &gt;&gt;&gt;&gt;</strong></p>
<p>我们知道，只有当函数被调用时，Python 才会为其分配一块临时的存储空间，所有在函数内部定义的变量，都会存储在这块空间中。而在函数执行完毕后，这块临时存储空间随即会被释放并回收，该空间中存储的变量自然也就无法再被使用。</p>
<p>而以使用其局部函数作为返回值的外部函数，当外部函数结束时，其局部函数中使用到的外部函数相关联变量会被绑定到内部函数，这样你就可以使得这些变量始终保存在内存中，不会随外部函数的结束而清除（变量状态保存）。</p>
<p>其实，上面介绍到的就是 Python 中闭包的概念，更多请参加：<a target="_blank" rel="noopener" href="https://orangeshare.cn/2018/01/11/python-zhong-de-han-shu-sheng-jie/">Python 中的函数升阶</a>。</p>
<hr>
<h3 id="函数内部调用"><a href="#函数内部调用" class="headerlink" title="函数内部调用"></a>函数内部调用</h3><p>Python 中在一个函数的内部，也是支持调用其它函数的。看如下样例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">rent = <span class="number">3000</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cost</span>():</span></span><br><span class="line">    <span class="keyword">global</span> variable_cost</span><br><span class="line">    utilities = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入本月的水电费用&#x27;</span>))</span><br><span class="line">    food_cost = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入本月的食材费用&#x27;</span>))</span><br><span class="line">    variable_cost = utilities + food_cost</span><br><span class="line">    print(<span class="string">&#x27;本月的变动成本是&#x27;</span> + <span class="built_in">str</span>(variable_cost))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum_cost</span>():</span></span><br><span class="line">    </span><br><span class="line">    cost()</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sum</span> = rent + variable_cost</span><br><span class="line">    print(<span class="string">&#x27;本月的总成本是&#x27;</span> + <span class="built_in">str</span>(<span class="built_in">sum</span>))</span><br><span class="line"></span><br><span class="line">sum_cost()</span><br></pre></td></tr></table></figure>

<blockquote>
<p>需要注意的是，语句对函数调用，必须在函数调用之后，包括直接调用的函数调用的其他函数也必须在调用语句之前，否则报错。</p>
</blockquote>
<p>然而，更多的是不再定义全局变量，而是将函数的预期执行结果作为当前函数的返回值：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">rent = <span class="number">3000</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cost</span>():</span></span><br><span class="line">    </span><br><span class="line">    utilities = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入本月的水电费用&#x27;</span>))</span><br><span class="line">    food_cost = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入本月的食材费用&#x27;</span>))</span><br><span class="line">    variable_cost = utilities + food_cost</span><br><span class="line">    print(<span class="string">&#x27;本月的变动成本是&#x27;</span> + <span class="built_in">str</span>(variable_cost))</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> variable_cost</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">sum_cost</span>():</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sum</span> = rent + cost()</span><br><span class="line">    print(<span class="string">&#x27;本月的总成本是&#x27;</span> + <span class="built_in">str</span>(<span class="built_in">sum</span>))</span><br><span class="line"></span><br><span class="line">sum_cost()</span><br></pre></td></tr></table></figure>

<p>这应该才是最合理的使用方法。</p>
<hr>
<h2 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h2><p>Python 中函数内部是支持调用其它函数的，那么，如果一个函数在内部是否可以调用自身本身呢？</p>
<p>可以的！！！这个函数就被称为递归函数。</p>
<p>来看一个实例，我们来计算阶乘 <code>n! = 1 x 2 x 3 x ... x n</code>，用函数 <code>fact(n)</code> 表示，可以看出：</p>
<p><code>fact(n) = n! = 1 x 2 x 3 x ... x (n-1) x n = (n-1)! x n = fact(n-1) x n</code></p>
<p>所以，<code>fact(n)</code> 可以表示为 <code>n x fact(n-1)</code>，只有 n=1 时需要特殊处理。</p>
<p>于是，<code>fact(n)</code> 用递归的方式写出来就是：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="function"><span class="keyword">def</span> <span class="title">fact</span>(<span class="params">n</span>):</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">if</span> n==<span class="number">1</span>:</span><br><span class="line"><span class="meta">... </span>        <span class="keyword">return</span> <span class="number">1</span></span><br><span class="line"><span class="meta">... </span>    <span class="keyword">return</span> n * fact(n - <span class="number">1</span>)</span><br><span class="line">...</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fact(<span class="number">1</span>)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fact(<span class="number">2</span>)</span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>fact(<span class="number">5</span>)</span><br><span class="line"><span class="number">120</span></span><br></pre></td></tr></table></figure>

<p>如果我们计算<code>fact(5)</code>，可以根据函数定义看到计算过程如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#x3D;&#x3D;&#x3D;&gt; fact(5)</span><br><span class="line">&#x3D;&#x3D;&#x3D;&gt; 5 * fact(4)</span><br><span class="line">&#x3D;&#x3D;&#x3D;&gt; 5 * (4 * fact(3))</span><br><span class="line">&#x3D;&#x3D;&#x3D;&gt; 5 * (4 * (3 * fact(2)))</span><br><span class="line">&#x3D;&#x3D;&#x3D;&gt; 5 * (4 * (3 * (2 * fact(1))))</span><br><span class="line">&#x3D;&#x3D;&#x3D;&gt; 5 * (4 * (3 * (2 * 1)))</span><br><span class="line">&#x3D;&#x3D;&#x3D;&gt; 5 * (4 * (3 * 2))</span><br><span class="line">&#x3D;&#x3D;&#x3D;&gt; 5 * (4 * 6)</span><br><span class="line">&#x3D;&#x3D;&#x3D;&gt; 5 * 24</span><br><span class="line">&#x3D;&#x3D;&#x3D;&gt; 120</span><br></pre></td></tr></table></figure>

<p>递归函数的优点是定义简单，逻辑清晰。理论上，所有的递归函数都可以写成循环的方式，但循环的逻辑不如递归清晰。</p>
<blockquote>
<p>执行递归函数将反复调用其自身，每调用一次就进入新的一层，当最内层的函数执行完毕后，再一层一层地由里到外退出。</p>
<p>当一个函数不断地调用它自身时，必须在某个时刻函数的返回值是确定的，即不再调用它自身：否则，这种递归就变成了无穷递归，类似于死循环。因此，在定义递归函数时有一条最重要的规定： 递归一定要向已知方向进行。</p>
</blockquote>
<hr>
<p><strong>[1] &gt;&gt;&gt;&gt; 递归中的栈溢出问题</strong></p>
<p>使用递归函数需要注意防止栈溢出。在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。</p>
<p>由于栈的大小不是无限的，所以递归调用的次数过多，会导致栈溢出。可以试试 <code>fact(1000)</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>fact(<span class="number">1000</span>)</span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">4</span>, <span class="keyword">in</span> fact</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">4</span>, <span class="keyword">in</span> fact</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">4</span>, <span class="keyword">in</span> fact</span><br><span class="line">  [Previous line repeated <span class="number">995</span> more times]</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">2</span>, <span class="keyword">in</span> fact</span><br><span class="line">RecursionError: maximum recursion depth exceeded <span class="keyword">in</span> comparison</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>[2] &gt;&gt;&gt;&gt; 尾递归解决栈溢出</strong></p>
<p>解决递归调用栈溢出的方法是进行 <strong>尾递归</strong> 优化 &gt;&gt;&gt;&gt;</p>
<p>普通的递归，每一次递归都需要调用函数，会创建新的栈，生成一大堆中间变量；而尾递归不会保存中间变量，每一级调用直接返回函数的返回值更新调用栈，而不用创建新的调用栈。</p>
<p><strong>如何实现尾递归</strong> &gt;&gt;&gt;&gt; 在函数返回的时候，调用其自身，并且 return 语句不能包含表达式。</p>
<p>上面的 <code>fact(n)</code> 函数由于 <code>return n * fact(n - 1)</code> 引入了乘法表达式，所以就不是尾递归了。要改成尾递归方式，需要多一点代码，主要是要把每一步的乘积传入到递归函数中：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fact</span>(<span class="params">n</span>):</span></span><br><span class="line">    <span class="keyword">return</span> fact_iter(n, <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fact_iter</span>(<span class="params">num, product</span>):</span></span><br><span class="line">    <span class="keyword">if</span> num == <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">return</span> product</span><br><span class="line">    <span class="keyword">return</span> fact_iter(num - <span class="number">1</span>, num * product)</span><br></pre></td></tr></table></figure>

<p>可以看到，<code>return fact_iter(num - 1, num * product)</code> 仅返回递归函数本身，<code>num - 1</code> 和 <code>num * product</code> 在函数调用前就会被计算，不影响函数调用。<code>fact(5)</code> 对应的 <code>fact_iter(5, 1)</code> 的调用如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x3D;&#x3D;&#x3D;&gt; fact_iter(5, 1)</span><br><span class="line">&#x3D;&#x3D;&#x3D;&gt; fact_iter(4, 5*1)</span><br><span class="line">&#x3D;&#x3D;&#x3D;&gt; fact_iter(3, 5*1*4)</span><br><span class="line">&#x3D;&#x3D;&#x3D;&gt; fact_iter(2, 5*1*4*3)</span><br><span class="line">&#x3D;&#x3D;&#x3D;&gt; fact_iter(1, 5*1*4*3*2)</span><br><span class="line">&#x3D;&#x3D;&#x3D;&gt; 120</span><br></pre></td></tr></table></figure>

<p>尾递归调用时，如果做了优化，栈不会增长，因此，无论多少次调用也不会导致栈溢出。</p>
<p>遗憾的是，某些编程语言没有针对尾递归做优化，Python 解释器就是其中之一，所以，即使把上面的 <code>fact(n)</code> 函数改成尾递归方式，也会导致栈溢出。</p>
<hr>
<p>能人无数啊！！！网上有大佬用装饰器实现了 Python 的尾递归，试运行下面代码验证：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3</span></span><br><span class="line"><span class="comment"># This program shows off a python decorator(</span></span><br><span class="line"><span class="comment"># which implements tail call optimization. It</span></span><br><span class="line"><span class="comment"># does this by throwing an exception if it is </span></span><br><span class="line"><span class="comment"># it&#x27;s own grandparent, and catching such </span></span><br><span class="line"><span class="comment"># exceptions to recall the stack.</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TailRecurseException</span>(<span class="params">BaseException</span>):</span>  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, args, kwargs</span>):</span></span><br><span class="line">    self.args = args</span><br><span class="line">    self.kwargs = kwargs</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">tail_call_optimized</span>(<span class="params">g</span>):</span>  </span><br><span class="line">  <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">  This function decorates a function with tail call</span></span><br><span class="line"><span class="string">  optimization. It does this by throwing an exception</span></span><br><span class="line"><span class="string">  if it is it&#x27;s own grandparent, and catching such</span></span><br><span class="line"><span class="string">  exceptions to fake the tail call optimization.</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  This function fails if the decorated</span></span><br><span class="line"><span class="string">  function recurses in a non-tail context.</span></span><br><span class="line"><span class="string">  &quot;&quot;&quot;</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">    f = sys._getframe()</span><br><span class="line">    <span class="keyword">if</span> f.f_back <span class="keyword">and</span> f.f_back.f_back \</span><br><span class="line">        <span class="keyword">and</span> f.f_back.f_back.f_code == f.f_code:</span><br><span class="line">      <span class="keyword">raise</span> TailRecurseException(args, kwargs)</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">      <span class="keyword">while</span> <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">try</span>:</span><br><span class="line">          <span class="keyword">return</span> g(*args, **kwargs)</span><br><span class="line">        <span class="keyword">except</span> TailRecurseException <span class="keyword">as</span> e:</span><br><span class="line">          args = e.args</span><br><span class="line">          kwargs = e.kwargs</span><br><span class="line">  func.__doc__ = g.__doc__</span><br><span class="line">  <span class="keyword">return</span> func</span><br><span class="line"></span><br><span class="line"><span class="meta">@tail_call_optimized</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factorial</span>(<span class="params">n, acc=<span class="number">1</span></span>):</span>  </span><br><span class="line">  <span class="string">&quot;calculate a factorial&quot;</span></span><br><span class="line">  <span class="keyword">if</span> n == <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">return</span> acc</span><br><span class="line">  <span class="keyword">return</span> factorial(n-<span class="number">1</span>, n*acc)</span><br><span class="line"></span><br><span class="line">print(factorial(<span class="number">10000</span>))  </span><br><span class="line"><span class="comment"># prints a big, big number,</span></span><br><span class="line"><span class="comment"># but doesn&#x27;t hit the recursion limit.</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@tail_call_optimized</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span>(<span class="params">i, current = <span class="number">0</span>, <span class="built_in">next</span> = <span class="number">1</span></span>):</span>  </span><br><span class="line">  <span class="keyword">if</span> i == <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">return</span> current</span><br><span class="line">  <span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">return</span> fib(i - <span class="number">1</span>, <span class="built_in">next</span>, current + <span class="built_in">next</span>)</span><br><span class="line"></span><br><span class="line">print(fib(<span class="number">10000</span>))  </span><br><span class="line"><span class="comment"># also prints a big number,</span></span><br><span class="line"><span class="comment"># but doesn&#x27;t hit the recursion limit.</span></span><br></pre></td></tr></table></figure>

<hr>
</div><div class="article-licensing box"><div class="licensing-title"><p>Python 中的函数</p><p><a href="https://www.orangeshare.cn/2018/01/10/python-zhong-de-han-shu/">https://www.orangeshare.cn/2018/01/10/python-zhong-de-han-shu/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>Author</h6><p>Waldeinsamkeit</p></div></div><div class="level-item is-narrow"><div><h6>Posted on</h6><p>2018-01-10</p></div></div><div class="level-item is-narrow"><div><h6>Updated on</h6><p>2022-03-20</p></div></div><div class="level-item is-narrow"><div><h6>Licensed under</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="icon" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a><a class="icon" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/Python/">Python</a></div><div class="notification is-danger">You need to set <code>install_url</code> to use ShareThis. Please set it in <code>_config.yml</code>.</div></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">Like this article? Support the author with</h3><div class="buttons is-centered"><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>Alipay</span><span class="qrcode"><img src="/" alt="Alipay"></span></a><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>Wechat</span><span class="qrcode"><img src="/" alt="Wechat"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2018/01/11/python-zhong-de-han-shu-sheng-jie/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Python 中的函数升阶</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2018/01/09/python-zhong-de-yun-suan-fu-yi-ji-liu-cheng-kong-zhi/"><span class="level-item">Python 中的运算符以及流程控制</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">Comments</h3><div class="notification is-danger">You forgot to set the <code>shortname</code> for Disqus. Please set it in <code>_config.yml</code>.</div></div></div></div><!--!--><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen  order-3 is-sticky"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="Waldeinsamkeit"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Waldeinsamkeit</p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">100</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">13</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">43</p></a></div></div></nav></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">Catalogue</h3><ul class="menu-list"><li><a class="level is-mobile" href="#函数定义"><span class="level-left"><span class="level-item">1</span><span class="level-item">函数定义</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#空函数沙发"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">空函数沙发</span></span></a></li><li><a class="level is-mobile" href="#函数文档说明支持"><span class="level-left"><span class="level-item">1.2</span><span class="level-item">函数文档说明支持</span></span></a></li></ul></li><li><a class="level is-mobile" href="#函数调用"><span class="level-left"><span class="level-item">2</span><span class="level-item">函数调用</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#深入理解函数名称"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">深入理解函数名称</span></span></a></li><li><a class="level is-mobile" href="#形参（位置参数）-amp-amp-实参"><span class="level-left"><span class="level-item">2.2</span><span class="level-item">形参（位置参数） &amp;&amp; 实参</span></span></a></li><li><a class="level is-mobile" href="#参数检查机制"><span class="level-left"><span class="level-item">2.3</span><span class="level-item">参数检查机制</span></span></a></li><li><a class="level is-mobile" href="#参数传递机制"><span class="level-left"><span class="level-item">2.4</span><span class="level-item">参数传递机制</span></span></a></li><li><a class="level is-mobile" href="#return-表达式"><span class="level-left"><span class="level-item">2.5</span><span class="level-item">return [表达式]</span></span></a></li></ul></li><li><a class="level is-mobile" href="#函数参数列表详解"><span class="level-left"><span class="level-item">3</span><span class="level-item">函数参数列表详解</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#位置参数"><span class="level-left"><span class="level-item">3.1</span><span class="level-item">位置参数</span></span></a></li><li><a class="level is-mobile" href="#关键字参数"><span class="level-left"><span class="level-item">3.2</span><span class="level-item">关键字参数</span></span></a></li><li><a class="level is-mobile" href="#默认参数"><span class="level-left"><span class="level-item">3.3</span><span class="level-item">默认参数</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#默认参数设置原则"><span class="level-left"><span class="level-item">3.3.1</span><span class="level-item">默认参数设置原则</span></span></a></li><li><a class="level is-mobile" href="#默认参数必须指向不可变对象"><span class="level-left"><span class="level-item">3.3.2</span><span class="level-item">默认参数必须指向不可变对象</span></span></a></li></ul></li><li><a class="level is-mobile" href="#不定长参数"><span class="level-left"><span class="level-item">3.4</span><span class="level-item">不定长参数</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#元组型不定长非关键字实参"><span class="level-left"><span class="level-item">3.4.1</span><span class="level-item">元组型不定长非关键字实参</span></span></a></li><li><a class="level is-mobile" href="#字典型不定长关键字实参"><span class="level-left"><span class="level-item">3.4.2</span><span class="level-item">字典型不定长关键字实参</span></span></a></li></ul></li><li><a class="level is-mobile" href="#参数混合"><span class="level-left"><span class="level-item">3.5</span><span class="level-item">参数混合</span></span></a></li><li><a class="level is-mobile" href="#序列支持向函数传参"><span class="level-left"><span class="level-item">3.6</span><span class="level-item">序列支持向函数传参</span></span></a></li></ul></li><li><a class="level is-mobile" href="#函数间协作"><span class="level-left"><span class="level-item">4</span><span class="level-item">函数间协作</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#浅析变量作用域"><span class="level-left"><span class="level-item">4.1</span><span class="level-item">浅析变量作用域</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#全局变量-amp-amp-局部变量"><span class="level-left"><span class="level-item">4.1.1</span><span class="level-item">全局变量 &amp;&amp; 局部变量</span></span></a></li><li><a class="level is-mobile" href="#获取指定作用域范围中的变量"><span class="level-left"><span class="level-item">4.1.2</span><span class="level-item">获取指定作用域范围中的变量</span></span></a></li><li><a class="level is-mobile" href="#函数中使用同名全局变量"><span class="level-left"><span class="level-item">4.1.3</span><span class="level-item">函数中使用同名全局变量</span></span></a></li></ul></li><li><a class="level is-mobile" href="#局部函数"><span class="level-left"><span class="level-item">4.2</span><span class="level-item">局部函数</span></span></a></li><li><a class="level is-mobile" href="#函数内部调用"><span class="level-left"><span class="level-item">4.3</span><span class="level-item">函数内部调用</span></span></a></li></ul></li><li><a class="level is-mobile" href="#递归函数"><span class="level-left"><span class="level-item">5</span><span class="level-item">递归函数</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="When Art Meets Tech" height="28"></a><p class="is-size-7"><span>&copy; 2023 Waldeinsamkeit</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p></div></div></div></div></footer><script src="https://cdnjs.loli.net/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" async></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/cookieconsent/3.1.1/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/js/lightgallery.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>
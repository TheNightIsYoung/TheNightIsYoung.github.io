<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Python 面向对象编程之类和对象 - When Art Meets Tech</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="When Art Meets Tech"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="When Art Meets Tech"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta description="前面我们提到过，我们知道 面向对象的编程概述。面向过程是具体化的，流程化的，解决一个问题，你需要一步一步的分析，一步一步的实现，这就是面向过程的设计。而面向对象呢？其实，面向对象是模型化的，你只需抽象出一个类，这是一个封闭的盒子，在这里你拥有数据也拥有解决问题的方法。 一切皆对象，面向对象的程序设计把计算机程序视为一组对象的集合，而每个对象都可以接收其他对象发过来的消息，并处理这些消息，计算机程序"><meta property="og:type" content="blog"><meta property="og:title" content="Python 面向对象编程之类和对象"><meta property="og:url" content="https://www.orangeshare.cn/2018/01/12/python-mian-xiang-dui-xiang-bian-cheng-zhi-lei-he-dui-xiang/"><meta property="og:site_name" content="When Art Meets Tech"><meta property="og:description" content="前面我们提到过，我们知道 面向对象的编程概述。面向过程是具体化的，流程化的，解决一个问题，你需要一步一步的分析，一步一步的实现，这就是面向过程的设计。而面向对象呢？其实，面向对象是模型化的，你只需抽象出一个类，这是一个封闭的盒子，在这里你拥有数据也拥有解决问题的方法。 一切皆对象，面向对象的程序设计把计算机程序视为一组对象的集合，而每个对象都可以接收其他对象发过来的消息，并处理这些消息，计算机程序"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://www.orangeshare.cn/img/og_image.png"><meta property="article:published_time" content="2018-01-12T02:40:29.000Z"><meta property="article:modified_time" content="2022-04-03T11:31:48.780Z"><meta property="article:author" content="Waldeinsamkeit"><meta property="article:tag" content="Python"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.orangeshare.cn/2018/01/12/python-mian-xiang-dui-xiang-bian-cheng-zhi-lei-he-dui-xiang/"},"headline":"When Art Meets Tech","image":["https://www.orangeshare.cn/img/og_image.png"],"datePublished":"2018-01-12T02:40:29.000Z","dateModified":"2022-04-03T11:31:48.780Z","author":{"@type":"Person","name":"Waldeinsamkeit"},"description":"前面我们提到过，我们知道 面向对象的编程概述。面向过程是具体化的，流程化的，解决一个问题，你需要一步一步的分析，一步一步的实现，这就是面向过程的设计。而面向对象呢？其实，面向对象是模型化的，你只需抽象出一个类，这是一个封闭的盒子，在这里你拥有数据也拥有解决问题的方法。 一切皆对象，面向对象的程序设计把计算机程序视为一组对象的集合，而每个对象都可以接收其他对象发过来的消息，并处理这些消息，计算机程序"}</script><link rel="canonical" href="https://www.orangeshare.cn/2018/01/12/python-mian-xiang-dui-xiang-bian-cheng-zhi-lei-he-dui-xiang/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Oxanium:wght@300;400;600&amp;family=Roboto+Mono"><link rel="stylesheet" href="/css/cyberpunk.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/cookieconsent/3.1.1/cookieconsent.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/pace/1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.2.0"></head>    <body class="is-3-column">    <nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="When Art Meets Tech" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Hexo Search" href="https://hexo.io/zh-cn/"><i class="fab fa-hotjar"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="Catalogue" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal"><i class="fas fa-angle-double-right"></i>Python 面向对象编程之类和对象</h1><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><i class="far fa-calendar-alt"> </i><time dateTime="${date_xml(page.date)}" title="${date_xml(page.date)}">2018-01-12</time></span><span class="level-item is-hidden-mobile"><i class="far fa-calendar-check"> </i><time dateTime="${date_xml(page.updated)}" title="${date_xml(page.updated)}">2022-04-03</time></span><span class="level-item"><a class="link-muted" href="/categories/Python/">Python</a></span><span class="level-item">2 hours read (About 21609 words)</span></div></div><div class="content"><p>前面我们提到过，我们知道 <a href="https://www.orangeshare.cn/2018/01/12/python-mian-xiang-dui-xiang-bian-cheng-zhi-lei-he-dui-xiang/">面向对象的编程概述</a>。面向过程是具体化的，流程化的，解决一个问题，你需要一步一步的分析，一步一步的实现，这就是面向过程的设计。而面向对象呢？其实，面向对象是模型化的，你只需抽象出一个类，这是一个封闭的盒子，在这里你拥有数据也拥有解决问题的方法。</p>
<p>一切皆对象，面向对象的程序设计把计算机程序视为一组对象的集合，而每个对象都可以接收其他对象发过来的消息，并处理这些消息，计算机程序的执行就是一系列消息在各个对象之间传递。</p>
<a id="more"></a>

<h2 id="面向对象初识"><a href="#面向对象初识" class="headerlink" title="面向对象初识"></a>面向对象初识</h2><p>Python 从设计之初就已经是一门面向对象的语言，在 Python 中所有数据类型都可以视为对象，当然也可以支持自定义对象。自定义的对象数据类型就是面向对象中的类（Class）的概念。</p>
<p>我们以一个例子来说明面向过程和面向对象在程序流程上的不同之处：</p>
<p>假设我们要处理学生的成绩表 &gt;&gt;&gt;&gt;</p>
<p>–&gt; 面向过程:</p>
<p>为了表示一个学生的成绩，面向过程的程序可以用一个 <code>dict</code> 表示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std1 = &#123; <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Michael&#x27;</span>, <span class="string">&#x27;score&#x27;</span>: <span class="number">98</span> &#125;</span><br><span class="line">std2 = &#123; <span class="string">&#x27;name&#x27;</span>: <span class="string">&#x27;Bob&#x27;</span>, <span class="string">&#x27;score&#x27;</span>: <span class="number">81</span> &#125;</span><br></pre></td></tr></table></figure>

<p>而处理学生成绩可以通过函数实现，比如打印学生的成绩：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">print_score</span>(<span class="params">std</span>):</span></span><br><span class="line">    print(<span class="string">&#x27;%s: %s&#x27;</span> % (std[<span class="string">&#x27;name&#x27;</span>], std[<span class="string">&#x27;score&#x27;</span>]))</span><br></pre></td></tr></table></figure>

<p>–&gt; 面向对象：</p>
<p>而如果采用面向对象的设计思想，我们首选思考的不是程序的执行流程，而是 <code>Student</code> 这种数据类型应该被视为一个对象，这个对象拥有 <code>name</code> 和 <code>score</code> 这两个属性（Property）。如果要打印一个学生的成绩，首先必须创建出这个学生对应的对象，然后，给对象发一个 <code>print_score</code> 消息，让对象自己把自己的数据打印出来。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, score</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.score = score</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print_score</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;%s: %s&#x27;</span> % (self.name, self.score))</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，以上代码仅是为了演示面向对象的编程思想，暂时先不需要深究。</p>
</blockquote>
<p>给对象发消息实际上就是调用对象对应的关联函数，我们称之为对象的方法（Method）。面向对象的程序写出来就像这样：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bart = Student(<span class="string">&#x27;Bart Simpson&#x27;</span>, <span class="number">59</span>)</span><br><span class="line">lisa = Student(<span class="string">&#x27;Lisa Simpson&#x27;</span>, <span class="number">87</span>)</span><br><span class="line">bart.print_score()</span><br><span class="line">lisa.print_score()</span><br></pre></td></tr></table></figure>

<p>上面，我们定义了 Class——Student，是指学生这个概念；而实例（Instance）则是一个个具体的 Student，比如：<code>Bart Simpson</code> 和 <code>Lisa Simpson</code> 是两个具体的 Student。</p>
<hr>
<h2 id="类和实例"><a href="#类和实例" class="headerlink" title="类和实例"></a>类和实例</h2><p>面向对象最重要的概念就是类（Class）和实例（Instance）。</p>
<p>必须牢记类是抽象的模板，类仅仅充当图纸的作用，本身并不能直接拿来用，而只有根据图纸造出的实际物品（对象）才能直接使用。</p>
<p>比如 Student 类，实例（张三、李四）是根据类实例化出来的一个个具体的 “对象”，每个对象都拥有相同的方法（打印成绩），但各自的数据可能不同（姓名、成绩）。</p>
<p>因此，Python 程序中类的使用顺序是这样的：</p>
<ul>
<li>创建（定义）类，也就是制作图纸的过程；</li>
<li>创建类的实例对象（根据图纸造出实际的物品），通过实例对象实现特定的功能。</li>
</ul>
<hr>
<h3 id="类"><a href="#类" class="headerlink" title="类"></a>类</h3><p>Python 中，定义类是通过 <code>class </code>关键字，其基本语法格式如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名(<span class="params"><span class="built_in">object</span></span>)：</span></span><br><span class="line"><span class="class">    多个（≥0）类属性...</span></span><br><span class="line"><span class="class">    多个（≥0）类方法...</span></span><br></pre></td></tr></table></figure>

<p>说明：</p>
<ul>
<li>类名：符合标识符命名规范，推荐使用代表该类功能的单词组合（首字母大写，其它字母小写）；</li>
<li>继承：<code>(object)</code> 表示该类是从哪个类继承下来的，通常，如果没有合适的继承类，就使用 <code>object</code> 类，这是所有类最终都会继承的类（也称为顶级父类）；</li>
<li>冒号：表示告诉 Python 解释器，下面要开始设计类的内部功能了，也就是编写类属性和类方法</li>
<li>类属性/类方法：无论是类属性还是类方法，对于类来说，它们都不是必需的，可以有也可以没有。另外，Python 类中属性和方法所在的位置是任意的，即它们之间并没有固定的前后次序。</li>
</ul>
<blockquote>
<p>关于继承，这里先不要深究~~~这里给出是为了保证类定义的完整性。</p>
</blockquote>
<p>以 Student 类为例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="string">&#x27;类的帮助信息&#x27;</span></span><br><span class="line">    add = <span class="string">&quot;This is my first class&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;这是类的构造函数&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print_score</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;print student`s score.&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>和函数一样，我们也可以为类定义说明文档，其要放到类头之后，类体之前的位置。</p>
<p>其次，可以看到，学生类（Student）中包含了一个名为 add 的类属性。注意，根据定义属性位置的不同，在各个类方法之外定义的变量称为类属性或类变量（如 add 属性），而在类方法中定义的属性称为实例属性（或实例变量），区别和用法后面会进行说明。</p>
<p>同时，学生类（Student）中还包含一个 <code>__init__()</code> 类方法和一个 <code>print_score</code> 方法。</p>
<p><strong>[1] &gt;&gt;&gt;&gt; 空类</strong></p>
<p>Python 中支持创建一个没有任何类属性和类方法的空类：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Empty</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>但在实际应用中，很少会创建空类，因为空类没有任何实际意义。</p>
<hr>
<p><strong>[2] &gt;&gt;&gt;&gt; 类的构造方法</strong></p>
<p>上面定义的 Student 类中，我们手动添加过一个 <code>__init__(self)</code> 方法，事实上，该方法是一个特殊的类方法，称为类的构造方法（构造函数）。</p>
<p>特殊在哪里？？？ &gt;&gt;&gt;&gt;</p>
<p>构造方法是用于后续创建类的对象（类实例化为对象）时使用的，每当创建一个类的实例对象时，Python 解释器都会自动调用它。</p>
<p><strong>1）–&gt;</strong> 隐式构造函数</p>
<p>事实上，定义类时，即使不手动为类添加任何构造方法，Python 也会自动为类添加一个仅包含 self 参数的构造方法（默认构造方法）。并且，在创建类对象（类实例化为对象）时，会自动调用默认构造方法。</p>
<p><strong>2）–&gt;</strong> 显示创建构造函数</p>
<p>手动（显示）添加构造方法的语法格式如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,...</span>):</span></span><br><span class="line">    代码块</span><br></pre></td></tr></table></figure>

<p>构造函数说明：</p>
<ul>
<li>此方法的方法名中，开头和结尾各有 2 个下划线，且中间不能有空格。前面已经说过，Python 中很多这种以双下划线开头、双下划线结尾的方法，都具有特殊的意义；</li>
<li><code>__init__()</code> 方法可以包含多个参数，但必须包含一个名为 <code>self</code> 的参数，且必须作为第一个参数。</li>
</ul>
<p>再贴出包含手动创建构造函数的类定义，重新认识一下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="string">&#x27;类的帮助信息&#x27;</span></span><br><span class="line">    add = <span class="string">&quot;This is my first class&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;这是类的构造函数&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print_score</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;print student`s score.&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>验证 &gt;&gt;&gt;&gt; 创建类的实例对象时，是否会自动调用构造函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="string">&#x27;类的帮助信息&#x27;</span></span><br><span class="line">    add = <span class="string">&quot;This is my first class&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;类的构造函数被调用了！&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print_score</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;print student`s score.&quot;</span>)</span><br><span class="line"></span><br><span class="line">zhang_san = Student() <span class="comment"># 创建一个学生对象 &gt;&gt;&gt; 张三（zhang_san）</span></span><br></pre></td></tr></table></figure>

<p>运行代码可看到如下结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类的构造函数被调用了！</span><br></pre></td></tr></table></figure>

<p>可以发现，创建类的实例对象时，确实隐式调用了我们手动创建的 <code>__init__()</code> 构造方法。</p>
<p><strong>3）–&gt;</strong> 多参数显示构造方法</p>
<p>在 <code>__init__()</code> 构造方法中，除了 self 参数外，还可以自定义一些参数，如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="string">&#x27;类的帮助信息&#x27;</span></span><br><span class="line">    add = <span class="string">&quot;This is my first class&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, score</span>):</span></span><br><span class="line">        print(name, <span class="string">&quot;Score: &quot;</span>, score)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print_score</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;print student`s score.&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>由于在创建对象时会隐式调用类的构造方法，如果构造函数中又定义有多个参数时，必须手动传递参数。但注意，self 不需要手动传递参数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zhang_san = Student(<span class="string">&quot;zhangsan&quot;</span>, <span class="number">100</span>) <span class="comment"># 创建一个学生对象 &gt;&gt;&gt; 张三（zhang_san）</span></span><br></pre></td></tr></table></figure>

<p>输出如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zhangsan Score:  100</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="self-方法参数"><a href="#self-方法参数" class="headerlink" title="self 方法参数"></a>self 方法参数</h3><p>不知道你发现没有，在前面类中定义方法的过程中，无论是定义类的构造方法，还是在类中定义一般方法，都要求将 <code>self</code> 参数作为方法的第一个参数。你可以返回去 Check 一下前面定义好的 Student 类。</p>
<p>那么，self 到底在其中扮演着什么样的角色呢？</p>
<p><strong>[1] &gt;&gt;&gt;&gt; self 由来</strong></p>
<p>事实上，Python 类中关于方法的定义规范是，无论是构造方法还是实例方法，最少要包含一个参数，但并没有规定该参数的具体名称。</p>
<p>也就是说，无论是定义构造方法还是实例方法中，都至少要包含一个参数，该参数名称是任意的（符合标识符命名）。</p>
<p>之所以将其命名为 <code>self</code>，只是程序员之间约定俗成的一种习惯，遵守这个约定，可以使我们编写的代码具有更好的可读性，大家一看到 self 参数，就知道它的作用。</p>
<p>那么 &gt;&gt;&gt;&gt; 为什么要至少包含一个参数，self 参数到底有什么作用呢？</p>
<p><strong>[2] &gt;&gt;&gt;&gt; 方法中第一个参数 self 的作用</strong></p>
<p>我们把类比作是造房子的图纸，那么类实例化后的对象对应的是根据图纸建成的真正可以住的房子（对象创建）。</p>
<p>思考一下 &gt;&gt;&gt;&gt; 根据一张图纸（类），我们可以设计出成千上万的房子（类对象），每个房子长相都是类似的（都有相同的类变量和类方法），但它们都有各自的主人，那么如何对它们进行区分呢？</p>
<p>self 参数来了，它就相当于每个房子的门钥匙（对象的引用），可以保证每个房子的主人在使用房子时仅能进入自己的房子（每个类对象只能调用自己的类变量和类方法）。</p>
<p>类比到 Python 实际场景 &gt;&gt;&gt;&gt;</p>
<p>Python 中，同一个类可以实例化多个类对象，当使用某个对象调用类的方法时，该对象会自动把自身的引用作为第一个参数传给该方法，这样 Python 解释器就明白当前正在调用的类方法属于哪一个对象了。也就是说，对象调用类方法时，Python 会自动绑定类方法的第一个参数使其指向调用该方法的对象。</p>
<p>你可以简单为 &gt;&gt;&gt;&gt;</p>
<p><strong>Python 解释器为了区分不同对象对构造方法或实例方法的拥有权，会自动绑定这些方法的第一个 self 参数到当前调用对象，self 就是一个指向当前调用对象的引用。</strong></p>
<p>这样，你就可以理解上面为什么在调用实例方法和构造方法时，不需要手动为第一个 self 参数传值了。</p>
<p>最后给出一个示例来理解上述说明：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="string">&#x27;类的帮助信息&#x27;</span></span><br><span class="line">    add = <span class="string">&quot;This is my first class&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(self, <span class="string">&quot;正在执行构造方法&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">study</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(self, <span class="string">&quot;正在学习 Python&quot;</span>)</span><br><span class="line"></span><br><span class="line">zhang_san = Student()</span><br><span class="line">print(<span class="string">&quot;Where zhang_san:&quot;</span>, zhang_san)</span><br><span class="line">zhang_san.study()</span><br><span class="line"><span class="comment"># &lt;__main__.Student object at 0x7f2e3521dcf8&gt; 正在执行构造方法</span></span><br><span class="line"><span class="comment"># Where zhang_san: &lt;__main__.Student object at 0x7f2e3521dcf8&gt;</span></span><br><span class="line"><span class="comment"># &lt;__main__.Student object at 0x7f2e3521dcf8&gt; 正在学习 Python</span></span><br><span class="line"></span><br><span class="line">li_si = Student()</span><br><span class="line">print(<span class="string">&quot;Where li_si:&quot;</span>, li_si)</span><br><span class="line">li_si.study()</span><br><span class="line"><span class="comment"># &lt;__main__.Student object at 0x7f2e3521dd68&gt; 正在执行构造方法</span></span><br><span class="line"><span class="comment"># Where li_si: &lt;__main__.Student object at 0x7f2e3521dd68&gt;</span></span><br><span class="line"><span class="comment"># &lt;__main__.Student object at 0x7f2e3521dd68&gt; 正在学习 Python</span></span><br></pre></td></tr></table></figure>

<hr>
<p>好了，我们已经学会如何定义一个类，但要 <strong>想使用定义好的类，必须创建该类的实例对象。</strong></p>
<h3 id="类的对象"><a href="#类的对象" class="headerlink" title="类的对象"></a>类的对象</h3><p>创建类实例对象的过程，又称为类的实例化过程，可以将类实例化成一个个具体的对象。</p>
<p>其语法格式如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类名(参数)</span><br></pre></td></tr></table></figure>

<p>说明：定义类时，如果没有手动添加 <code>__init__()</code> 构造方法，又或者添加的 <code>__init__()</code> 中仅有一个 <code>self</code> 参数，则创建类对象时的参数可以省略不写。</p>
<p>创建了名为 Language 的类，并对其进行了实例化：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Language</span> :</span></span><br><span class="line">    <span class="comment"># 下面定义了 2 个类变量</span></span><br><span class="line">    name = <span class="string">&quot;Python&quot;</span></span><br><span class="line">    add = <span class="string">&quot;Python is a OOP language.&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, add</span>):</span></span><br><span class="line">        <span class="comment"># 下面定义 2 个实例变量</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.add = add</span><br><span class="line">        print(name, <span class="string">&quot;Production：&quot;</span>, add)</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 下面定义了一个 say 实例方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">say</span>(<span class="params">self, content</span>):</span></span><br><span class="line">        print(content)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将该 Language 对象赋给 language 变量</span></span><br><span class="line">language = Language(<span class="string">&quot;Python&quot;</span>,<span class="string">&quot;Python is a OOP language.&quot;</span>)</span><br><span class="line"><span class="comment"># Python Production： Python is a OOP language.</span></span><br></pre></td></tr></table></figure>

<p>上面的程序中，由于构造方法除 <code>self</code> 参数外，还包含 <code>2</code> 个参数，且这 <code>2</code> 个参数没有设置默认参数，因此在实例化类对象时，需要传入相应的 <code>name</code> 值和 <code>add</code> 值（<code>self</code> 参数是特殊参数，不需要手动传值，Python 会自动传给它值）。</p>
<hr>
<p><strong>类实例化对象的使用 &gt;&gt;&gt;&gt;</strong></p>
<p>一般情况下，<strong>类的使用，实际上是对类实例化后对象的使用。</strong></p>
<p>上面我们已经完成了类的实例化，即获得了一个个的具体的对象。实例化后的类对象可以执行以下两种操作：</p>
<ul>
<li>访问或修改类对象具有的实例变量，甚至可以添加新的实例变量或者删除已有的实例变量；</li>
<li>访问类对象的方法，包括调用现有的方法，甚至给类对象动态添加方法。</li>
</ul>
<p><strong>1）–&gt;</strong> 访问类对象的变量或方法</p>
<p>使用已实例化好的类对象，访问类中实例变量（方法）的语法格式如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">类对象名.变量名(方法名)</span><br></pre></td></tr></table></figure>

<p>给出代码演示，如何通过上面 language 对象调用类中的实例变量和实例方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将该 Language 对象赋给 language 变量</span></span><br><span class="line">language = Language(<span class="string">&quot;Python&quot;</span>,<span class="string">&quot;Python is a OOP language.&quot;</span>)</span><br><span class="line"><span class="comment"># Python Production： Python is a OOP language.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问 name &amp;&amp; add 实例变量的值</span></span><br><span class="line">print(language.name, language.add)</span><br><span class="line"><span class="comment"># Python Python is a OOP language.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改实例变量的值</span></span><br><span class="line">language.name = <span class="string">&quot;Python Lesson&quot;</span></span><br><span class="line">language.add = <span class="string">&quot;http://c.biancheng.net/python&quot;</span></span><br><span class="line">print(language.name, language.add)</span><br><span class="line"><span class="comment"># Python Lesson http://c.biancheng.net/python</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 访问（调用）language 的 say()方法</span></span><br><span class="line">language.say(<span class="string">&quot;人生苦短，我用 Python&quot;</span>)</span><br><span class="line"><span class="comment"># 人生苦短，我用 Python</span></span><br></pre></td></tr></table></figure>

<p><strong>2）–&gt;</strong> 为类对象动态增加或删除实例变量</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 为 language 对象增加一个 money 实例变量</span></span><br><span class="line">language.money= <span class="number">159.9</span></span><br><span class="line">print(language.money)</span><br><span class="line"><span class="comment"># 159.9</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除新添加的 money 实例变量</span></span><br><span class="line"><span class="keyword">del</span> language.money</span><br><span class="line"><span class="comment"># 再次尝试输出 money，此时会报错：AttributeError</span></span><br><span class="line">print(language.money)</span><br><span class="line"><span class="comment"># Traceback (most recent call last):</span></span><br><span class="line"><span class="comment">#   File &quot;.code.tio&quot;, line 38, in </span></span><br><span class="line"><span class="comment">#     print(language.money)</span></span><br><span class="line"><span class="comment"># AttributeError: &#x27;Language&#x27; object has no attribute &#x27;money&#x27;</span></span><br></pre></td></tr></table></figure>

<p><strong>3）–&gt;</strong> 为类对象动态增加实例方法</p>
<p>以本节开头的 Language 类为例，由于其内部只包含一个 <code>say()</code> 方法，因此该类实例化出的 language 对象也只包含一个 <code>say()</code> 方法。Python 中允许为类对象动态增加方法，我们还可以为 language 对象动态添加其它方法。</p>
<p>需要注意的是，为 language 对象动态增加的方法，Python 不会自动将调用者自动绑定到第一个参数（即使将第一个参数命名为 self 也没用），函数调用是需要手动绑定。例如如下代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先定义一个函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">info</span>(<span class="params">self</span>):</span></span><br><span class="line">    print(<span class="string">&quot;---info函数---&quot;</span>, self)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将方法 info 动态绑定给 language 对象</span></span><br><span class="line">language.foo = info</span><br><span class="line"><span class="comment"># 需要手动将 info 方法的 self 参数绑定到 language 对象</span></span><br><span class="line">language.foo(language)</span><br><span class="line"><span class="comment"># ---info函数--- &lt;__main__.Language object at 0x7f281a544d30&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用 lambda 表达式为 language 对象动态绑定方法 bar</span></span><br><span class="line">language.bar = <span class="keyword">lambda</span> self: print(<span class="string">&#x27;--lambda表达式--&#x27;</span>, self)</span><br><span class="line">language.bar(language)</span><br><span class="line"><span class="comment"># --lambda表达式-- &lt;__main__.Language object at 0x7f281a544d30&gt;</span></span><br></pre></td></tr></table></figure>

<p>有没有不用手动给 self 传值的动态增加方法呢？ &gt;&gt;&gt;&gt; 需要借助 <code>types</code> 模块下的 <code>MethodType</code>：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">study</span>(<span class="params">self,content</span>):</span></span><br><span class="line">    print(<span class="string">&quot;正在学习：%s&quot;</span> % content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> types <span class="keyword">import</span> MethodType</span><br><span class="line">language.study = MethodType(study, language)</span><br><span class="line"><span class="comment"># 第一个参数已经绑定了，无需传入，可直接进行函数调用了</span></span><br><span class="line">language.study(<span class="string">&quot;Python&quot;</span>)</span><br><span class="line"><span class="comment"># 正在学习：Python</span></span><br></pre></td></tr></table></figure>

<p>由于使用 <code>MethodType</code> 包装 <code>study()</code> 函数时，已经将该函数的 self 参数绑定为 <code>language</code>，因此后续再使用 <code>study()</code> 函数时，就不用再给 self 参数绑定值了。</p>
<hr>
<h3 id="类属性和类方法详解"><a href="#类属性和类方法详解" class="headerlink" title="类属性和类方法详解"></a>类属性和类方法详解</h3><p>对于前面提到的类属性和类方法，看官老爷可能会有一种疑惑：怎么一会儿叫实例属性和实例方法，一会儿叫类属性和类方法，到底是不是一回事儿？？？</p>
<p>至少可以达成一个共识 <strong>&gt;&gt;&gt;&gt;</strong> 无论是类属性还是类方法，都无法像普通变量或者函数那样，在类的外部直接使用它们。我们可以将类看做一个独立的空间，则类属性其实就是在类体中定义的变量，类方法是在类体中定义的函数。</p>
<p>关于上述差别，和前面函数部分讲解的变量作用域是类似的，Python 中根据类体中变量定义的位置，以及变量和方法定义方式的不同，类属性和类方法的叫法以及使用也是有差别的。</p>
<hr>
<h4 id="类属性-amp-amp-实例属性"><a href="#类属性-amp-amp-实例属性" class="headerlink" title="类属性 &amp;&amp; 实例属性"></a>类属性 &amp;&amp; 实例属性</h4><p>在类体中，根据变量定义位置以及方式的不同，类属性可细分为以下 3 种类型：</p>
<ul>
<li>类体中、所有函数之外：此范围定义的变量，称为 <strong>类属性或类变量</strong>；</li>
<li>类体中，所有函数内部：以 <code>self.varName</code> 的方式定义的变量，称为 <strong>实例属性或实例变量</strong>；</li>
<li>类体中，所有函数内部：以 <code>varName = VarName</code> 的方式定义的变量，称为 <strong>局部变量</strong>。</li>
</ul>
<p>那么，类变量、实例变量以及局部变量之间有哪些不同呢？</p>
<p><strong>[1] &gt;&gt;&gt;&gt; 类变量（类属性）</strong></p>
<p>类变量指的是在类中，但在各个类方法外定义的变量。实例如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Language</span> :</span></span><br><span class="line">    <span class="comment"># 下面定义了 2 个类变量</span></span><br><span class="line">    name = <span class="string">&quot;Python&quot;</span></span><br><span class="line">    add = <span class="string">&quot;Python is a OOP language.&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 下面定义了一个 say 实例方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">say</span>(<span class="params">self, content</span>):</span></span><br><span class="line">        print(content)</span><br></pre></td></tr></table></figure>

<p>上面代码中，<code>name</code> 和 <code>add</code> 就属于类变量。</p>
<p><strong>1）–&gt;</strong> 类变量访问方式</p>
<p>类变量的访问方式有 2 种，既可以使用类名直接访问，也可以使用类的实例化对象访问。</p>
<p>类名访问示例（可访问，可修改） &gt;&gt;&gt;&gt;</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用类名直接访问</span></span><br><span class="line">print(Language.name)</span><br><span class="line">print(Language.add)</span><br><span class="line"><span class="comment"># Python</span></span><br><span class="line"><span class="comment"># Python is a OOP language.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改类变量的值</span></span><br><span class="line">Language.name = <span class="string">&quot;Python3.X&quot;</span></span><br><span class="line">Language.add = <span class="string">&quot;Python3.X is a OOP language.&quot;</span></span><br><span class="line">print(Language.name)</span><br><span class="line">print(Language.add)</span><br><span class="line"><span class="comment"># Python3.X</span></span><br><span class="line"><span class="comment"># Python3.X is a OOP language.</span></span><br></pre></td></tr></table></figure>

<p>类对象访问示例（可访问，不可修改） &gt;&gt;&gt;&gt; <strong>不推荐！！！</strong>后续会说明</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">lang = Language()</span><br><span class="line">print(lang.name)</span><br><span class="line">print(lang.add)</span><br><span class="line"><span class="comment"># Python3.X</span></span><br><span class="line"><span class="comment"># Python3.X is a OOP language.</span></span><br></pre></td></tr></table></figure>

<p>需要注意的是，通过类对象对类变量进行赋值，其本质将不再是修改类变量的值，而是在给该对象动态增加新的实例变量。</p>
<p><strong>2）–&gt;</strong> 类变量在所有类的实例化对象中作为公用资源存在</p>
<p>注意，类变量（类属性）为所有实例化对象共有，通过类名修改类变量的值，会影响所有的实例化对象。</p>
<p><strong>3）–&gt;</strong> 动态增加和删除类变量</p>
<p>类似于类对象中动态增加和删除实例变量操作，可以通过类名为类和类对象动态增加或删除类变量：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Language.test = <span class="number">10.2</span></span><br><span class="line">print(Language.test)</span><br><span class="line">print(lang.test)</span><br><span class="line"><span class="comment"># 10.2</span></span><br><span class="line"><span class="comment"># 10.2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> Language.test</span><br><span class="line">print(Language.test)</span><br><span class="line"><span class="comment"># Traceback (most recent call last):</span></span><br><span class="line"><span class="comment">#   File &quot;.code.tio&quot;, line 28, in </span></span><br><span class="line"><span class="comment">#     print(Language.test)</span></span><br><span class="line"><span class="comment"># AttributeError: type object &#x27;Language&#x27; has no attribute &#x27;test&#x27;</span></span><br></pre></td></tr></table></figure>

<p><strong>总结</strong>：使用类名的方式进行类变量（类属性）的访问、修改以及删除，并且类变量（类属性）为所有实例化对象共有。</p>
<hr>
<p><strong>[2] &gt;&gt;&gt;&gt; 实例变量（实例属性）</strong></p>
<p>实例变量指的是在任意类方法内部，以 <code>self.变量名</code> 的方式定义的变量，其特点是只作用于调用方法的对象。</p>
<blockquote>
<p>另外，实例变量只能通过对象名访问，无法通过类名访问。</p>
</blockquote>
<p>示例如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Language</span> :</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.name = <span class="string">&quot;Python&quot;</span></span><br><span class="line">        self.add = <span class="string">&quot;Python is a OOP language.&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 下面定义了一个 say 实例方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">say</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.catalog = <span class="number">1999</span></span><br><span class="line">        </span><br><span class="line">lang = Language()</span><br><span class="line">print(lang.name)</span><br><span class="line">print(lang.add)</span><br><span class="line"><span class="comment"># Python</span></span><br><span class="line"><span class="comment"># Python is a OOP language.</span></span><br><span class="line"></span><br><span class="line">lang2 = Language()</span><br><span class="line">print(lang2.name)</span><br><span class="line">print(lang2.add)</span><br><span class="line"><span class="comment"># Python</span></span><br><span class="line"><span class="comment"># Python is a OOP language.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 只有调用 say()，才会拥有 catalog 实例变量</span></span><br><span class="line">lang2.say()</span><br><span class="line">print(lang2.catalog)</span><br><span class="line"><span class="comment"># 1999</span></span><br><span class="line"><span class="comment"># 由于 lang 对象未调用 say() 方法，因此其没有 catalog 变量，下面这行代码会报错</span></span><br><span class="line">print(lang.catalog)</span><br><span class="line"><span class="comment"># Traceback (most recent call last):</span></span><br><span class="line"><span class="comment">#   File &quot;.code.tio&quot;, line 22, in </span></span><br><span class="line"><span class="comment">#     print(lang.catalog)</span></span><br><span class="line"><span class="comment"># AttributeError: &#x27;Language&#x27; object has no attribute &#x27;catalog&#x27;</span></span><br></pre></td></tr></table></figure>

<p>说明：Language 类中，<code>name</code>、<code>add</code> 以及 <code>catalog</code> 都是实例变量。其中，由于 <code>__init__()</code> 函数在创建类对象时会自动调用，而 <code>say()</code> 方法需要类对象手动调用。因此，Language 类的类对象都会包含 <code>name</code> 和 <code>add</code> 实例变量，而只有调用了 <code>say()</code> 方法的类对象，才包含 <code>catalog</code> 实例变量。</p>
<p>通过 <code>__init__()</code> 构造函数中实例变量（属性）的特性，你应该受到启发 &gt;&gt;&gt;&gt;</p>
<p><strong>1）–&gt;</strong> 实例变量为所有类的实例化对象绑定通用属性</p>
<p>有些人可能会问，既然是通用属性，那将这些通用属性定义为类变量（类属性）不就行了？</p>
<p>你没有考虑到的是，一旦通用属性被定义为类变量后，即被所有类的实例化对象所共享，导致该通用属性在所有对象中的取值都相同，这就失去其意义了。</p>
<p>也就是说，实例变量为类的实例化对象所独占。通过某个对象修改实例变量的值，不会影响类的其它实例化对象。</p>
<hr>
<p><strong>2）–&gt;</strong> 动态增加和删除实例变量</p>
<p>前面讲过，通过类对象可以访问类变量，但无法修改类变量的值。这是因为，通过类对象修改类变量的值，不是在给“类变量赋值”，而是定义新的实例变量。</p>
<p>示例如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Language</span> :</span></span><br><span class="line">    </span><br><span class="line">    name = <span class="string">&quot;Python&quot;</span></span><br><span class="line">    add = <span class="string">&quot;Python is a OOP language.&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 下面定义了一个 say 实例方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">say</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.catalog = <span class="number">1999</span></span><br><span class="line"></span><br><span class="line">lang = Language()</span><br><span class="line"><span class="comment"># lang 访问类变量</span></span><br><span class="line">print(lang.name)</span><br><span class="line">print(lang.add)</span><br><span class="line"><span class="comment"># Python</span></span><br><span class="line"><span class="comment"># Python is a OOP language.</span></span><br><span class="line"></span><br><span class="line">lang.name = <span class="string">&quot;Python3.X&quot;</span></span><br><span class="line">lang.add = <span class="string">&quot;Python3.X is a OOP language.&quot;</span></span><br><span class="line"><span class="comment"># lang 实例变量的值</span></span><br><span class="line">print(lang.name)</span><br><span class="line">print(lang.add)</span><br><span class="line"><span class="comment"># Python3.X</span></span><br><span class="line"><span class="comment"># Python3.X is a OOP language.</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 类变量的值</span></span><br><span class="line">print(Language.name)</span><br><span class="line">print(Language.add)</span><br><span class="line"><span class="comment"># Python</span></span><br><span class="line"><span class="comment"># Python is a OOP language.</span></span><br></pre></td></tr></table></figure>

<p><strong>3）–&gt;</strong> 实例变量和类变量同名问题</p>
<p>类中，实例变量和类变量可以同名，但这种情况下使用类对象将无法调用类变量，它会首选实例变量！！！</p>
<p>明白前面说的：为什么不推荐 “类变量使用对象名调用” 的原因了吧。</p>
<hr>
<p><strong>[3] &gt;&gt;&gt;&gt; 局部变量</strong></p>
<p>除了实例变量，类方法中还可以定义局部变量。和前者不同，局部变量直接以 <code>变量名=值</code> 的方式进行定义，例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Book</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">count</span>(<span class="params">self,money</span>):</span></span><br><span class="line">        sale = <span class="number">0.8</span> * money</span><br><span class="line">        print(<span class="string">&quot;优惠后的价格为：&quot;</span>, sale)</span><br><span class="line"></span><br><span class="line">ibook = Book()</span><br><span class="line">ibook.count(<span class="number">100</span>)</span><br><span class="line"><span class="comment"># 优惠后的价格为： 80.0</span></span><br></pre></td></tr></table></figure>

<p>通常情况下，定义局部变量是为了所在类方法功能的实现。需要注意的一点是，局部变量只能用于所在函数中，函数执行完成后，局部变量也会被销毁。</p>
<hr>
<h4 id="类方法-amp-amp-静态方法-amp-amp-实例方法"><a href="#类方法-amp-amp-静态方法-amp-amp-实例方法" class="headerlink" title="类方法 &amp;&amp; 静态方法 &amp;&amp; 实例方法"></a>类方法 &amp;&amp; 静态方法 &amp;&amp; 实例方法</h4><p>和类属性一样，类方法也可以进行更细致的划分，具体可分为类方法、实例方法和静态方法：</p>
<ul>
<li><strong>类方法</strong>：采用 @classmethod 修饰的方法；</li>
<li><strong>静态方法</strong>：采用 @staticmethod 修饰的方法；</li>
<li><strong>实例方法</strong>：不用任何修饰的方法。</li>
</ul>
<blockquote>
<p>其中 @classmethod 和 @staticmethod 都是函数装饰器，后续章节会对其做详细介绍。</p>
</blockquote>
<p><strong>[1] &gt;&gt;&gt;&gt; 实例方法</strong></p>
<p>通常情况下，在类中定义的方法默认都是实例方法，无需使用任何方法修饰符（使用最多）。</p>
<p>前面章节中，我们定义的类方法均为实例方法。甚至，类的构造方法（函数）理论上也属于实例方法，只不过它比较特殊。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Language</span> :</span></span><br><span class="line">    <span class="comment"># 类构造函数，也属于实例方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.name = <span class="string">&quot;Python&quot;</span></span><br><span class="line">        self.add = <span class="string">&quot;Python is a OOP language.&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 下面定义了一个 say 实例方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">say</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.catalog = <span class="number">1999</span></span><br></pre></td></tr></table></figure>

<p>实例方法最大的特点就是，它最少也要包含一个 <code>self</code> 参数，用于绑定调用此方法的实例对象（Python 会自动完成绑定）。</p>
<p>并且，<strong>实例方法支持如下两种调用方式</strong>：</p>
<ul>
<li>类对象调用（绑定方法调用）；</li>
<li>类名调用（非绑定方法调用）。</li>
</ul>
<p>两种方式的 <strong>调用差别在于</strong>：和前面使用类对象调用实例方法不同，通过类名直接调用实例方法时，Python 并不会自动给 self 参数传值（需要手动传递 self 对象引用）。</p>
<p>也就是说如果想用类调用实例方法，不能像如下这样：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Language</span> :</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 下面定义了一个 info 实例方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">info</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;I am learning python.&quot;</span>)</span><br><span class="line">        </span><br><span class="line">Language.info()</span><br></pre></td></tr></table></figure>

<p>如上使用（不为 self 传入对象引用），会报出如下错误：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;.code.tio&quot;</span>, line <span class="number">7</span>, <span class="keyword">in</span> </span><br><span class="line">    Language.info()</span><br><span class="line">TypeError: info() missing <span class="number">1</span> required positional argument: <span class="string">&#x27;self&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 报错提示：调用 info() 类方式时缺少给 self 参数传参。</span></span><br></pre></td></tr></table></figure>

<p>考虑一下，这也是合理的。<code>self</code> 参数需要的是方法的实际调用者（是类对象），而这里只提供了类名，当然无法自动传值。</p>
<p>故，采用类名调用实例方法时，必须手动为 self 参数传值：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Language</span> :</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 下面定义了一个 info 实例方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">info</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;I am learning python.&quot;</span>)</span><br><span class="line"></span><br><span class="line">lang = Language()        </span><br><span class="line">Language.info(lang)</span><br><span class="line"><span class="comment"># I am learning python.</span></span><br></pre></td></tr></table></figure>

<p>需要注意的是，上面的报错信息只是让我们手动为 <code>self</code> 参数传值，但并没有规定必须传一个该类的对象，其实完全可以任意传入一个参数，例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Language</span> :</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 下面定义了一个 info 实例方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">info</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(self, <span class="string">&quot;am learning python.&quot;</span>)</span><br><span class="line">        </span><br><span class="line">Language.info(<span class="string">&quot;zhang_san&quot;</span>)</span><br><span class="line"><span class="comment"># zhang_san am learning python.</span></span><br></pre></td></tr></table></figure>

<p>可见，<code>&quot;zhang_san&quot;</code> 这个字符串传给了 <code>info()</code> 方法的 <code>self</code> 参数，但这样的使用会引发程序异常，需要注意。</p>
<hr>
<p><strong>[2] &gt;&gt;&gt;&gt; 类方法</strong></p>
<p>Python 类方法和实例方法相似，它最少也要包含一个参数，只不过类方法中通常将其命名为 <code>cls</code>，Python 会自动将 <strong>类本身绑定给 <code>cls</code> 参数</strong>。也就是说，在调用类方法时，无需显式为 cls 参数传参。</p>
<blockquote>
<p>和 <code>self</code> 一样，<code>cls</code> 参数的命名也不是规定的（可以随意命名），只是 Python 程序员约定俗称的习惯而已。</p>
</blockquote>
<p>和实例方法最大的不同在于，类方法需要使用 <code>＠classmethod</code> 修饰符进行修饰，例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Language</span> :</span></span><br><span class="line">    <span class="comment"># 类构造函数，也属于实例方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.name = <span class="string">&quot;Python&quot;</span></span><br><span class="line">        self.add = <span class="string">&quot;Python is a OOP language.&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 下面定义了一个 info 类方法</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">info</span>(<span class="params">cls</span>):</span></span><br><span class="line">        print(<span class="string">&quot;Calling Class Method&quot;</span>, cls)</span><br></pre></td></tr></table></figure>

<p>需要注意的是，如果没有 <code>＠classmethod</code>，则 Python 解释器会将 <code>info()</code> 方法认定为实例方法，而不是类方法。</p>
<p><strong>类方法调用 &gt;&gt;&gt;&gt;</strong></p>
<p>类方法推荐使用类名直接调用，当然也可以使用实例对象来调用（不推荐）:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用类名直接调用：  </span></span><br><span class="line">Language.info()</span><br><span class="line"><span class="comment"># Calling Class Method  </span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用类对象调用：      </span></span><br><span class="line">lang = Language()</span><br><span class="line">lang.info()</span><br><span class="line"><span class="comment"># Calling Class Method</span></span><br></pre></td></tr></table></figure>

<hr>
<p><strong>[3] &gt;&gt;&gt;&gt; 静态方法</strong></p>
<p>静态方法，其实就是前面学习的函数，和函数唯一的区别是，静态方法定义在类这个空间（类命名空间）中，而函数则定义在程序所在的空间（全局命名空间）中。</p>
<p>静态方法没有类似 <code>self</code>、<code>cls</code> 这样的特殊参数，因此 Python 解释器不会对它包含的参数做任何类或对象的绑定。也正因为如此，类的静态方法中无法调用任何类属性和类方法。</p>
<p>静态方法需要使用 <code>＠staticmethod</code> 修饰，例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Language</span> :</span></span><br><span class="line">    <span class="comment"># 下面定义了一个 info 类方法</span></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">info</span>(<span class="params">cls</span>):</span></span><br><span class="line">        print(<span class="string">&quot;Calling Class Method&quot;</span>, cls)</span><br><span class="line">        </span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">test</span>(<span class="params">name, add</span>):</span></span><br><span class="line">        <span class="comment"># info() # 这是错误的</span></span><br><span class="line">        print(name, add)</span><br></pre></td></tr></table></figure>

<p><strong>静态方法的调用 &gt;&gt;&gt;&gt;</strong> </p>
<p>既可以使用类名，也可以使用类对象进行静态方法的调用，例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用类名直接调用：  </span></span><br><span class="line">Language.test(<span class="string">&quot;Python&quot;</span>, <span class="string">&quot;is a OOP language.&quot;</span>)  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 使用类对象调用：      </span></span><br><span class="line">lang = Language()</span><br><span class="line">lang.test(<span class="string">&quot;Python&quot;</span>, <span class="string">&quot;is a OOP language.&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>在实际编程中，几乎不会用到类方法和静态方法，因为我们完全可以使用函数代替它们实现想要的功能，但在一些特殊的场景中（例如工厂模式中），使用类方法和静态方法也是很不错的选择。</p>
<hr>
<h3 id="类命名空间"><a href="#类命名空间" class="headerlink" title="类命名空间"></a>类命名空间</h3><p>前面提到过，Python 类体中的代码位于独立的命名空间（称为类命名空间）中。换句话说，所有用 <code>class</code> 关键字修饰的代码块，都可以看做是位于独立的命名空间中。</p>
<blockquote>
<p>和类命名空间相对的是 <strong>全局命名空间</strong>，即整个 Python 程序默认都位于全局命名空间中。而类体则独立位于 <strong>类命名空间</strong>中。</p>
</blockquote>
<p>事实上，类是由多个类属性和类方法构成，而类属性其实就是定义在类这个独立空间中的变量，而类方法其实就是定义在类空间中的函数，和定义在全局命名空间中的变量和函数相比，并没有明显的不同。</p>
<p>程序实例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 全局空间定义变量</span></span><br><span class="line">name = <span class="string">&quot;Python&quot;</span></span><br><span class="line">add = <span class="string">&quot;Python is a OOP language.&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 全局空间定义函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say</span> ():</span></span><br><span class="line">    print(<span class="string">&quot;Python Global Method&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Language</span>:</span></span><br><span class="line">     <span class="comment"># 定义 Language 空间的类变量</span></span><br><span class="line">    name1 = <span class="string">&quot;Python3.X&quot;</span></span><br><span class="line">    add = <span class="string">&quot;Python3.X is a OOP language.&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 定义 Language 空间的 say </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">say</span>():</span></span><br><span class="line">        print(<span class="string">&quot;Python Method in Class&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用全局的变量和函数</span></span><br><span class="line">print(name,add)</span><br><span class="line">say()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用类独立空间的变量和函数</span></span><br><span class="line">print(Language.name1, Language.add)</span><br><span class="line">Language.say()</span><br></pre></td></tr></table></figure>

<p><strong>类命名空间中编写可执行程序 &gt;&gt;&gt;&gt;</strong></p>
<p>Python 还允许直接在类命名空间中编写可执行程序（例如输出语句、分支语句、循环等等），例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Language</span>:</span></span><br><span class="line">    <span class="comment">#直接编写可执行代码</span></span><br><span class="line">    print(<span class="string">&#x27;正在执行类空间中的代码&#x27;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        print(i)</span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">正在执行类空间中的代码</span><br><span class="line"><span class="number">0</span></span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="number">2</span></span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">4</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="类的封装特性（访问限制）"><a href="#类的封装特性（访问限制）" class="headerlink" title="类的封装特性（访问限制）"></a>类的封装特性（访问限制）</h2><p>这一小节，我们来看面向对象四大特性之一的：封装。</p>
<p>我们知道，类（Class）的内部可以定义类属性和类方法，而外部代码可以直接通过 <font color="red">“类对象.属性名” 或 “类对象.方法名(参数)”</font> 的方式来操作相应数据和类内部方法（看作是一个简单封装）。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, score</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.score = score</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">print_score</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;%s: %s&#x27;</span> % (self.name, self.score))</span><br><span class="line"></span><br><span class="line">bart = Student(<span class="string">&#x27;Bart Simpson&#x27;</span>, <span class="number">59</span>)</span><br><span class="line">print(bart.name, <span class="string">&quot;Score: &quot;</span>, bart.score)</span><br><span class="line">bart.score = <span class="number">99</span></span><br><span class="line">print(bart.score)</span><br><span class="line">bart.print_score()</span><br></pre></td></tr></table></figure>

<p>事实上，更多时候对于设计一个良好封装的类时，我们需要刻意地将一些属性和方法隐藏在类的内部，这样在使用此类时，将无法直接以 <font color="red">“类对象.属性名”（或 “类对象.方法名(参数)”</font> 的形式调用这些属性（或方法）。</p>
<p>那么，如何将不想直接暴露给用户的属性和方法隐藏在类的内部呢？！！ &gt;&gt;&gt;&gt;</p>
<h3 id="Python-中的访问限制"><a href="#Python-中的访问限制" class="headerlink" title="Python 中的访问限制"></a>Python 中的访问限制</h3><p>和其它面向对象的编程语言（如 C++、Java）不同，Python 类中的变量和函数，不是公有的（类似 public 属性），就是私有的（类似 private），这两种属性的区别如下：</p>
<ul>
<li>public：公有属性的类变量和类函数，在类的外部、类内部以及子类中，都可以正常访问；</li>
<li>private：私有属性的类变量和类函数，只能在本类内部使用，类的外部以及子类都无法使用。</li>
</ul>
<p>但是，Python 并没有提供 <code>public</code>、<code>private</code> 这些修饰符。为了实现类的封装，Python 采取了下面的方法：</p>
<ul>
<li>默认情况下，Python 类中的变量和方法都是公有（public）的，它们的名称前都没有下划线 <code>(_)</code>；</li>
<li>如果类中的变量和函数，其名称以双下划线 <code>(__)</code> 开头，则该变量（函数）为私有变量（私有函数），其属性等同于 private。</li>
</ul>
<p>所以，我们把 <code>Student</code> 类改一改：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, score</span>):</span></span><br><span class="line">        self.__name = name</span><br><span class="line">        self.__score = score</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__print_score</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;%s: %s&#x27;</span> % (self.__name, self.__score))</span><br></pre></td></tr></table></figure>

<p>改完之后，对于外部代码来说，没什么变动，但是已经无法从外部访问 <code>实例变量.__name</code> &amp;&amp; <code>实例变量.__score</code> &amp;&amp; <code>实例变量.__print_score</code> 了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">bart = Student(<span class="string">&#x27;Bart Simpson&#x27;</span>, <span class="number">59</span>)</span><br><span class="line"></span><br><span class="line">print(bart.__name, <span class="string">&quot;Score: &quot;</span>, bart.__score)</span><br><span class="line"><span class="comment"># Traceback (most recent call last):</span></span><br><span class="line"><span class="comment">#   File &quot;.code.tio&quot;, line 12, in </span></span><br><span class="line"><span class="comment">#     print(bart.__name, &quot;Score: &quot;, bart.__score)</span></span><br><span class="line"><span class="comment"># AttributeError: &#x27;Student&#x27; object has no attribute &#x27;__name&#x27;</span></span><br><span class="line">bart.__print_score()</span><br><span class="line"><span class="comment"># AttributeError: &#x27;Student&#x27; object has no attribute &#x27;__print_score&#x27;</span></span><br></pre></td></tr></table></figure>

<p><strong>私有变量或方法命名问题</strong></p>
<p>除此之外，还可以定义以单下划线 <code>(_)</code> 开头的类属性或者类方法（例如 <code>_name</code>、<code>_display(self)</code>），这种类属性和类方法通常也被视为私有属性和私有方法。虽然它们也能通过类对象正常访问，但是按照约定俗成的规定，当你看到这样的变量或方法时，意思就是，“虽然我可以被访问，但是，请把我视为私有，不要随意访问”。</p>
<p>注意，Python 类中还有以双下划线 <code>(__)</code> 开头和结尾的类方法（例如类的构造函数 <code>__init__(self)</code>），这些都是 Python 内部定义的，用于 Python 内部调用。我们自己定义类属性或者类方法时，不要使用这种格式。·</p>
<p>这样就确保了外部代码不能随意修改对象内部的状态，这种通过访问限制的保护，会使得代码更加健壮。</p>
<hr>
<p>那么，如何访问这些被规定了访问限制的私有属性呢 &gt;&gt;&gt;&gt; </p>
<p>你需要使用<font color="red"> Python 中的描述符协议</font>，或者使用类定义时暴露出来的 <font color="red">未隐藏的类方法</font> 来间接操作这些隐藏的属性和方法（本质上都是通过 get &amp;&amp; set 方法进行访问）。</p>
<h3 id="Python-中的描述符"><a href="#Python-中的描述符" class="headerlink" title="Python 中的描述符"></a>Python 中的描述符</h3><p>先来认识一下 Python 中描述符的概念：</p>
<p>本质上，描述符就是一个类，只不过它定义了另一个类中属性的访问方式。换句话说，一个类可以将属性管理全权委托给描述符类。</p>
<blockquote>
<p>描述符是 Python 中复杂属性访问的基础，它在内部被用于实现 <code>property</code>、<code>@property 装饰器</code> 和 <code>super</code> 类型等。这里先不容深究这些概念~~~后文会给出相关说明。</p>
</blockquote>
<p>描述符类基于以下 3 个特殊方法（换句话说，这 3 个方法组成了描述符协议）：</p>
<ul>
<li><code>__get__(self, obj, value)</code>：在读取属性时将调用这一方法（本节后续用 <code>getter</code> 表示）；</li>
<li><code>__set__(self, obj, type=None)</code>：在设置属性时将调用这一方法（本节后续用 <code>setter</code> 表示）；</li>
<li><code>__delete__(self, obj)</code>：对属性调用 del 时将调用这一方法。</li>
</ul>
<p>其中，实现了 <code>setter</code> 和 <code>getter</code> 方法的描述符类被称为 <strong>数据描述符</strong>；反之，如果只实现了 <code>getter</code> 方法，则称为 <strong>非数据描述符</strong>。</p>
<p>实际上，在每次进行属性访问时，描述符协议中的方法都由类对象的特殊方法 <code>__getattribute__()</code> 调用（注意不要和 <code>__getattr__()</code> 弄混）。也就是说，每次使用 <font color="red">类对象.属性（或者 getattr(类对象，属性值)）</font>的调用方式时，都会隐式地调用 <code>__getattribute__()</code>，它会按照下列顺序查找该属性：</p>
<ol>
<li>验证该属性是否为类实例对象的数据描述符；</li>
<li>如果不是，就查看该属性是否能在类实例对象的 <code>__dict__</code> 中找到；</li>
<li>最后，查看该属性是否为类实例对象的非数据描述符。</li>
</ol>
<p>为了表达清楚，这里举个例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 描述符类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">revealAccess</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, initval = <span class="literal">None</span>, name = <span class="string">&#x27;var&#x27;</span></span>):</span></span><br><span class="line">        self.val = initval</span><br><span class="line">        self.name = name</span><br><span class="line"></span><br><span class="line">    <span class="comment"># getter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__get__</span>(<span class="params">self, obj, objtype</span>):</span></span><br><span class="line">        print(<span class="string">&quot;Retrieving&quot;</span>,self.name)</span><br><span class="line">        <span class="keyword">return</span> self.val</span><br><span class="line">    <span class="comment"># setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__set__</span>(<span class="params">self, obj, val</span>):</span></span><br><span class="line">        print(<span class="string">&quot;updating&quot;</span>,self.name)</span><br><span class="line">        self.val = val</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myClass</span>:</span></span><br><span class="line">    x = revealAccess(<span class="number">10</span>, <span class="string">&#x27;var &quot;x&quot;&#x27;</span>)</span><br><span class="line">    y = <span class="number">5</span></span><br><span class="line"></span><br><span class="line">m = myClass()</span><br><span class="line">print(m.x)</span><br><span class="line"><span class="comment"># Retrieving var &quot;x&quot;</span></span><br><span class="line"><span class="comment"># 10</span></span><br><span class="line"></span><br><span class="line">m.x = <span class="number">20</span></span><br><span class="line"><span class="comment"># updating var &quot;x&quot;</span></span><br><span class="line">print(m.x)</span><br><span class="line">print(m.y)</span><br><span class="line"><span class="comment"># Retrieving var &quot;x&quot;</span></span><br><span class="line"><span class="comment"># 20</span></span><br><span class="line"><span class="comment"># 5</span></span><br></pre></td></tr></table></figure>

<p>可以看出，如果一个类的某个属性有数据描述符，那么每次查找这个属性时，都会调用描述符的 <code>__get__()</code> 方法，并返回它的值；同样，每次在对该属性赋值时，也会调用 <code>__set__()</code> 方法。</p>
<p>注意，虽然上面例子中没有使用 <code>__del__()</code> 方法，但也很容易理解，当每次使用 <code>del 类对象.属性（或者 delattr(类对象，属性)）</code> 语句时，都会调用该方法。</p>
<hr>
<p>除了使用描述符类来对类属性进行封装外，还可以使用 <strong>property()函数</strong> 或者 <strong>@property 装饰器</strong>：</p>
<h3 id="Python-property-函数"><a href="#Python-property-函数" class="headerlink" title="Python property() 函数"></a>Python property() 函数</h3><p>前面，我们一直在用 <code>类对象.属性</code> 的方式访问类中定义的属性，其实这种做法是欠妥的，因为它破坏了类的封装原则。正常情况下，类包含的属性应该是隐藏的，只允许通过类提供的公共方法（未隐藏的类方法）来间接实现对类属性的访问和操作。</p>
<p>因此，在不破坏类封装原则的基础上，为了能够有效操作类中的属性，类中应定义用于读（或写）类属性的多个 getter &amp;&amp; setter 方法，这样就可以通过这些暴露出来的公共方法来操作隐藏的类属性了。</p>
<p>例如，上面的 Student 类中，如果外部代码要访问、修改以及删除 <code>name</code> 怎么办？方法如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, score</span>):</span></span><br><span class="line">        self.__name = name</span><br><span class="line">        self.__score = score</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 设置 name 属性值的函数 </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setname</span>(<span class="params">self,name</span>):</span></span><br><span class="line">        self.__name = name</span><br><span class="line">    <span class="comment"># 访问 name 属性值的函数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getname</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.__name</span><br><span class="line">    <span class="comment"># 删除 name 属性值的函数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delname</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.__name = <span class="string">&quot;xxxx&quot;</span></span><br><span class="line"></span><br><span class="line">bart = Student(<span class="string">&#x27;Bart Simpson&#x27;</span>, <span class="number">99</span>)</span><br><span class="line"><span class="comment"># 获取 name 属性值</span></span><br><span class="line">print(bart.getname())</span><br><span class="line"><span class="comment"># Bart Simpson</span></span><br><span class="line"><span class="comment"># 设置 name 属性值</span></span><br><span class="line">bart.setname(<span class="string">&quot;Bart Valli&quot;</span>)</span><br><span class="line">print(bart.getname())</span><br><span class="line"><span class="comment"># Bart Valli</span></span><br><span class="line"><span class="comment"># 删除 name 属性值</span></span><br><span class="line">bart.delname()</span><br><span class="line">print(bart.getname())</span><br><span class="line"><span class="comment"># xxxx</span></span><br></pre></td></tr></table></figure>

<p>看官老爷可能会觉得，这种操作类属性的方式比较麻烦，更习惯使用 <code>类对象.属性</code> 这种方式。</p>
<p><strong>property() 函数登场 &gt;&gt;&gt;&gt;</strong></p>
<p>庆幸的是，Python 中提供了 <code>property()</code> 函数，让开发者依旧使用 <code>类对象.属性</code> 的方式操作类中的属性。其语法格式如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">属性名 = <span class="built_in">property</span>(fget=<span class="literal">None</span>, fset=<span class="literal">None</span>, fdel=<span class="literal">None</span>, doc=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure>

<p>说明，<code>fget</code> 参数用于指定获取该属性值的类方法，<code>fset</code> 参数用于指定设置该属性值的方法，<code>fdel</code> 参数用于指定删除该属性值的方法，最后的 doc 是一个文档字符串，用于说明此函数的作用。</p>
<blockquote>
<p>注意，在使用 <code>property()</code> 函数时，以上 4 个参数可以仅指定第 1 个、或者前 2 个、或者前 3 个，当前也可以全部指定。也就是说，<code>property()</code> 函数中参数的指定并不是完全随意的。</p>
</blockquote>
<p>例如，修改上面的程序，为 <code>name</code> 属性配置 <code>property()</code> 函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, score</span>):</span></span><br><span class="line">        self.__name = name</span><br><span class="line">        self.__score = score</span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 设置 name 属性值的函数 </span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">setname</span>(<span class="params">self,name</span>):</span></span><br><span class="line">        self.__name = name</span><br><span class="line">    <span class="comment"># 访问 name 属性值的函数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getname</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.__name</span><br><span class="line">    <span class="comment"># 删除 name 属性值的函数</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">delname</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.__name = <span class="string">&quot;xxxx&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 为 name 属性配置 property 函数</span></span><br><span class="line">    name = <span class="built_in">property</span>(getname, setname, delname, <span class="string">&quot;Name Getter &amp;&amp; Setter &amp;&amp; deleter&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调取说明文档的 2 种方式</span></span><br><span class="line">print(Student.name.__doc__)</span><br><span class="line"><span class="comment"># Name Getter &amp;&amp; Setter &amp;&amp; Del</span></span><br><span class="line"><span class="built_in">help</span>(Student.name)</span><br><span class="line"><span class="comment"># Help on property:</span></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="comment">#     Name Getter &amp;&amp; Setter &amp;&amp; Del</span></span><br><span class="line">    </span><br><span class="line">bart = Student(<span class="string">&#x27;Bart Simpson&#x27;</span>, <span class="number">99</span>)</span><br><span class="line"><span class="comment"># 获取 name  property 函数</span></span><br><span class="line">print(bart.name)</span><br><span class="line"><span class="comment"># Bart Simpson</span></span><br><span class="line"><span class="comment"># 设置 name  property 函数</span></span><br><span class="line">bart.name = <span class="string">&quot;Bart Valli&quot;</span></span><br><span class="line">print(bart.name)</span><br><span class="line"><span class="comment"># Bart Valli</span></span><br><span class="line"><span class="comment"># 删除 name 属性值</span></span><br><span class="line"><span class="keyword">del</span> bart.name</span><br><span class="line">print(bart.name)</span><br><span class="line"><span class="comment"># xxxx</span></span><br></pre></td></tr></table></figure>

<p>注意，由于 <code>getname()</code> 方法中需要返回 <code>name</code> 属性，如果使用 <code>self.name</code> 的话，其本身又被调用 <code>getname()</code>，这将会先入无限死循环。</p>
<p>当然，<code>property()</code> 函数也可以少传入几个参数。以上面的程序为例，我们可以修改 <code>property()</code> 函数如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="built_in">property</span>(getname, setname)</span><br></pre></td></tr></table></figure>

<p>这意味着，<code>name</code> 是一个可读写的属性，但不能删除。因为 <code>property()</code> 函数中并没有为 <code>name</code> 配置用于函数该属性的方法。也就是说，即便 Student 类中设计有 <code>delname()</code> 函数，这种情况下也不能用来删除 <code>name</code> 属性。但你仍然可以使用 <code>delname</code> 函数。</p>
<hr>
<h3 id="Python-property-装饰器"><a href="#Python-property-装饰器" class="headerlink" title="Python @property 装饰器"></a>Python @property 装饰器</h3><p>Python 中，既要保护类的封装特性，又要让开发者可以使用 <code>对象.属性</code> 的方式操作操作类属性，除了使用 <code>property()</code> 函数，Python 还提供了 <code>@property</code> 装饰器。</p>
<p>通过 @property 装饰器，可以直接通过方法名来访问方法，不需要在方法名后添加一对 <code>()</code> 小括号。</p>
<p>@property 的语法格式如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@property</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> 方法名(<span class="params">self</span>)</span></span><br><span class="line"><span class="function">    代码块</span></span><br></pre></td></tr></table></figure>

<p>例如，定义一个矩形类，并定义用 <code>@property</code> 修饰的方法操作类中的 <code>area</code> 私有属性，代码如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rect</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,area</span>):</span></span><br><span class="line">        self.__area = area</span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">area</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.__area</span><br><span class="line"></span><br><span class="line">rect = Rect(<span class="number">30</span>)</span><br><span class="line">print(<span class="string">&quot;矩形的面积是：&quot;</span>, rect.area)</span><br><span class="line"><span class="comment"># 矩形的面积是： 30</span></span><br></pre></td></tr></table></figure>

<p>上面程序中，使用 ＠property 修饰了 <code>area()</code> 方法，这样就使得该方法变成了 <code>area</code> 私有属性的 <code>getter</code> 方法。</p>
<p>你可以将其简单看作是为 <code>area</code> 私有属性添加一个不带下划线的同名 <code>getter</code> 方法，以提供 <code>对象.属性</code> 方式进行私有属性的读取。如果只包含该方法，<code>area</code> 私有属性只具有读属性。</p>
<p>也就是说，在使用 <code>Rect</code> 类时，无法对 <code>area</code> 属性重新赋值，即运行如下代码会报错：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">rect.area = <span class="number">90</span></span><br><span class="line">print(<span class="string">&quot;修改后的面积：&quot;</span>, rect.area)</span><br><span class="line"><span class="comment"># Traceback (most recent call last):</span></span><br><span class="line"><span class="comment">#   File &quot;.code.tio&quot;, line 12, in </span></span><br><span class="line"><span class="comment">#     rect.area = 90</span></span><br><span class="line"><span class="comment"># AttributeError: can&#x27;t set attribute</span></span><br></pre></td></tr></table></figure>

<p>如果想要为 <code>area</code> 私有属性添加修改以及删除操作，就需要使用 <code>setter 装饰器 &amp;&amp; deleter 装饰器</code> 添加不带下划线的同名 <code>getter &amp;&amp; deleter</code> 方法:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@area.setter</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">area</span>(<span class="params">self, value</span>):</span></span><br><span class="line">    self.__area = value</span><br><span class="line"><span class="meta">@area.deleter</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">area</span>(<span class="params">self</span>):</span></span><br><span class="line">    self.__area = <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>完整代码样例如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rect</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,area</span>):</span></span><br><span class="line">        self.__area = area</span><br><span class="line"><span class="meta">    @property</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">area</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.__area</span><br><span class="line"><span class="meta">    @area.setter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">area</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        self.__area = value</span><br><span class="line"><span class="meta">    @area.deleter</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">area</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.__area = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">rect = Rect(<span class="number">30</span>)</span><br><span class="line">print(<span class="string">&quot;矩形的面积是：&quot;</span>, rect.area)</span><br><span class="line"><span class="comment"># 矩形的面积是： 30</span></span><br><span class="line"></span><br><span class="line">rect.area = <span class="number">90</span></span><br><span class="line">print(<span class="string">&quot;修改后的面积：&quot;</span>, rect.area)</span><br><span class="line"><span class="comment"># 修改后的面积： 90</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> rect.area</span><br><span class="line">print(<span class="string">&quot;删除后的 area 值为：&quot;</span>, rect.area)</span><br><span class="line"><span class="comment"># 删除后的 area 值为： 0</span></span><br></pre></td></tr></table></figure>

<p>这样 <code>area</code> 私有属性就有了 <code>getter &amp;&amp; setter &amp;&amp; deleter</code> 方法，该属性就变成了具有读、写、删除功能的属性了。</p>
<hr>
<h3 id="访问限制优点"><a href="#访问限制优点" class="headerlink" title="访问限制优点"></a>访问限制优点</h3><p>使用上述的封装机制，保证了类内部数据结构的完整性。因为使用类的用户无法直接看到类中的数据结构，只能使用类允许公开的数据和方法，很好地避免了外部对内部数据的影响，提高了程序的可维护性。</p>
<p>并且由于用户只能借助暴露出来的类方法来访问数据，这时只需要在这些暴露的方法中加入适当的控制逻辑，即可轻松避免用户对类中属性或方法的不合理操作，有助于提高程序的健壮性。</p>
<p>例如，你可以通过下面形式来提高程序的健壮性：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_score</span>(<span class="params">self, score</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="number">0</span> &lt;= score &lt;= <span class="number">100</span>:</span><br><span class="line">            self.__score = score</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&#x27;bad score&#x27;</span>)</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="深入了解访问限制底层原理"><a href="#深入了解访问限制底层原理" class="headerlink" title="深入了解访问限制底层原理"></a>深入了解访问限制底层原理</h3><p>事实上，Python 封装特性的实现纯属“投机取巧”，之所以类对象无法直接调用以双下划线开头命名的类属性和类方法，是因为其底层实现时，Python 偷偷改变了它们的名称。</p>
<p>我们定义了一个 Student 类，定义如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, score</span>):</span></span><br><span class="line">        self.__name = name</span><br><span class="line">        self.__score = score</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__print_score</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;%s: %s&#x27;</span> % (self.__name, self.__print_score))</span><br></pre></td></tr></table></figure>

<p>在这个类中，有一个 <code>__print_score()</code> 方法，由于其是私有方法，且该类没有提供任何调用该方法的“接口”，因此在目前看来，此方法根本无法在类外部调用。也就是说，如下调用 <code>__print_score()</code> 方法是不可行的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">zhangsan = Student(<span class="string">&quot;zhang_san&quot;</span>, <span class="number">99</span>)</span><br><span class="line">zhang_san.__print_score()</span><br><span class="line"><span class="comment"># Traceback (most recent call last):</span></span><br><span class="line"><span class="comment">#   File &quot;.code.tio&quot;, line 11, in </span></span><br><span class="line"><span class="comment">#     zhangsan.__print_score()</span></span><br><span class="line"><span class="comment"># AttributeError: &#x27;Student&#x27; object has no attribute &#x27;__print_score&#x27;</span></span><br></pre></td></tr></table></figure>

<p>那么，是不是类似 <code>__print_score()</code> 这种的私有方法，真的没有方法调用吗？</p>
<p>事实上，对于以双下划线开头命名的类属性或类方法，Python 在底层实现时，将它们的名称都偷偷改成了 <code>_类名__属性（方法）名</code> 的格式。</p>
<p>以 Student 类中的 <code>__print_score()</code> 为例，Python 在底层将其方法名偷偷改成了<code>_Student__print_score</code> 。例如在 Student 类的基础上，执行如下代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, score</span>):</span></span><br><span class="line">        self.__name = name</span><br><span class="line">        self.__score = score</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__print_score</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;%s: %s&#x27;</span> % (self.__name, self.__score))</span><br><span class="line"></span><br><span class="line">zhangsan = Student(<span class="string">&quot;zhang_san&quot;</span>, <span class="number">99</span>)</span><br><span class="line">zhangsan._Student__print_score()</span><br><span class="line"><span class="comment"># zhang_san: 99</span></span><br></pre></td></tr></table></figure>

<p>原来如此~~~，再尝试一下私有的类属性的访问：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">print(zhangsan._Student__name)</span><br><span class="line">print(zhangsan._Student__score)</span><br><span class="line"><span class="comment"># zhang_san</span></span><br><span class="line"><span class="comment"># 99</span></span><br><span class="line"></span><br><span class="line">zhangsan._Student__score = <span class="number">69</span></span><br><span class="line">print(zhangsan._Student__score)</span><br><span class="line"><span class="comment"># 69</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="类的继承特性"><a href="#类的继承特性" class="headerlink" title="类的继承特性"></a>类的继承特性</h2><p>继承特性，经常用于创建和现有类功能类似的新类，又或是新类只需要在现有类基础上添加一些成员（属性和方法），但又不想直接将现有类代码复制给新类。也就是说，通过使用继承这种机制，可以轻松实现类的重复使用，提高其复用性。</p>
<p>在 OOP 程序设计中，当我们定义一个 class 的时候，可以从某个现有的 class 继承，新的 class 称为 <strong>子类（Subclass）</strong>，而被继承的 class 称为 <strong>基类、父类或超类（Base class、Super class）</strong>。有读者可能还听说过 “派生” 这个词汇，它和继承是一个意思，只是观察角度不同而已。换句话说，<font color='red'>继承是相对子类来说的，即子类继承自父类；而派生是相对于父类来说的，即父类派生出子类。</font></p>
<p>子类继承父类时，只需在定义子类时，将父类（可以是多个）放在子类之后的圆括号里即可。语法格式如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> 类名(<span class="params">父类<span class="number">1</span>, 父类<span class="number">2</span>, ...</span>)：</span></span><br><span class="line"><span class="class">    #类定义部分</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意，如果类中没有显式指定继承自哪个类，则默认继承 object 类（object 类是 Python 中所有类的父类，顶级父类）。另外，Python 的继承是多继承机制（和 C++ 一样），即一个子类可以同时拥有多个直接父类。</p>
</blockquote>
<p>假设已经编写了一个名为 <code>Animal</code> 的类，定义有一个 <code>run()</code> 实例方法可以直接打印：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;Animal is running...&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>当我们需要编写 <code>Dog </code>和 <code>Cat</code> 类时，要求新类不仅具有 <code>run()</code> 方法，还具有叫声方法 <code>call()</code>。此时，笨方法是将 <code>run()</code> 方法直接复制到新类中并且添加表示叫声的方法 <code>call()</code>，这样就没有复用之前已经定义好的 <code>Animal</code> 类。</p>
<p>事实上，更简单的方法，就是使用类的继承机制。此时可以直接从 <code>Animal</code> 类继承：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;Animal is running...&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>(<span class="params">Animal</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">call</span>():</span></span><br><span class="line">        print(<span class="string">&quot;Dog is calling:&quot;</span>, <span class="string">&quot;Wangwangwang....&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>(<span class="params">Animal</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">call</span>():</span></span><br><span class="line">        print(<span class="string">&quot;Cat is calling:&quot;</span>, <span class="string">&quot;Miaomiaomiao....&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>对于 <code>Dog </code>来说，<code>Animal</code> 就是它的父类，对于 <code>Animal</code> 来说，<code>Dog</code> 就是它的子类。<code>Cat</code> 和 <code>Dog</code> 类似。</p>
<hr>
<p><strong>[1] &gt;&gt;&gt;&gt; 子类继承父类所有的属性以及方法</strong></p>
<p>继承有什么好处？？？</p>
<p>继承最大的好处是子类获得了父类的全部功能，即具有父类全部的属性和方法（即便该属性或方法是私有（private）的）。</p>
<p>上面由于 <code>Animial</code> 类中已经实现了 <code>run()</code> 方法，因此 <code>Dog</code> 和 <code>Cat</code> 作为它的子类，即使什么事也没干，但自动拥有了 <code>run()</code> 方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    name = <span class="string">&quot;This is a Animal&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;Animal is running...&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>(<span class="params">Animal</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>(<span class="params">Animal</span>):</span></span><br><span class="line">	<span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">jinmao = Dog()</span><br><span class="line">print(jinmao.name)</span><br><span class="line"><span class="comment"># This is a Animal</span></span><br><span class="line">jinmao.run()</span><br><span class="line"><span class="comment"># Animal is running...</span></span><br></pre></td></tr></table></figure>

<hr>
<p><strong>[2] &gt;&gt;&gt;&gt; 子类重写（覆盖）父类中方法</strong></p>
<p>继承第二个好处是在子类中可以重写父类中方法。</p>
<p>我们知道，子类继承了父类，那么子类就拥有了父类所有的类属性和类方法。通常情况下，子类会在此基础上，扩展一些新的类属性和类方法。</p>
<p>能会遇到这样一种情况，即子类从父类继承得来的类方法中，大部分是适合子类使用的，但有个别的类方法，并不能直接照搬父类的，如果不对这部分类方法进行修改，子类对象无法使用。针对这种情况，我们就需要在子类中重复父类的方法。</p>
<p>上面 Animal 的例子，无论是 <code>Dog </code>还是 <code>Cat</code>，它们 <code>run()</code> 的时候，显示的都是 <code>Animal is running...</code>，然而符合逻辑的做法是分别显示 <code>Dog is running...</code> 和 <code>Cat is running...</code>，因此：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    name = <span class="string">&quot;This is a Animal&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;Animal is running...&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>(<span class="params">Animal</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;Dog is running...&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Cat</span>(<span class="params">Animal</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;Cat is running...&#x27;</span>)</span><br><span class="line"></span><br><span class="line">jinmao = Dog()</span><br><span class="line">jinmao.run()</span><br><span class="line"><span class="comment"># Dog is running...</span></span><br><span class="line"></span><br><span class="line">xianluo = Cat()</span><br><span class="line">xianluo.run()</span><br><span class="line"><span class="comment"># Cat is running...</span></span><br></pre></td></tr></table></figure>

<p>事实上，如果我们在子类中重写（覆盖）了从父类继承来的类方法，那么当在类的外部通过子类对象调用该方法时，Python 总是会执行子类中重写的方法。</p>
<p><strong>子类中调用父类中被重写的方法 &gt;&gt;&gt;&gt;</strong></p>
<p>这就产生一个新的问题，即如果想调用父类中被重写的这个方法，该怎么办呢？</p>
<p>我们知道，Python 中的类可以看做是一个独立空间，而类方法其实就是出于该空间中的一个函数。而如果想要全局空间或者其它类的独立空间中，调用类空间中的函数，只需要通过类名调用该函数即可（要注意此时为未绑定方法调用，注意给 self 传参）。</p>
<hr>
<p><strong>[3] &gt;&gt;&gt;&gt; Python 中的多继承</strong></p>
<p>大部分面向对象的编程语言，都只支持单继承，即子类有且只能有一个父类。而 Python 却支持多继承（C++也支持多继承）。和单继承相比，多继承容易让代码逻辑复杂、思路混乱，一直备受争议，中小型项目中较少使用，后来的 Java、C#、PHP 等干脆取消了多继承。</p>
<p>使用多继承经常需要面临的问题是，多个父类中包含同名的类方法。</p>
<p>对于这种情况，Python 的处置措施是：根据子类继承多个父类时这些父类的前后次序决定，即排在前面父类中的类方法会覆盖排在后面父类中的同名类方法。</p>
<p>举个样例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.name = People</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">say</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;People 类: &quot;</span>, self.name)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.name = Animal</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">say</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;Animal 类: &quot;</span>,self.name)</span><br><span class="line">        </span><br><span class="line"><span class="comment"># People中的 name 属性和 say() 会遮蔽 Animal 类中的</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">People, Animal</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Dog</span>(<span class="params">Animal, People</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">zhangsan = Person()</span><br><span class="line">zhangsan.name = <span class="string">&quot;Zhang San&quot;</span></span><br><span class="line">zhangsan.say()</span><br><span class="line"></span><br><span class="line">jinmao = Dog()</span><br><span class="line">jinmao.name = <span class="string">&quot;Jin Mao&quot;</span></span><br><span class="line">jinmao.say()</span><br></pre></td></tr></table></figure>

<p>推荐：尽管 Python 在语法上支持多继承，但逼不得已，建议大家不要使用多继承。</p>
<hr>
<h3 id="深入理解-Python-中的-MRO"><a href="#深入理解-Python-中的-MRO" class="headerlink" title="深入理解 Python 中的 MRO"></a>深入理解 Python 中的 MRO</h3><p>我们知道，Python 类是支持（多）继承的，一个类的方法和属性可能定义在当前类，也可能定义在基类。当调用类方法或类属性时，就需要对当前类以及它的基类进行搜索，以确定方法或属性的位置，而搜索的顺序就称为方法解析顺序（MRO）。</p>
<p>方法解析顺序（Method Resolution Order，MRO）。对于 <font color='red'>只支持单继承的编程语言来说，MRO 很简单，就是从当前类开始，逐个搜索它的父类（思考一下上面说到的 “子类重写（覆盖）父类中方法”）</font>；而对于 Python，它支持多继承，MRO 相对会复杂一些。</p>
<p>实际上，Python 发展至今，经历了以下 3 种 MRO 算法，分别是：</p>
<ol>
<li>从左往右，采用深度优先搜索（Deep-first search, DFS）的算法，称为旧式类的 MRO；</li>
<li>自 Python 2.2 版本开始，新式类 MRO 在采用深度优先搜索算法的基础上，对其做了优化；</li>
<li>自 Python 2.3 版本，对新式类采用了 C3 算法。由于 Python3.X 仅支持新式类，所以我们只使用 C3 算法。</li>
</ol>
<p>为什么 MRO 弃用了前两种算法，而选择最终的 C3 算法呢？？？ &gt;&gt;&gt;&gt; 前两种算法都存在一定的问题。</p>
<hr>
<h4 id="旧式类-MRO-算法"><a href="#旧式类-MRO-算法" class="headerlink" title="旧式类 MRO 算法"></a>旧式类 MRO 算法</h4><p>在使用旧式类的 MRO 算法时，以 【程序一】 为例:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">method</span>(<span class="params">self</span>):</span></span><br><span class="line">      print(<span class="string">&quot;CommonA&quot;</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>(<span class="params">A</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>(<span class="params">A</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">method</span>(<span class="params">self</span>):</span></span><br><span class="line">      print(<span class="string">&quot;CommonC&quot;</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>(<span class="params">B, C</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">D().method()</span><br></pre></td></tr></table></figure>

<p>通过分析可以想到，此程序中的 4 个类是一个“菱形”继承的关系，当使用 D 类对象访问 <code>method()</code> 方法时，根据 <strong>深度优先算法</strong>，搜索顺序为 <code>D-&gt;B-&gt;A-&gt;C-&gt;A</code>。</p>
<p>因此，使用旧式类的 MRO 算法最先搜索得到的是基类 <code>A</code> 中的 <code>method()</code> 方法，即在 Python&lt;2.2 版本中，此程序的运行结果为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CommonA</span><br></pre></td></tr></table></figure>

<p>但是，这个结果显然不是想要的，我们希望搜索到的是 <code>C</code> 类中的 <code>method()</code> 方法。</p>
<hr>
<h4 id="新式类-MRO-算法"><a href="#新式类-MRO-算法" class="headerlink" title="新式类 MRO 算法"></a>新式类 MRO 算法</h4><p>Python 2.2 版本中推出了新的计算新式类 MRO 的方法，它仍然采用从左至右的 <strong>深度优先遍历，但是如果遍历中出现重复的类，只保留最后一个。</strong></p>
<p>【程序一】 中，通过深度优先遍历，其搜索顺序为 <code>D-&gt;B-&gt;A-&gt;C-&gt;A</code>，由于此顺序中有两个 <code>A</code>，因此仅保留后一个，简化后得到最终的搜索顺序为 <code>D-&gt;B-&gt;C-&gt;A</code>。</p>
<blockquote>
<p>新式类可以直接通过 <code>类名.__mro__</code> 的方式获取类的 MRO，也可以通过 <code>类名.mro()</code> 的形式，旧式类是没有 <code>__mro__</code> 属性和 <code>mro()</code> 方法的。</p>
</blockquote>
<p>可以看到，这种 MRO 方式已经能够解决“菱形”继承的问题，但是可能会违反单调性原则。单调性原则是指在类存在多继承时，子类不能改变基类的 MRO 搜索顺序，否则会导致程序发生异常。</p>
<p>例如，分析如下程序 【程序二】：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">  <span class="keyword">pass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Y</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">  <span class="keyword">pass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>(<span class="params">X,Y</span>):</span></span><br><span class="line">  <span class="keyword">pass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>(<span class="params">Y,X</span>):</span></span><br><span class="line">  <span class="keyword">pass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>(<span class="params">A, B</span>):</span></span><br><span class="line">  <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>通过进行深度遍历，得到搜索顺序为 <code>C-&gt;A-&gt;X-&gt;object-&gt;Y-&gt;object-&gt;B-&gt;Y-&gt;object-&gt;X-&gt;object</code>，再进行简化（相同取后者），得到 <code>C-&gt;A-&gt;B-&gt;Y-&gt;X-&gt;object</code>。</p>
<p>下面来分析这样的搜索顺序是否合理，我们来看下各个类中的 MRO：</p>
<ul>
<li>对于 A，其搜索顺序为 <code>A-&gt;X-&gt;Y-&gt;object</code>；</li>
<li>对于 B，其搜索顺序为 <code>B-&gt;Y-&gt;X-&gt;object</code>；</li>
<li>对于 C，其搜索顺序为 <code>C-&gt;A-&gt;B-&gt;Y-&gt;X-&gt;object</code>。</li>
</ul>
<p>可以看到，A 和 C 中，X、Y 的搜索顺序是相反的，也就是说，当 A 被继承时，它本身的搜索顺序发生了改变，这违反了单调性原则。</p>
<hr>
<h4 id="MRO-C3"><a href="#MRO-C3" class="headerlink" title="MRO C3"></a>MRO C3</h4><p>为解决 Python 2.2 中 MRO 所存在的问题，Python 2.3 采用了 C3 方法来确定方法解析顺序。多数情况下，如果某人提到 Python 中的 MRO，指的都是 C3 算法。</p>
<p>在 Python 2.3 及后续版本中，运行 【程序一】，得到如下结果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CommonC</span><br></pre></td></tr></table></figure>

<p>运行 【程序二】，会产生如下异常：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;&lt;stdin&gt;&quot;</span>, line <span class="number">1</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">TypeError: Cannot create a consistent method resolution</span><br><span class="line">order (MRO) <span class="keyword">for</span> bases X, Y</span><br></pre></td></tr></table></figure>

<p>由此可见，C3 可以有效解决前面 2 种算法的问题。</p>
<p>那么，C3 算法是怎样实现的呢？？？</p>
<p><strong>C3 实现方法 &gt;&gt;&gt;&gt;</strong></p>
<p>以 【程序一】 为主：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">method</span>(<span class="params">self</span>):</span></span><br><span class="line">      print(<span class="string">&quot;CommonA&quot;</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>(<span class="params">A</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>(<span class="params">A</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">method</span>(<span class="params">self</span>):</span></span><br><span class="line">      print(<span class="string">&quot;CommonC&quot;</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">D</span>(<span class="params">B, C</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>C3 把各个类的 MRO 记为如下等式：</p>
<ul>
<li>类 A：L[A] = merge(A , object)</li>
<li>类 B：L[B] = [B] + merge(L[A] , [A])</li>
<li>类 C：L[C] = [C] + merge(L[A] , [A])</li>
<li>类 D：L[D] = [D] + merge(L[B] , L[C] , [B] , [C])</li>
</ul>
<blockquote>
<p>注意，以类 A 等式为例，其中 merge 包含的 A 称为 <code>L[A]</code> 的头，剩余元素（这里仅有一个 <code>object</code>）称为尾。对于类 B 等式，其中包含两个列表，L[A] &amp;&amp; [A]，分别有头和尾。</p>
</blockquote>
<p>这里的关键在于 merge，它的运算方式如下：</p>
<ol>
<li>检查第一个列表的头元素（如 <code>L[A]</code> 的头），记作 H;</li>
<li>若 H 未出现在 merge 中其它列表的尾部，则将其输出，并将其从所有列表中删除，然后回到步骤 1；否则，取出下一个列表的头部记作 H，继续该步骤。</li>
</ol>
<p>重复上述步骤，直至列表为空或者不能再找出可以输出的元素。如果是前一种情况，则算法结束；如果是后一种情况，Python 会抛出异常。</p>
<p>由此，可以计算出类 A &amp;&amp; B &amp;&amp; C &amp;&amp; D 的 MRO，其计算过程为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">L[A] = merge(A , <span class="built_in">object</span>)</span><br><span class="line">     = [A] + merge(<span class="built_in">object</span>)</span><br><span class="line">     = [A, <span class="built_in">object</span>]</span><br><span class="line"></span><br><span class="line">L[B] = [B] + merge(L[A], [A])</span><br><span class="line">     = [B] + merge([A, <span class="built_in">object</span>], [A])</span><br><span class="line">     = [B, A] + merge([<span class="built_in">object</span>])</span><br><span class="line">     = [B, A, <span class="built_in">object</span>]</span><br><span class="line"></span><br><span class="line">L[C] = [C, A, <span class="built_in">object</span>]</span><br><span class="line"></span><br><span class="line">L[D] = [D] + merge(L[B], L[C], [B], [C])</span><br><span class="line">     = [D] + merge([B, A, <span class="built_in">object</span>], [C, A, <span class="built_in">object</span>], [B], [C])</span><br><span class="line">     = [D, B] + merge([A, <span class="built_in">object</span>], [C, A, <span class="built_in">object</span>], [C])</span><br><span class="line">     = [D, B, C] + merge([A, <span class="built_in">object</span>], [A, <span class="built_in">object</span>])</span><br><span class="line">     = [D, B, C, A] + merge([<span class="built_in">object</span>], [<span class="built_in">object</span>])</span><br><span class="line">     = [D, B, C, A, <span class="built_in">object</span>]</span><br></pre></td></tr></table></figure>

<p>你可以在 Python 交互式环境下通过 <code>类名.mro()</code> 验证一下如上推理：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>A.mro()</span><br><span class="line">[&lt;class &#x27;__main__.A&#x27;&gt;, &lt;class &#x27;object&#x27;&gt;]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>B.mro()</span><br><span class="line">[&lt;class &#x27;__main__.B&#x27;&gt;, &lt;class &#x27;__main__.A&#x27;&gt;, &lt;class &#x27;object&#x27;&gt;]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>C.mro()</span><br><span class="line">[&lt;class &#x27;__main__.C&#x27;&gt;, &lt;class &#x27;__main__.A&#x27;&gt;, &lt;class &#x27;object&#x27;&gt;]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>D.mro()</span><br><span class="line">[&lt;class &#x27;__main__.D&#x27;&gt;, &lt;class &#x27;__main__.B&#x27;&gt;, &lt;class &#x27;__main__.C&#x27;&gt;, &lt;class &#x27;__main__.A&#x27;&gt;, &lt;class &#x27;object&#x27;&gt;]</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="继承升阶"><a href="#继承升阶" class="headerlink" title="继承升阶"></a>继承升阶</h3><p>我们知道，Python 中内置有一个 object 类，它是所有内置类型的共同祖先，也是所有没有显式指定父类的类（包括用户自定义的）的共同祖先。</p>
<p>因此在实际编程过程中，如果想实现与某个 Python 内置类型具有类似行为的类时，最好的方法就是将这个内置类型子类化。</p>
<p><strong>内置类型子类化</strong>，其实就是自定义一个新类，使其继承有类似行为的内置类，通过重定义这个新类实现指定的功能。</p>
<p>举个例子，如下所示创建了一个名为 newDict 的类，其中 <code>newDictError</code> 是自定义的异常类：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">newDictError</span>(<span class="params">ValueError</span>):</span></span><br><span class="line">  <span class="string">&quot;&quot;&quot;如果向 newDict 添加重复值，则引发此异常&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">newDict</span>(<span class="params"><span class="built_in">dict</span></span>):</span></span><br><span class="line">  <span class="string">&quot;&quot;&quot;不接受重复值的字典&quot;&quot;&quot;</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__setitem__</span>(<span class="params">self,key,value</span>):</span></span><br><span class="line">    <span class="keyword">if</span> value <span class="keyword">in</span> self.values():</span><br><span class="line">      <span class="keyword">if</span> ((key <span class="keyword">in</span> self <span class="keyword">and</span> self[key]!=value) <span class="keyword">or</span> (key <span class="keyword">not</span> <span class="keyword">in</span> self)):</span><br><span class="line">        <span class="keyword">raise</span> newDictError(<span class="string">&quot;这个值已经存在，并对应不同的键&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="built_in">super</span>().__setitem__(key,value)</span><br><span class="line"></span><br><span class="line">demoDict = newDict()</span><br><span class="line"></span><br><span class="line">demoDict[<span class="string">&#x27;key&#x27;</span>]=<span class="string">&#x27;value&#x27;</span></span><br><span class="line">demoDict[<span class="string">&#x27;other_key&#x27;</span>]=<span class="string">&#x27;value2&#x27;</span></span><br><span class="line">print(demoDict)</span><br><span class="line"></span><br><span class="line">demoDict[<span class="string">&#x27;other_key&#x27;</span>]=<span class="string">&#x27;value&#x27;</span></span><br><span class="line">print(demoDict)</span><br></pre></td></tr></table></figure>

<p>可以看到，<code>newDict</code> 是 Python 中 <code>dict</code> 类型的子类，所以其大部分行为都和 <code>dict</code> 内置类相同。唯一不同之处在于，<code>newDict</code> 不允许字典中多个键对应相同的值。如果用户试图添加具有相同值的新元素，则会引发 <code>newDictError</code> 异常，并给出提示信息。</p>
<blockquote>
<p>由于目前尚未学习如何处理异常，因此这里没有 <code>newDictError</code> 做任何处理，异常处理会在后续章节做详细讲解。</p>
</blockquote>
<p>另外，如果查看现有代码你会发现，其实很多类都是对 Python 内置类的部分实现，它们作为子类的速度更快，代码更整洁。</p>
<p>其实，除了 Python 中常用的基本内置类型，<code>collections</code> 模块中还额外提供了很多有用的容器，这些容器可以满足大部分情况。</p>
<hr>
<h3 id="Super-使用"><a href="#Super-使用" class="headerlink" title="Super() 使用"></a>Super() 使用</h3><p>我们知道，Python 中子类会继承父类所有的类属性和类方法。严格来说，类的构造方法其实就是实例方法，因此毫无疑问，父类的构造方法，子类同样会继承。</p>
<p>但我们知道，Python 是一门支持多继承的面向对象编程语言，如果子类继承的多个父类中包含同名的类实例方法，则子类对象在调用该方法时，会优先选择排在最前面的父类中的实例方法。显然，构造方法也是如此。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,name</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">say</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;我是人，名字为：&quot;</span>, self.name)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,food</span>):</span></span><br><span class="line">        self.food = food</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">display</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;我是动物,我吃&quot;</span>, self.food)</span><br><span class="line"></span><br><span class="line"><span class="comment"># People中的 name 属性和 say() 会遮蔽 Animal 类中的</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">People, Animal</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">per = Person(<span class="string">&quot;zhang_san&quot;</span>)</span><br><span class="line">per.say()</span><br><span class="line"><span class="comment"># per.display()</span></span><br></pre></td></tr></table></figure>

<p>Person 类同时继承 People 和 Animal，其中 People 在前。这意味着，在创建 <code>per</code> 对象时，其将会调用从 People 继承来的构造函数。因此我们看到，上面程序在创建 <code>per</code> 对象的同时，还要给 <code>name</code> 属性进行赋值。</p>
<hr>
<h4 id="场景引入"><a href="#场景引入" class="headerlink" title="场景引入"></a>场景引入</h4><p>但如果去掉上述代码中最后一行的注释符，运行此行代码，Python 解释器会报如下错误：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">&quot;.code.tio&quot;</span>, line <span class="number">19</span>, <span class="keyword">in</span> </span><br><span class="line">    per.display()</span><br><span class="line">  File <span class="string">&quot;.code.tio&quot;</span>, line <span class="number">11</span>, <span class="keyword">in</span> display</span><br><span class="line">    print(<span class="string">&quot;我是动物,我吃&quot;</span>, self.food)</span><br><span class="line">AttributeError: <span class="string">&#x27;Person&#x27;</span> <span class="built_in">object</span> has no attribute <span class="string">&#x27;food&#x27;</span></span><br></pre></td></tr></table></figure>

<p>这是因为，从 Animal 类中继承的 <code>display()</code> 方法中，需要用到 <code>food</code> 属性的值，但由于 People 类的构造方法“遮蔽”了Animal 类的构造方法，使得在创建 <code>per</code> 对象时，Animal 类的构造方法未得到执行，所以程序出错。</p>
<p>反过来也是如此，如果将代码改为如下形式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">Animal, People</span>)</span></span><br></pre></td></tr></table></figure>

<p>则在创建 <code>per</code> 对象时，会给 <code>food</code> 属性传值。这意味着，<code>per.display()</code> 能顺序执行，但 <code>per.say()</code> 将会报错。</p>
<p>怎么办？？？</p>
<hr>
<p>针对这种情况，正确的做法是定义 Person 类自己的构造方法（等同于重写第一个直接父类的构造方法）。</p>
<p>但需要注意，<strong>如果在子类中定义构造方法，则必须在该方法中调用父类的构造方法。</strong></p>
<h4 id="子类中调用父类构造函数"><a href="#子类中调用父类构造函数" class="headerlink" title="子类中调用父类构造函数"></a>子类中调用父类构造函数</h4><p>也就是说，当某个类具有多继承时，为了保证可以正常使用继承至其父类中的各种方法，一般需要在子类中定义构造方法，并且必须在该方法中调用父类的构造方法。</p>
<p>在子类中的构造方法中，调用父类构造方法的方式有两种，分别是：</p>
<ol>
<li>类可以看做一个独立空间，在类的外部调用其中的实例方法，可以向调用普通函数那样，只不过需要使用非绑定方式进行调用 <code>类名.方法名(参数)</code>。同理前面子类中调用父类中被重写的方法说明；</li>
<li>使用 super() 函数，但注意如果涉及多继承时，该函数只能调用第一个直接父类的构造方法。</li>
</ol>
<blockquote>
<p>也就是说，涉及到多继承时，在子类构造函数中，调用第一个父类构造方法的方式有以上 2 种（super() 函数有使用限制），而调用其它父类构造方法的方式只能使用未绑定方法。</p>
</blockquote>
<p><code>super()</code> 函数的使用语法格式如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python 2.X &amp;&amp; Python 3.X</span></span><br><span class="line"><span class="built_in">super</span>(Class, obj).__init__(self,...)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Python 3.X（推荐使用！！！）</span></span><br><span class="line"><span class="built_in">super</span>().__init__(self,...)</span><br></pre></td></tr></table></figure>

<p>例如，对于上面的程序可以尝试如下修改：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">People</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,name</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">say</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;我是人, 名字为：&quot;</span>, self.name)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,food</span>):</span></span><br><span class="line">        self.food = food</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">display</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;我是动物, 我吃&quot;</span>, self.food)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">People, Animal</span>):</span></span><br><span class="line">    <span class="comment">#自定义构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, food</span>):</span></span><br><span class="line">        <span class="comment">#调用 People 类的构造方法</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(name)</span><br><span class="line">        <span class="comment"># super(Person, self).__init__(name) #执行效果和上一行相同</span></span><br><span class="line">        <span class="comment"># People.__init__(self, name) # 使用未绑定方法调用 People 类构造方法</span></span><br><span class="line">        <span class="comment"># 调用其它父类的构造方法，需手动给 self 传值</span></span><br><span class="line">        Animal.__init__(self, food)</span><br><span class="line"></span><br><span class="line">per = Person(<span class="string">&quot;zhang_san&quot;</span>, <span class="string">&quot;Meats&quot;</span>)</span><br><span class="line">per.say()</span><br><span class="line">per.display()</span><br></pre></td></tr></table></figure>

<p>可以看到，Person 类自定义的构造方法中，调用 People 类构造方法，可以使用 <code>super()</code> 函数，也可以使用未绑定方法。但是调用 Animal 类的构造方法，只能使用未绑定方法。</p>
<p>注意，这里 <code>super()</code> 方法不仅可以调用第一个直接父类中的构造函数，还可以调用其第一个父类中的重写方法（或其它方法），例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span>(<span class="params">People, Animal</span>):</span></span><br><span class="line">    <span class="comment">#自定义构造方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name, food</span>):</span></span><br><span class="line">        <span class="comment">#调用 People 类的构造方法</span></span><br><span class="line">        <span class="built_in">super</span>().__init__(name)</span><br><span class="line">        <span class="comment"># super(Person,self).__init__(name) #执行效果和上一行相同</span></span><br><span class="line">        <span class="comment"># People.__init__(self, name) # 使用未绑定方法调用 People 类构造方法</span></span><br><span class="line">        <span class="comment"># 调用其它父类的构造方法，需手动给 self 传值</span></span><br><span class="line">        Animal.__init__(self, food)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">say</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().say() <span class="comment"># 调用父类 say() 方法</span></span><br><span class="line">        print(<span class="string">&quot;我是&quot;</span>, self.name)</span><br></pre></td></tr></table></figure>

<hr>
<h4 id="Super-注意事项"><a href="#Super-注意事项" class="headerlink" title="Super 注意事项"></a>Super 注意事项</h4><p>Python 中，由于基类不会在子类 <code>__init__()</code> 中被隐式地调用，需要程序员显式调用它们。这种情况下，当程序中包含多重继承的类层次结构时，使用 super 是非常危险的，往往会在类的初始化过程中出现问题。</p>
<p><strong>[1] &gt;&gt;&gt;&gt; 混用 super 与显式类调用</strong></p>
<p>分析如下程序，C 类使用了 <code>__init__()</code> 方法调用它的基类，会造成 B 类被调用了 2 次：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;A&quot;</span>,end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;B&quot;</span>,end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>(<span class="params">A,B</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;C&quot;</span>,end=<span class="string">&quot; &quot;</span>)</span><br><span class="line">        A.__init__(self)</span><br><span class="line">        <span class="comment"># super().__init__(self)</span></span><br><span class="line">        B.__init__(self)</span><br><span class="line">        </span><br><span class="line">print(<span class="string">&quot;MRO:&quot;</span>,[x.__name__ <span class="keyword">for</span> x <span class="keyword">in</span> C.__mro__])</span><br><span class="line">C()</span><br><span class="line"><span class="comment"># MRO: [&#x27;C&#x27;, &#x27;A&#x27;, &#x27;B&#x27;, &#x27;object&#x27;]</span></span><br><span class="line"><span class="comment"># C A B B</span></span><br></pre></td></tr></table></figure>

<p>出现以上这种情况的原因在于，C 的实例调用 <code>A.__init__(self)</code>，使得 <code>super(A,self).__init__()</code> 调用了 <code>B.__init__()</code> 方法。换句话说，<code>super</code> 应该被用到整个类的层次结构中。</p>
<p>但是，有时这种层次结构的一部分位于第三方代码中，我们无法确定外部包的这些代码中是否使用 <code>super()</code>，因此，当需要对某个第三方类进行子类化时，最好查看其内部代码以及 MRO 中其他类的内部代码。</p>
<hr>
<p><strong>[2] &gt;&gt;&gt;&gt; 不同种类参数</strong></p>
<p>使用 super 的另一个问题是初始化过程中的参数传递。如果没有相同的签名（参数），一个类怎么能调用其基类的 <code>__init__()</code> 代码呢？这会导致下列问题：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">commonBase</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;commonBase&quot;</span>)</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">base1</span>(<span class="params">commonBase</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;base1&quot;</span>)</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">base2</span>(<span class="params">commonBase</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        print(<span class="string">&quot;base2&quot;</span>)</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myClass</span>(<span class="params">base1,base2</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,arg</span>):</span></span><br><span class="line">        print(<span class="string">&quot;my base&quot;</span>)</span><br><span class="line">        <span class="built_in">super</span>().__init__(arg) <span class="comment"># 形式一</span></span><br><span class="line">        <span class="comment"># super().__init__()  # 形式二</span></span><br><span class="line"></span><br><span class="line">myClass(<span class="number">10</span>)</span><br></pre></td></tr></table></figure>

<p>可以看到，<code>base1</code> &amp;&amp; <code>base2</code> 需要不同的参数传入，使用形式一还是形式二传入呢？都是会导致问题的！！！</p>
<p>一种解决方法是使用 <code>*args</code> 和 <code>**kwargs</code> 包装的参数和关键字参数，这样即使不使用它们，所有的构造函数也会传递所有参数，如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">commonBase</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,*args,**kwargs</span>):</span></span><br><span class="line">        print(<span class="string">&quot;commonBase&quot;</span>)</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">base1</span>(<span class="params">commonBase</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,*args,**kwargs</span>):</span></span><br><span class="line">        print(<span class="string">&quot;base1&quot;</span>)</span><br><span class="line">        <span class="built_in">super</span>().__init__(*args,**kwargs)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">base2</span>(<span class="params">commonBase</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,*args,**kwargs</span>):</span></span><br><span class="line">        print(<span class="string">&quot;base2&quot;</span>)</span><br><span class="line">        <span class="built_in">super</span>().__init__(*args,**kwargs)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">myClass</span>(<span class="params">base1,base2</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,arg</span>):</span></span><br><span class="line">        print(<span class="string">&quot;my base&quot;</span>)</span><br><span class="line">        <span class="built_in">super</span>().__init__(arg)</span><br><span class="line">myClass(<span class="number">10</span>)</span><br></pre></td></tr></table></figure>

<p>不过，这是一种很糟糕的解决方法，由于任何参数都可以传入，所有构造函数都可以接受任何类型的参数，这会导致代码变得脆弱。另一种解决方法是在 MyClass 中显式地使用特定类的 <code>__init__()</code> 调用，但这无疑会导致第一种错误。</p>
<p>如果想要避免程序中出现以上的这些问题，这里给出几点建议：</p>
<ul>
<li>尽可能避免使用多继承，可以使用一些设计模式来替代它；</li>
<li>super 的使用必须一致，即在类的层次结构中，要么全部使用 super，要么全不用。混用 super 和传统调用是一种混乱的写法；</li>
<li>如果代码需要兼容 Python 2.x，在 Python 3.x 中应该显式地继承自 object。在 Python 2.x 中，没有指定任何祖先地类都被认定为旧式类。</li>
<li>调用父类时应提前查看类的层次结构，也就是使用类的 <code>__mro__</code> 属性或者 <code>mro()</code> 方法查看有关类的 MRO。</li>
</ul>
<hr>
<p>前面，我们介绍了类的封装和继承特性，下面来看其多态性：</p>
<h2 id="类的多态特性"><a href="#类的多态特性" class="headerlink" title="类的多态特性"></a>类的多态特性</h2><p>我们都知道，Python 是弱类型语言，其最明显的特征是在使用变量时，无需为其指定具体的数据类型。这会导致一种情况，即同一变量可能会被先后赋值不同的类对象，例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Language</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">say</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;赋值的是 Language 类的实例对象&quot;</span>)</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IPython</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">say</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;赋值的是 IPython 类的实例对象&quot;</span>)</span><br><span class="line">a = Language()</span><br><span class="line">a.say()</span><br><span class="line"><span class="comment"># 赋值的是 Language 类的实例对象</span></span><br><span class="line"></span><br><span class="line">a = IPython()</span><br><span class="line">a.say()</span><br><span class="line"><span class="comment"># 赋值的是 IPython 类的实例对象</span></span><br></pre></td></tr></table></figure>

<p>可以看到，<code>a</code> 可以被先后赋值为 <code>Language</code> 类和 <code>IPython</code> 类的对象，但这并不是多态。</p>
<p>类的多态特性，需要满足以下两个前提条件：</p>
<ul>
<li>继承：多态一定是发生在子类和父类之间；</li>
<li>重写：子类重写了父类的方法。</li>
</ul>
<p>对上面代码的改写：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CLanguage</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">say</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;调用的是 Clanguage 类的 say 方法&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CPython</span>(<span class="params">CLanguage</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">say</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;调用的是 CPython 类的 say 方法&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CLinux</span>(<span class="params">CLanguage</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">say</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;调用的是 CLinux 类的 say 方法&quot;</span>)</span><br><span class="line">        </span><br><span class="line">a = CLanguage()</span><br><span class="line">a.say()</span><br><span class="line"><span class="comment"># 调用的是 Clanguage 类的 say 方法</span></span><br><span class="line">a = CPython()</span><br><span class="line">a.say()</span><br><span class="line"><span class="comment"># 调用的是 CPython 类的 say 方法</span></span><br><span class="line">a = CLinux()</span><br><span class="line">a.say()</span><br><span class="line"><span class="comment"># 调用的是 CLinux 类的 say 方法</span></span><br></pre></td></tr></table></figure>

<p>CPython 和 CLinux 都继承自 CLanguage 类，且各自都重写了父类的 <code>say()</code> 方法。从运行结果可以看出，同一变量 <code>a</code> 在执行同一个 <code>say()</code> 方法时，由于 <code>a</code> 实际表示不同的类实例对象，因此 <code>a.say()</code> 调用的并不是同一个类中的 <code>say()</code> 方法，这就是多态。</p>
<p>要理解多态的好处，我们还需要再编写一个函数，这个函数接受一个 <code>CLanguage</code> 类型的变量：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">WhoSay</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">say</span>(<span class="params">self,cLanguage</span>):</span></span><br><span class="line">        cLanguage.say()</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CLanguage</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">say</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;调用的是 Clanguage 类的say方法&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CPython</span>(<span class="params">CLanguage</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">say</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;调用的是 CPython 类的say方法&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CLinux</span>(<span class="params">CLanguage</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">say</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;调用的是 CLinux 类的say方法&quot;</span>)</span><br><span class="line"></span><br><span class="line">a = WhoSay()</span><br><span class="line"><span class="comment"># 调用 CLanguage 类的 say() 方法</span></span><br><span class="line">a.say(CLanguage())</span><br><span class="line"><span class="comment"># 调用 CPython 类的 say() 方法</span></span><br><span class="line">a.say(CPython())</span><br><span class="line"><span class="comment"># 调用 CLinux 类的 say() 方法</span></span><br><span class="line">a.say(CLinux())</span><br></pre></td></tr></table></figure>

<p>此程序中，通过给 WhoSay 类中的 <code>say()</code> 函数添加一个 <code>cLanguage</code> 参数，其内部利用传入的 <code>cLanguage</code> 调用 <code>say()</code> 方法。这意味着，当调用 WhoSay 类中的 <code>say()</code> 方法时，我们传给 <code>cLanguage</code> 参数的是哪个类的实例对象，它就会调用那个类中的 <code>say()</code> 方法。</p>
<p><strong>开闭原则 &gt;&gt;&gt;&gt;</strong></p>
<p>对于一个变量，我们只需要知道它是 <code>cLanguage</code> 类型，无需确切地知道它的子类型，就可以放心地调用 <code>say()</code> 方法，而具体调用的 <code>say()</code> 方法是作用在 <code>CLanguage</code>、<code>CPython</code> 还是 <code>CLinux </code> 对象上，由运行时该对象的确切类型决定，这就是多态真正的威力。</p>
<p>这样，调用方只管调用，不管细节，而当我们新增一种 <code>CLanguage</code> 的子类时，只要确保 <code>say()</code> 方法编写正确，不用管原来的代码是如何调用的。这就是著名的“开闭”原则：</p>
<p>对扩展开放：允许新增 <code>CLanguage</code> 子类；</p>
<p>对修改封闭：不需要修改依赖 <code>CLanguage</code> 类型的 <code>say()</code> 等函数。</p>
<hr>
<h2 id="静态语言-vs-动态语言"><a href="#静态语言-vs-动态语言" class="headerlink" title="静态语言 vs 动态语言"></a>静态语言 vs 动态语言</h2><p>对于静态语言（例如 Java）来说，如果需要传入 <code>CLanguage</code> 类型，则传入的对象必须是 <code>CLanguage</code> 类型或者它的子类，否则，将无法调用 <code>say()</code> 方法。</p>
<p>对于 Python 这样的动态语言来说，则不一定需要传入 <code>CLanguage</code> 类型。我们只需要保证传入的对象有一个 <code>say()</code> 方法就可以了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Timer</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">say</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;Start...&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>例如，Python 的 <code>file-like object</code> 类型。对真正的文件对象，它有一个 <code>read()</code> 方法，返回其内容。</p>
<p>但是对于许多对象，只要有 <code>read()</code> 方法，都被视为 <code>file-like object</code>。许多函数接收的参数就是 <code>file-like object</code>，你不一定要传入真正的文件对象，完全可以传入任何实现了 <code>read()</code> 方法的对象。</p>
<hr>
<h2 id="枚举类"><a href="#枚举类" class="headerlink" title="枚举类"></a>枚举类</h2><p>一些具有特殊含义的类，其实例化对象的个数往往是固定的，比如用一个类表示月份，则该类的实例对象最多有 <code>12</code> 个；再比如用一个类表示季节，则该类的实例化对象最多有 <code>4</code> 个。</p>
<p>针对这种特殊的类，<font color='red'>Python 3.4 中新增加了 Enum 枚举类。</font> 也就是说，对于这些实例化对象个数固定的类，可以用枚举类来定义。</p>
<p><strong>[1] &gt;&gt;&gt;&gt; 枚举类的定义和属性访问</strong></p>
<p>例如，下面程序演示了如何定义一个枚举类：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> enum <span class="keyword">import</span> Enum</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Color</span>(<span class="params">Enum</span>):</span></span><br><span class="line">    <span class="comment"># 为序列值指定 value 值</span></span><br><span class="line">    red = <span class="number">1</span></span><br><span class="line">    green = <span class="number">2</span></span><br><span class="line">    blue = <span class="number">3</span></span><br></pre></td></tr></table></figure>

<p>如果想将一个类定义为枚举类，只需要令其继承自 enum 模块中的 Enum 类即可。例如在上面程序中，Color 类继承自 Enum 类，则证明这是一个枚举类。</p>
<p>在 Color 枚举类中，red、green、blue 都是该类的成员（可以理解为是类变量）。注意，枚举类的每个成员都由 2 部分组成，分别为 name 和 value，其中 name 属性值为该枚举值的变量名（如 <code>red</code>），value 代表该枚举值的序号（序号通常从 <code>1</code> 开始）。</p>
<p>和普通类的用法不同，枚举类不能用来实例化对象，但这并不妨碍我们访问枚举类中的成员。访问枚举类成员的方式有多种，例如以 Color 枚举类为例，在其基础上添加如下代码：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> enum <span class="keyword">import</span> Enum</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Color</span>(<span class="params">Enum</span>):</span></span><br><span class="line">    <span class="comment"># 为序列值指定 value 值</span></span><br><span class="line">    red = <span class="number">1</span></span><br><span class="line">    green = <span class="number">2</span></span><br><span class="line">    blue = <span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用枚举成员的 3 种方式</span></span><br><span class="line">print(Color.red)</span><br><span class="line"><span class="comment"># Color.red</span></span><br><span class="line">print(Color[<span class="string">&#x27;red&#x27;</span>])</span><br><span class="line"><span class="comment"># Color.red</span></span><br><span class="line">print(Color(<span class="number">1</span>))</span><br><span class="line"><span class="comment"># Color.red</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调取枚举成员中的 value 和 name</span></span><br><span class="line">print(Color.red.value)</span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line">print(Color.red.name)</span><br><span class="line"><span class="comment"># red</span></span><br></pre></td></tr></table></figure>

<hr>
<p><strong>[2] &gt;&gt;&gt;&gt; 枚举类不支持外部修改</strong></p>
<p>枚举类中各个成员的值，不能在类的外部做任何修改，也就是说，下面语法的做法是错误的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Color.red = <span class="number">4</span></span><br><span class="line"><span class="comment"># Traceback (most recent call last):</span></span><br><span class="line"><span class="comment">#   File &quot;.code.tio&quot;, line 18, in </span></span><br><span class="line"><span class="comment">#     Color.red = 4</span></span><br><span class="line"><span class="comment">#   File &quot;/usr/lib64/python3.6/enum.py&quot;, line 361, in __setattr__</span></span><br><span class="line"><span class="comment">#     raise AttributeError(&#x27;Cannot reassign members.&#x27;)</span></span><br><span class="line"><span class="comment"># AttributeError: Cannot reassign members.</span></span><br></pre></td></tr></table></figure>

<p><strong>[3] &gt;&gt;&gt;&gt; 枚举类成员比较</strong></p>
<p>枚举类成员之间不支持比较大小，但可以用 <code>==</code> 或者 <code>is</code> 进行比较是否相等，例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">print(Color.red == Color.green)</span><br><span class="line"><span class="comment"># False</span></span><br><span class="line">print(Color.red.name <span class="keyword">is</span> Color.green.name)</span><br><span class="line"><span class="comment"># False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># print(Color.red &gt; Color.green)</span></span><br><span class="line"><span class="comment"># Traceback (most recent call last):</span></span><br><span class="line"><span class="comment">#   File &quot;.code.tio&quot;, line 20, in </span></span><br><span class="line"><span class="comment">#     print(Color.red &gt; Color.green)</span></span><br><span class="line"><span class="comment"># TypeError: &#x27;&gt;&#x27; not supported between instances of &#x27;Color&#x27; and &#x27;Color&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 支持比较相应值大小：</span></span><br><span class="line">print(Color.red.value &lt; Color.green.value)</span><br><span class="line"><span class="comment"># True</span></span><br></pre></td></tr></table></figure>

<p><strong>[4] &gt;&gt;&gt;&gt; 枚举类成员遍历</strong></p>
<p>遍历枚举类中所有成员的支持两种方式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> color <span class="keyword">in</span> Color:</span><br><span class="line">    print(color, color.value)</span><br><span class="line"><span class="comment"># Color.red 1</span></span><br><span class="line"><span class="comment"># Color.green 2</span></span><br><span class="line"><span class="comment"># Color.blue 3</span></span><br></pre></td></tr></table></figure>

<p>除此之外，该枚举类还提供了一个 <code>__members__</code> 属性，该属性是一个包含枚举类中所有成员的字典，通过遍历该属性，也可以访问枚举类中的各个成员。例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> name,member <span class="keyword">in</span> Color.__members__.items():</span><br><span class="line">    print(name, <span class="string">&quot;-&gt;&quot;</span>, member, <span class="string">&quot; -&gt; value: &quot;</span>, member.value)</span><br><span class="line"><span class="comment"># red -&gt; Color.red  -&gt; value:  1</span></span><br><span class="line"><span class="comment"># green -&gt; Color.green  -&gt; value:  2</span></span><br><span class="line"><span class="comment"># blue -&gt; Color.blue  -&gt; value:  3</span></span><br></pre></td></tr></table></figure>

<hr>
<p><strong>[5] &gt;&gt;&gt;&gt; @unique 装饰器</strong></p>
<p>Python 枚举类中各个成员必须保证 <code>name</code> 互不相同（唯一Key），但 <code>value</code> 可以相同，举个例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> enum <span class="keyword">import</span> Enum</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Color</span>(<span class="params">Enum</span>):</span></span><br><span class="line">    <span class="comment"># 为序列值指定 value 值</span></span><br><span class="line">    red = <span class="number">1</span></span><br><span class="line">    green = <span class="number">1</span></span><br><span class="line">    blue = <span class="number">3</span></span><br><span class="line">print(Color[<span class="string">&#x27;green&#x27;</span>])</span><br><span class="line"><span class="comment"># Color.red</span></span><br></pre></td></tr></table></figure>

<p>可以看到，Color 枚举类中 red 和 green 具有相同的值（都是 <code>1</code>），Python 允许这种情况的发生，它会将 green 当做是 red 的别名，因此当访问 green 成员时，最终输出的是 red。</p>
<p>在实际编程过程中，如果想避免发生这种情况，可以借助 <code>@unique</code> 装饰器，这样当枚举类中出现相同值的成员时，程序会报 <code>ValueError</code> 错误。例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> enum <span class="keyword">import</span> Enum,unique</span><br><span class="line"></span><br><span class="line"><span class="meta">@unique</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Color</span>(<span class="params">Enum</span>):</span></span><br><span class="line">    <span class="comment"># 为序列值指定 value 值</span></span><br><span class="line">    red = <span class="number">1</span></span><br><span class="line">    green = <span class="number">1</span></span><br><span class="line">    blue = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">print(Color[<span class="string">&#x27;green&#x27;</span>])</span><br><span class="line"><span class="comment"># Traceback (most recent call last):</span></span><br><span class="line"><span class="comment">#   File &quot;.code.tio&quot;, line 4, in </span></span><br><span class="line"><span class="comment">#     class Color(Enum):</span></span><br><span class="line"><span class="comment">#   File &quot;/usr/lib64/python3.6/enum.py&quot;, line 834, in unique</span></span><br><span class="line"><span class="comment">#     (enumeration, alias_details))</span></span><br><span class="line"><span class="comment"># ValueError: duplicate values found in : green -&gt; red</span></span><br></pre></td></tr></table></figure>

<hr>
<p><strong>[6] &gt;&gt;&gt;&gt;  Enum() 函数创建枚举类</strong></p>
<p>除了通过继承 Enum 类的方法创建枚举类，还可以使用 Enum() 函数快速创建枚举类。例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> enum <span class="keyword">import</span> Enum</span><br><span class="line"><span class="comment">#创建一个枚举类</span></span><br><span class="line">Color = Enum(<span class="string">&quot;Color&quot;</span>,(<span class="string">&#x27;red&#x27;</span>,<span class="string">&#x27;green&#x27;</span>,<span class="string">&#x27;blue&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用枚举成员的 3 种方式</span></span><br><span class="line">print(Color.red)</span><br><span class="line">print(Color[<span class="string">&#x27;red&#x27;</span>])</span><br><span class="line">print(Color(<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调取枚举成员中的 value 和 name</span></span><br><span class="line">print(Color.red.value)</span><br><span class="line">print(Color.red.name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历枚举类中所有成员的 2 种方式</span></span><br><span class="line"><span class="keyword">for</span> color <span class="keyword">in</span> Color:</span><br><span class="line">    print(color, color.value)</span><br><span class="line"><span class="keyword">for</span> name,member <span class="keyword">in</span> Color.__members__.items():</span><br><span class="line">    print(name, <span class="string">&quot;-&gt;&quot;</span>, member, <span class="string">&quot; -&gt; value: &quot;</span>, member.value)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="实战搜索引擎"><a href="#实战搜索引擎" class="headerlink" title="实战搜索引擎"></a>实战搜索引擎</h2><p>要想实现一个搜索引擎，首先要了解什么是搜索引擎。</p>
<p>简单地理解，搜索引擎是一个系统，它可以帮助用户去互联网上搜集与其检索内容相关的信息。</p>
<p>通常，一个搜索引擎由搜索器、索引器、检索器以及用户接口组成，其中各个部分的含义如下：</p>
<ul>
<li>搜索器：其实就是我们常说的爬虫、它能够从互联网中搜集大量的信息，并将之传递给索引器；</li>
<li>索引器：理解搜索器搜索到的信息，并从中抽取出索引项，存储到内部的数据库中，等待检索；</li>
<li>检索器：根据用户查询的内容，在已经建立好的索引库中快速检索出与之相关的信息，并做相关度评价，以此进行排序；</li>
<li>用户接口：其作用就是提供给用户输入查询内容的窗口（例如百度、谷歌的搜索框），并将检索好的内容反馈给用户。</li>
</ul>
<p>由于爬虫知识不是重点，这里不再做深入介绍，我们假设搜索样本就存在于本地磁盘中的文件。为了方便，这里只提供五个用于检索的文件，各文件存放的内容分别如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 1.txt</span></span><br><span class="line">Python 官方文档</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2.txt</span></span><br><span class="line">https://docs.python.org/zh-cn/<span class="number">3</span>/</span><br><span class="line"></span><br><span class="line"><span class="comment"># 3.txt</span></span><br><span class="line">「Python 官方文档」是一个在线学习 Python 的网站，在这里你可以查找到 Python 的最新变化以及历史信息。</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4.txt</span></span><br><span class="line">Python 官方文档有 Python 官方开发团队提供，致力于发布 Python 最新变化以及历史信息，以供开发人员学习使用。</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5.txt</span></span><br><span class="line">抛开喧嚣，卸下繁华，只为一纸清凉，遇到更好的自己。</span><br></pre></td></tr></table></figure>

<p>下面，根据以上知识，我们先实现一个最基本的搜索引擎：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SearchEngineBase</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 搜索器</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">crawl_corpus</span>(<span class="params">self, file_path</span>):</span>  </span><br><span class="line">        <span class="keyword">with</span> <span class="built_in">open</span>(file_path, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> fin:</span><br><span class="line">            text = fin.read().decode(<span class="string">&#x27;utf-8&#x27;</span>)</span><br><span class="line">        self.process_corpus(file_path, text)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 索引器</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_corpus</span>(<span class="params">self, <span class="built_in">id</span>, text</span>):</span></span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&#x27;process_corpus not implemented.&#x27;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 检索器</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searcher</span>(<span class="params">self, query</span>):</span></span><br><span class="line">        <span class="keyword">raise</span> Exception(<span class="string">&#x27;searcher not implemented.&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 用户接口</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span>(<span class="params">search_engine</span>):</span></span><br><span class="line">    <span class="keyword">for</span> file_path <span class="keyword">in</span> [<span class="string">&#x27;1.txt&#x27;</span>, <span class="string">&#x27;2.txt&#x27;</span>, <span class="string">&#x27;3.txt&#x27;</span>, <span class="string">&#x27;4.txt&#x27;</span>, <span class="string">&#x27;5.txt&#x27;</span>]:</span><br><span class="line">        search_engine.crawl_corpus(file_path)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        query = <span class="built_in">input</span>()</span><br><span class="line">        results = search_engine.searcher(query)</span><br><span class="line">        print(<span class="string">&#x27;found &#123;&#125; result(s):&#x27;</span>.<span class="built_in">format</span>(<span class="built_in">len</span>(results)))</span><br><span class="line">        <span class="keyword">for</span> result <span class="keyword">in</span> results:</span><br><span class="line">            print(result)</span><br></pre></td></tr></table></figure>

<p>以上代码仅是建立了搜索引擎的一个基本框架，它可以作为基类被其他类继承，那么继承自此类的类将分别代表不同的搜索引擎，它们应该各自实现基类中的 process_corpus() 和 searcher() 方法。</p>
<p>整个代码的运行过程是这样的，首先将各个检索文件中包含的内容连同该文件所在的路径一起传递给索引器，索引器会以该文件的路径建立索引，等待用户检索。</p>
<p>在 SearchEngineBase 类的基础上，下面实现了一个基本可以工作的搜索引擎：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SimpleEngine</span>(<span class="params">SearchEngineBase</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line">        <span class="comment"># 建立索引时使用</span></span><br><span class="line">        self.__id_to_texts = &#123;&#125;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">process_corpus</span>(<span class="params">self, <span class="built_in">id</span>, text</span>):</span></span><br><span class="line">        <span class="comment"># 以文件路径为键，文件内容为值，形成键值对，存储在字典中，由此建立索引</span></span><br><span class="line">        self.__id_to_texts[<span class="built_in">id</span>] = text</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">searcher</span>(<span class="params">self, query</span>):</span></span><br><span class="line">        results = []</span><br><span class="line">         <span class="comment"># 依次检索字典中的键值对，如果文件内容中包含用户要搜索的信息，则将此文件的文件路径存储在 results 列表中</span></span><br><span class="line">        <span class="keyword">for</span> <span class="built_in">id</span>, text <span class="keyword">in</span> self.__id_to_texts.items():</span><br><span class="line">            <span class="keyword">if</span> query <span class="keyword">in</span> text:</span><br><span class="line">                results.append(<span class="built_in">id</span>)</span><br><span class="line">        <span class="keyword">return</span> results</span><br><span class="line"></span><br><span class="line">search_engine = SimpleEngine()</span><br><span class="line">main(search_engine)</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">C语言中文网</span><br><span class="line">found <span class="number">3</span> result(s):</span><br><span class="line"><span class="number">1.</span>txt</span><br><span class="line"><span class="number">3.</span>txt</span><br><span class="line"><span class="number">4.</span>txt</span><br></pre></td></tr></table></figure>

<p>可以看到，用户搜索与 “Python 官方文档” 有关的内容，最终检索到了 1.txt、3.txt和 4.txt 文件中包含与之相关的内容。由此，只需要短短十来行代码就可以实现一个基础的搜索引擎。</p>
<hr>
</div><div class="article-licensing box"><div class="licensing-title"><p>Python 面向对象编程之类和对象</p><p><a href="https://www.orangeshare.cn/2018/01/12/python-mian-xiang-dui-xiang-bian-cheng-zhi-lei-he-dui-xiang/">https://www.orangeshare.cn/2018/01/12/python-mian-xiang-dui-xiang-bian-cheng-zhi-lei-he-dui-xiang/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>Author</h6><p>Waldeinsamkeit</p></div></div><div class="level-item is-narrow"><div><h6>Posted on</h6><p>2018-01-12</p></div></div><div class="level-item is-narrow"><div><h6>Updated on</h6><p>2022-04-03</p></div></div><div class="level-item is-narrow"><div><h6>Licensed under</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="icon" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a><a class="icon" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/Python/">Python</a></div><div class="notification is-danger">You need to set <code>install_url</code> to use ShareThis. Please set it in <code>_config.yml</code>.</div></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">Like this article? Support the author with</h3><div class="buttons is-centered"><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>Alipay</span><span class="qrcode"><img src="/" alt="Alipay"></span></a><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>Wechat</span><span class="qrcode"><img src="/" alt="Wechat"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2018/01/13/python-mian-xiang-dui-xiang-bian-cheng-zhi-lei-de-te-shu-shu-xing-he-fang-fa/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Python 面向对象编程之类的特殊属性和方法</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2018/01/11/python-zhong-de-han-shu-sheng-jie/"><span class="level-item">Python 中的函数升阶</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">Comments</h3><div class="notification is-danger">You forgot to set the <code>shortname</code> for Disqus. Please set it in <code>_config.yml</code>.</div></div></div></div><!--!--><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen  order-3 is-sticky"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="Waldeinsamkeit"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Waldeinsamkeit</p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">101</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">13</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">43</p></a></div></div></nav></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">Catalogue</h3><ul class="menu-list"><li><a class="level is-mobile" href="#面向对象初识"><span class="level-left"><span class="level-item">1</span><span class="level-item">面向对象初识</span></span></a></li><li><a class="level is-mobile" href="#类和实例"><span class="level-left"><span class="level-item">2</span><span class="level-item">类和实例</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#类"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">类</span></span></a></li><li><a class="level is-mobile" href="#self-方法参数"><span class="level-left"><span class="level-item">2.2</span><span class="level-item">self 方法参数</span></span></a></li><li><a class="level is-mobile" href="#类的对象"><span class="level-left"><span class="level-item">2.3</span><span class="level-item">类的对象</span></span></a></li><li><a class="level is-mobile" href="#类属性和类方法详解"><span class="level-left"><span class="level-item">2.4</span><span class="level-item">类属性和类方法详解</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#类属性-amp-amp-实例属性"><span class="level-left"><span class="level-item">2.4.1</span><span class="level-item">类属性 &amp;&amp; 实例属性</span></span></a></li><li><a class="level is-mobile" href="#类方法-amp-amp-静态方法-amp-amp-实例方法"><span class="level-left"><span class="level-item">2.4.2</span><span class="level-item">类方法 &amp;&amp; 静态方法 &amp;&amp; 实例方法</span></span></a></li></ul></li><li><a class="level is-mobile" href="#类命名空间"><span class="level-left"><span class="level-item">2.5</span><span class="level-item">类命名空间</span></span></a></li></ul></li><li><a class="level is-mobile" href="#类的封装特性（访问限制）"><span class="level-left"><span class="level-item">3</span><span class="level-item">类的封装特性（访问限制）</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Python-中的访问限制"><span class="level-left"><span class="level-item">3.1</span><span class="level-item">Python 中的访问限制</span></span></a></li><li><a class="level is-mobile" href="#Python-中的描述符"><span class="level-left"><span class="level-item">3.2</span><span class="level-item">Python 中的描述符</span></span></a></li><li><a class="level is-mobile" href="#Python-property-函数"><span class="level-left"><span class="level-item">3.3</span><span class="level-item">Python property() 函数</span></span></a></li><li><a class="level is-mobile" href="#Python-property-装饰器"><span class="level-left"><span class="level-item">3.4</span><span class="level-item">Python @property 装饰器</span></span></a></li><li><a class="level is-mobile" href="#访问限制优点"><span class="level-left"><span class="level-item">3.5</span><span class="level-item">访问限制优点</span></span></a></li><li><a class="level is-mobile" href="#深入了解访问限制底层原理"><span class="level-left"><span class="level-item">3.6</span><span class="level-item">深入了解访问限制底层原理</span></span></a></li></ul></li><li><a class="level is-mobile" href="#类的继承特性"><span class="level-left"><span class="level-item">4</span><span class="level-item">类的继承特性</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#深入理解-Python-中的-MRO"><span class="level-left"><span class="level-item">4.1</span><span class="level-item">深入理解 Python 中的 MRO</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#旧式类-MRO-算法"><span class="level-left"><span class="level-item">4.1.1</span><span class="level-item">旧式类 MRO 算法</span></span></a></li><li><a class="level is-mobile" href="#新式类-MRO-算法"><span class="level-left"><span class="level-item">4.1.2</span><span class="level-item">新式类 MRO 算法</span></span></a></li><li><a class="level is-mobile" href="#MRO-C3"><span class="level-left"><span class="level-item">4.1.3</span><span class="level-item">MRO C3</span></span></a></li></ul></li><li><a class="level is-mobile" href="#继承升阶"><span class="level-left"><span class="level-item">4.2</span><span class="level-item">继承升阶</span></span></a></li><li><a class="level is-mobile" href="#Super-使用"><span class="level-left"><span class="level-item">4.3</span><span class="level-item">Super() 使用</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#场景引入"><span class="level-left"><span class="level-item">4.3.1</span><span class="level-item">场景引入</span></span></a></li><li><a class="level is-mobile" href="#子类中调用父类构造函数"><span class="level-left"><span class="level-item">4.3.2</span><span class="level-item">子类中调用父类构造函数</span></span></a></li><li><a class="level is-mobile" href="#Super-注意事项"><span class="level-left"><span class="level-item">4.3.3</span><span class="level-item">Super 注意事项</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#类的多态特性"><span class="level-left"><span class="level-item">5</span><span class="level-item">类的多态特性</span></span></a></li><li><a class="level is-mobile" href="#静态语言-vs-动态语言"><span class="level-left"><span class="level-item">6</span><span class="level-item">静态语言 vs 动态语言</span></span></a></li><li><a class="level is-mobile" href="#枚举类"><span class="level-left"><span class="level-item">7</span><span class="level-item">枚举类</span></span></a></li><li><a class="level is-mobile" href="#实战搜索引擎"><span class="level-left"><span class="level-item">8</span><span class="level-item">实战搜索引擎</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="When Art Meets Tech" height="28"></a><p class="is-size-7"><span>&copy; 2024 Waldeinsamkeit</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p></div></div></div></div></footer><script src="https://cdnjs.loli.net/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" async></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/cookieconsent/3.1.1/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/js/lightgallery.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>
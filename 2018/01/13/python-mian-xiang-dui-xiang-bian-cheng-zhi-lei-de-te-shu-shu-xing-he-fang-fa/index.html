<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Python 面向对象编程之类的特殊属性和方法 - When Art Meets Tech</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="When Art Meets Tech"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="When Art Meets Tech"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta description="Python 类中，凡是以双下划线 __ 开头和结尾命名的成员（属性和方法），都被称为类的特殊成员（特殊属性和特殊方法），例如类的 __init__(self) 构造方法。此外，Python 类中还包含很多其它的特殊成员，包括 __del__(self)、__new__(self) 等等，这里会一一进行详解。"><meta property="og:type" content="blog"><meta property="og:title" content="Python 面向对象编程之类的特殊属性和方法"><meta property="og:url" content="https://www.orangeshare.cn/2018/01/13/python-mian-xiang-dui-xiang-bian-cheng-zhi-lei-de-te-shu-shu-xing-he-fang-fa/"><meta property="og:site_name" content="When Art Meets Tech"><meta property="og:description" content="Python 类中，凡是以双下划线 __ 开头和结尾命名的成员（属性和方法），都被称为类的特殊成员（特殊属性和特殊方法），例如类的 __init__(self) 构造方法。此外，Python 类中还包含很多其它的特殊成员，包括 __del__(self)、__new__(self) 等等，这里会一一进行详解。"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://www.orangeshare.cn/img/og_image.png"><meta property="article:published_time" content="2018-01-13T06:40:29.000Z"><meta property="article:modified_time" content="2022-04-05T11:47:19.830Z"><meta property="article:author" content="Waldeinsamkeit"><meta property="article:tag" content="Python"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.orangeshare.cn/2018/01/13/python-mian-xiang-dui-xiang-bian-cheng-zhi-lei-de-te-shu-shu-xing-he-fang-fa/"},"headline":"When Art Meets Tech","image":["https://www.orangeshare.cn/img/og_image.png"],"datePublished":"2018-01-13T06:40:29.000Z","dateModified":"2022-04-05T11:47:19.830Z","author":{"@type":"Person","name":"Waldeinsamkeit"},"description":"Python 类中，凡是以双下划线 __ 开头和结尾命名的成员（属性和方法），都被称为类的特殊成员（特殊属性和特殊方法），例如类的 __init__(self) 构造方法。此外，Python 类中还包含很多其它的特殊成员，包括 __del__(self)、__new__(self) 等等，这里会一一进行详解。"}</script><link rel="canonical" href="https://www.orangeshare.cn/2018/01/13/python-mian-xiang-dui-xiang-bian-cheng-zhi-lei-de-te-shu-shu-xing-he-fang-fa/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Oxanium:wght@300;400;600&amp;family=Roboto+Mono"><link rel="stylesheet" href="/css/cyberpunk.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/cookieconsent/3.1.1/cookieconsent.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/pace/1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.2.0"></head>    <body class="is-3-column">    <nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="When Art Meets Tech" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Hexo Search" href="https://hexo.io/zh-cn/"><i class="fab fa-hotjar"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="Catalogue" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal"><i class="fas fa-angle-double-right"></i>Python 面向对象编程之类的特殊属性和方法</h1><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><i class="far fa-calendar-alt"> </i><time dateTime="${date_xml(page.date)}" title="${date_xml(page.date)}">2018-01-13</time></span><span class="level-item is-hidden-mobile"><i class="far fa-calendar-check"> </i><time dateTime="${date_xml(page.updated)}" title="${date_xml(page.updated)}">2022-04-05</time></span><span class="level-item"><a class="link-muted" href="/categories/Python/">Python</a></span><span class="level-item">2 hours read (About 19817 words)</span></div></div><div class="content"><p>Python 类中，凡是以双下划线 <code>__</code> 开头和结尾命名的成员（属性和方法），都被称为类的特殊成员（特殊属性和特殊方法），例如类的 <code>__init__(self)</code> 构造方法。此外，Python 类中还包含很多其它的特殊成员，包括 <code>__del__(self)</code>、<code>__new__(self)</code> 等等，这里会一一进行详解。</p>
<a id="more"></a>

<h2 id="类常用特殊成员整理"><a href="#类常用特殊成员整理" class="headerlink" title="类常用特殊成员整理"></a>类常用特殊成员整理</h2><p>我们知道，Python 类中的特殊成员，其特殊性类似 C++ 类的 <code>private</code> 私有成员，即不能在类的外部直接调用，但允许借助类中的普通方法调用甚至修改它们（封装）。如果需要，还可以对类的特殊方法进行重写，从而实现一些特殊的功能。</p>
<p>这一小节，将会详解 Python 顶级父类 <code>object</code> 中常用特殊成员的使用：</p>
<h3 id="Method-new"><a href="#Method-new" class="headerlink" title="Method: __new__"></a>Method: <code>__new__</code></h3><p><code>__new__()</code> 是一种用来创建类实例的静态方法，它无需使用 @staticmethod 装饰器修饰，且该方法会优先 <code>__init__()</code> 初始化方法被调用。</p>
<p><strong>[1] &gt;&gt;&gt;&gt; <code>__new__()</code> 返回当前类实例</strong></p>
<p>一般情况下，重写 <code>__new__()</code> 的实现需要使用合适的参数调用其超类的 <code>super().__new__()</code>，并在返回之前修改实例。</p>
<p>实例如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">demoClass</span>:</span></span><br><span class="line">    instances_created = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">cls,*args,**kwargs</span>):</span></span><br><span class="line">        print(<span class="string">&quot;__new__():&quot;</span>,cls,args,kwargs)</span><br><span class="line">        instance = <span class="built_in">super</span>().__new__(cls)</span><br><span class="line">        instance.number = cls.instances_created</span><br><span class="line">        cls.instances_created += <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> instance</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,attribute</span>):</span></span><br><span class="line">        print(<span class="string">&quot;__init__():&quot;</span>,self,attribute)</span><br><span class="line">        self.attribute = attribute</span><br><span class="line"></span><br><span class="line">test1 = demoClass(<span class="string">&quot;abc&quot;</span>)</span><br><span class="line"><span class="comment"># __new__():  (&#x27;abc&#x27;,) &#123;&#125;</span></span><br><span class="line"><span class="comment"># __init__(): &lt;__main__.demoClass object at 0x7efd9982fcc0&gt; abc</span></span><br><span class="line">test2 = demoClass(<span class="string">&quot;xyz&quot;</span>)</span><br><span class="line"><span class="comment"># __new__():  (&#x27;xyz&#x27;,) &#123;&#125;</span></span><br><span class="line"><span class="comment"># __init__(): &lt;__main__.demoClass object at 0x7efd9982fcf8&gt; xyz</span></span><br><span class="line">print(test1.number, test1.instances_created)</span><br><span class="line"><span class="comment"># 0 2</span></span><br><span class="line">print(test2.number, test2.instances_created)</span><br><span class="line"><span class="comment"># 1 2</span></span><br></pre></td></tr></table></figure>

<p><strong>[2] &gt;&gt;&gt;&gt; <code>__new__()</code> 返回其它类实例</strong></p>
<p><code>__new__()</code> 通常会返回该类的一个实例，但有时也可能会返回其他类的实例，如果发生了这种情况，则会跳过对 <code>__init__()</code> 方法的调用。</p>
<p>而在某些情况下（比如需要修改不可变类实例（Python 的某些内置类型）的创建行为），利用这一点会事半功倍。比如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">nonZero</span>(<span class="params"><span class="built_in">int</span></span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__new__</span>(<span class="params">cls,value</span>):</span></span><br><span class="line">        print(<span class="string">&quot;__new__()&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">super</span>().__new__(cls,value) <span class="keyword">if</span> value != <span class="number">0</span> <span class="keyword">else</span> <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,skipped_value</span>):</span></span><br><span class="line">        <span class="comment"># 此例中会跳过此方法</span></span><br><span class="line">        print(<span class="string">&quot;__init__()&quot;</span>)</span><br><span class="line">        <span class="built_in">super</span>().__init__()</span><br><span class="line"></span><br><span class="line">print(<span class="built_in">type</span>(nonZero(-<span class="number">12</span>)))</span><br><span class="line"><span class="comment"># __new__()</span></span><br><span class="line"><span class="comment"># __init__()</span></span><br><span class="line">print(<span class="built_in">type</span>(nonZero(<span class="number">0</span>)))</span><br><span class="line"><span class="comment"># __new__()</span></span><br></pre></td></tr></table></figure>

<p><strong>[3] &gt;&gt;&gt;&gt; 何时使用 <code>__new__()</code>？</strong></p>
<p>很简单，在 <code>__init__()</code> 不够用的时候。</p>
<p>例如，前面例子中对 Python 不可变的内置类型（如 <code>int</code>、<code>str</code>、<code>float</code> 等）进行了子类化，这是因为一旦创建了这样不可变的对象实例，就无法在 <code>__init__()</code> 方法中对其进行修改。</p>
<p>有些读者可能会认为，<code>__new__()</code> 对执行重要的对象初始化很有用，如果用户忘记使用 <code>super()</code>，可能会漏掉这一初始化。虽然这听上去很合理，但有一个主要的缺点，即如果使用这样的方法，那么即便初始化过程已经是预期的行为，程序员明确跳过初始化步骤也会变得更加困难。不仅如此，它还破坏了 <code>__init__() 中执行所有初始化工作</code> 的潜规则。</p>
<p>并且，由于 <code>__new__()</code> 不限于返回同一个类的实例，所以很容易被滥用，不负责任地使用这种方法可能会对代码有害，所以要谨慎使用。</p>
<p>一般来说，对于特定问题，最好搜索其他可用的解决方案，最好不要影响对象的创建过程，使其违背程序员的预期。比如说，前面提到的覆写不可变类型初始化的例子，完全可以用工厂方法（一种设计模式）来替代。</p>
<hr>
<h3 id="Method-repr"><a href="#Method-repr" class="headerlink" title="Method: __repr__"></a>Method: <code>__repr__</code></h3><p>我们经常会直接输出类的实例化对象，例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Language</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line">langs = Language()</span><br><span class="line"></span><br><span class="line">print(langs)</span><br><span class="line"><span class="comment"># &lt;__main__.Language object at 0x7fe399c6a710&gt;</span></span><br></pre></td></tr></table></figure>

<p>通常情况下，直接输出某个实例化对象，本意往往是想了解该对象的基本信息，例如该对象有哪些属性，它们的值各是多少等等。但默认情况下，我们得到的信息只会是 <code>class name + object at + &lt;memory address&gt;</code>，对我们了解该实例化对象帮助不大。</p>
<p>那么，有没有可能自定义输出实例化对象时的信息呢？？？答案是肯定，通过重写类的 <code>__repr__()</code> 方法即可。</p>
<p><strong>重写 <code>__repr__()</code> 方法输出实例化对象时的信息 &gt;&gt;&gt;&gt;</strong></p>
<p>事实上，当我们输出某个实例化对象时，其调用的就是该对象的 <code>__repr__()</code> 方法，输出的是该方法的返回值。</p>
<p>以本节开头的程序为例，执行 <code>print(clangs)</code> 等同于执行 <code>print(clangs.__repr__())</code>，程序的输出结果是一样的（输出的内存地址可能不同）。</p>
<p>和 <code>__init__(self)</code> 的性质一样，Python 中的每个类都包含 <code>__repr__()</code> 方法，这是因为 <code>object</code> 类包含 <code>__reper__()</code> 方法，而 Python 中所有的类都直接或间接继承自 object 类。因此，你可以通过在类中重写这个方法，从而实现当输出实例化对象时，输出我们想要的信息。</p>
<p>实例演示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Language</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.name = <span class="string">&quot;Python&quot;</span></span><br><span class="line">        self.add = <span class="string">&quot;Python is a OOP programing.&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Language [name = &quot;</span> + self.name +<span class="string">&quot;, add = &quot;</span> + self.add + <span class="string">&quot; ]&quot;</span></span><br><span class="line"></span><br><span class="line">langs = Language()</span><br><span class="line">print(langs)</span><br><span class="line"><span class="comment"># Language [name = Python, add = Python is a OOP programing. ]</span></span><br></pre></td></tr></table></figure>

<p>由此可见，<code>__repr__()</code> 方法是类的实例化对象用来做“自我介绍”的方法，默认情况下，它会返回当前对象的 <code>class name + object at + &lt;memory address&gt;</code>，而如果对该方法进行重写，可以为其制作自定义的自我描述信息。</p>
<hr>
<h3 id="Method-del"><a href="#Method-del" class="headerlink" title="Method: __del__"></a>Method: <code>__del__</code></h3><p>我们知道，Python 中通过调用 <code>__init__()</code> 构造方法来创建当前类的实例化对象；<code>__del__()</code> 方法，功能正好和 <code>__init__()</code> 相反，其用来销毁实例化对象。</p>
<p>事实上在编写程序时，如果之前创建的类实例化对象后续不再使用，最好在适当位置手动将其销毁，释放其占用的内存空间（垃圾回收，GC）。</p>
<blockquote>
<p>大多数情况下，Python 开发者不需要手动进行垃圾回收，因为 Python 有自动的垃圾回收机制，能自动将不需要使用的实例对象进行销毁。</p>
</blockquote>
<p>但注意，无论是手动销毁，还是 Python 自动帮我们销毁，都会调用 <code>__del__()</code> 方法。实例演示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Language</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;调用 __init__() 方法构造对象&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__del__</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;调用 __del__() 销毁对象，释放其空间&quot;</span>)</span><br><span class="line"></span><br><span class="line">langs = Language()</span><br><span class="line"><span class="comment"># 调用 __init__() 方法构造对象</span></span><br><span class="line"><span class="keyword">del</span> langs</span><br><span class="line"><span class="comment"># 调用 __del__() 销毁对象，释放其空间</span></span><br></pre></td></tr></table></figure>

<p><strong>[1] &gt;&gt;&gt;&gt; 类的自动回收机制</strong></p>
<p>千万不要误认为，只要为该实例对象调用 <code>__del__()</code> 方法，该对象所占用的内存空间就会被释放。举个例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Language</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;调用 __init__() 方法构造对象&quot;</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__del__</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;调用 __del__() 销毁对象，释放其空间&quot;</span>)</span><br><span class="line"></span><br><span class="line">langs = Language()</span><br><span class="line"><span class="comment"># 添加一个引用 langs 对象的实例对象</span></span><br><span class="line">cl = langs</span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> langs</span><br><span class="line">print(<span class="string">&quot;**** Program End ****&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>运行结果如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">调用 __init__() 方法构造对象</span><br><span class="line">**** Program End ****</span><br><span class="line">调用 __del__() 销毁对象，释放其空间</span><br></pre></td></tr></table></figure>

<p>可以看到，当程序中有其它变量（比如这里的 cl）引用该实例对象时，即便手动调用 <code>__del__()</code> 方法，该方法也不会立即执行，而是等待程序执行完成之后才会释放。这就和 Python 的垃圾回收机制有关。</p>
<p>以上面程序中的 <code>langs</code> 为例，实际上构建 <code>langs</code> 实例对象的过程分为两步：</p>
<ol>
<li>先使用 <code>Language()</code> 调用该类中的 <code>__init__()</code> 方法构造出一个该类的对象（将其称为 C，计数器为 0），并立即用 <code>langs</code> 这个变量作为所建实例对象的引用（ C 的计数器值 + 1）。</li>
<li>在此基础上，又有一个 <code>cl</code> 变量引用 <code>langs</code>（其实相当于引用 <code>Language()</code>，此时 C 的计数器再 +1 ），这时如果调用 <code>del langs</code> 语句，只会导致 C 的计数器减 1（值变为 1），因为 C 的计数器值不为 0，因此 C 不会被销毁（不会执行 <code>__del__()</code> 方法）。</li>
</ol>
<p><strong>[2] &gt;&gt;&gt;&gt; 重写时需显式调用父类 <code>__del__()</code> 方法</strong></p>
<p>需要额外说明的是，如果我们重写子类的 <code>__del__()</code> 方法（父类为非 object 的类），则必须显式调用父类的 <code>__del__()</code> 方法，这样才能保证在回收子类对象时，其占用的资源（可能包含继承自父类的部分资源）能被彻底释放。</p>
<p>为了说明这一点，这里举一个反例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Language</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__del__</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;调用父类 __del__() 方法&quot;</span>)</span><br><span class="line">        </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">cl</span>(<span class="params">Language</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__del__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># super().__del__() # 需要显示调用父类 __del__() 方法</span></span><br><span class="line">        print(<span class="string">&quot;调用子类 __del__() 方法&quot;</span>)</span><br><span class="line">        </span><br><span class="line">c = cl()</span><br><span class="line"><span class="keyword">del</span> c</span><br><span class="line"><span class="comment"># 调用子类 __del__() 方法</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Method-dir"><a href="#Method-dir" class="headerlink" title="Method: __dir__"></a>Method: <code>__dir__</code></h3><p>在 Python 内置函数中，提到过 <code>dir()</code> 函数，通过此函数可以某个对象拥有的所有的属性名和方法名，该函数会返回一个包含有所有属性名和方法名的有序列表。</p>
<p>实例如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Language</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span> (<span class="params">self,</span>):</span></span><br><span class="line">        self.name = <span class="string">&quot;C语言中文网&quot;</span></span><br><span class="line">        self.add = <span class="string">&quot;http://c.biancheng.net&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">say</span>():</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">langs = Language()</span><br><span class="line">print(<span class="built_in">dir</span>(langs))</span><br><span class="line"><span class="comment"># [&#x27;__class__&#x27;, &#x27;__delattr__&#x27;, &#x27;__dict__&#x27;, &#x27;__dir__&#x27;, &#x27;__doc__&#x27;, &#x27;__eq__&#x27;, &#x27;__format__&#x27;, &#x27;__ge__&#x27;, &#x27;__getattribute__&#x27;, &#x27;__gt__&#x27;, &#x27;__hash__&#x27;, &#x27;__init__&#x27;, &#x27;__init_subclass__&#x27;, &#x27;__le__&#x27;, &#x27;__lt__&#x27;, &#x27;__module__&#x27;, &#x27;__ne__&#x27;, &#x27;__new__&#x27;, &#x27;__reduce__&#x27;, &#x27;__reduce_ex__&#x27;, &#x27;__repr__&#x27;, &#x27;__setattr__&#x27;, &#x27;__sizeof__&#x27;, &#x27;__str__&#x27;, &#x27;__subclasshook__&#x27;, &#x27;__weakref__&#x27;, &#x27;add&#x27;, &#x27;name&#x27;, &#x27;say&#x27;]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>可以看到，不仅仅输出本类中新添加的属性名和方法（最后 3 个），还会输出从父类（这里为 object 类）继承得到的属性名和方法名。</p>
</blockquote>
<p>值得一提的是，dir() 函数的内部实现，其实是在调用参数对象 <code>__dir__()</code> 方法的基础上，对该方法返回的属性名和方法名做了排序。</p>
<p>所以，你完全可以自行调用该对象具有的 <code>__dir__()</code> 方法来查看某个对象拥有的所有的属性名和方法名：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Language</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span> (<span class="params">self,</span>):</span></span><br><span class="line">        self.name = <span class="string">&quot;C语言中文网&quot;</span></span><br><span class="line">        self.add = <span class="string">&quot;http://c.biancheng.net&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">say</span>():</span></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">langs = Language()</span><br><span class="line">print(langs.__dir__())</span><br><span class="line">[<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;add&#x27;</span>, <span class="string">&#x27;__module__&#x27;</span>, <span class="string">&#x27;__init__&#x27;</span>, <span class="string">&#x27;say&#x27;</span>, <span class="string">&#x27;__dict__&#x27;</span>, <span class="string">&#x27;__weakref__&#x27;</span>, <span class="string">&#x27;__doc__&#x27;</span>, <span class="string">&#x27;__repr__&#x27;</span>, <span class="string">&#x27;__hash__&#x27;</span>, <span class="string">&#x27;__str__&#x27;</span>, <span class="string">&#x27;__getattribute__&#x27;</span>, <span class="string">&#x27;__setattr__&#x27;</span>, <span class="string">&#x27;__delattr__&#x27;</span>, <span class="string">&#x27;__lt__&#x27;</span>, <span class="string">&#x27;__le__&#x27;</span>, <span class="string">&#x27;__eq__&#x27;</span>, <span class="string">&#x27;__ne__&#x27;</span>, <span class="string">&#x27;__gt__&#x27;</span>, <span class="string">&#x27;__ge__&#x27;</span>, <span class="string">&#x27;__new__&#x27;</span>, <span class="string">&#x27;__reduce_ex__&#x27;</span>, <span class="string">&#x27;__reduce__&#x27;</span>, <span class="string">&#x27;__subclasshook__&#x27;</span>, <span class="string">&#x27;__init_subclass__&#x27;</span>, <span class="string">&#x27;__format__&#x27;</span>, <span class="string">&#x27;__sizeof__&#x27;</span>, <span class="string">&#x27;__dir__&#x27;</span>, <span class="string">&#x27;__class__&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>显然，使用 <code>__dir__()</code> 方法和 <code>dir()</code> 函数输出的数据是相同，仅仅顺序不同。</p>
<hr>
<h3 id="Method-dict"><a href="#Method-dict" class="headerlink" title="Method:  __dict__"></a>Method: <code> __dict__</code></h3><p>事实上，在 Python 类的内部，无论是类属性还是实例属性，都是以字典的形式进行存储的，其中属性名作为键，而值作为该键对应的值。</p>
<p>为了方便用户查看类中包含哪些属性，Python 类提供了 <code>__dict__</code> 属性。</p>
<p>需要注意是，该属性可以用类名或者类的实例对象来调用：</p>
<ul>
<li>使用类名直接调用 <code>__dict__</code>，会输出该由类中所有类属性组成的字典；</li>
<li>使用类的实例对象调用 <code>__dict__</code>，会输出由类中所有实例属性组成的字典。</li>
</ul>
<p>实例演示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Language</span>:</span></span><br><span class="line">    a = <span class="number">1</span></span><br><span class="line">    b = <span class="number">2</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span> (<span class="params">self</span>):</span></span><br><span class="line">        self.name = <span class="string">&quot;Python&quot;</span></span><br><span class="line">        self.add = <span class="string">&quot;Python is a OOP Programing&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">info</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;Instance Method&quot;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">say</span>(<span class="params">cls</span>):</span></span><br><span class="line">        print(<span class="string">&quot;Class Method&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过类名调用__dict__</span></span><br><span class="line">print(Language.__dict__)</span><br><span class="line"><span class="comment"># &#123;&#x27;__module__&#x27;: &#x27;__main__&#x27;, &#x27;a&#x27;: 1, &#x27;b&#x27;: 2, &#x27;__init__&#x27;: , &#x27;info&#x27;: , &#x27;say&#x27;: , &#x27;__dict__&#x27;: , &#x27;__weakref__&#x27;: , &#x27;__doc__&#x27;: None&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过类实例对象调用 __dict__</span></span><br><span class="line">langs = Language()</span><br><span class="line">print(langs.__dict__)</span><br><span class="line"><span class="comment"># &#123;&#x27;name&#x27;: &#x27;Python&#x27;, &#x27;add&#x27;: &#x27;Python is a OOP Programing&#x27;&#125;</span></span><br></pre></td></tr></table></figure>

<p>不仅如此，对于具有继承关系的父类和子类来说，父类有自己的 <code>__dict__</code>，同样子类也有自己的 <code>__dict__</code>，它不会包含父类的 <code>__dict__</code>。例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Language</span>:</span></span><br><span class="line">    a = <span class="number">1</span></span><br><span class="line">    b = <span class="number">2</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span> (<span class="params">self</span>):</span></span><br><span class="line">        self.name = <span class="string">&quot;Python&quot;</span></span><br><span class="line">        self.add = <span class="string">&quot;Python is a OOP Programing&quot;</span></span><br><span class="line">       </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CL</span>(<span class="params">Language</span>):</span></span><br><span class="line">    c = <span class="number">1</span></span><br><span class="line">    d = <span class="number">2</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span> (<span class="params">self</span>):</span></span><br><span class="line">        self.na = <span class="string">&quot;Python3.X&quot;</span></span><br><span class="line">        self.ad = <span class="string">&quot;Python3.X is a OOP Programing&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 父类名调用__dict__</span></span><br><span class="line">print(Language.__dict__)</span><br><span class="line"><span class="comment"># &#123;&#x27;__module__&#x27;: &#x27;__main__&#x27;, &#x27;a&#x27;: 1, &#x27;b&#x27;: 2, &#x27;__init__&#x27;: , &#x27;__dict__&#x27;: , &#x27;__weakref__&#x27;: , &#x27;__doc__&#x27;: None&#125;</span></span><br><span class="line"><span class="comment"># 子类名调用__dict__</span></span><br><span class="line">print(CL.__dict__)</span><br><span class="line"><span class="comment"># &#123;&#x27;__module__&#x27;: &#x27;__main__&#x27;, &#x27;c&#x27;: 1, &#x27;d&#x27;: 2, &#x27;__init__&#x27;: , &#x27;__doc__&#x27;: None&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 父类实例对象调用 __dict__</span></span><br><span class="line">langs = Language()</span><br><span class="line">print(langs.__dict__)</span><br><span class="line"><span class="comment"># &#123;&#x27;name&#x27;: &#x27;Python&#x27;, &#x27;add&#x27;: &#x27;Python is a OOP Programing&#x27;&#125;</span></span><br><span class="line"><span class="comment"># 子类实例对象调用 __dict__</span></span><br><span class="line">cl = CL()</span><br><span class="line">print(cl.__dict__)</span><br><span class="line"><span class="comment"># &#123;&#x27;na&#x27;: &#x27;Python3.X&#x27;, &#x27;ad&#x27;: &#x27;Python3.X is a OOP Programing&#x27;&#125;</span></span><br></pre></td></tr></table></figure>

<p>可见，通过子类直接调用的 <code>__dict__</code> 中，并没有包含父类中的 <code>a</code> 和 <code>b</code> 类属性；同样，通过子类对象调用的 <code>__dict__</code>，也没有包含父类对象拥有的 <code>name</code> 和 <code>add</code> 实例属性。</p>
<p>总结一下：</p>
<ul>
<li>实例的 <code>__dict__</code> 仅存储与该实例相关的实例属性;</li>
<li>类的 <code>__dict__</code> 存储所有实例共享的变量和函数(类属性，方法等)，类的 <code>__dict__</code> 并不包含其父类的属性。</li>
</ul>
<p><strong>[1] &gt;&gt;&gt;&gt; 修改类实例属性值</strong></p>
<p>借助由类实例对象调用 <code>__dict__</code> 属性获取的字典，可以使用字典的方式对其中实例属性的值进行修改，例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Language</span>:</span></span><br><span class="line">    a = <span class="number">1</span></span><br><span class="line">    b = <span class="number">2</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span> (<span class="params">self</span>):</span></span><br><span class="line">        self.name = <span class="string">&quot;Python&quot;</span></span><br><span class="line">        self.add = <span class="string">&quot;Python is a OOP Programing&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#通过类实例对象调用 __dict__</span></span><br><span class="line">langs = Language()</span><br><span class="line">print(langs.__dict__)</span><br><span class="line"><span class="comment"># &#123;&#x27;name&#x27;: &#x27;Python&#x27;, &#x27;add&#x27;: &#x27;Python is a OOP Programing&#x27;&#125;</span></span><br><span class="line">langs.__dict__[<span class="string">&#x27;name&#x27;</span>] = <span class="string">&quot;Python3.X&quot;</span></span><br><span class="line">print(langs.name)</span><br><span class="line"><span class="comment"># Python3.X</span></span><br></pre></td></tr></table></figure>

<p><strong>[2] &gt;&gt;&gt;&gt; <code>__dict__</code> 魔法操作</strong></p>
<p>我们知道，<code>__dict__</code> 是用来存储对象属性的一个字典，其键为属性名，值为属性的值。</p>
<p>既然 <code>__dict__</code> 是个字典那么我们就可以用字典的属性了。我们通过使用 <code>dir()</code> 属性来看看 <code>__dict__</code> 都有哪些属性:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">&#x27;__class__&#x27;</span>, <span class="string">&#x27;__contains__&#x27;</span>, <span class="string">&#x27;__delattr__&#x27;</span>, <span class="string">&#x27;__delitem__&#x27;</span>, <span class="string">&#x27;__dir__&#x27;</span>, <span class="string">&#x27;__doc__&#x27;</span>, <span class="string">&#x27;__eq__&#x27;</span>, <span class="string">&#x27;__format__&#x27;</span>, <span class="string">&#x27;__ge__&#x27;</span>, <span class="string">&#x27;__getattribute__&#x27;</span>, <span class="string">&#x27;__getitem__&#x27;</span>, <span class="string">&#x27;__gt__&#x27;</span>, <span class="string">&#x27;__hash__&#x27;</span>, <span class="string">&#x27;__init__&#x27;</span>, <span class="string">&#x27;__init_subclass__&#x27;</span>, <span class="string">&#x27;__iter__&#x27;</span>, <span class="string">&#x27;__le__&#x27;</span>, <span class="string">&#x27;__len__&#x27;</span>, <span class="string">&#x27;__lt__&#x27;</span>, <span class="string">&#x27;__ne__&#x27;</span>, <span class="string">&#x27;__new__&#x27;</span>, <span class="string">&#x27;__reduce__&#x27;</span>, <span class="string">&#x27;__reduce_ex__&#x27;</span>, <span class="string">&#x27;__repr__&#x27;</span>, <span class="string">&#x27;__reversed__&#x27;</span>, <span class="string">&#x27;__setattr__&#x27;</span>, <span class="string">&#x27;__setitem__&#x27;</span>, <span class="string">&#x27;__sizeof__&#x27;</span>, <span class="string">&#x27;__str__&#x27;</span>, <span class="string">&#x27;__subclasshook__&#x27;</span>, <span class="string">&#x27;clear&#x27;</span>, <span class="string">&#x27;copy&#x27;</span>, <span class="string">&#x27;fromkeys&#x27;</span>, <span class="string">&#x27;get&#x27;</span>, <span class="string">&#x27;items&#x27;</span>, <span class="string">&#x27;keys&#x27;</span>, <span class="string">&#x27;pop&#x27;</span>, <span class="string">&#x27;popitem&#x27;</span>, <span class="string">&#x27;setdefault&#x27;</span>, <span class="string">&#x27;update&#x27;</span>, <span class="string">&#x27;values&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>我们看一段代码内含注释:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.name=<span class="string">&quot;liming&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">save_data</span>(<span class="params">self,dicts</span>):</span></span><br><span class="line">        self.__dict__.update(dicts)<span class="comment">#添加字典元素</span></span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(self.__dict__,<span class="built_in">dict</span>):</span><br><span class="line">            print(<span class="literal">True</span>)</span><br><span class="line">        <span class="comment"># 获取字典独有的属性</span></span><br><span class="line">        print(<span class="built_in">set</span>(<span class="built_in">dir</span>(self.__dict__))-<span class="built_in">set</span>(<span class="built_in">dir</span>(self)))</span><br><span class="line">        <span class="keyword">return</span> self.__dict__</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">     dicts=&#123;<span class="string">&quot;a&quot;</span>:<span class="number">1</span>, <span class="string">&quot;b&quot;</span>:<span class="number">2</span>, <span class="string">&quot;c&quot;</span>:<span class="number">3</span>&#125;</span><br><span class="line">     a=A()</span><br><span class="line">     print(a.save_data(dicts))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"><span class="comment"># True</span></span><br><span class="line"><span class="comment"># &#123;&#x27;pop&#x27;, &#x27;items&#x27;, &#x27;__contains__&#x27;, &#x27;get&#x27;, &#x27;__len__&#x27;, &#x27;__delitem__&#x27;, &#x27;setdefault&#x27;, &#x27;values&#x27;, &#x27;__iter__&#x27;, &#x27;clear&#x27;, &#x27;keys&#x27;, &#x27;update&#x27;, &#x27;popitem&#x27;, &#x27;__getitem__&#x27;, &#x27;__setitem__&#x27;, &#x27;fromkeys&#x27;, &#x27;copy&#x27;&#125;</span></span><br><span class="line"><span class="comment"># &#123;&#x27;name&#x27;: &#x27;liming&#x27;, &#x27;a&#x27;: 1, &#x27;b&#x27;: 2, &#x27;c&#x27;: 3&#125;</span></span><br></pre></td></tr></table></figure>

<p>可以看到，<code>__dict__</code> 也提供了一个 <code>update</code> 方法，用于使用一个新的字典所包含的键值对来更新己有的字典。</p>
<p>这对于给对象的属性赋值的时候，非常 pythonic：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,dicts</span>):</span></span><br><span class="line">        self.name=dicts[<span class="string">&quot;name&quot;</span>]</span><br><span class="line">        self.age=dicts[<span class="string">&quot;age&quot;</span>]</span><br><span class="line">        self.sex=dicts[<span class="string">&quot;sex&quot;</span>]</span><br><span class="line">        self.hobby=dicts[<span class="string">&quot;hobby&quot;</span>]</span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">     dicts=&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;lisa&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">23</span>,<span class="string">&quot;sex&quot;</span>:<span class="string">&quot;women&quot;</span>,<span class="string">&quot;hobby&quot;</span>:<span class="string">&quot;hardstyle&quot;</span>&#125;</span><br><span class="line">     a=A(dicts)</span><br></pre></td></tr></table></figure>

<p>想象一下如果我们传入的字典有 100 个键….如何还是这样一个一个赋值不敢想不敢想？！！</p>
<p>你可以使用如下方法：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self,dicts</span>):</span></span><br><span class="line">        self.__dict__.update(dicts)</span><br><span class="line">        print(self.__dict__)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">     dicts=&#123;<span class="string">&quot;name&quot;</span>:<span class="string">&quot;lisa&quot;</span>,<span class="string">&quot;age&quot;</span>:<span class="number">23</span>,<span class="string">&quot;sex&quot;</span>:<span class="string">&quot;women&quot;</span>,<span class="string">&quot;hobby&quot;</span>:<span class="string">&quot;hardstyle&quot;</span>&#125;</span><br><span class="line">     a=A(dicts)</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="common-Method"><a href="#common-Method" class="headerlink" title="common Method"></a>common Method</h3><p>这一小节我们来看几个类以及对象相关的常用函数：</p>
<h4 id="setattr-amp-amp-getattr-amp-amp-hasattr"><a href="#setattr-amp-amp-getattr-amp-amp-hasattr" class="headerlink" title="setattr &amp;&amp; getattr &amp;&amp; hasattr"></a>setattr &amp;&amp; getattr &amp;&amp; hasattr</h4><p><strong>[1] &gt;&gt;&gt;&gt; hasattr() 函数</strong></p>
<p>hasattr() 函数用来判断某个类实例对象是否包含指定名称的属性或方法。该函数的语法格式如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">hasattr</span>(obj, name)</span><br></pre></td></tr></table></figure>

<p>说明：<code>obj</code> 指的是某个类的实例对象，<code>name</code> 表示指定的属性名或方法名。同时，该函数会将判断的结果（<code>True</code> or <code>False</code>）作为返回值反馈回来。</p>
<p>实例演示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Language</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span> (<span class="params">self</span>):</span></span><br><span class="line">        self.name = <span class="string">&quot;Python&quot;</span></span><br><span class="line">        self.add = <span class="string">&quot;Python is a OOP Programing.&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">say</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;I am learning Python.&quot;</span>)</span><br><span class="line"></span><br><span class="line">langs = Language()</span><br><span class="line">print(<span class="built_in">hasattr</span>(langs,<span class="string">&quot;name&quot;</span>))</span><br><span class="line"><span class="comment"># True</span></span><br><span class="line">print(<span class="built_in">hasattr</span>(langs,<span class="string">&quot;add&quot;</span>))</span><br><span class="line"><span class="comment"># True</span></span><br><span class="line">print(<span class="built_in">hasattr</span>(langs,<span class="string">&quot;say&quot;</span>))</span><br><span class="line"><span class="comment"># True</span></span><br></pre></td></tr></table></figure>

<p>显然，无论是属性名还是方法名，都在 hasattr() 函数的匹配范围内。</p>
<p>需要注意的是，我们只能通过该函数判断实例对象是否包含该名称的属性或方法，但不能精确判断，该名称代表的是属性还是方法。</p>
<p><strong>[2] &gt;&gt;&gt;&gt; getattr() 函数</strong></p>
<p>getattr() 函数获取某个类实例对象中指定属性的值。和 hasattr() 函数不同，该函数只会从类对象包含的所有属性中进行查找。其语法格式如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">getattr</span>(obj, name[, default])</span><br></pre></td></tr></table></figure>

<p>其中，<code>obj</code> 表示指定的类实例对象；<code>name</code> 表示指定的属性名；而 <code>default</code> 是可选参数，用于设定该函数的默认返回值，即当函数查找失败时；如果不指定 <code>default</code> 参数，则程序将直接报 <code>AttributeError</code> 错误，反之该函数将返回 <code>default</code> 指定的值。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Language</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span> (<span class="params">self</span>):</span></span><br><span class="line">        self.name = <span class="string">&quot;Python&quot;</span></span><br><span class="line">        self.add = <span class="string">&quot;Python is a OOP Programing.&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">say</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;I am learning Python.&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">langs = Language()</span><br><span class="line">print(<span class="built_in">getattr</span>(langs,<span class="string">&quot;name&quot;</span>))</span><br><span class="line">print(<span class="built_in">getattr</span>(langs,<span class="string">&quot;add&quot;</span>))</span><br><span class="line">print(<span class="built_in">getattr</span>(langs,<span class="string">&quot;say&quot;</span>))</span><br><span class="line">print(<span class="built_in">getattr</span>(langs,<span class="string">&quot;display&quot;</span>,<span class="string">&#x27;nodisplay&#x27;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"><span class="comment"># Python</span></span><br><span class="line"><span class="comment"># Python is a OOP Programing.</span></span><br><span class="line"><span class="comment"># &lt;bound method Language.say of &lt;__main__.CLanguage object at 0x000001FC2F2E3245&gt;&gt;</span></span><br><span class="line"><span class="comment"># nodisplay</span></span><br></pre></td></tr></table></figure>

<p>可以看到，对于类中已有的属性，<code>getattr()</code> 会返回它们的值，而如果该名称为方法名，则返回该方法的状态信息；反之，如果该明白不为类对象所有，要么返回默认的参数，要么程序报 <code>AttributeError</code> 错误。</p>
<p><strong>[3] &gt;&gt;&gt;&gt; setattr() 函数</strong></p>
<p>setattr() 函数的功能相对比较复杂，它最基础的功能是修改类实例对象中的属性值。其次，它还可以实现为实例对象动态添加属性或者方法。其语法格式如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setattr</span>(obj, name, value)</span><br></pre></td></tr></table></figure>

<p><strong>1）–&gt;</strong> 修改类实例对象中的属性值</p>
<p>实例演示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Language</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span> (<span class="params">self</span>):</span></span><br><span class="line">        self.name = <span class="string">&quot;Python&quot;</span></span><br><span class="line">        self.add = <span class="string">&quot;Python is a OOP Programing.&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">say</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;I am learning Python.&quot;</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">langs = Language()</span><br><span class="line">print(langs.name)</span><br><span class="line">print(langs.add)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setattr</span>(langs,<span class="string">&quot;name&quot;</span>,<span class="string">&quot;Python3.X&quot;</span>)</span><br><span class="line"><span class="built_in">setattr</span>(langs,<span class="string">&quot;add&quot;</span>,<span class="string">&quot;Python3.X is a OOP Programing.&quot;</span>)</span><br><span class="line">print(langs.name)</span><br><span class="line">print(langs.add)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"><span class="comment"># Python</span></span><br><span class="line"><span class="comment"># Python is a OOP Programing.</span></span><br><span class="line"><span class="comment"># Python3.X</span></span><br><span class="line"><span class="comment"># Python3.X is a OOP Programing.</span></span><br></pre></td></tr></table></figure>

<p><strong>2）–&gt;</strong> 别名用法</p>
<p>setattr() 函数，还可以将类属性修改为一个类方法，同样也可以将类方法修改成一个类属性。</p>
<p>实例演示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say</span>():</span></span><br><span class="line">    print(<span class="string">&quot;I am learning Python.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Language</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span> (<span class="params">self</span>):</span></span><br><span class="line">        self.name = <span class="string">&quot;Python&quot;</span></span><br><span class="line">        self.add = <span class="string">&quot;Python is a OOP Programing&quot;</span></span><br><span class="line"></span><br><span class="line">langs = Language()</span><br><span class="line">print(langs.name)</span><br><span class="line">print(langs.add)</span><br><span class="line"></span><br><span class="line"><span class="built_in">setattr</span>(langs, <span class="string">&quot;name&quot;</span>, say)</span><br><span class="line">langs.name()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"><span class="comment"># Python</span></span><br><span class="line"><span class="comment"># Python is a OOP Programing</span></span><br><span class="line"><span class="comment"># I am learning Python.</span></span><br></pre></td></tr></table></figure>

<p>显然，通过修改 <code>name</code> 属性的值为 <code>say</code>（全局函数），原来的 <code>name</code> 属性就变成了一个 <code>name()</code> 方法。</p>
<p><strong>3）–&gt;</strong> 动态添加实例属性和方法 </p>
<p>使用 setattr() 函数对实例对象中执行名称的属性或方法进行修改时，如果该名称查找失败，Python 解释器不会报错，而是会给该实例对象动态添加一个指定名称的属性或方法。</p>
<p>实例演示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say</span>():</span></span><br><span class="line">    print(<span class="string">&quot;I am learning Python.&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Language</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">langs = Language()</span><br><span class="line"><span class="built_in">setattr</span>(langs,<span class="string">&quot;name&quot;</span>,<span class="string">&quot;Python&quot;</span>)</span><br><span class="line"><span class="built_in">setattr</span>(langs,<span class="string">&quot;say&quot;</span>, say)</span><br><span class="line"></span><br><span class="line">print(langs.name)</span><br><span class="line">langs.say()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"><span class="comment"># Python</span></span><br><span class="line"><span class="comment"># I am learning Python.</span></span><br></pre></td></tr></table></figure>

<p>可以看到，虽然 <code>Language</code> 为空类，但通过 setattr() 函数，我们为 langs 对象动态添加了一个 <code>name</code> 属性和一个 <code>say()</code> 方法。</p>
<hr>
<h4 id="issubclass-amp-amp-isinstance"><a href="#issubclass-amp-amp-isinstance" class="headerlink" title="issubclass &amp;&amp; isinstance"></a>issubclass &amp;&amp; isinstance</h4><p>Python 中提供了如下两个函数来进行类型检查：</p>
<ul>
<li>issubclass(cls, class_or_tuple)：检查 cls 是否为后一个类或元组包含的多个类中任意类的子类；</li>
<li>isinstance(obj, class_or_tuple)：检查 obj 是否为后一个类或元组包含的多个类中任意类的对象。</li>
</ul>
<p>通过使用上面两个函数，程序可以方便地先执行检查，然后才调用方法，这样可以保证程序不会出现意外情况。</p>
<p>类型检查实例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 定义一个字符串</span></span><br><span class="line">hello = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">print(<span class="string">&#x27;[&quot;Hello&quot; 是否是 str 类的实例?] --&gt;&#x27;</span>, <span class="built_in">isinstance</span>(hello, <span class="built_in">str</span>))</span><br><span class="line">print(<span class="string">&#x27;[&quot;Hello&quot; 是否是 object 类的实例?] --&gt;&#x27;</span>, <span class="built_in">isinstance</span>(hello, <span class="built_in">object</span>))</span><br><span class="line">print(<span class="string">&#x27;[ str 是否是 object 类的子类?] --&gt;&#x27;</span>, <span class="built_in">issubclass</span>(<span class="built_in">str</span>, <span class="built_in">object</span>))</span><br><span class="line">print(<span class="string">&#x27;[&quot;Hello&quot; 是否是 tuple 类的实例?] --&gt;&#x27;</span>, <span class="built_in">isinstance</span>(hello, <span class="built_in">tuple</span>))</span><br><span class="line">print(<span class="string">&#x27;[ str 是否是 tuple 类的子类?] --&gt;&#x27;</span>, <span class="built_in">issubclass</span>(<span class="built_in">str</span>, <span class="built_in">tuple</span>), <span class="string">&#x27;\n&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个列表</span></span><br><span class="line">my_list = [<span class="number">2</span>, <span class="number">4</span>]</span><br><span class="line">print(<span class="string">&#x27;&#123; [2, 4] 是否是 list 类的实例?&#125; --&gt;&#x27;</span>, <span class="built_in">isinstance</span>(my_list, <span class="built_in">list</span>))</span><br><span class="line">print(<span class="string">&#x27;&#123; [2, 4] 是否是 object 类及其子类的实例?&#125; --&gt;&#x27;</span>, <span class="built_in">isinstance</span>(my_list, <span class="built_in">object</span>))</span><br><span class="line">print(<span class="string">&#x27;&#123; list 是否是 object 类的子类?&#125; --&gt;&#x27;</span>, <span class="built_in">issubclass</span>(<span class="built_in">list</span>, <span class="built_in">object</span>))</span><br><span class="line">print(<span class="string">&#x27;&#123; [2, 4] 是否是 tuple 类及其子类的实例?&#125; --&gt;&#x27;</span>, <span class="built_in">isinstance</span>([<span class="number">2</span>, <span class="number">4</span>], <span class="built_in">tuple</span>))</span><br><span class="line">print(<span class="string">&#x27;&#123; list 是否是 tuple 类的子类?&#125; --&gt;&#x27;</span>, <span class="built_in">issubclass</span>(<span class="built_in">list</span>, <span class="built_in">tuple</span>))</span><br></pre></td></tr></table></figure>

<p>通过上面程序可以看出，<code>issubclass()</code> 和 <code>isinstance()</code> 两个函数的用法差不多，区别只是 issubclass() 的第一个参数是类名，而 isinstance() 的第一个参数是变量，这也与两个函数的意义对应：issubclass 用于判断是否为子类，而 isinstance() 用于判断是否为该类或子类的实例。</p>
<p><strong>[1] &gt;&gt;&gt;&gt; 元组参数</strong></p>
<p>issubclass() 和 isinstance() 两个函数的第二个参数都可使用元组。</p>
<p>实例演示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">data = (<span class="number">20</span>, <span class="string">&#x27;fkit&#x27;</span>)</span><br><span class="line">print(<span class="string">&#x27;[ data 是否为列表或元组? ] -&gt;&#x27;</span>, <span class="built_in">isinstance</span>(data, (<span class="built_in">list</span>, <span class="built_in">tuple</span>))) <span class="comment"># True</span></span><br><span class="line">print(<span class="string">&#x27;[ str 是否为 list 或 tuple 的 子类? ] -&gt;&#x27;</span>, <span class="built_in">issubclass</span>(<span class="built_in">str</span>, (<span class="built_in">list</span>, <span class="built_in">tuple</span>)))</span><br><span class="line">print(<span class="string">&#x27;[ str 是否为 list 或 tuple 或 object 的子类? ] -&gt;&#x27;</span>, <span class="built_in">issubclass</span>(<span class="built_in">str</span>, (<span class="built_in">list</span>, <span class="built_in">tuple</span>, <span class="built_in">object</span>)))</span><br></pre></td></tr></table></figure>

<p><strong>[2] &gt;&gt;&gt;&gt; <code>__bases__</code> 属性参看直接父类</strong></p>
<p>Python 为所有类都提供了一个 <code>__bases__</code> 属性，通过该属性可以查看该类的所有直接父类，该属性返回所有直接父类组成的元组。</p>
<p>实例演示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>(<span class="params">A, B</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;类 A 的所有父类:&#x27;</span>, A.__bases__)</span><br><span class="line">print(<span class="string">&#x27;类 B 的所有父类:&#x27;</span>, B.__bases__)</span><br><span class="line">print(<span class="string">&#x27;类 C 的所有父类:&#x27;</span>, C.__bases__)</span><br><span class="line"><span class="comment"># 类 A 的所有父类: (&lt;class &#x27;object&#x27;&gt;,)</span></span><br><span class="line"><span class="comment"># 类 B 的所有父类: (&lt;class &#x27;object&#x27;&gt;,)</span></span><br><span class="line"><span class="comment"># 类 C 的所有父类: (&lt;class &#x27;__main__.A&#x27;&gt;, &lt;class &#x27;__main__.B&#x27;&gt;)</span></span><br></pre></td></tr></table></figure>

<p>可以看出，如果在定义类时没有显式指定它的父类，则这些类默认的父类是 object 类。</p>
<p><strong>[3] &gt;&gt;&gt;&gt; <code>__subclasses__()</code> 方法参看直接父类</strong></p>
<p>Python 还为所有类都提供了一个 <code>__subclasses__()</code> 方法，通过该方法可以查看该类的所有直接子类，该方法返回该类的所有子类组成的列表。</p>
<p>实例演示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span>(<span class="params">A, B</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">&#x27;类 A 的所有子类:&#x27;</span>, A.__subclasses__())</span><br><span class="line">print(<span class="string">&#x27;类 B 的所有子类:&#x27;</span>, B.__subclasses__())</span><br><span class="line"><span class="comment"># 类 A 的所有子类: [&lt;class &#x27;__main__.C&#x27;&gt;]</span></span><br><span class="line"><span class="comment"># 类 B 的所有子类: [&lt;class &#x27;__main__.C&#x27;&gt;]</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Method-call"><a href="#Method-call" class="headerlink" title="Method: __call__"></a>Method: <code>__call__</code></h3><p><code>__call__</code> 是 Python 类中一个非常特殊的实例方法。功能类似于在类中重载 <code>()</code> 运算符，使得类实例对象可以像调用普通函数那样，以 <code>对象名()</code> 的形式使用。</p>
<p>举个例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Language</span>:</span></span><br><span class="line">    <span class="comment"># 定义__call__方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">self,name,add</span>):</span></span><br><span class="line">        print(<span class="string">&quot;调用__call__()方法&quot;</span>, name, add)</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">langs = Language()</span><br><span class="line">langs(<span class="string">&quot;Python&quot;</span>, <span class="string">&quot;Python is a OOP Programing.&quot;</span>)</span><br><span class="line"><span class="comment"># 调用__call__()方法 Python Python is a OOP Programing.</span></span><br></pre></td></tr></table></figure>

<p>可以看到，通过在 Language 类中实现 <code>__call__()</code> 方法，使的 langs 实例对象变为了可调用对象。</p>
<blockquote>
<p>Python 中，凡是可以将 <code>()</code> 直接应用到自身并执行，都称为可调用对象。可调用对象包括自定义的函数、Python 内置函数以及本节所讲的类实例对象。</p>
</blockquote>
<p>对于可调用对象，实际上 <code>名称()</code> 可以理解为是 <code>名称.__call__()</code> 的简写。如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">langs.__call__(<span class="string">&quot;Python&quot;</span>, <span class="string">&quot;Python is a OOP Programing.&quot;</span>)</span><br><span class="line"><span class="comment"># 调用__call__()方法 Python Python is a OOP Programing.</span></span><br></pre></td></tr></table></figure>

<p>再来看一个自定义函数的例子，例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">say</span>():</span></span><br><span class="line">    print(<span class="string">&quot;Python is a OOP Programing.&quot;</span>)</span><br><span class="line"></span><br><span class="line">say()</span><br><span class="line">say.__call__()</span><br><span class="line"><span class="comment"># Python is a OOP Programing.</span></span><br><span class="line"><span class="comment"># Python is a OOP Programing.</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>不仅如此，类中的实例方法也有以上 2 种调用方式，这里不再举例，有兴趣的读者可自行编写代码尝试。</p>
</blockquote>
<hr>
<p><strong>用 <code>__call__()</code> 弥补 <code>hasattr()</code> 函数的短板 &gt;&gt;&gt;&gt;</strong></p>
<p>前面我们提到，hasattr() 函数查找类的实例对象中是否包含指定名称的属性或者方法，但该函数有一个缺陷，即它无法判断该指定的名称，到底是类属性还是类方法。</p>
<p>要解决这个问题，我们可以借助可调用对象的概念。要知道，类实例对象包含的方法，其实也属于可调用对象，但类属性却不是。举个例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CLanguage</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span> (<span class="params">self</span>):</span></span><br><span class="line">        self.name = <span class="string">&quot;Python&quot;</span></span><br><span class="line">        self.add = <span class="string">&quot;Python is a OOP Programing.&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">say</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;I am learning Python.&quot;</span>)</span><br><span class="line"></span><br><span class="line">clangs = CLanguage()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="built_in">hasattr</span>(clangs,<span class="string">&quot;name&quot;</span>):</span><br><span class="line">    print(<span class="built_in">hasattr</span>(clangs.name,<span class="string">&quot;__call__&quot;</span>))</span><br><span class="line"><span class="keyword">if</span> <span class="built_in">hasattr</span>(clangs,<span class="string">&quot;say&quot;</span>):</span><br><span class="line">    print(<span class="built_in">hasattr</span>(clangs.say,<span class="string">&quot;__call__&quot;</span>))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"><span class="comment"># False</span></span><br><span class="line"><span class="comment"># True</span></span><br></pre></td></tr></table></figure>

<p>可以看到，由于 <code>name</code> 是类属性，它没有以 <code>__call__</code> 为名的 <code>__call__()</code> 方法；而 <code>say</code> 是类方法，它是可调用对象，因此它有 <code>__call__()</code> 方法。</p>
<hr>
<h2 id="Python-中的运算符重载"><a href="#Python-中的运算符重载" class="headerlink" title="Python 中的运算符重载"></a>Python 中的运算符重载</h2><p>前面我们学习了各种序列类型，每个类型都有其独特的操作方法。例如列表类型支持直接做加法操作实现添加元素的功能，字符串类型支持直接做加法实现字符串的拼接功能。</p>
<p>也就是说，同样的运算符对于不同序列类型的意义是不一样的，这是怎么做到的呢？</p>
<p>事实上，每种序列类型都是 Python 的一个类，例如列表是 <code>list</code> 类，字典是 <code>dict</code> 类等，这些序列类的内部使用了一个叫作 <strong>重载运算符</strong> 的技术来实现不同运算符所对应的操作。</p>
<p>所谓重载运算符，是指通过重写 Python 内置运算符对应的方法来实现的。这样当类对象在进行运算符操作时，系统就会调用类中相应重写方法来处理。这些方法都是以双下划线开头和结尾的，类似于 <code>__X__</code> 的形式。</p>
<p>那么，Python 类支持对哪些内置方法进行重载呢？如下表列出来常用的可重载的运算符，以及各自的含义：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>重载运算符</td>
<td>含义</td>
</tr>
<tr>
<td><code>__new__</code></td>
<td>创建类，在 <code>__init__</code> 之前创建对象</td>
</tr>
<tr>
<td><code>__init__</code></td>
<td>类的构造函数，其功能是创建类对象时做初始化工作。</td>
</tr>
<tr>
<td><code>__del__</code></td>
<td>析构函数，其功能是销毁对象时进行回收资源的操作</td>
</tr>
<tr>
<td><code>__add__</code></td>
<td>加法运算符 +，当类对象 X 做例如 X+Y 或者 X+=Y 等操作，内部会调用此方法。但如果类中对 <code>__iadd__</code> 方法进行了重载，则类对象 X 在做 X+=Y 类似操作时，会优先选择调用 <code>__iadd__</code> 方法。</td>
</tr>
<tr>
<td><code>__radd__</code></td>
<td>当类对象 X 做类似 Y+X 的运算时，会调用此方法。</td>
</tr>
<tr>
<td><code>__iadd__</code></td>
<td>重载 += 运算符，也就是说，当类对象 X 做类似 X+=Y 的操作时，会调用此方法。</td>
</tr>
<tr>
<td><code>__or__</code></td>
<td>“或”运算符</td>
</tr>
<tr>
<td><code>__repr__，__str__</code></td>
<td>格式转换方法，分别对应函数 repr(X)、str(X)</td>
</tr>
<tr>
<td><code>__call__</code></td>
<td>函数调用，类似于 X(*args, **kwargs) 语句</td>
</tr>
<tr>
<td><code>__getattr__</code></td>
<td>点号运算，用来获取类属性</td>
</tr>
<tr>
<td><code>__setattr__</code></td>
<td>属性赋值语句，类似于 X.any=value</td>
</tr>
<tr>
<td><code>__delattr__</code></td>
<td>删除属性，类似于 del X.any</td>
</tr>
<tr>
<td><code>__getattribute__</code></td>
<td>获取属性，类似于 X.any</td>
</tr>
<tr>
<td><code>__getitem__</code></td>
<td>索引运算，类似于 X[key]，X[i:j]</td>
</tr>
<tr>
<td><code>__setitem__</code></td>
<td>索引赋值语句，类似于 X[key], X[i:j]=sequence</td>
</tr>
<tr>
<td><code>__delitem__ </code></td>
<td>索引和分片删除</td>
</tr>
<tr>
<td><code>__get__, __set__, __delete__</code></td>
<td>描述符属性，类似于 X.attr，X.attr=value，del X.attr</td>
</tr>
<tr>
<td><code>__len__ </code></td>
<td>计算长度，类似于 len(X)</td>
</tr>
<tr>
<td><code>__lt__，__gt__，__le__，__ge__，__eq__，__ne__ </code></td>
<td>比较，分别对应于 &lt;、&gt;、&lt;=、&gt;=、=、!= 运算符。</td>
</tr>
<tr>
<td><code>__iter__，__next__</code></td>
<td>迭代环境下，生成迭代器与取下一条，类似于 I=iter(X) 和 next()</td>
</tr>
<tr>
<td><code>__contains__</code></td>
<td>成员关系测试，类似于 item in X</td>
</tr>
<tr>
<td><code>__index__ </code></td>
<td>整数值，类似于 hex(X)，bin(X)，oct(X)</td>
</tr>
<tr>
<td><code>__enter__，__exit__</code></td>
<td>在对类对象执行类似 with obj as var 的操作之前，会先调用 <code>__enter__</code> 方法，其结果会传给 var；在最终结束该操作之前，会调用 <code>__exit__</code> 方法（常用于做一些清理、扫尾的工作）</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>实例演示：</p>
<p><strong>[1] &gt;&gt;&gt;&gt; 构造函数和析构函数：<code>__init__</code> 和 <code>__del__</code> 重载</strong></p>
<p>主要作用是进行对象的创建和回收，当实例创建时，就会调用 <code>__init__</code> 构造方法。当实例对象被收回时，析构函数 <code>__del__</code> 会自动执行。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Human</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        self.name = name</span><br><span class="line">        print(<span class="string">&quot;__init__&quot;</span>, self.name)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__del__</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;__del__&quot;</span>)</span><br><span class="line"></span><br><span class="line">test = Human(<span class="string">&quot;zhang_san&quot;</span>)</span><br><span class="line">test = <span class="string">&quot;del&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>[2] &gt;&gt;&gt;&gt; 加减运算： <code>__add__</code> 和 <code>__sub__</code> 重载</strong></p>
<p> 重载这两个方法就可以在普通的对象上添加＋－运算符操作。下面的代码演示了如何使用 <code>＋ &amp;&amp; －</code> 运算符:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Computer</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        self.value = value</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__add__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.value + other</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__sub__</span>(<span class="params">self, other</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self.value - other</span><br><span class="line"></span><br><span class="line">test = Computer(<span class="number">10</span>)</span><br><span class="line">print(test + <span class="number">2</span>)</span><br><span class="line">print(test - <span class="number">5</span>)</span><br></pre></td></tr></table></figure>

<p>如果将代码中的 <code>__sub__</code> 方法去掉，再调用减号运算符就会出错。</p>
<p><strong>[3] &gt;&gt;&gt;&gt; 对象的字符串表达形式： <code>__repr__</code> 和 <code>__str__</code> 重载</strong></p>
<p>都是用来表示对象的字符串表达形式：</p>
<ul>
<li>print()、str() 方法会调用到 <code>__str__</code> 方法</li>
<li>print()、str() 和 repr() 方法会调用 <code>__repr__</code> 方法。</li>
</ul>
<p>从下面的例子可以看出，当两个方法同时定义时，Python 会优先搜索并调用 <code>__str__</code> 方法。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Str</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__str__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;__str__ called&quot;</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;__repr__ called&quot;</span></span><br><span class="line"></span><br><span class="line">str_test = Str()</span><br><span class="line">print(str_test)</span><br><span class="line"><span class="comment"># __str__ called</span></span><br><span class="line"></span><br><span class="line">print(<span class="built_in">repr</span>(str_test))</span><br><span class="line"><span class="comment"># __repr__ called</span></span><br><span class="line">print(<span class="built_in">str</span>(str_test))</span><br><span class="line"><span class="comment"># __str__ called</span></span><br></pre></td></tr></table></figure>

<p><strong>[4] &gt;&gt;&gt;&gt; 索引取值和赋值： <code>__getitem__</code> 和 <code>__setitem__</code> 重载</strong></p>
<p>通过实现这两个方法，可以通过诸如 <code>X[i]</code> 的形式对对象进行取值和赋值，还可以对对象使用切片操作。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Indexer</span>:</span></span><br><span class="line">    data = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span>(<span class="params">self, index</span>):</span></span><br><span class="line">        <span class="keyword">return</span> Indexer.data[index]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setitem__</span>(<span class="params">self, index, value</span>):</span></span><br><span class="line">        Indexer.data[index] = value</span><br><span class="line">        print(Indexer.data)</span><br><span class="line"></span><br><span class="line">test = Indexer()</span><br><span class="line">print(test[<span class="number">1</span>])</span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line">print(test[<span class="number">0</span>:<span class="number">3</span>])</span><br><span class="line"><span class="comment"># [1, 2, 3]</span></span><br><span class="line"></span><br><span class="line">test[<span class="number">3</span>] = <span class="number">6</span></span><br><span class="line"><span class="comment"># [1, 2, 3, 6, 5]</span></span><br></pre></td></tr></table></figure>

<p><strong>[5] &gt;&gt;&gt;&gt; 设置和访问属性： <code>__getattr__</code> 和 <code>__setattr__</code> 重载</strong></p>
<p>我们可以通过重载 <code>__getattr__</code> 和 <code>__setattr__</code> 来拦截对对象成员的访问。</p>
<p><code>__getattr__</code> 在访问对象中不存在的成员时会自动调用。<code>__setattr__</code> 方法用于在初始化对象成员的时候调用，即在设置 <code>__dict__</code> 的 <code>item</code> 时就会调用 <code>__setattr__</code> 方法。具体例子如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, ax, bx</span>):</span></span><br><span class="line">        self.ax = ax</span><br><span class="line">        self.bx = bx</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(self.__dict__)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span>(<span class="params">self, name</span>):</span></span><br><span class="line">        <span class="keyword">if</span> name <span class="keyword">in</span> self.__dict__.keys():</span><br><span class="line">            <span class="keyword">return</span> self.__dict__[name]</span><br><span class="line">        print(<span class="string">&quot;__getattr__ called&quot;</span>)</span><br><span class="line">            </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setattr__</span>(<span class="params">self, name, value</span>):</span></span><br><span class="line">        print(<span class="string">&quot;__setattr__ called&quot;</span>)</span><br><span class="line">        self.__dict__[name] = value</span><br><span class="line">        </span><br><span class="line">test = Test(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">test.foo()</span><br><span class="line"><span class="comment"># __setattr__ called</span></span><br><span class="line"><span class="comment"># __setattr__ called</span></span><br><span class="line"><span class="comment"># &#123;&#x27;ax&#x27;: 1, &#x27;bx&#x27;: 2&#125;</span></span><br><span class="line"></span><br><span class="line">print(test.c)</span><br><span class="line"><span class="comment"># __getattr__ called</span></span><br><span class="line"><span class="comment"># None</span></span><br><span class="line"></span><br><span class="line">test.ax = <span class="number">4</span></span><br><span class="line">test.foo()</span><br><span class="line"><span class="comment"># __setattr__ called</span></span><br><span class="line"><span class="comment"># &#123;&#x27;ax&#x27;: 4, &#x27;bx&#x27;: 2&#125;</span></span><br></pre></td></tr></table></figure>

<p>从结果可以看出，访问不存在的实例变量 c 时会调用 <code>__getattr__</code> 方法；当 <code>__init__</code> 被调用的时候，赋值运算也会调用 <code>__setattr__</code> 方法。</p>
<p><strong>[6] &gt;&gt;&gt;&gt; 迭代器对象: <code>__iter__</code> 和 <code>__next__</code> 重载</strong></p>
<p>前面我们知道，Python 中的迭代，可以直接通过重载 <code>__getitem__</code> 方法来实现，看下面的例子:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Indexer</span>:</span></span><br><span class="line">    data = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span>(<span class="params">self, index</span>):</span></span><br><span class="line">        <span class="keyword">return</span> Indexer.data[index]</span><br><span class="line"></span><br><span class="line">test = Indexer()</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> test:</span><br><span class="line">    print(item)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line"><span class="comment"># 4</span></span><br><span class="line"><span class="comment"># 5</span></span><br></pre></td></tr></table></figure>

<p>通过上面的方法是可以实现迭代，但并不是最好的方式。</p>
<p>事实上，Python 中的迭代操作会优先尝试调用 <code>__iter__</code> 方法，再尝试 <code>__getitem__</code>。迭代环境（for in）是通过 <code>iter()</code> 去尝试寻找 <code>__iter__</code> 方法来实现，而这种方法返回一个迭代器对象。如果 <code>__iter__</code> 方法已经提供，Python 会重复调用迭代器对象的 <code>next()</code> 方法，直到发生 <code>StopIteration</code> 异常；如果没有找到 <code>__iter__</code>，Python 才会尝试使用 <code>__getitem__</code> 机制。下面看一下迭代器的例子:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Next</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, data=<span class="number">1</span></span>):</span></span><br><span class="line">        self.data = data</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;__iter__ called&quot;</span>)</span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;__next__ called&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> self.data &gt;<span class="number">5</span>:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            self.data += <span class="number">1</span></span><br><span class="line">            <span class="keyword">return</span> self.data</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> inx <span class="keyword">in</span> Next(<span class="number">3</span>):</span><br><span class="line">    print(inx)</span><br><span class="line">print(<span class="string">&quot;---------&quot;</span>)</span><br><span class="line"><span class="comment"># __iter__ called</span></span><br><span class="line"><span class="comment"># __next__ called</span></span><br><span class="line"><span class="comment"># 4</span></span><br><span class="line"><span class="comment"># __next__ called</span></span><br><span class="line"><span class="comment"># 5</span></span><br><span class="line"><span class="comment"># __next__ called</span></span><br><span class="line"><span class="comment"># 6</span></span><br><span class="line"><span class="comment"># __next__ called</span></span><br><span class="line"><span class="comment"># ---------</span></span><br><span class="line"></span><br><span class="line">n = Next(<span class="number">3</span>)</span><br><span class="line">i = <span class="built_in">iter</span>(n)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        print(<span class="built_in">next</span>(i))</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># __iter__ called</span></span><br><span class="line"><span class="comment"># __next__ called</span></span><br><span class="line"><span class="comment"># 4</span></span><br><span class="line"><span class="comment"># __next__ called</span></span><br><span class="line"><span class="comment"># 5</span></span><br><span class="line"><span class="comment"># __next__ called</span></span><br><span class="line"><span class="comment"># 6</span></span><br><span class="line"><span class="comment"># __next__ called </span></span><br></pre></td></tr></table></figure>

<p>可见实现了 <code>__iter__</code> 和 <code>__next__</code> 方法后，可以通过 <code>for in</code> 的方式迭代遍历对象，也可以通过 <code>iter()</code> 和 <code>next()</code> 方法迭代遍历对象。</p>
<hr>
<p><strong>[7] &gt;&gt;&gt;&gt; 自定义序列示例</strong></p>
<p>基于前面介绍的方法重载，我们来实现一个自定义的序列类。</p>
<p>下面列出了和自定义序列类有关的几个特殊方法：</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td><code>__len__(self)</code></td>
<td>返回序列类中存储元素的个数。</td>
</tr>
<tr>
<td><code>__contains__(self, value)    </code></td>
<td>判断当前序列中是否包含 value 这个指定元素。</td>
</tr>
<tr>
<td><code>__getitem__(self, key)</code></td>
<td>通过指定的 key（键），返回对应的 value（值）。</td>
</tr>
<tr>
<td><code>__setitem__(self, key, value)</code></td>
<td>修改指定 key（键）对应的 value（值）。</td>
</tr>
<tr>
<td><code>__delitem__(self, key)</code></td>
<td>删除指定键值对。</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<p><strong>重写原则 &gt;&gt;&gt;&gt;</strong></p>
<p>1）在上表中的这些特殊方法进行重写时，在实现其基础功能的基础上，还可以根据实际情况，对各个方法的具体实现进行适当调整。</p>
<p>以 <code>__setitem__()</code> 方法为例，当在序列中未找到指定 <code>key</code> 的情况下，该方法可以报错，当然也可以将此键值对添加到当前序列中。</p>
<p>2）在实现自定义序列类时，并不是必须重写表中全部的特殊方法。</p>
<p>例如如果该自定义序列是一个不可变序列（即序列中的元素不能做修改），则无需重写 <code>__setitem__()</code> 和 <code>__delitem__()</code> 方法；反之，如果该自定义序列是一个可变序列，可以重写以上五个特殊方法。</p>
<p>下面实现一个比较简单的序列类（字典类），其特点是只能存储 <code>int</code> 类型的元素：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntDict</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># 定义用于存储数据的字典</span></span><br><span class="line">        self.__data = &#123;&#125;</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(<span class="built_in">list</span>(self.__data.values()))</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span>(<span class="params">self, key</span>):</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self.__data:</span><br><span class="line">            <span class="keyword">return</span> self.__data[key]</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setitem__</span>(<span class="params">self, key, value</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(value, <span class="built_in">int</span>):</span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="string">&quot;Not Int Type&quot;</span>)</span><br><span class="line">        self.__data[key] = value</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__delitem__</span>(<span class="params">self, key</span>):</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self.__data: <span class="keyword">del</span> self.__data[key]</span><br><span class="line"></span><br><span class="line">dic = IntDict()</span><br><span class="line"><span class="comment"># 输出序列中元素的个数，调用 __len__() 方法</span></span><br><span class="line">print(<span class="built_in">len</span>(dic))</span><br><span class="line"></span><br><span class="line"><span class="comment"># 向序列中添加元素，调用 __setitem__() 方法</span></span><br><span class="line">dic[<span class="string">&#x27;a&#x27;</span>] = <span class="number">1</span></span><br><span class="line">dic[<span class="string">&#x27;b&#x27;</span>] = <span class="number">2</span></span><br><span class="line">print(<span class="built_in">len</span>(dic))</span><br><span class="line"></span><br><span class="line">dic[<span class="string">&#x27;a&#x27;</span>] = <span class="number">3</span></span><br><span class="line">dic[<span class="string">&#x27;c&#x27;</span>] = <span class="number">4</span></span><br><span class="line">print(dic[<span class="string">&#x27;a&#x27;</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除指定元素，调用 __delitem__() 方法</span></span><br><span class="line"><span class="keyword">del</span> dic[<span class="string">&#x27;a&#x27;</span>]</span><br><span class="line">print(dic[<span class="string">&#x27;a&#x27;</span>])</span><br><span class="line">print(<span class="built_in">len</span>(dic))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"><span class="comment"># 0</span></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line"><span class="comment"># None</span></span><br><span class="line"><span class="comment"># 2</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Python-中的迭代器"><a href="#Python-中的迭代器" class="headerlink" title="Python 中的迭代器"></a>Python 中的迭代器</h2><p>我们已经知道，字符串（str）、列表（list）、元组（tuple）、字典（dict）、集合（set）等序列容器有一个共同的特性：它们都支持使用 <code>for in</code> 循环遍历存储的元素。</p>
<h3 id="可迭代对象（Iterable）"><a href="#可迭代对象（Iterable）" class="headerlink" title="可迭代对象（Iterable）"></a>可迭代对象（Iterable）</h3><p>事实上，像字符串（str）、列表（list）、元组（tuple）、字典（dict）、集合（set）这些可以直接作用于 <code>for in</code> 循环的容器对象，都可以统称为可迭代对象（Iterable object）。</p>
<p>关于 Python 中的可迭代对象更多说明请参见：<a href="https://www.orangeshare.cn/2018/01/07/python-zhong-de-ke-die-dai-dui-xiang-iterable/">Python 中的可迭代对象（Iterable）</a>。</p>
<p>我们可以通过 collections 模块中的 Iterable 类型来判断一个对象是否是可迭代对象，具体判断方法如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">from</span> collections.abc <span class="keyword">import</span> Iterable</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>([], Iterable)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(&#123;&#125;, Iterable)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(<span class="string">&#x27;abc&#x27;</span>, Iterable)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>((x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)), Iterable)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(<span class="number">100</span>, Iterable)</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>

<p>那么，可迭代对象（Iterable）和迭代器（Iterator）是否是一回事儿？答案肯定是不是的，不然废话这么多干嘛？！！</p>
<hr>
<h3 id="何为迭代器（Iterator）"><a href="#何为迭代器（Iterator）" class="headerlink" title="何为迭代器（Iterator）"></a>何为迭代器（Iterator）</h3><p>从字面来理解，迭代器指的是：支持迭代的容器。这里的容器可以是列表、元组等 Python 内置的基础容器，也可以是用户自定义的容器类对象，只要该容器支持迭代即可。</p>
<p>你可能会问，既然都是支持迭代的容器，那么迭代器（Iterator）和可迭代对象（Iterable）的差别在哪里？？？</p>
<p><strong>[1] &gt;&gt;&gt;&gt; 迭代器特性</strong></p>
<p>更确切的说，<strong>迭代器（Iterator）</strong> 具有如下特性：</p>
<ul>
<li>支持迭代的（for in 遍历），可以记住遍历位置的容器；</li>
<li>迭代器对象从容器的第一个元素开始访问，直到所有的元素被访问完结束，并且迭代器访问只能往前无法后退；</li>
<li>迭代器具有两个基本的方法：<code>iter()</code> &amp;&amp; <code>next()</code>；</li>
<li>迭代器都是可迭代对象。</li>
</ul>
<p>上述列出的这些特性，都可以在下文给出的迭代器中表现出来。</p>
<p><strong>[2] &gt;&gt;&gt;&gt; 判断对象是否属于迭代器</strong></p>
<p>那么，如何判断一个对象是否属于 <code>Iterator</code>呢？可以借助 connections 模块中的 Iterator：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections.abc <span class="keyword">import</span> Iterator</span><br><span class="line">print(<span class="built_in">isinstance</span>((x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">10</span>)), Iterator))</span><br><span class="line">print(<span class="built_in">isinstance</span>([], Iterator))</span><br><span class="line">print(<span class="built_in">isinstance</span>(&#123;&#125;, Iterator))</span><br><span class="line">print(<span class="built_in">isinstance</span>(<span class="string">&#x27;abc&#x27;</span>, Iterator))</span><br><span class="line"></span><br><span class="line"><span class="comment"># True</span></span><br><span class="line"><span class="comment"># False</span></span><br><span class="line"><span class="comment"># False</span></span><br><span class="line"><span class="comment"># False</span></span><br></pre></td></tr></table></figure>

<p>可以看到，列表、字典、以及字符串等确实不是迭代器。并且 <code>list</code>、<code>dict</code>、<code>str</code> 虽然是 <code>Iterable</code>，却不是 <code>Iterator</code>（不存在 <code>next()</code> 函数）。</p>
<p><strong>[3] &gt;&gt;&gt;&gt; next &amp;&amp; iter 方法说明</strong></p>
<p><strong>1）–&gt;</strong> iter()</p>
<p><code>iter()</code> 函数，可以将 <code>list</code>、<code>dict</code>、<code>str </code> 等 <code>Iterable</code> 对象变为 <code>Iterator</code>，从而创建迭代器：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(<span class="built_in">iter</span>([]), Iterator)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(<span class="built_in">iter</span>(<span class="string">&#x27;abc&#x27;</span>), Iterator)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">isinstance</span>(<span class="built_in">iter</span>(&#123;&#125;), Iterator)</span><br><span class="line"><span class="literal">True</span></span><br></pre></td></tr></table></figure>

<p><strong>2）–&gt;</strong> next()</p>
<p>迭代器容器对象可以被 <code>next()</code> 函数调用，并不断返回下一个元素值。元素访问完后，继续调用 <code>next()</code> 函数会产生 <code>StopIteration</code> Error。</p>
<p>代码演示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">it = <span class="built_in">iter</span>(<span class="built_in">list</span>)    <span class="comment"># 创建迭代器对象</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="built_in">print</span> (<span class="built_in">next</span>(it))</span><br><span class="line">    <span class="keyword">except</span> StopIteration:</span><br><span class="line">        print(<span class="string">&quot;Iterator Occur StopIteration Error&quot;</span>)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历后无法重新遍历出元素（只能向前访问）</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> it:</span><br><span class="line">    print(item)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 这里会报错：StopIteration，表示容器中元素已经遍历完了</span></span><br><span class="line">print(<span class="built_in">next</span>(it))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line"><span class="comment"># 4</span></span><br><span class="line"><span class="comment"># Iterator Occur StopIteration Error</span></span><br></pre></td></tr></table></figure>

<p><strong>[4] &gt;&gt;&gt;&gt; 迭代器对象打印</strong></p>
<p>注意，直接打印迭代器对象是无法查看迭代器容器中元素值的，你需要根据容器数据结构使用 Python 内置的 list() &amp;&amp; tuple() &amp;&amp; dict() 等来将其转化成可打印的形式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span>=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>]</span><br><span class="line">it = <span class="built_in">iter</span>(<span class="built_in">list</span>)    <span class="comment"># 创建迭代器对象</span></span><br><span class="line"></span><br><span class="line">print(it)</span><br><span class="line">print(<span class="built_in">tuple</span>(it))</span><br><span class="line"></span><br><span class="line"><span class="comment"># &lt;list_iterator object at 0x0000017949EA36D8&gt;</span></span><br><span class="line"><span class="comment"># (1, 2, 3, 4)</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="如何定义迭代器容器"><a href="#如何定义迭代器容器" class="headerlink" title="如何定义迭代器容器"></a>如何定义迭代器容器</h3><p>这里给出两种迭代器的实现思路：</p>
<ol>
<li>运算符重载方法：通过重写类的 <code>__next__() &amp;&amp; __iter__()</code> 方法实现自定义迭代器类；</li>
<li>内置函数方法：通过内置的 iter() 迭代器函数实现迭代器。</li>
</ol>
<p><strong>[1] &gt;&gt;&gt;&gt; 自定义迭代器类</strong></p>
<p>如果要自定义实现一个迭代器，则类中必须实现如下两个方法：</p>
<ul>
<li><code>__next__(self)</code>：返回容器的下一个元素；</li>
<li><code>__iter__(self)</code>：该方法返回一个迭代器（iterator）对象，该对象实现了 <code>__next__()</code> 方法并通过 <code>StopIteration</code> 异常来标识迭代的完成。</li>
</ul>
<blockquote>
<p>事实上，在运算符重载中已经实现过一个简单的迭代器了，推荐返回重新认识一下。</p>
</blockquote>
<p>例如，下面程序自定义了一个简易的列表容器迭代器，支持迭代访问（对照迭代器特性进行学习）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">listDemo</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.__date=[] <span class="comment"># 用于存储迭代器容器元素</span></span><br><span class="line">        self.__step = <span class="number">0</span> <span class="comment"># 记录迭代器遍历位置，用于 StopIteration 异常判断 </span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.__step &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br><span class="line">        self.__step -= <span class="number">1</span></span><br><span class="line">        <span class="comment"># 返回下一个元素</span></span><br><span class="line">        <span class="keyword">return</span> self.__date[self.__step]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># 实例对象本身就是迭代器对象，因此直接返回 self 即可</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 用于向容器中添加元素</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setitem__</span>(<span class="params">self,key,value</span>):</span></span><br><span class="line">        self.__date.insert(key,value)</span><br><span class="line">        self.__step += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">mylist = listDemo()</span><br><span class="line">mylist[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">mylist[<span class="number">1</span>] = <span class="number">2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断是否为迭代器：</span></span><br><span class="line"><span class="keyword">from</span> collections.abc <span class="keyword">import</span> Iterator</span><br><span class="line">print(<span class="built_in">isinstance</span>(mylist, Iterator))</span><br><span class="line"><span class="comment"># True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> mylist:</span><br><span class="line">    <span class="built_in">print</span> (i)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"><span class="comment"># __next__ called</span></span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line"><span class="comment"># __next__ called</span></span><br><span class="line"><span class="comment"># __next__ called</span></span><br></pre></td></tr></table></figure>

<p><strong>StopIteration 说明 &gt;&gt;&gt;&gt;</strong></p>
<p>迭代环境下，StopIteration 异常用于标识迭代的完成，防止出现无限循环的情况。</p>
<p>上面程序遍历（for in）时，会自动调用 <code>__next__()</code> 方法来返回迭代器容器中的下个元素直至发生 StopIteration，故需要在 <code>__next__()</code> 方法中设置在完成指定循环条件后触发 StopIteration 异常来结束迭代，这是必要的。</p>
<hr>
<p><strong>[2] &gt;&gt;&gt;&gt; 内置 iter() 迭代器函数</strong></p>
<p>Python 内置的 <code>iter()</code> 函数可以将对象转化为一个迭代器（返回一个迭代器对象），该函数的语法格式如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">iter</span>(obj[, sentinel])</span><br></pre></td></tr></table></figure>

<p>其中，obj 必须是一个可迭代的容器对象，而 sentinel 作为可选参数，如果使用此参数，要求 obj 必须是一个可调用对象，具体功能后面会讲。</p>
<blockquote>
<p>关于可调用对象，指的是该类的实例对象可以像函数那样，直接以 <code>对象名()</code> 的形式被使用。通过在类中添加 <code>__call__()</code> 方法，就可以将该类的实例对象编程为可调用对象（参见博文第一章节相关内容）。</p>
</blockquote>
<p>iter() 函数的两种使用形式 &gt;&gt;&gt;&gt;</p>
<p><strong>1）–&gt;</strong> iter(obj)</p>
<p>我们常用的是仅有第一个参数的 <code>iter()</code> 函数，即通过传入一个可迭代对象，<code>iter()</code> 函数会返回一个迭代器对象。</p>
<p>你可以通过调用该迭代器中的 <code>__next__()</code> 方法即可实现迭代（或者 for in）。例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">mylist = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将可迭代的列表转换为迭代器</span></span><br><span class="line">myIter = <span class="built_in">iter</span>(mylist)</span><br><span class="line"></span><br><span class="line">print(<span class="built_in">type</span>(mylist))</span><br><span class="line">print(<span class="built_in">type</span>(myIter))</span><br><span class="line"><span class="comment"># &lt;class &#x27;list&#x27;&gt;</span></span><br><span class="line"><span class="comment"># &lt;class &#x27;list_iterator&#x27;&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 依次获取迭代器的下一个元素</span></span><br><span class="line">print(myIter.__next__())</span><br><span class="line">print(myIter.__next__())</span><br><span class="line">print(myIter.__next__())</span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过 for in 进行遍历：</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> <span class="built_in">iter</span>(mylist):</span><br><span class="line">    print(item, end=<span class="string">&#x27;-&gt;&#x27;</span>)</span><br><span class="line"><span class="comment"># 1-&gt;2-&gt;3-&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 迭代器访问结束后，继续访问会产生 StopIteration 异常</span></span><br><span class="line">print(myIter.__next__())</span><br><span class="line"><span class="comment"># Traceback (most recent call last):</span></span><br><span class="line"><span class="comment">#   File &quot;.code.tio&quot;, line 7, in </span></span><br><span class="line"><span class="comment">#     print(item, end=&#x27;-&gt;&#x27;)</span></span><br><span class="line"><span class="comment"># StopIteration</span></span><br></pre></td></tr></table></figure>

<p>可以看到，当迭代完存储的所有元素之后，如果继续迭代，则 <code>__next__()</code> 方法会抛出 <code>StopIteration</code> 异常。</p>
<p>另外，你也可以使用 <code>next()</code> 内置函数来迭代，即 <code>next(myIter)</code>，和 <code>__next__()</code> 方法是完全一样的。</p>
<hr>
<p><strong>2）–&gt;</strong> iter(obj[, sentinel])</p>
<p>如果同时使用 <code>iter()</code> 函数中的两个参数，则要求第一个 obj 参数必须传入可调用对象（可以不支持迭代）。</p>
<p>这样，当使用 <code>iter()</code> 函数返回的迭代器对象调用 <code>__next__()</code> 方法时，它会通过执行 obj() 调用 <code>__call__()</code> 方法来返回元素。</p>
<p>如果此时，<code>__call__()</code> 方法的返回值和第 2 个参数值相同，则输出 <code>StopInteration</code> 异常；反之，则输出 <code>__call__() </code>方法的返回值。</p>
<p>例如，修改 <code>listDemo</code> 类如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">listDemo</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.__date=[]</span><br><span class="line">        self.__step = <span class="number">0</span></span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setitem__</span>(<span class="params">self,key,value</span>):</span></span><br><span class="line">        self.__date.insert(key,value)</span><br><span class="line">        self.__step += <span class="number">1</span></span><br><span class="line">        </span><br><span class="line">    <span class="comment"># 使该类实例对象成为可调用对象</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.__step -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> self.__date[self.__step]</span><br><span class="line">        </span><br><span class="line">mylist = listDemo()</span><br><span class="line">mylist[<span class="number">0</span>]=<span class="number">1</span></span><br><span class="line">mylist[<span class="number">1</span>]=<span class="number">2</span></span><br><span class="line">mylist[<span class="number">2</span>]=<span class="number">3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 mylist 变为迭代器</span></span><br><span class="line">test = <span class="built_in">iter</span>(mylist, <span class="number">4</span>)</span><br><span class="line">print(test)</span><br><span class="line"><span class="comment"># &lt;callable_iterator object at 0x000001F22F8FC860&gt;</span></span><br><span class="line"></span><br><span class="line">print(<span class="built_in">next</span>(test)) <span class="comment"># 实际调用 __call__() 方法</span></span><br><span class="line">print(<span class="built_in">next</span>(test))</span><br><span class="line">print(<span class="built_in">next</span>(test))</span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line"></span><br><span class="line">print(<span class="built_in">next</span>(test))</span><br><span class="line"><span class="comment"># StopIteration Error</span></span><br></pre></td></tr></table></figure>

<hr>
<p><strong>3）–&gt;</strong> iter(obj[, sentinel]) 实用场景</p>
<p>iter(obj[, sentinel]) 形式常用来构建块读取器。</p>
<p>例如，从二进制数据库文件中读取固定宽度的块，直至到达文件的末尾:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> partial</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;mydata.db&#x27;</span>, <span class="string">&#x27;rb&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">for</span> block <span class="keyword">in</span> <span class="built_in">iter</span>(partial(f.read, <span class="number">64</span>), <span class="string">b&#x27;&#x27;</span>):</span><br><span class="line">        process_block(block)</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>[3] &gt;&gt;&gt;&gt; 自定义字典迭代器 Demo</strong></p>
<p>运算符重载小节最后，我们实现了一个自定义字典类序列，该字典是一个可迭代对象，但该字典对象并不支持良好的迭代（死循环），这里我们来将其升级为一个良好的迭代器。</p>
<blockquote>
<p>尽管上面的自定义字典类序列中重写了 <code>__getitem__</code> 方法，但仍然是不支持良好迭代的，你可以尝试下~~~</p>
</blockquote>
<p>这里，基于上述知识，我们来完善一下上一小节中的自定义字典序列：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntDict</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># 定义用于存储数据的字典</span></span><br><span class="line">        self.__data = &#123;&#125;</span><br><span class="line">        self.__step = <span class="number">0</span></span><br><span class="line">        self.__key_record = []</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__len__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(<span class="built_in">list</span>(self.__data.values()))</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__getitem__</span>(<span class="params">self, key</span>):</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self.__data:</span><br><span class="line">            <span class="keyword">return</span> self.__data[key]</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">None</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setitem__</span>(<span class="params">self, key, value</span>):</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> <span class="built_in">isinstance</span>(value, <span class="built_in">int</span>):</span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="string">&quot;Not Int Type&quot;</span>)</span><br><span class="line">        self.__data[key] = value</span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">not</span> <span class="keyword">in</span> self.__key_record:</span><br><span class="line">            self.__key_record.append(key)</span><br><span class="line">            self.__step += <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__delitem__</span>(<span class="params">self, key</span>):</span></span><br><span class="line">        <span class="keyword">if</span> key <span class="keyword">in</span> self.__data: </span><br><span class="line">            <span class="keyword">del</span> self.__data[key]</span><br><span class="line">            <span class="keyword">del</span> self.__key_record[self.__key_record.index(key)]</span><br><span class="line">            self.__step -= <span class="number">1</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">if</span> self.__step &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br><span class="line">        self.__step -= <span class="number">1</span></span><br><span class="line">        <span class="keyword">return</span> (self.__key_record[self.__step], self.__data[self.__key_record[self.__step]])</span><br><span class="line"></span><br><span class="line">dic = IntDict()</span><br><span class="line"><span class="comment"># 输出序列中元素的个数，调用 __len__() 方法</span></span><br><span class="line">print(<span class="built_in">len</span>(dic))</span><br><span class="line"><span class="comment"># 0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断是否为迭代器：</span></span><br><span class="line"><span class="keyword">from</span> collections.abc <span class="keyword">import</span> Iterator</span><br><span class="line">print(<span class="built_in">isinstance</span>(dic, Iterator))</span><br><span class="line"><span class="comment"># True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 向序列中添加元素，调用 __setitem__() 方法</span></span><br><span class="line">dic[<span class="string">&#x27;Google&#x27;</span>] = <span class="number">1</span></span><br><span class="line">dic[<span class="string">&#x27;Edge&#x27;</span>] = <span class="number">2</span></span><br><span class="line">print(<span class="built_in">len</span>(dic))</span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"></span><br><span class="line">dic[<span class="string">&#x27;Firfox&#x27;</span>] = <span class="number">3</span></span><br><span class="line">dic[<span class="string">&#x27;Google&#x27;</span>] = <span class="number">4</span></span><br><span class="line">print(dic[<span class="string">&#x27;Google&#x27;</span>])</span><br><span class="line"><span class="comment"># 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除指定元素，调用 __delitem__() 方法</span></span><br><span class="line"><span class="keyword">del</span> dic[<span class="string">&#x27;Google&#x27;</span>]</span><br><span class="line">print(dic[<span class="string">&#x27;Google&#x27;</span>])</span><br><span class="line">print(<span class="built_in">len</span>(dic))</span><br><span class="line"><span class="comment"># None</span></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 字典遍历，调用 __next__() 方法</span></span><br><span class="line"><span class="keyword">for</span> key,value <span class="keyword">in</span> dic:</span><br><span class="line">    print(key, value)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Firfox 3</span></span><br><span class="line"><span class="comment"># Edge 2</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="enumerate-迭代器"><a href="#enumerate-迭代器" class="headerlink" title="enumerate 迭代器"></a>enumerate 迭代器</h3><p>enumerate 方法可以用来实现下标循环 &gt;&gt;&gt;&gt;</p>
<p>很多情况下，我们想要对 <code>list</code> 或 <code>tuple</code> 实现类似 Java 那样的下标循环怎么办？</p>
<p>Python 中内置的 <code>enumerate</code> 函数可以把一个 list （tuple）变成 <code>index-element</code>（索引-元素）对，这样就可以在<code>for</code>循环中同时迭代索引和元素本身。</p>
<p>先来给出 <code>enumerate</code> 内置函数的语法格式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">enumerate</span>(iterable, start=<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>其中，<code>iterable</code> 表示必须是可迭代的对象，<code>start</code> 表示下标开始的序号，该函数返回一个可迭代的 enumerate 对象（非枚举对象），<code>index-element</code> 以元组形式保存在迭代器中。</p>
<p>来看一个示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">seasons = [<span class="string">&#x27;Spring&#x27;</span>, <span class="string">&#x27;Summer&#x27;</span>, <span class="string">&#x27;Fall&#x27;</span>, <span class="string">&#x27;Winter&#x27;</span>]</span><br><span class="line"></span><br><span class="line">seasons_enum_1 = <span class="built_in">enumerate</span>(seasons)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 判断是否为枚举对象</span></span><br><span class="line"><span class="keyword">from</span> enum <span class="keyword">import</span> Enum</span><br><span class="line"><span class="built_in">type</span>(Enum)</span><br><span class="line">print(<span class="built_in">isinstance</span>(seasons_enum_1, Enum))</span><br><span class="line"><span class="comment"># False</span></span><br><span class="line"><span class="comment"># 判断是否为迭代器：</span></span><br><span class="line"><span class="keyword">from</span> collections.abc <span class="keyword">import</span> Iterator</span><br><span class="line">print(<span class="built_in">isinstance</span>(seasons_enum_1, Iterator))</span><br><span class="line"><span class="comment"># True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> index, elem <span class="keyword">in</span> seasons_enum_1:</span><br><span class="line">    print(index, elem)</span><br><span class="line">print(<span class="string">&quot;-----------------&quot;</span>)</span><br><span class="line">seasons_enum_2 = <span class="built_in">enumerate</span>(seasons, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">for</span> index, elem <span class="keyword">in</span> seasons_enum_2:</span><br><span class="line">    print(index, elem)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"><span class="comment"># &lt;enumerate object at 0x000002B6C69AA438&gt;</span></span><br><span class="line"><span class="comment"># False</span></span><br><span class="line"><span class="comment"># True</span></span><br><span class="line"><span class="comment"># 0 Spring</span></span><br><span class="line"><span class="comment"># 1 Summer</span></span><br><span class="line"><span class="comment"># 2 Fall</span></span><br><span class="line"><span class="comment"># 3 Winter</span></span><br><span class="line"><span class="comment"># -----------------</span></span><br><span class="line"><span class="comment"># 3 Spring</span></span><br><span class="line"><span class="comment"># 4 Summer</span></span><br><span class="line"><span class="comment"># 5 Fall</span></span><br><span class="line"><span class="comment"># 6 Winter</span></span><br></pre></td></tr></table></figure>

<p>你无法直接查看可迭代的 enumerate 枚举对象中的 <code>index-element</code> 信息：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(seasons_enum)</span><br><span class="line">&lt;<span class="built_in">enumerate</span> <span class="built_in">object</span> at <span class="number">0x0000021C934C4CF0</span>&gt;</span><br></pre></td></tr></table></figure>

<p>但我们可以通过使用 Python 内置的 list() &amp;&amp; tuple() &amp;&amp; dict() 来将其转化成可打印的形式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">seasons = [<span class="string">&#x27;Spring&#x27;</span>, <span class="string">&#x27;Summer&#x27;</span>, <span class="string">&#x27;Fall&#x27;</span>, <span class="string">&#x27;Winter&#x27;</span>]</span><br><span class="line"></span><br><span class="line">seasons_list = <span class="built_in">list</span>(<span class="built_in">enumerate</span>(seasons))</span><br><span class="line">print(seasons_list)</span><br><span class="line"><span class="comment"># [(0, &#x27;Spring&#x27;), (1, &#x27;Summer&#x27;), (2, &#x27;Fall&#x27;), (3, &#x27;Winter&#x27;)]</span></span><br><span class="line"></span><br><span class="line">seasons_tup = <span class="built_in">tuple</span>(<span class="built_in">enumerate</span>(seasons))</span><br><span class="line">print(seasons_tup)</span><br><span class="line"><span class="comment"># ((0, &#x27;Spring&#x27;), (1, &#x27;Summer&#x27;), (2, &#x27;Fall&#x27;), (3, &#x27;Winter&#x27;))</span></span><br><span class="line"></span><br><span class="line">seasons_dict = <span class="built_in">dict</span>(<span class="built_in">enumerate</span>(seasons))</span><br><span class="line">print(seasons_dict)</span><br><span class="line"><span class="comment"># &#123;0: &#x27;Spring&#x27;, 1: &#x27;Summer&#x27;, 2: &#x27;Fall&#x27;, 3: &#x27;Winter&#x27;&#125;</span></span><br></pre></td></tr></table></figure>

<p>这样，你就可以以 List &amp;&amp; Tuple &amp;&amp; Dict 的形式进行枚举对象数据的访问了。</p>
<hr>
<h3 id="深入解读迭代器"><a href="#深入解读迭代器" class="headerlink" title="深入解读迭代器"></a>深入解读迭代器</h3><p>我们知道，迭代器的主要功能就是进行容器元素的迭代（遍历），有了上面的知识，我们就可以重新认识一下 for 循环了：</p>
<h4 id="For-循环解读"><a href="#For-循环解读" class="headerlink" title="For 循环解读"></a>For 循环解读</h4><p>事实上，Python 中的迭代操作会优先尝试调用 <code>    __iter__</code> 方法，再尝试 <code>__getitem__</code>。</p>
<p>迭代环境（<code>for ... in ...</code> 或者 <code>next(Iterator)</code>）是通过 iter() 去尝试优先寻找 <code>__iter__</code> 方法来实现，而这种方法返回一个迭代器对象。</p>
<p>如果 <code>__iter__</code> 方法已经提供，Python 会重复调用迭代器对象的 next() 方法，直到发生 <code>StopIteration</code> 异常；如果没有找到 <code>__iter__</code>，Python 才会尝试使用     <code>__getitem__</code> 机制。</p>
<p>示例演示:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">listDemo</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.__date=[] <span class="comment"># 用于存储迭代器容器元素</span></span><br><span class="line">        self.__step = <span class="number">0</span> <span class="comment"># 记录迭代器遍历位置，用于 StopIteration 异常判断 </span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__next__</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;__next__ called&quot;</span>)</span><br><span class="line">        <span class="keyword">if</span> self.__step &lt;= <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">raise</span> StopIteration</span><br><span class="line">        self.__step -= <span class="number">1</span></span><br><span class="line">        <span class="comment"># 返回下一个元素</span></span><br><span class="line">        <span class="keyword">return</span> self.__date[self.__step]</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span>(<span class="params">self</span>):</span></span><br><span class="line">        print(<span class="string">&quot;__iter__ called&quot;</span>)</span><br><span class="line">        <span class="comment"># 实例对象本身就是迭代器对象，因此直接返回 self 即可</span></span><br><span class="line">        <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 用于向容器中添加元素</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__setitem__</span>(<span class="params">self,key,value</span>):</span></span><br><span class="line">        self.__date.insert(key,value)</span><br><span class="line">        self.__step += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">mylist1 = listDemo()</span><br><span class="line">mylist1[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">mylist1[<span class="number">1</span>] = <span class="number">2</span></span><br><span class="line">mylist1[<span class="number">2</span>] = <span class="number">3</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> mylist1:</span><br><span class="line">    print(item)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;----------&quot;</span>)</span><br><span class="line"></span><br><span class="line">mylist2 = listDemo()</span><br><span class="line">mylist2[<span class="number">0</span>] = <span class="number">4</span></span><br><span class="line">mylist2[<span class="number">1</span>] = <span class="number">5</span></span><br><span class="line">mylist2[<span class="number">2</span>] = <span class="number">6</span></span><br><span class="line">iter_list = <span class="built_in">iter</span>(mylist2)</span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        print(<span class="built_in">next</span>(iter_list))</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"><span class="comment"># __iter__ called</span></span><br><span class="line"><span class="comment"># __next__ called</span></span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line"><span class="comment"># __next__ called</span></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"><span class="comment"># __next__ called</span></span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line"><span class="comment"># __next__ called</span></span><br><span class="line"><span class="comment"># ----------</span></span><br><span class="line"><span class="comment"># __iter__ called</span></span><br><span class="line"><span class="comment"># __next__ called</span></span><br><span class="line"><span class="comment"># 6</span></span><br><span class="line"><span class="comment"># __next__ called</span></span><br><span class="line"><span class="comment"># 5</span></span><br><span class="line"><span class="comment"># __next__ called</span></span><br><span class="line"><span class="comment"># 4</span></span><br><span class="line"><span class="comment"># __next__ called</span></span><br></pre></td></tr></table></figure>

<p>可以看到，使用 <code>for ... in ...</code> 循环方式进行遍历和在 <code>while</code> 循环内使用 <code>next(Iterator)</code> 是等价的。</p>
<p>因此，对于迭代器容器中的元素遍历，支持三种方式：</p>
<ol>
<li>for … in …；</li>
<li>while 循环结构内使用 next(Iterator) 或者 <code>Iterator.__next__()</code>，捕获 <code>StopIteration</code> 异常后停止；</li>
<li>借助 Python 内置的 list() &amp;&amp; tuple() &amp;&amp; dict() &amp;&amp; set() 等转化为相应基本数据类型，然后进行遍历。</li>
</ol>
<p>关于 <code>__getitem__</code> 的迭代（循环）样例这里就不重复给出了，你可以参见第一个版本的自定义字典序列 Demo，或者参见运算符重载部分关于迭代器的重载部分。</p>
<hr>
<h4 id="Iterator-数据流"><a href="#Iterator-数据流" class="headerlink" title="Iterator 数据流"></a>Iterator 数据流</h4><p>你可能还对 <code>list</code>、<code>dict</code>、<code>str</code>等序列容器不是 <code>Iterator</code> 感到很困惑。</p>
<p>事实上，Python 的 <code>Iterator</code> 对象表示的是一个数据流，Iterator 对象可以被 <code>next()</code> 函数调用并不断返回下一个数据，直到没有数据时抛出 <code>StopIteration</code> 错误。</p>
<p>这也就意味着，在 <code>Iterator</code> 数据流向前迭代过程中，可以看作是容器内数据流出的过程，表现为当前对象无法再通过迭代方式获取数据了（已经流完了）。</p>
<p><strong>Iterator 数据流 可以看作是惰性的计算序列 &gt;&gt;&gt;&gt;</strong></p>
<p>可以把这个数据流看做是一个有序序列，但我们却不能提前知道序列的长度，只能不断通过 <code>next()</code> 函数实现按需计算下一个数据，所以 <code>Iterator</code> 的计算是惰性的，只有在需要返回下一个数据时它才会计算。</p>
<p><code>Iterator</code> 甚至可以表示一个无限大的数据流，例如全体自然数。而使用 list 是永远不可能存储全体自然数的。</p>
<hr>
<h2 id="Python-中的生成器"><a href="#Python-中的生成器" class="headerlink" title="Python 中的生成器"></a>Python 中的生成器</h2><p>上一小节我们解读了什么是迭代器。事实上，生成器本质上也是迭代器，不过它比较特殊。</p>
<p>那么，相较于一般的迭代器，生成器特殊在哪里？？？</p>
<h3 id="生成器（Generator）特性"><a href="#生成器（Generator）特性" class="headerlink" title="生成器（Generator）特性"></a>生成器（Generator）特性</h3><p>参看前面我们创建的任意一个迭代器容器，你会发现，在使用该容器迭代一组数据时，必须事先将所有数据存储到容器中，才能开始迭代。而生成器（generator）却不同，它可以实现在迭代的同时生成元素（<strong>边迭代边计算元素</strong>）。</p>
<p>也就是说，对于某些特定的可迭代容器（如果其内部的元素是可以用某种算法推算得到的），将其编码成一个生成器对象，该生成器不会一次性生成容器中的所有元素，而是什么时候需要，才什么时候生成。</p>
<p>可能有同学就要问了，这样的机制什么用处呢？？？</p>
<p>想象一个容器内部元素可以用某种算法推算得到的场景 &gt;&gt;&gt;&gt;</p>
<p>例如前面通过列表推导式（解析式）直接创建一个列表，由于内存限制，列表容量肯定是有限的。假设要创建一个包含 10 万个元素的列表，这不仅占用很大的存储空间，如果程序中当前仅仅访问前面部分的元素，那后面绝大多数元素占用的空间都白白浪费了，这时生成器这种边迭代边推算的机制就会非常有用。</p>
<p>退一步来讲，就算容器中元素数量较少时，节省的内存有限，但使用生成器仍可以帮助我们获得一个方便操作的迭代器，这也是有益的。</p>
<p><strong>使用生成器需要注意以下几点 &gt;&gt;&gt;&gt;</strong></p>
<ul>
<li>生成器适用于容器内部元素可以用某种算法推算得到的场景；</li>
<li>更适用于推算算法比较复杂时，用类似推导式（例如列表推导式）的 <code>for</code> 循环无法实现的场景；</li>
<li>生成器是边迭代边计算元素的，元素什么时候需要，什么时候生成，用于节省内存空间；</li>
<li>生成器是一个特殊的迭代器，支持迭代器中的相关使用规则。</li>
</ul>
<hr>
<p>并且，除了具有如上特性，生成器的创建方式也比迭代器简单很多。</p>
<h3 id="生成器创建"><a href="#生成器创建" class="headerlink" title="生成器创建"></a>生成器创建</h3><p>Python 中提供了两种生成器的创建方式：1）带 yield 关键字的生成器函数；2）元组推导式（… for … in …）。</p>
<h4 id="yield-关键字"><a href="#yield-关键字" class="headerlink" title="yield 关键字"></a>yield 关键字</h4><p>使用带 yield 关键字的生成器函数来创建生成器分为以下两步：</p>
<ol>
<li>定义一个以 <strong>yield 关键字标识返回值</strong> 的函数；</li>
<li>调用刚刚创建的函数，即可创建一个生成器。</li>
</ol>
<p>Get Start &gt;&gt;&gt;&gt;</p>
<p>比如，构建一个著名的斐波那契数列（Fibonacci）容器，除第一个和第二个元素外，任意一个数都可由前两个数相加得到。类似于：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">8</span>, <span class="number">13</span>, <span class="number">21</span>, <span class="number">34</span>, ...</span><br></pre></td></tr></table></figure>

<p>斐波拉契数列用列表推导式写不出来（推导算法较复杂），但是，用函数把它打印出来却很容易：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibonc</span>(<span class="params"><span class="built_in">max</span></span>):</span></span><br><span class="line">    idx = <span class="number">0</span></span><br><span class="line">    a, b = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> idx &lt; <span class="built_in">max</span>:</span><br><span class="line">        print(b)</span><br><span class="line">        a, b = (b, a + b)</span><br><span class="line">        idx += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">fibonc(<span class="number">4</span>)</span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"><span class="comment"># 3</span></span><br></pre></td></tr></table></figure>

<p>我们知道，斐波那契数列（Fibonacci）容器构建是符合生成器使用条件的，事实上上面的函数和 generator 仅一步之遥，即将 <code>print(b)</code> 打印函数改为 <code>yield b</code> 作为返回就可以了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibonc</span>(<span class="params"><span class="built_in">max</span></span>):</span></span><br><span class="line">    print(<span class="string">&quot; call fibonc generator &quot;</span>)</span><br><span class="line">    idx = <span class="number">0</span></span><br><span class="line">    a, b = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> idx &lt; <span class="built_in">max</span>:</span><br><span class="line">        <span class="keyword">yield</span> b</span><br><span class="line">        a, b = (b, a + b)</span><br><span class="line">        idx += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">fi = fibonc(<span class="number">4</span>)</span><br><span class="line">print(fi)</span><br><span class="line"><span class="comment"># &lt;generator object fibonc at 0x0000012D76D41258&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> collections.abc <span class="keyword">import</span> Iterator</span><br><span class="line">print(<span class="built_in">isinstance</span>(fi, Iterator))</span><br><span class="line"><span class="comment"># True</span></span><br></pre></td></tr></table></figure>

<p>这样我们就成功创建了一个 <code>fi</code> 生成器对象。显然，和普通函数不同，fibonc(max) 函数的返回值用的是 yield 关键字，而不是 return 关键字，此类函数又称为生成器函数（generator function）。</p>
<blockquote>
<p>注意，即便调用生成器函数，Python 解释器也不会执行函数中的代码，它只会返回一个生成器（对象）。并且，和 return 作为返回值关键字相比，yield 除了可以返回相应的值，还有一个更重要的功能，即每当程序执行完该语句时，程序就会暂停执行。</p>
</blockquote>
<hr>
<p><strong>[1] &gt;&gt;&gt;&gt; 生成器元素访问</strong></p>
<p>生成器对象创建好之后，如何使用生成器中的元素数据呢？</p>
<p>即，要想使生成器函数得以执行，或者想使执行完 yield 语句立即暂停的程序得以继续执行，怎么办？</p>
<p>同理于迭代器，有以下三种方式：</p>
<ul>
<li>while 循环结构内使用 next(Iterator) 或者 <code>Iterator.__next__()</code> 遍历生成器，捕获 <code>StopIteration</code> 异常后停止；</li>
<li>通过 for 循环遍历生成器；</li>
<li>借助 Python 内置的 list() &amp;&amp; tuple() &amp;&amp; dict() &amp;&amp; set() 等转化为相应基本数据类型，然后进行遍历。</li>
</ul>
<p>示例如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibonc</span>(<span class="params"><span class="built_in">max</span></span>):</span></span><br><span class="line">    print(<span class="string">&quot; call fibonc generator &quot;</span>)</span><br><span class="line">    idx = <span class="number">0</span></span><br><span class="line">    a, b = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> idx &lt; <span class="built_in">max</span>:</span><br><span class="line">        <span class="keyword">yield</span> b</span><br><span class="line">        a, b = (b, a + b)</span><br><span class="line">        idx += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">fi = fibonc(<span class="number">4</span>)</span><br><span class="line">print(fi)</span><br><span class="line"><span class="comment"># &lt;generator object fibonc at 0x000002564CEE2BF8&gt;</span></span><br><span class="line"><span class="keyword">from</span> collections.abc <span class="keyword">import</span> Iterator</span><br><span class="line">print(<span class="built_in">isinstance</span>(fi, Iterator))</span><br><span class="line"><span class="comment"># True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用 next() or  __next__ 内置函数</span></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        print(<span class="built_in">next</span>(fi))</span><br><span class="line">        <span class="comment"># print(fi.__next__())</span></span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"><span class="comment"># call fibonc generator</span></span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过 for 循环遍历生成器</span></span><br><span class="line">fi1 = fibonc(<span class="number">4</span>)</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> fi1:</span><br><span class="line">    print(item)</span><br><span class="line"><span class="comment"># call fibonc generator</span></span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过 list() 转化</span></span><br><span class="line">fi2 = fibonc(<span class="number">4</span>)</span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> <span class="built_in">list</span>(fi2):</span><br><span class="line">    print(item)</span><br><span class="line"><span class="comment"># call fibonc generator</span></span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"><span class="comment"># 3</span></span><br></pre></td></tr></table></figure>

<hr>
<p><strong>[2] &gt;&gt;&gt;&gt; 生成器执行方式</strong></p>
<p>给出一个例子来看生成器内部程序的执行机制：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibonc</span>(<span class="params"><span class="built_in">max</span></span>):</span></span><br><span class="line">    print(<span class="string">&quot;Begin to run&quot;</span>)</span><br><span class="line">    idx = <span class="number">0</span></span><br><span class="line">    a, b = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> idx &lt; <span class="built_in">max</span>:</span><br><span class="line">        <span class="keyword">yield</span> b</span><br><span class="line">        a, b = (b, a + b)</span><br><span class="line">        idx += <span class="number">1</span></span><br><span class="line">        print(<span class="string">&quot;Continue to run&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    print(<span class="string">&quot;Run End&quot;</span>)</span><br><span class="line"></span><br><span class="line">fi = fibonc(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用 next() or  __next__ 内置函数</span></span><br><span class="line">print(<span class="built_in">next</span>(fi))</span><br><span class="line"><span class="comment"># Begin to run</span></span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line">print(fi.__next__())</span><br><span class="line"><span class="comment"># Continue to run</span></span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 通过 for 循环遍历生成器</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> fi:</span><br><span class="line">    print(item)</span><br><span class="line"><span class="comment"># Continue to run</span></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"><span class="comment"># Continue to run</span></span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line"><span class="comment"># Continue to run</span></span><br><span class="line"><span class="comment"># Run End</span></span><br></pre></td></tr></table></figure>

<p>1）首先，在创建有 <code>fi</code> 生成器的前提下，通过其调用 <code>next()</code> 内置函数，会使 Python 解释器开始执行 fibonc() 生成器函数中的代码，因此会输出 <code>Begin to run</code>，程序会一直执行到 <code>yield b</code>，而此时的 b==1，因此 Python 解释器输出 <code>1</code>。由于受到 yield 的影响，程序会在此处暂停。</p>
<p>2）然后，我们使用 <code>fi</code> 生成器调用 <code>__next__()</code> 方法，该方法的作用和 next() 函数完全相同（事实上，next() 函数的底层执行的也是 <code>__next__()</code> 方法），它会使得程序继续执行，即输出 <code>Continue to run</code>，程序又会执行到 <code>yield b</code>，此时 b==1，因此输出 <code>1</code>，然后程序暂停。</p>
<p>3）最后，我们使用 for 循环遍历 <code>fi</code> 生成器，之所以能这么做，是因为 for 循环底层会不断地调用 next() 函数，使暂停的程序继续执行，因此会输出后续的结果。</p>
<blockquote>
<p>注意，在 Python 2.x 版本中不能使用 <code>__next__()</code> 方法，可以使用 next() 内置函数，另外生成器还有 next() 方法（即以 num.next() 的方式调用）。</p>
</blockquote>
<hr>
<h4 id="元组推导式"><a href="#元组推导式" class="headerlink" title="元组推导式"></a>元组推导式</h4><p>另外对于不复杂的算法推算场景，即容器中元素可以使用推导式（解析式）生成。</p>
<p>Python 中支持一个很简单的 generator 创建方法就是，使用元组推导式，其返回一个生成器对象：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">gen = (x <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">4</span>))</span><br><span class="line">print(gen)</span><br><span class="line"><span class="comment"># &lt;generator object &lt;genexpr&gt; at 0x000002987E724F68&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> gen:</span><br><span class="line">    print(item)</span><br><span class="line"><span class="comment"># 0</span></span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"><span class="comment"># 3</span></span><br></pre></td></tr></table></figure>

<p>关于 gen 中元素遍历方式，请参见上一小节提供的三种方式。</p>
<hr>
<h4 id="素数示例"><a href="#素数示例" class="headerlink" title="素数示例"></a>素数示例</h4><p>一个生成器函数中是可以包含多个 yield 关键字作为返回的，这和 return 关键字是类似的。我们将以实现一个以素数作为元素的生成器容器进行展示。</p>
<p>我们知道，素数就是质数，是一个大于 1 的自然数，且除了 1 和它本身外，不再有其他的因数。</p>
<p>素数都有哪些？ &gt;&gt;&gt;&gt; 计算素数的一个方法是埃氏筛法，它的算法理解起来非常简单：</p>
<p>首先，列出从 <code>2</code> 开始的所有自然数，构造一个序列：</p>
<p>2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, … </p>
<p>取序列的第一个数 <code>2</code>，它一定是素数，然后用 <code>2</code> 把序列的 <code>2</code> 的倍数筛掉：</p>
<p>3, <del>4</del>, 5, <del>6</del>, 7, <del>8</del>, 9, <del>10</del>, 11, <del>12</del>, 13, <del>14</del>, 15, <del>16</del>, 17, <del>18</del>, 19, <del>20</del>, …</p>
<p>取新序列的第一个数 <code>3</code>，它一定是素数，然后用 <code>3</code> 把序列的 <code>3</code> 的倍数筛掉：</p>
<p>5, <del>6</del>, 7, <del>8</del>, <del>9</del>, <del>10</del>, 11, <del>12</del>, 13, <del>14</del>, <del>15</del>, <del>16</del>, 17, <del>18</del>, 19, <del>20</del>, … </p>
<p>取新序列的第一个数<code>5</code>，然后用<code>5</code>把序列的<code>5</code>的倍数筛掉： </p>
<p>7, <del>8</del>, <del>9</del>, <del>10</del>, 11, <del>12</del>, 13, <del>14</del>, <del>15</del>, <del>16</del>, 17, <del>18</del>, 19, <del>20</del>, …</p>
<p>这样不断筛下去，就可以得到所有的素数。</p>
<p><strong>Python 编程实现过程 &gt;&gt;&gt;&gt;</strong></p>
<p>先来看三个核心的函数功能实现：</p>
<p><strong>1）–&gt;</strong> 先构造一个从 <code>3</code> 开始的奇数序列（注意这是一个生成器，并且是一个无限序列），作为初始序列：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__oddSeq_generator</span>(<span class="params">self</span>):</span></span><br><span class="line">    n = <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        n += <span class="number">2</span></span><br><span class="line">        <span class="keyword">yield</span> n</span><br></pre></td></tr></table></figure>

<p><strong>2）–&gt;</strong> 然后定义一个倍数筛查函数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__not_divisible</span>(<span class="params">self, n</span>):</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">lambda</span> x: x % n &gt; <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p><strong>3）–&gt;</strong> 定义一个生成器，不断返回下一个素数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__primes</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">    it = self.__oddSeq_generator() <span class="comment"># 初始序列</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        n = <span class="built_in">next</span>(it) <span class="comment"># 返回序列的第一个数</span></span><br><span class="line">        <span class="keyword">yield</span> n</span><br><span class="line">        it = <span class="built_in">filter</span>(self.__not_divisible(n), it) <span class="comment"># 构造新序列</span></span><br></pre></td></tr></table></figure>

<p>类封装后，最终如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrimesCalc</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, number</span>):</span></span><br><span class="line">        self.__primes_list = []</span><br><span class="line">        self.__generate_flag = <span class="literal">False</span></span><br><span class="line">        self.number = number</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__oddSeq_generator</span>(<span class="params">self</span>):</span></span><br><span class="line">        n = <span class="number">1</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            n += <span class="number">2</span></span><br><span class="line">            <span class="keyword">yield</span> n</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__not_divisible</span>(<span class="params">self, n</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">lambda</span> x: x % n &gt; <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__primes</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">        it = self.__oddSeq_generator() <span class="comment"># 初始序列</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            n = <span class="built_in">next</span>(it) <span class="comment"># 返回序列的第一个数</span></span><br><span class="line">            <span class="keyword">yield</span> n</span><br><span class="line">            it = <span class="built_in">filter</span>(self.__not_divisible(n), it) <span class="comment"># 构造新序列</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">calc</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">for</span> item <span class="keyword">in</span> self.__primes():</span><br><span class="line">            <span class="keyword">if</span> (item &lt;= self.number) &amp; (<span class="keyword">not</span> self.__generate_flag):</span><br><span class="line">                self.__primes_list.append(item)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                self.__generate_flag = <span class="literal">True</span></span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        <span class="keyword">return</span> self.__primes_list</span><br><span class="line"></span><br><span class="line">primes_obj70 = PrimesCalc(<span class="number">70</span>)</span><br><span class="line">res = primes_obj70.calc()</span><br><span class="line">print(res)</span><br><span class="line"><span class="comment"># [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67]</span></span><br><span class="line"></span><br><span class="line">primes_obj50 = PrimesCalc(<span class="number">50</span>)</span><br><span class="line">res1 = primes_obj50.calc()</span><br><span class="line">print(res1)</span><br><span class="line"><span class="comment"># [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47]</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="生成器高级用法"><a href="#生成器高级用法" class="headerlink" title="生成器高级用法"></a>生成器高级用法</h3><p>本节将在上述基础上，继续讲解生成器的一些高级用法，会涉及到：send() &amp;&amp; close() &amp;&amp; throw() 三种生成器方法。</p>
<h4 id="send-方法"><a href="#send-方法" class="headerlink" title="send 方法"></a>send 方法</h4><p>我们知道，通过 for 循环以及 next() 或者 <code>__next__()</code> 等方法，可以实现从外界控制生成器的执行。除此之外，通过 send() 方法，还可以向生成器中传值。</p>
<p>需要注意的是，使用 send() 方法可选择带一个参数，也可以不带任何参数（用 None 表示）。</p>
<p><strong>[1] &gt;&gt;&gt;&gt; send(None)</strong></p>
<p>当使用不带参数的 send(None) 方法时，它和 next() 函数的功能完全相同。例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">intNum</span>():</span></span><br><span class="line">    print(<span class="string">&quot;Start to run&quot;</span>)</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">5</span>):</span><br><span class="line">        <span class="keyword">yield</span> i</span><br><span class="line">        print(<span class="string">&quot;Continue to run&quot;</span>)</span><br><span class="line"></span><br><span class="line">num = intNum()</span><br><span class="line">print(num.send(<span class="literal">None</span>))</span><br><span class="line"><span class="comment"># Start to run</span></span><br><span class="line"><span class="comment"># 0</span></span><br><span class="line">print(num.send(<span class="literal">None</span>))</span><br><span class="line"><span class="comment"># Continue to run</span></span><br><span class="line"><span class="comment"># 1</span></span><br></pre></td></tr></table></figure>

<p>注意，虽然 <code>send(None)</code> 的功能是 <code>next()</code> 完全相同，但更推荐使用 next()，不推荐使用 send(None)。</p>
<hr>
<p><strong>[2] &gt;&gt;&gt;&gt; send(value)</strong></p>
<p>send(value) 具备 next() 函数的部分功能，即将暂停在 yield 语句出的程序继续执行；但与此同时，该函数还会将 value 值作为 yield 语句返回值赋值给接收者。</p>
<p>样例演示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>():</span></span><br><span class="line">    buff_a = <span class="keyword">yield</span> <span class="string">&quot;hello&quot;</span></span><br><span class="line">    buff_b = <span class="keyword">yield</span> buff_a</span><br><span class="line">    <span class="keyword">yield</span> buff_b</span><br><span class="line"></span><br><span class="line">f = foo()</span><br><span class="line">print(f.send(<span class="string">&quot;Python&quot;</span>))</span><br><span class="line"><span class="comment"># TypeError: can&#x27;t send non-None value to a just-started generator</span></span><br></pre></td></tr></table></figure>

<p>哎？报错了：”你无法传入一个非 None 的值给一个刚启动的生成器”，什么意思？ &gt;&gt;&gt;&gt;</p>
<p>事实上，带参数的 send(value) 无法启动执行生成器函数。必须先传递一个 None 进去或者调用一次 next() 方法（启动生成器），才能进行传值操作。修改程序如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>():</span></span><br><span class="line">    buff_a = <span class="keyword">yield</span> <span class="string">&quot;hello&quot;</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">&quot;buff_a --&gt;&quot;</span>, buff_a)</span><br><span class="line">    buff_b = <span class="keyword">yield</span> <span class="string">&quot;hello&quot;</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">&quot;buff_b --&gt;&quot;</span>, buff_b)</span><br><span class="line">    buff_c = <span class="keyword">yield</span> buff_b</span><br><span class="line"></span><br><span class="line">    print(<span class="string">&quot;buff_c --&gt;&quot;</span>, buff_c)</span><br><span class="line">    <span class="keyword">yield</span> buff_c</span><br><span class="line"></span><br><span class="line">f = foo()</span><br><span class="line"></span><br><span class="line">print(<span class="built_in">next</span>(f)) <span class="comment"># 等价于 print(f.send(None))</span></span><br><span class="line"><span class="comment"># hello</span></span><br><span class="line"></span><br><span class="line">print(f.send(<span class="literal">None</span>))  <span class="comment"># 等价于 print(next(f))</span></span><br><span class="line"><span class="comment"># buff_a --&gt; None</span></span><br><span class="line"><span class="comment"># hello</span></span><br><span class="line"></span><br><span class="line">print(f.send(<span class="string">&quot;Python&quot;</span>))</span><br><span class="line"><span class="comment"># buff_b --&gt; Python</span></span><br><span class="line"><span class="comment"># Python</span></span><br><span class="line"></span><br><span class="line">print(f.send(<span class="string">&quot;Python is a OPP Program.&quot;</span>))</span><br><span class="line"><span class="comment"># buff_c --&gt; Python is a OPP Program.</span></span><br><span class="line"><span class="comment"># Python is a OPP Program.</span></span><br></pre></td></tr></table></figure>

<p>分析一下程序的执行流程：</p>
<p>1）首先，构建生成器函数，并利用其创建生成器对象 <code>f</code>。</p>
<p>2）使用 next() 函数启动生成器（其功能和 f.send(None) 函数完全相同），开始执行生成器函数，程序会执行到 <code>yield &quot;hello&quot;</code>，而此时的值为 “hello”，因此 Python 解释器输出 <code>hello</code>。这里注意，此时还未对 <code>buff_a</code> 进行赋值。</p>
<p>3）使用生成器 f 调用无参的 send(None) 函数重新启动生成器，它会使得程序继续执行（buff_a 赋值 -&gt; 打印 buff_a），程序执行到第二个 <code>yield &quot;hello&quot;</code> 语句停止（未对 buff_b 进行赋值），此时 Python 解释器输出 <code>hello</code>。同时，你会发现，在打印 buff_a 时，输出 <code>buff_a --&gt; None</code>，思考一下为什么？？？</p>
<blockquote>
<p>事实上，3）在 buff_a 进行赋值时，由于使用的是 send(None) 函数启动的生成器，其没有返回值（或者就认为它也会将 None 赋值给当前 yield 语句的接收者），这就很合理了。这是不进一步意味着 next() 函数也是同理的，你可以将 send(None) 语句换为 next() 验证一下。</p>
</blockquote>
<p>4）开始使用生成器 f 调用有参的 send(value) 函数重新启动生成器，它会使得程序继续执行（buff_b 赋值 -&gt; 打印 buff_b），程序执行到 <code>yield buff_b&quot;</code> 语句停止（未对 buff_c 进行赋值），此时 Python 解释器输出 <code>Python</code>。这里，由于使用的是带 value 值的方式，故 buff_b 进行赋值时会拿到 <code>&quot;Python&quot;</code>，故打印输出：<code>buff_b --&gt; Python</code>。</p>
<p>5）最后依然是使用生成器 f 调用有参的 send(value) 函数重新启动生成器，过程和 4）中同理，请结合理解一下。</p>
<hr>
<h4 id="close-方法"><a href="#close-方法" class="headerlink" title="close 方法"></a>close 方法</h4><p>当程序在生成器函数中遇到 yield 语句暂停运行时，此时如果调用 close() 方法，会阻止生成器函数继续执行，该函数会在程序停止运行的位置抛出 <code>GeneratorExit</code> 异常。</p>
<p>举个例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>():</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">yield</span> <span class="string">&quot;Python&quot;</span></span><br><span class="line">    <span class="keyword">except</span> GeneratorExit:</span><br><span class="line">        print(<span class="string">&#x27;捕获到 GeneratorExit，你可以在这里进行异常处理操作&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">f = foo()</span><br><span class="line">print(<span class="built_in">next</span>(f))</span><br><span class="line"><span class="comment"># Python</span></span><br><span class="line">f.close()</span><br><span class="line"><span class="comment"># 捕获到 GeneratorExit，你可以在这里进行异常处理操作</span></span><br></pre></td></tr></table></figure>

<p>需要注意的是，生成器函数一旦使用 close() 函数停止运行，后续将无法再调用 next() 函数或者 <code>__next__()</code> 方法启动执行，否则会抛出 <code>StopIteration</code> 异常。例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>():</span></span><br><span class="line">    <span class="keyword">yield</span> <span class="string">&quot;Python&quot;</span></span><br><span class="line">    print(<span class="string">&quot;close 后仍想要执行的代码&quot;</span>)</span><br><span class="line">    </span><br><span class="line">f = foo()</span><br><span class="line">print(<span class="built_in">next</span>(f))</span><br><span class="line"><span class="comment"># Python</span></span><br><span class="line"></span><br><span class="line">f.close()</span><br><span class="line"><span class="built_in">next</span>(f)</span><br><span class="line"><span class="comment"># StopIteration Error</span></span><br></pre></td></tr></table></figure>

<p>这就意味着，close 后仍想要执行的代码无法执行了，怎么办？</p>
<p>可以通过通过捕获 <code>GeneratorExit</code> 异常，可以在异常处理中继续执行生成器函数中仍然想执行的代码。但是注意这部分代码中不能再包含 yield 语句，否则程序会抛出 <code>RuntimeError</code> 异常。例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>():</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">yield</span> <span class="string">&quot;Python&quot;</span></span><br><span class="line">    <span class="keyword">except</span> GeneratorExit:</span><br><span class="line">        print(<span class="string">&#x27;捕获到 GeneratorExit，你可以在这里进行异常处理操作&#x27;</span>)</span><br><span class="line">        print(<span class="string">&#x27;close 后仍想要执行的代码&#x27;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">yield</span> <span class="string">&quot;Java&quot;</span></span><br><span class="line">        </span><br><span class="line">f = foo()</span><br><span class="line">print(<span class="built_in">next</span>(f))</span><br><span class="line"><span class="comment"># Python</span></span><br><span class="line"></span><br><span class="line">f.close()</span><br><span class="line"><span class="comment"># 捕获到 GeneratorExit，你可以在这里进行异常处理操作</span></span><br><span class="line"><span class="comment"># close 后仍想要执行的代码</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># RuntimeError Traceback (most recent call last)</span></span><br><span class="line"><span class="comment">#     ---&gt; f.close()</span></span><br><span class="line"><span class="comment">#     RuntimeError: generator ignored GeneratorExit</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="throw-方法"><a href="#throw-方法" class="headerlink" title="throw 方法"></a>throw 方法</h4><p>生成器 throw() 方法的功能是，在生成器函数执行暂停处，抛出一个指定的异常，之后程序会继续执行生成器函数中后续的代码，直到遇到下一个 yield 语句。</p>
<blockquote>
<p>需要注意的是，如果到剩余代码执行完毕没有遇到下一个 yield 语句，则程序会抛出 StopIteration 异常。</p>
</blockquote>
<p>示例如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span>():</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">    <span class="keyword">except</span> ValueError:</span><br><span class="line">        print(<span class="string">&#x27;捕获到 ValueError&#x27;</span>)</span><br><span class="line"></span><br><span class="line">f = foo()</span><br><span class="line">print(<span class="built_in">next</span>(f))</span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line"></span><br><span class="line">f.throw(ValueError)</span><br><span class="line"><span class="comment"># 捕获到 ValueError</span></span><br><span class="line"><span class="comment"># Traceback (most recent call last):</span></span><br><span class="line"><span class="comment"># ...</span></span><br><span class="line"><span class="comment"># StopIteration</span></span><br></pre></td></tr></table></figure>

<p>显然，一开始生成器函数在 yield 1 处暂停执行，当执行 throw() 方法时，它会先抛出 ValueError 异常，然后继续执行后续代码找到下一个 yield 语句，该程序中由于后续不再有 yield 语句，因此程序执行到最后，会抛出一个 StopIteration 异常。</p>
<hr>
<h2 id="Python-中的-函数装饰器"><a href="#Python-中的-函数装饰器" class="headerlink" title="Python 中的@函数装饰器"></a>Python 中的@函数装饰器</h2><p>所谓函数装饰器（Decorator），是指 <font color='red'>通过装饰器函数，在不修改原函数的前提下，来对函数的功能进行合理的扩充。</font></p>
<h3 id="函数装饰器引入"><a href="#函数装饰器引入" class="headerlink" title="@函数装饰器引入"></a>@函数装饰器引入</h3><p>在前面的章节，我们已经学习了三种 Python 内置的函数装饰器，分别是：＠staticmethod、＠classmethod 和 @property。它们分别是基于 Python 内置的装饰器函数 staticmethod()、classmethod() 和 property() 来实现的。</p>
<p>如下样例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span>:</span></span><br><span class="line">    </span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo</span>(<span class="params">cls</span>):</span></span><br><span class="line">        print(<span class="string">&quot;Class Method&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>也就是说，在不修改原函数 foo(cls) 的前提下（默认为类的实例方法），我们使用了一个 <code>@classmethod</code> 的装饰器，使得 foo(cls) 函数成为了一个类方法（功能扩展）。其中，<code>@classmethod</code> 函数装饰器，是基于装饰器函数 classmethod() 实现的。</p>
<p>那么，到底什么是函数装饰器？装饰器函数又是如何定义的？？？</p>
<p>你需要了解函数装饰器的工作原理 &gt;&gt;&gt;&gt;</p>
<hr>
<h3 id="函数装饰器工作原理"><a href="#函数装饰器工作原理" class="headerlink" title="@函数装饰器工作原理"></a>@函数装饰器工作原理</h3><p>假设用 funA() 装饰器函数所对应的函数装饰器 <code>@funA</code>，去装饰 funB() 函数以实现扩展其功能。如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># funA 作为装饰器函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">funA</span>(<span class="params">fn</span>):</span></span><br><span class="line">    <span class="comment">#...</span></span><br><span class="line">    fn() <span class="comment"># 执行传入的 fn 参数</span></span><br><span class="line">    <span class="comment">#...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;...&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@funA</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">funB</span>():</span></span><br><span class="line">    <span class="comment">#...</span></span><br></pre></td></tr></table></figure>

<p>实际上，上面程序完全等价于下面的程序：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">funA</span>(<span class="params">fn</span>):</span></span><br><span class="line">    <span class="comment">#...</span></span><br><span class="line">    fn() <span class="comment"># 执行传入的 fn 参数</span></span><br><span class="line">    <span class="comment">#...</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;...&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">funB</span>():</span></span><br><span class="line">    <span class="comment">#...</span></span><br><span class="line"></span><br><span class="line">funB = funA(funB) <span class="comment"># 等价于 @funA</span></span><br></pre></td></tr></table></figure>

<p>对比如上程序可以发现，，使用装饰器函数 funA() 去装饰另一个函数 funB()，其底层执行了如下 2 步操作：</p>
<ol>
<li>将 funB 作为参数传给 funA() 函数（传递的是函数，即函数名，或函数引用）；</li>
<li>将 funA() 函数执行完成的返回值反馈回  funB。</li>
</ol>
<p>来看一个实例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># funA 作为装饰器函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">funA</span>(<span class="params">fn</span>):</span></span><br><span class="line">    print(<span class="string">&quot;2018-3-13 12:30:12&quot;</span>)</span><br><span class="line">    fn() <span class="comment"># 执行传入的 fn 参数</span></span><br><span class="line">    print(<span class="string">&quot;2018-3-13 12:30:15&quot;</span>)</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="string">&quot;Decorator Return&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@funA</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">funB</span>():</span></span><br><span class="line">    print(<span class="string">&quot;Learning Python&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2018-3-13 12:30:12</span></span><br><span class="line"><span class="comment"># Learning Python</span></span><br><span class="line"><span class="comment"># 2018-3-13 12:30:15</span></span><br></pre></td></tr></table></figure>

<p><strong>观察函数装饰器返回 &gt;&gt;&gt;&gt;</strong></p>
<p>在此基础上，如果在程序末尾添加如下语句（打印观察返回的 funB 是什么？）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(funB)</span><br><span class="line"><span class="comment"># Decorator Return</span></span><br></pre></td></tr></table></figure>

<p>可见，funB 从一个函数引用，变为了一个普通的变量引用。显然，你可以理解被 “＠函数”修饰的函数不再是原来的函数，而是被替换成一个新的东西（取决于装饰器的返回值）：</p>
<ul>
<li>如果装饰器函数的返回值为普通变量，那么被修饰的函数名就变成了变量名；</li>
<li>如果装饰器返回的是一个函数的名称，那么被修饰的函数名依然表示一个函数。</li>
</ul>
<hr>
<h3 id="带参数的-函数装饰器"><a href="#带参数的-函数装饰器" class="headerlink" title="带参数的@函数装饰器###"></a>带参数的@函数装饰器###</h3><p>分析@函数装饰器工作原理可以发现，即当被修饰的 funB() 函数无参数时，可以直接将 funB 作为 funA() 的参数传入。</p>
<p>思考一下，如果被修饰的函数本身带有参数 funB(arg)，那应该如何传值呢？即如何向装饰器函数传递一个带参数的函数？？？</p>
<p>解决方法很简单 &gt;&gt;&gt;&gt;</p>
<p>就是在装饰器函数（funA()）中嵌套一个函数，该函数带有的参数个数和被装饰器修饰的函数相同。</p>
<p><strong>[1] &gt;&gt;&gt;&gt; 被修饰函数带有参数</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># funA 作为装饰器函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">funA</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">arg</span>):</span></span><br><span class="line">        <span class="comment"># 说明：函数对象中，有一个 `__name__ `属性，可以拿到函数的名字</span></span><br><span class="line">        print(<span class="string">&#x27;%s %s&#x27;</span> % (arg, func.__name__) )</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@funA</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">funB</span>(<span class="params">arg</span>):</span></span><br><span class="line">    print(<span class="string">&quot;funB call&quot;</span>)</span><br><span class="line">    </span><br><span class="line">funB(<span class="string">&quot;test&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>等价于如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># funA 作为装饰器函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">funA</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">arg</span>):</span></span><br><span class="line">        <span class="comment"># 说明：函数对象中，有一个 `__name__ `属性，可以拿到函数的名字</span></span><br><span class="line">        print(<span class="string">&#x27;%s %s&#x27;</span> % (arg, func.__name__) )</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">funB</span>(<span class="params">arg</span>):</span></span><br><span class="line">    print(<span class="string">&quot;funB call&quot;</span>)</span><br><span class="line">    </span><br><span class="line">funB = funA(funB)</span><br><span class="line">funB(<span class="string">&quot;test&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>显然，此时 funB() 函数被装饰器 funA() 修饰，funB 就被赋值为 wrapper。这意味着，虽然我们在程序显式调用的是 funB() 函数，但其实执行的是装饰器嵌套的 wrapper() 函数。</p>
<hr>
<p><strong>[2] &gt;&gt;&gt;&gt; 多个（≥ 2）函数被同一个装饰器函数修饰，这些函数带有的参数个数并不相等</strong></p>
<p>解决方法很简单 &gt;&gt;&gt;&gt;</p>
<p>用 <code>*args</code> 和 <code>**kwargs</code> 作为装饰器内部嵌套函数的参数，<code>*args</code> 和 <code>**kwargs</code> 表示接受任意数量和类型的参数。举个例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># funA 作为装饰器函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">funA</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*arg, **kwarg</span>):</span></span><br><span class="line">        func(*arg, **kwarg)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@funA</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">funB</span>(<span class="params">arg</span>):</span></span><br><span class="line">    print(<span class="string">&quot;Learning&quot;</span>, arg)</span><br><span class="line"></span><br><span class="line"><span class="meta">@funA</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">funC</span>(<span class="params">name, add</span>):</span></span><br><span class="line">    print(name, add)</span><br><span class="line">    </span><br><span class="line">funB(<span class="string">&quot;Python&quot;</span>)</span><br><span class="line">funC(<span class="string">&quot;Learning&quot;</span>, <span class="string">&quot;Java&quot;</span>)</span><br><span class="line"><span class="comment"># Learning Python</span></span><br><span class="line"><span class="comment"># Learning Java</span></span><br></pre></td></tr></table></figure>

<p>你应该可以想到，当只有一个被修饰函数，且被修饰函数参数列表有任意多个时，也可以采用上述方法。</p>
<hr>
<p>上面我们提到的，都是被修饰函数中的参数场景。那你有没有考虑过一个问题，如果装饰器函数本身带有参数的话怎么办？？？</p>
<p><strong>[3] &gt;&gt;&gt;&gt; 函数装饰器中含参数</strong></p>
<p>如果装饰器函数（decorator）本身就需要传入参数怎么办？？？</p>
<p>借鉴上面的方法，可以在装饰器函数（funA）的外面套一个外部函数，通过外部函数传入参数，但需要保证外部函数返回一个装饰器（decorator），这是必要的。</p>
<p>为了方便理解，我们将 funA 改名为 decorator，示例如下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># externalFunc 作为外部函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">externalFunc</span>(<span class="params">text</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorator</span>(<span class="params">func</span>):</span> <span class="comment"># funA 作为装饰器函数</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*arg, **kwarg</span>):</span> <span class="comment"># wrapper 作为内嵌函数</span></span><br><span class="line">            print(<span class="string">&#x27;%s %s:&#x27;</span> % (text, func.__name__)) <span class="comment"># 说明：函数对象中，有一个 `__name__ `属性，可以拿到函数的名字</span></span><br><span class="line">            func(*arg, **kwarg)</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> decorator</span><br><span class="line"></span><br><span class="line"><span class="meta">@externalFunc(<span class="params"><span class="string">&#x27;execute&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">funB</span>(<span class="params">arg</span>):</span></span><br><span class="line">    print(<span class="string">&quot;Learning&quot;</span>, arg)</span><br><span class="line"></span><br><span class="line"><span class="meta">@externalFunc(<span class="params"><span class="string">&#x27;execute&#x27;</span></span>)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">funC</span>(<span class="params">name, add</span>):</span></span><br><span class="line">    print(name, add)</span><br><span class="line">    </span><br><span class="line">funB(<span class="string">&quot;Python&quot;</span>)</span><br><span class="line">funC(<span class="string">&quot;Learning&quot;</span>, <span class="string">&quot;Java&quot;</span>)</span><br><span class="line"><span class="comment"># execute funB:</span></span><br><span class="line"><span class="comment"># Learning Python</span></span><br><span class="line"><span class="comment"># execute funC:</span></span><br><span class="line"><span class="comment"># Learning Java</span></span><br></pre></td></tr></table></figure>

<p>这种 3 层嵌套等价于如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># externalFunc 作为外部函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">externalFunc</span>(<span class="params">text</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorator</span>(<span class="params">func</span>):</span> <span class="comment"># funA 作为装饰器函数</span></span><br><span class="line">        </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*arg, **kwarg</span>):</span> <span class="comment"># wrapper 作为内嵌函数</span></span><br><span class="line">            print(<span class="string">&#x27;%s %s:&#x27;</span> % (text, func.__name__)) <span class="comment"># 说明：函数对象中，有一个 `__name__ `属性，可以拿到函数的名字</span></span><br><span class="line">            func(*arg, **kwarg)</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> decorator</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">funB</span>(<span class="params">arg</span>):</span></span><br><span class="line">    print(<span class="string">&quot;Learning&quot;</span>, arg)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">funC</span>(<span class="params">name, add</span>):</span></span><br><span class="line">    print(name, add)</span><br><span class="line"></span><br><span class="line">funB = externalFunc(<span class="string">&quot;execute&quot;</span>)(funB)</span><br><span class="line">funC = externalFunc(<span class="string">&quot;execute&quot;</span>)(funC)</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="完整的-函数装饰器"><a href="#完整的-函数装饰器" class="headerlink" title="完整的@函数装饰器"></a>完整的@函数装饰器</h3><p>先给出一个前面的，一般@函数装饰器的样例程序：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># funA 作为装饰器函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">funA</span>(<span class="params">func</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*arg, **kwarg</span>):</span></span><br><span class="line">        func(*arg, **kwarg)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@funA</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">funB</span>(<span class="params">arg</span>):</span></span><br><span class="line">    print(<span class="string">&quot;Learning&quot;</span>, arg)</span><br><span class="line"></span><br><span class="line"><span class="meta">@funA</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">funC</span>(<span class="params">name, add</span>):</span></span><br><span class="line">    print(name, add)</span><br><span class="line">    </span><br><span class="line">funB(<span class="string">&quot;Python&quot;</span>)</span><br><span class="line">funC(<span class="string">&quot;Learning&quot;</span>, <span class="string">&quot;Java&quot;</span>)</span><br><span class="line"><span class="comment"># Learning Python</span></span><br><span class="line"><span class="comment"># Learning Java</span></span><br></pre></td></tr></table></figure>

<p>考虑一下，在以上基础上添加如下代码的输出效果：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(funB.__name__)</span><br><span class="line">print(funC.__name__)</span><br></pre></td></tr></table></figure>

<p>可以看到，运行后函数名称输出的都是 <code>wrapper</code>，这不是我们预期的输出啊，既然访问的是 <code>funB/funC</code>，你应该输出相应的函数签名啊。</p>
<p>事实上，出现上述情况也不意外，因为装饰器函数返回的那个 <code>wrapper()</code> 函数名字就是 <code>&#39;wrapper&#39;</code>， <code>funB/funC</code> 指向的实际上还是 <code>wrapper()</code> 函数的空间。所以需要把原始函数的 <code>__name__ </code>等属性复制到 <code>wrapper()</code> 函数中，否则有些依赖函数签名的代码执行就会出错。</p>
<p>当然了，不需要编写 <code>wrapper.__name__ = func.__name__</code> 这样的代码，Python functools 模块内置的 <code>functools.wraps</code> 就是干这个事的，所以，一个完整的 decorator 的写法如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">funA</span>(<span class="params">func</span>):</span></span><br><span class="line"><span class="meta">    @functools.wraps(<span class="params">func</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args, **kw</span>):</span></span><br><span class="line">        print(<span class="string">&#x27;call %s():&#x27;</span> % func.__name__)</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kw)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br></pre></td></tr></table></figure>

<p>或者针对带参数的 decorator：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">externalFunc</span>(<span class="params">text</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorator</span>(<span class="params">func</span>):</span></span><br><span class="line"><span class="meta">        @functools.wraps(<span class="params">func</span>)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args, **kw</span>):</span></span><br><span class="line">            print(<span class="string">&#x27;%s %s():&#x27;</span> % (text, func.__name__))</span><br><span class="line">            <span class="keyword">return</span> func(*args, **kw)</span><br><span class="line">        <span class="keyword">return</span> wrapper</span><br><span class="line">    <span class="keyword">return</span> decorator</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="函数装饰器嵌套"><a href="#函数装饰器嵌套" class="headerlink" title="@函数装饰器嵌套"></a>@函数装饰器嵌套</h3><p>上面都是使用一个装饰器的情况，但实际上，Python 中的函数也支持多个装饰器，比如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@funA</span></span><br><span class="line"><span class="meta">@funB</span></span><br><span class="line"><span class="meta">@funC</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span>():</span></span><br><span class="line">    <span class="comment">#...</span></span><br></pre></td></tr></table></figure>

<p>上面程序的执行顺序是里到外，所以它等效于下面这行代码:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fun = funA( funB( funC(fun) ) )</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="深入解读-函数装饰器"><a href="#深入解读-函数装饰器" class="headerlink" title="深入解读@函数装饰器"></a>深入解读@函数装饰器</h3><p>这一小节将通过实际工作中的几个例子，来加深对@函数装饰器的理解。</p>
<h4 id="身份认证"><a href="#身份认证" class="headerlink" title="身份认证"></a>身份认证</h4><p>首先是最常见的身份认证的应用。</p>
<p>这个很容易理解，举个最常见的例子，登录微信时，需要输入用户名密码，然后点击确认，这样服务器端便会查询你的用户名是否存在、是否和密码匹配等等。如果认证通过，就可以顺利登录；反之，则提示你登录失败。</p>
<p>再比如一些网站，你不登录也可以浏览内容，但如果你想要发布文章或留言，在点击发布时，服务器端便会查询你是否登录。如果没有登录，就不允许这项操作等等。</p>
<p>一个实现身份认证的简单示例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">authenticate</span>(<span class="params">func</span>):</span></span><br><span class="line"><span class="meta">    @functools.wraps(<span class="params">func</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        request = args[<span class="number">0</span>]</span><br><span class="line">        <span class="comment"># 如果用户处于登录状态</span></span><br><span class="line">        <span class="keyword">if</span> check_user_logged_in(request):</span><br><span class="line">            <span class="comment"># 执行函数 post_comment()</span></span><br><span class="line">            <span class="keyword">return</span> func(*args, **kwargs)  </span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">raise</span> Exception(<span class="string">&#x27;Authentication failed&#x27;</span>)</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line">   </span><br><span class="line"><span class="meta">@authenticate</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">post_comment</span>(<span class="params">request</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>上面这段代码中，定义了装饰器 authenticate，函数 post_comment() 则表示发表用户对某篇文章的评论，每次调用这个函数前，都会先检查用户是否处于登录状态，如果是登录状态，则允许这项操作；如果没有登录，则不允许。</p>
<hr>
<h4 id="日志记录"><a href="#日志记录" class="headerlink" title="日志记录"></a>日志记录</h4><p>日志记录同样是很常见的一个案例。</p>
<p>在实际工作中，如果你怀疑某些函数的耗时过长，导致整个系统的延迟增加，想在线上测试某些函数的执行时间，那么，装饰器就是一种很常用的手段。</p>
<p>示例演示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">log_execution_time</span>(<span class="params">func</span>):</span></span><br><span class="line"><span class="meta">    @functools.wraps(<span class="params">func</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        start = time.perf_counter()</span><br><span class="line">        res = func(*args, **kwargs)</span><br><span class="line">        end = time.perf_counter()</span><br><span class="line">        print(<span class="string">&#x27;&#123;&#125; took &#123;&#125; ms&#x27;</span>.<span class="built_in">format</span>(func.__name__, (end - start) * <span class="number">1000</span>))</span><br><span class="line">        <span class="keyword">return</span> res</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line">   </span><br><span class="line"><span class="meta">@log_execution_time</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">calculate_similarity</span>(<span class="params">items</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">calculate_similarity(<span class="string">&quot;test&quot;</span>)</span><br><span class="line"><span class="comment"># calculate_similarity took 0.00039999999999999996 ms</span></span><br></pre></td></tr></table></figure>

<p>这里，装饰器 log_execution_time 记录某个函数的运行时间，并返回其执行结果。如果你想计算任何函数的执行时间，在这个函数上方加上 <code>@log_execution_time</code> 即可。</p>
<hr>
<h3 id="输入合理性检查"><a href="#输入合理性检查" class="headerlink" title="输入合理性检查"></a>输入合理性检查</h3><p>在大型公司的机器学习框架中，调用机器集群进行模型训练前，往往会用装饰器对其输入（往往是很长的 json 文件）进行合理性检查。这样就可以大大避免输入不正确对机器造成的巨大开销。</p>
<p>示例演示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> functools</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">validation_check</span>(<span class="params">func</span>):</span></span><br><span class="line"><span class="meta">    @functools.wraps(<span class="params">func</span>)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">        ... <span class="comment"># 检查输入是否合法</span></span><br><span class="line">   </span><br><span class="line"><span class="meta">@validation_check</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">neural_network_training</span>(<span class="params">*args, **kwargs</span>):</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure>

<p>很多情况下都会出现输入不合理的现象。因为我们调用的训练模型往往很复杂，输入的文件有成千上万行，很多时候确实也很难发现。</p>
<p>试想一下，如果没有输入的合理性检查，很容易出现“模型训练了好几个小时后，系统却报错说输入的一个参数不对，成果付之一炬”的现象。这样的“惨案”，大大减缓了开发效率，也对机器资源造成了巨大浪费。</p>
<hr>
<h3 id="缓存装饰器"><a href="#缓存装饰器" class="headerlink" title="缓存装饰器"></a>缓存装饰器</h3><p>关于缓存装饰器的用法，其实十分常见，这里以 Python 内置的 LRU cache 为例来说明。</p>
<p>LRU cache，在 Python 中的表示形式是 @lru_cache。@lru_cache 会缓存进程中的函数参数和结果，当缓存满了以后，会删除最近最久未使用的数据。</p>
<p>正确使用缓存装饰器，往往能极大地提高程序运行效率。举个例子，大型公司服务器端的代码中往往存在很多关于设备的检查，比如使用的设备是安卓还是 iPhone，版本号是多少。这其中的一个原因，就是一些新的功能，往往只在某些特定的手机系统或版本上才有（比如 Android v200+）。</p>
<p>这样一来，我们通常使用缓存装饰器来包裹这些检查函数，避免其被反复调用，进而提高程序运行效率，比如写成下面这样：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@lru_cache</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">check</span>(<span class="params">param1, param2, ...</span>) # 检查用户设备类型，版本号等等</span></span><br><span class="line"><span class="function">    ...</span></span><br></pre></td></tr></table></figure>

<hr>
</div><div class="article-licensing box"><div class="licensing-title"><p>Python 面向对象编程之类的特殊属性和方法</p><p><a href="https://www.orangeshare.cn/2018/01/13/python-mian-xiang-dui-xiang-bian-cheng-zhi-lei-de-te-shu-shu-xing-he-fang-fa/">https://www.orangeshare.cn/2018/01/13/python-mian-xiang-dui-xiang-bian-cheng-zhi-lei-de-te-shu-shu-xing-he-fang-fa/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>Author</h6><p>Waldeinsamkeit</p></div></div><div class="level-item is-narrow"><div><h6>Posted on</h6><p>2018-01-13</p></div></div><div class="level-item is-narrow"><div><h6>Updated on</h6><p>2022-04-05</p></div></div><div class="level-item is-narrow"><div><h6>Licensed under</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="icon" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a><a class="icon" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/Python/">Python</a></div><div class="notification is-danger">You need to set <code>install_url</code> to use ShareThis. Please set it in <code>_config.yml</code>.</div></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">Like this article? Support the author with</h3><div class="buttons is-centered"><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>Alipay</span><span class="qrcode"><img src="/" alt="Alipay"></span></a><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>Wechat</span><span class="qrcode"><img src="/" alt="Wechat"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2018/01/14/python-zhong-de-yi-chang-chu-li-ji-zhi/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Python 中的异常处理机制</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2018/01/12/python-mian-xiang-dui-xiang-bian-cheng-zhi-lei-he-dui-xiang/"><span class="level-item">Python 面向对象编程之类和对象</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">Comments</h3><div class="notification is-danger">You forgot to set the <code>shortname</code> for Disqus. Please set it in <code>_config.yml</code>.</div></div></div></div><!--!--><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen  order-3 is-sticky"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="Waldeinsamkeit"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Waldeinsamkeit</p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">101</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">13</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">43</p></a></div></div></nav></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">Catalogue</h3><ul class="menu-list"><li><a class="level is-mobile" href="#类常用特殊成员整理"><span class="level-left"><span class="level-item">1</span><span class="level-item">类常用特殊成员整理</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Method-new"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">Method: __new__</span></span></a></li><li><a class="level is-mobile" href="#Method-repr"><span class="level-left"><span class="level-item">1.2</span><span class="level-item">Method: __repr__</span></span></a></li><li><a class="level is-mobile" href="#Method-del"><span class="level-left"><span class="level-item">1.3</span><span class="level-item">Method: __del__</span></span></a></li><li><a class="level is-mobile" href="#Method-dir"><span class="level-left"><span class="level-item">1.4</span><span class="level-item">Method: __dir__</span></span></a></li><li><a class="level is-mobile" href="#Method-dict"><span class="level-left"><span class="level-item">1.5</span><span class="level-item">Method:  __dict__</span></span></a></li><li><a class="level is-mobile" href="#common-Method"><span class="level-left"><span class="level-item">1.6</span><span class="level-item">common Method</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#setattr-amp-amp-getattr-amp-amp-hasattr"><span class="level-left"><span class="level-item">1.6.1</span><span class="level-item">setattr &amp;&amp; getattr &amp;&amp; hasattr</span></span></a></li><li><a class="level is-mobile" href="#issubclass-amp-amp-isinstance"><span class="level-left"><span class="level-item">1.6.2</span><span class="level-item">issubclass &amp;&amp; isinstance</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Method-call"><span class="level-left"><span class="level-item">1.7</span><span class="level-item">Method: __call__</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Python-中的运算符重载"><span class="level-left"><span class="level-item">2</span><span class="level-item">Python 中的运算符重载</span></span></a></li><li><a class="level is-mobile" href="#Python-中的迭代器"><span class="level-left"><span class="level-item">3</span><span class="level-item">Python 中的迭代器</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#可迭代对象（Iterable）"><span class="level-left"><span class="level-item">3.1</span><span class="level-item">可迭代对象（Iterable）</span></span></a></li><li><a class="level is-mobile" href="#何为迭代器（Iterator）"><span class="level-left"><span class="level-item">3.2</span><span class="level-item">何为迭代器（Iterator）</span></span></a></li><li><a class="level is-mobile" href="#如何定义迭代器容器"><span class="level-left"><span class="level-item">3.3</span><span class="level-item">如何定义迭代器容器</span></span></a></li><li><a class="level is-mobile" href="#enumerate-迭代器"><span class="level-left"><span class="level-item">3.4</span><span class="level-item">enumerate 迭代器</span></span></a></li><li><a class="level is-mobile" href="#深入解读迭代器"><span class="level-left"><span class="level-item">3.5</span><span class="level-item">深入解读迭代器</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#For-循环解读"><span class="level-left"><span class="level-item">3.5.1</span><span class="level-item">For 循环解读</span></span></a></li><li><a class="level is-mobile" href="#Iterator-数据流"><span class="level-left"><span class="level-item">3.5.2</span><span class="level-item">Iterator 数据流</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#Python-中的生成器"><span class="level-left"><span class="level-item">4</span><span class="level-item">Python 中的生成器</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#生成器（Generator）特性"><span class="level-left"><span class="level-item">4.1</span><span class="level-item">生成器（Generator）特性</span></span></a></li><li><a class="level is-mobile" href="#生成器创建"><span class="level-left"><span class="level-item">4.2</span><span class="level-item">生成器创建</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#yield-关键字"><span class="level-left"><span class="level-item">4.2.1</span><span class="level-item">yield 关键字</span></span></a></li><li><a class="level is-mobile" href="#元组推导式"><span class="level-left"><span class="level-item">4.2.2</span><span class="level-item">元组推导式</span></span></a></li><li><a class="level is-mobile" href="#素数示例"><span class="level-left"><span class="level-item">4.2.3</span><span class="level-item">素数示例</span></span></a></li></ul></li><li><a class="level is-mobile" href="#生成器高级用法"><span class="level-left"><span class="level-item">4.3</span><span class="level-item">生成器高级用法</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#send-方法"><span class="level-left"><span class="level-item">4.3.1</span><span class="level-item">send 方法</span></span></a></li><li><a class="level is-mobile" href="#close-方法"><span class="level-left"><span class="level-item">4.3.2</span><span class="level-item">close 方法</span></span></a></li><li><a class="level is-mobile" href="#throw-方法"><span class="level-left"><span class="level-item">4.3.3</span><span class="level-item">throw 方法</span></span></a></li></ul></li></ul></li><li><a class="level is-mobile" href="#Python-中的-函数装饰器"><span class="level-left"><span class="level-item">5</span><span class="level-item">Python 中的@函数装饰器</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#函数装饰器引入"><span class="level-left"><span class="level-item">5.1</span><span class="level-item">@函数装饰器引入</span></span></a></li><li><a class="level is-mobile" href="#函数装饰器工作原理"><span class="level-left"><span class="level-item">5.2</span><span class="level-item">@函数装饰器工作原理</span></span></a></li><li><a class="level is-mobile" href="#带参数的-函数装饰器"><span class="level-left"><span class="level-item">5.3</span><span class="level-item">带参数的@函数装饰器###</span></span></a></li><li><a class="level is-mobile" href="#完整的-函数装饰器"><span class="level-left"><span class="level-item">5.4</span><span class="level-item">完整的@函数装饰器</span></span></a></li><li><a class="level is-mobile" href="#函数装饰器嵌套"><span class="level-left"><span class="level-item">5.5</span><span class="level-item">@函数装饰器嵌套</span></span></a></li><li><a class="level is-mobile" href="#深入解读-函数装饰器"><span class="level-left"><span class="level-item">5.6</span><span class="level-item">深入解读@函数装饰器</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#身份认证"><span class="level-left"><span class="level-item">5.6.1</span><span class="level-item">身份认证</span></span></a></li><li><a class="level is-mobile" href="#日志记录"><span class="level-left"><span class="level-item">5.6.2</span><span class="level-item">日志记录</span></span></a></li></ul></li><li><a class="level is-mobile" href="#输入合理性检查"><span class="level-left"><span class="level-item">5.7</span><span class="level-item">输入合理性检查</span></span></a></li><li><a class="level is-mobile" href="#缓存装饰器"><span class="level-left"><span class="level-item">5.8</span><span class="level-item">缓存装饰器</span></span></a></li></ul></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="When Art Meets Tech" height="28"></a><p class="is-size-7"><span>&copy; 2024 Waldeinsamkeit</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p></div></div></div></div></footer><script src="https://cdnjs.loli.net/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" async></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/cookieconsent/3.1.1/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/js/lightgallery.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>
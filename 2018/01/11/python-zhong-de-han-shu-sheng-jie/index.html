<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Python 中的函数升阶 - When Art Meets Tech</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="When Art Meets Tech"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="When Art Meets Tech"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta description="我们知道函数是 Python 内建支持的一种封装，通过一层一层的函数封装，就可以把复杂任务分解成简单的任务，这种分解可以称之为面向过程的程序设计。函数就是面向过程的程序设计的基本单元。本文作为 Python 中 函数使用的升阶内容。"><meta property="og:type" content="blog"><meta property="og:title" content="Python 中的函数升阶"><meta property="og:url" content="https://www.orangeshare.cn/2018/01/11/python-zhong-de-han-shu-sheng-jie/"><meta property="og:site_name" content="When Art Meets Tech"><meta property="og:description" content="我们知道函数是 Python 内建支持的一种封装，通过一层一层的函数封装，就可以把复杂任务分解成简单的任务，这种分解可以称之为面向过程的程序设计。函数就是面向过程的程序设计的基本单元。本文作为 Python 中 函数使用的升阶内容。"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/TheNightIsYoung/HexoImageBed0/Img/map.png"><meta property="article:published_time" content="2018-01-11T07:40:29.000Z"><meta property="article:modified_time" content="2022-04-04T15:14:16.982Z"><meta property="article:author" content="Waldeinsamkeit"><meta property="article:tag" content="Python"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://cdn.jsdelivr.net/gh/TheNightIsYoung/HexoImageBed0/Img/map.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.orangeshare.cn/2018/01/11/python-zhong-de-han-shu-sheng-jie/"},"headline":"When Art Meets Tech","image":["https://cdn.jsdelivr.net/gh/TheNightIsYoung/HexoImageBed0/Img/map.png"],"datePublished":"2018-01-11T07:40:29.000Z","dateModified":"2022-04-04T15:14:16.982Z","author":{"@type":"Person","name":"Waldeinsamkeit"},"description":"我们知道函数是 Python 内建支持的一种封装，通过一层一层的函数封装，就可以把复杂任务分解成简单的任务，这种分解可以称之为面向过程的程序设计。函数就是面向过程的程序设计的基本单元。本文作为 Python 中 函数使用的升阶内容。"}</script><link rel="canonical" href="https://www.orangeshare.cn/2018/01/11/python-zhong-de-han-shu-sheng-jie/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Oxanium:wght@300;400;600&amp;family=Roboto+Mono"><link rel="stylesheet" href="/css/cyberpunk.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/cookieconsent/3.1.1/cookieconsent.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/pace/1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.2.0"></head>    <body class="is-3-column">    <nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="When Art Meets Tech" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Hexo Search" href="https://hexo.io/zh-cn/"><i class="fab fa-hotjar"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="Catalogue" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal"><i class="fas fa-angle-double-right"></i>Python 中的函数升阶</h1><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><i class="far fa-calendar-alt"> </i><time dateTime="${date_xml(page.date)}" title="${date_xml(page.date)}">2018-01-11</time></span><span class="level-item is-hidden-mobile"><i class="far fa-calendar-check"> </i><time dateTime="${date_xml(page.updated)}" title="${date_xml(page.updated)}">2022-04-04</time></span><span class="level-item"><a class="link-muted" href="/categories/Python/">Python</a></span><span class="level-item">42 minutes read (About 6290 words)</span></div></div><div class="content"><p>我们知道函数是 Python 内建支持的一种封装，通过一层一层的函数封装，就可以把复杂任务分解成简单的任务，这种分解可以称之为面向过程的程序设计。函数就是面向过程的程序设计的基本单元。本文作为 Python 中 <strong>函数使用的升阶内容。</strong></p>
<a id="more"></a>

<p>前面已经介绍了 Python 函数的所有基本用法和使用注意事项，但是，Python 函数的用法还远不止此。</p>
<p>除了我们已经了解的函数赋值（别名）、局部函数、函数调用、函数间相互调用，甚至作为其他函数的返回值以外，Python 中还支持很多高级的用法：闭包函数、lambda 匿名函数、函数式编程等等。</p>
<hr>
<h2 id="lambda-匿名函数"><a href="#lambda-匿名函数" class="headerlink" title="lambda 匿名函数"></a>lambda 匿名函数</h2><p>Python 中支持一种快速定义简单函数的方法 –&gt; Lambda 表达式，也称为匿名函数。</p>
<p>lambda 表达式，常用来表示内部仅包含 1 行表达式的简单函数。如果一个函数的函数体仅有 1 行表达式，则该函数就可以用 lambda 表达式来代替。</p>
<p>lambda 表达式的语法格式如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="keyword">lambda</span> [<span class="built_in">list</span>] : 表达式</span><br></pre></td></tr></table></figure>

<p>其中，定义 lambda 表达式，必须使用 lambda 关键字；<code>[list]</code> 作为可选参数，等同于函数定义时指定的形参列表，<code>name</code> 为该 lambda 表达式（匿名含数）的名称。</p>
<p>明白为什么叫匿名函数了吗？ &gt;&gt;&gt;&gt; 简单到不需要使用专门的函数名称，而是采用函数别名的方式直接赋值给变量就行了，就像一个表达式一样简单（lambda 表达式）。能猜到如何调用吗?：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">name()</span><br></pre></td></tr></table></figure>

<p>既然是等同于一个简单函数，故可以转换成普通函数的形式：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">name</span>(<span class="params"><span class="built_in">list</span></span>):</span></span><br><span class="line">    <span class="keyword">return</span> 表达式</span><br><span class="line"></span><br><span class="line">name(<span class="built_in">list</span>)</span><br></pre></td></tr></table></figure>

<p>来一个实例（求 2 个数之和）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 求 2 个数之和的匿名函数</span></span><br><span class="line">add = <span class="keyword">lambda</span> x,y:x+y</span><br><span class="line">print(add(<span class="number">3</span>,<span class="number">4</span>))</span><br></pre></td></tr></table></figure>

<p>可以这样理解 lambda 表达式，其就是简单函数（函数体仅是单行的表达式）的简写版本。这可以帮助我们省去定义函数的过程，对于不需要多次复用的函数，使用 lambda 表达式可以在用完之后立即释放，提高程序执行的性能。</p>
<hr>
<h2 id="重新认识闭包函数"><a href="#重新认识闭包函数" class="headerlink" title="重新认识闭包函数"></a>重新认识闭包函数</h2><p>和前面讲的嵌套函数（局部函数）类似，不同之处在于，闭包中外部函数返回的不是一个具体的值，而是一个函数。</p>
<p>构成闭包的条件：</p>
<ul>
<li>必须有一个内嵌函数（局部函数）；</li>
<li>内嵌函数必须引用其外部函数中的变量；</li>
<li>外部函数的返回值必须是内嵌函数。</li>
</ul>
<p>先来看一个例子(不定长参数的求和)：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lazy_sum</span>(<span class="params">*args</span>):</span></span><br><span class="line">    <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">calc_sum</span>():</span></span><br><span class="line">        <span class="keyword">nonlocal</span> <span class="built_in">sum</span></span><br><span class="line">        <span class="keyword">for</span> arg <span class="keyword">in</span> args:</span><br><span class="line">            <span class="built_in">sum</span> += arg</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span></span><br><span class="line">    <span class="keyword">return</span> calc_sum</span><br><span class="line"></span><br><span class="line">f1 = lazy_sum(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>)</span><br><span class="line">print(f1())</span><br><span class="line"><span class="comment"># 25</span></span><br><span class="line"></span><br><span class="line">f2 = lazy_sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line">print(f2())</span><br><span class="line"><span class="comment"># 15</span></span><br></pre></td></tr></table></figure>

<p>程序中，我们在函数 <code>lazy_sum</code> 中又定义了局部函数（内嵌函数） <code>calc_sum</code>，并且，内嵌函数 <code>calc_sum</code> 引用了外部函数 <code>lazy_sum</code> 的参数和局部变量。</p>
<p>当调用外部函数 <code>lazy_sum</code> 时返回 <code>calc_sum</code> 嵌入函数的引用，相关参数和变量都保存在返回的嵌入函数中，这就是一个典型的 “闭包（Closure）” 结构。</p>
<p>看到这里，读者可能会问，为什么要使用闭包呢？完全可以写成下面的形式（多简洁）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lazy_sum</span>(<span class="params">*args</span>):</span></span><br><span class="line">    <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> arg <span class="keyword">in</span> args:</span><br><span class="line">        <span class="built_in">sum</span> += arg</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>事实上，我们知道使用闭包结构，当外部函数结束后，其局部函数中使用到的外部函数相关联变量会被绑定到内部函数，这样你就可以使得这些变量始终保存在内存中，不会随外部函数的结束而清除，起到变量状态保存的作用。</p>
<p>基于此，你可以想到 &gt;&gt;&gt;&gt;</p>
<p>一般函数开头需要做一些额外工作，当需要多次调用该函数时，如果将那些额外工作的代码放在外部函数，就可以减少多次调用导致的不必要开销，提高程序的运行效率。</p>
<hr>
<p><strong>[1] &gt;&gt;&gt;&gt; 外部函数的每次调用返回都的是一个新的函数引用</strong></p>
<p>这也就意味着，即使传入完全相同的参数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">lazy_sum</span>(<span class="params">*args</span>):</span></span><br><span class="line">    <span class="built_in">sum</span> = <span class="number">0</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">calc_sum</span>():</span></span><br><span class="line">        <span class="keyword">nonlocal</span> <span class="built_in">sum</span></span><br><span class="line">        <span class="keyword">for</span> arg <span class="keyword">in</span> args:</span><br><span class="line">            <span class="built_in">sum</span> += arg</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sum</span></span><br><span class="line">    <span class="keyword">return</span> calc_sum</span><br><span class="line"></span><br><span class="line">f1 = lazy_sum(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>)</span><br><span class="line">f2 = lazy_sum(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">print(f1 == f2)</span><br><span class="line"><span class="comment"># False</span></span><br></pre></td></tr></table></figure>

<p><code>f1()</code> 和 <code>f2()</code> 的调用结果互不影响，可以看作每次执行内嵌函数调用都会新开辟一块内存空间。</p>
<hr>
<p><strong>[2] &gt;&gt;&gt;&gt; 内嵌函数被调用时才执行</strong></p>
<p>使用闭包结构时，需要注意的是，外部函数调用时内嵌函数并没有立刻执行（用来返回来一个内嵌函数引用），而是直到显式调用内嵌函数 <code>f1()/f2()</code> 时才执行。</p>
<p>我们来看一个例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count</span>():</span></span><br><span class="line">    fs = []</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">4</span>):</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">f</span>():</span></span><br><span class="line">             <span class="keyword">return</span> i*i</span><br><span class="line">        fs.append(f)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># print(fs)</span></span><br><span class="line">    <span class="comment"># [.f at 0x7fc3e786d510&gt;, .f at 0x7fc3e786d598&gt;, .f at 0x7fc3e786d620&gt;]</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fs</span><br><span class="line"></span><br><span class="line">f1, f2, f3 = count()</span><br><span class="line">print(<span class="string">&quot;f1, f2, f3 :&quot;</span>, f1(),f2(),f3())</span><br></pre></td></tr></table></figure>

<p>上面程序中，每次循环都会向列表中添加一次内嵌函数引用（引用都不相同），然后最终把包含 3 个函数引用的列表返回。猜猜上面的代码结果是什么 –&gt; 1, 4, 9 ？</p>
<p>但实际结果是：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; f1, f2, f3 : 9 9 9</span></span><br></pre></td></tr></table></figure>

<p>f1, f2, f3 全部都是 <code>9</code>！！！</p>
<p>原因就在于（变量状态保存）：尽管内嵌函数引用了外部函数的变量 <code>i</code>，但在调用外部函数时并非立刻执行，外部函数结束后返回了循环构建的 3 个函数引用列表，此时它们所引用的变量 <code>i</code> 已经变成了 <code>3</code>。之后使用 <code>f1(), f2(), f3()</code> 调用内嵌函数时，按照 <code>i==3</code> 计算，因此最终结果为 <code>9</code>。</p>
<p>牢记一点：<strong>返回函数不要引用任何循环变量，或者后续会发生变化的变量。</strong></p>
<hr>
<p><strong>[3] &gt;&gt;&gt;&gt;闭包中循环变量的使用</strong></p>
<p>如果一定要引用循环变量怎么办？</p>
<p>方法就是再内嵌函数外再外嵌套一个函数，用该函数的参数绑定循环变量当前的值，然后该参数的值会被绑定给内嵌函数，之后无论该循环变量后续如何更改，已绑定给内嵌函数参数的值不变：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count</span>():</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">f</span>(<span class="params">j</span>):</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">g</span>():</span></span><br><span class="line">            <span class="keyword">return</span> j*j</span><br><span class="line">        <span class="keyword">return</span> g</span><br><span class="line">    fs = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">4</span>):</span><br><span class="line">        fs.append(f(i)) <span class="comment"># f(i) 立刻被执行，因此 i 的当前值被传入 f(j)</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> fs</span><br><span class="line">    </span><br><span class="line">f1, f2, f3 = count()</span><br><span class="line">print(<span class="string">&quot;f1, f2, f3 :&quot;</span>, f1(),f2(),f3())</span><br><span class="line"><span class="comment"># f1, f2, f3 : 1 4 9</span></span><br></pre></td></tr></table></figure>

<hr>
<p><strong>[4] &gt;&gt;&gt;&gt;闭包中的 <strong>closure</strong> 属性</strong></p>
<p>闭包比普通的函数多了一个 <code>__closure__</code> 属性，该属性记录着外部函数绑定给内嵌函数变量（自由变量）的地址。当闭包被调用时，系统就会根据该地址找到对应的变量，完成整体的函数调用。</p>
<p>以 outer() 为例，当其被调用时，可以通过 <code>__closure__</code> 属性获取变量 <code>b</code> 存储的地址，例如：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">def outer():</span><br><span class="line">    b = 10 # 自由变量</span><br><span class="line">    def inner(x):</span><br><span class="line">        return 5 * x + b</span><br><span class="line">        </span><br><span class="line">    return inner</span><br><span class="line">    </span><br><span class="line">b = 2</span><br><span class="line">fun = outer()</span><br><span class="line">print(fun(b))</span><br><span class="line"><span class="meta">#</span><span class="bash"> 20</span></span><br><span class="line"></span><br><span class="line">print(fun.__closure__)</span><br><span class="line"><span class="meta">#</span><span class="bash"> (&lt;cell at 0x000002503F36ED60: int object at 0x00007FFCC8AC1F00&gt;,)</span></span><br></pre></td></tr></table></figure>

<p>可以看到，显示的内容是一个 <code>int</code> 整数类型，这就是 fun 中自由变量 <code>b</code> 的初始值。还可以看到，<code>__closure__</code> 属性的类型是一个元组，这表明闭包可以支持多个自由变量的形式。</p>
<p>说是这么说的，得眼见为实（补充如下内容）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(fun.__closure__[<span class="number">0</span>].cell_contents)</span><br><span class="line"><span class="comment"># 10</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Python-解释器-eval-amp-amp-exec"><a href="#Python-解释器-eval-amp-amp-exec" class="headerlink" title="Python 解释器 eval &amp;&amp; exec"></a>Python 解释器 eval &amp;&amp; exec</h2><p><code>eval()</code> 和 <code>exec()</code> 函数都属于 Python 的内置函数，功能相当于一个 Python 的解释器。</p>
<p><strong>eval()</strong> 和 <strong>exec()</strong> 函数的功能都是可以 &gt;&gt;&gt;&gt; <strong>执行一个字符串形式的 Python 代码（代码以字符串的形式提供）</strong>。</p>
<p>不同之处在于 &gt;&gt;&gt;&gt; eval() 执行完要返回结果，而 exec() 执行完不返回结果。</p>
<p>eval() &amp;&amp; exec() 函数的语法格式为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># eval()</span></span><br><span class="line"><span class="built_in">eval</span>(expression, <span class="built_in">globals</span>=<span class="literal">None</span>, <span class="built_in">locals</span>=<span class="literal">None</span>, /)</span><br><span class="line"><span class="comment"># exec()</span></span><br><span class="line">exec(expression, <span class="built_in">globals</span>=<span class="literal">None</span>, <span class="built_in">locals</span>=<span class="literal">None</span>, /)</span><br></pre></td></tr></table></figure>

<p>可以看到，二者的语法格式除了函数名，其他都相同，其中各个参数的具体含义如下：</p>
<ul>
<li>expression：这个参数是一个字符串，代表要执行的语句 。该语句受后面两个字典类型参数 <code>globals</code> 和 <code>locals</code> 的限制，只有在 <code>globals</code> 字典和 <code>locals</code> 字典作用域内的函数和变量才能被执行。</li>
<li>globals：这个参数管控的是一个全局的命名空间，即 <code>expression</code> 可以使用全局命名空间中的函数。如果只是提供了 <code>globals</code> 参数，而没有提供自定义的 <code>__builtins__</code>，则系统会将当前环境中的 <code>__builtins__</code> 复制到自己提供的 <code>globals</code> 中，然后才会进行计算；如果连 <code>globals</code> 这个参数都没有被提供，则使用 Python 的全局命名空间。</li>
<li>locals：这个参数管控的是一个局部的命名空间，和 <code>globals</code> 类似，当它和 <code>globals</code> 中有重复或冲突时，以 <code>locals</code> 的为准。如果 <code>locals</code> 没有被提供，则默认为 <code>globals</code>。</li>
</ul>
<blockquote>
<p><code>__builtins__</code> 是 Python 的内建模块，平时使用的 int、str、abs 都在这个模块中。通过 print(dic[<code>&quot;__builtins__&quot;</code>]) 语句可以查看 <code>__builtins__</code> 所对应的 <code>value</code>。</p>
</blockquote>
<hr>
<p><strong>[1] &gt;&gt;&gt;&gt; globals 作用域</strong></p>
<p>首先，通过如下的例子来演示参数 <code>globals</code> 作用域的作用，注意观察它是何时将 <strong>builtins</strong> 复制 globals 字典中去的：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dic=&#123;&#125; <span class="comment"># 定义一个字典</span></span><br><span class="line">dic[<span class="string">&#x27;b&#x27;</span>] = <span class="number">3</span> <span class="comment"># 在 dic 中加一条元素:&quot;b=3&quot;</span></span><br><span class="line"><span class="built_in">print</span> (dic.keys()) <span class="comment"># 先将 dic 的 key 打印出来，有一个元素 b</span></span><br><span class="line">exec(<span class="string">&quot;a = 4&quot;</span>, dic) <span class="comment"># 在 exec 执行的语句后面跟一个作用域 dic</span></span><br><span class="line">print(dic.keys()) <span class="comment"># exec 后，dic 的 key 多了一个</span></span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dict_keys([&#x27;b&#x27;])</span><br><span class="line">dict_keys([&#x27;b&#x27;, &#x27;__builtins__&#x27;, &#x27;a&#x27;])</span><br></pre></td></tr></table></figure>

<p>上面的代码是在作用域 <code>dic</code> 下执行了一句 <code>a = 4</code> 的代码。可以看出，exec() 之前 <code>dic</code> 中的 <code>key</code> 只有一个 <code>b</code>。执行完 exec() 之后，系统在 <code>dic</code> 中生成了两个新的 <code>key</code>，分别是 <code>a</code> 和 <code>__builtins__</code>。其中，<code>a</code> 为执行语句生成的变量，系统将其放到指定的作用域字典里；<code>__builtins__</code> 是系统加入的内置 key。</p>
<p><strong>[2] &gt;&gt;&gt;&gt; locals 作用域</strong></p>
<p>使用如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a=<span class="number">10</span></span><br><span class="line">b=<span class="number">20</span></span><br><span class="line">c=<span class="number">30</span></span><br><span class="line">g=&#123;<span class="string">&#x27;a&#x27;</span>:<span class="number">6</span>, <span class="string">&#x27;b&#x27;</span>:<span class="number">8</span>&#125; <span class="comment">#定义一个字典</span></span><br><span class="line">t=&#123;<span class="string">&#x27;b&#x27;</span>:<span class="number">100</span>, <span class="string">&#x27;c&#x27;</span>:<span class="number">10</span>&#125; <span class="comment">#定义一个字典</span></span><br><span class="line"></span><br><span class="line">print(<span class="built_in">eval</span>(<span class="string">&#x27;a+b+c&#x27;</span>, g, t)) <span class="comment"># 定义一个字典</span></span><br><span class="line"><span class="comment"># Output: 116</span></span><br></pre></td></tr></table></figure>

<hr>
<p><strong>[3] &gt;&gt;&gt;&gt; exec() &amp;&amp; eval() 的区别</strong></p>
<p>exec() &amp;&amp; eval() 的区别在于：eval() 执行完会返回结果，而 exec() 执行完不返回结果。</p>
<p>实例演示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span></span><br><span class="line">exec(<span class="string">&quot;a = 2&quot;</span>) <span class="comment">#相当于直接执行 a=2</span></span><br><span class="line">print(a)</span><br><span class="line">a = exec(<span class="string">&quot;2+3&quot;</span>) <span class="comment">#相当于直接执行 2+3，但是并没有返回值，a 应为 None</span></span><br><span class="line">print(a)</span><br><span class="line">a = <span class="built_in">eval</span>(<span class="string">&#x27;2+3&#x27;</span>) <span class="comment">#执行 2+3，并把结果返回给 a</span></span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure>

<p>运行结果为：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">None</span><br><span class="line">5</span><br></pre></td></tr></table></figure>

<p>也就是说，<code>exec()</code> 中最适合放置运行后没有结果的语句，而 <code>eval()</code> 中适合放置有结果返回的语句。</p>
<hr>
<p><strong>[4] &gt;&gt;&gt;&gt; 应用场景</strong></p>
<p>在使用 Python 开发服务端程序时，这两个函数应用得非常广泛。例如，客户端向服务端发送一段字符串代码，服务端无需关心具体的内容，直接跳过 eval() 或 exec() 来执行，这样的设计会使服务端与客户端的耦合度更低，系统更易扩展。</p>
<p>另外，如果读者以后接触 TensorFlow 框架，就会发现该框架中的静态图就是类似这个原理实现的：</p>
<ul>
<li>TensorFlow 中先将张量定义在一个静态图里，这就相当将键值对添加到字典里一样；</li>
<li>TensorFlow 中通过 session 和张量的 eval() 函数来进行具体值的运算，就当于使用 eval() 函数进行具体值的运算一样。</li>
</ul>
<p>需要注意的是，在使用 eval() 或是 exec() 来处理请求代码时，函数 eval() 和 exec() 常常会被黑客利用，成为可以执行系统级命令的入口点，进而来攻击网站。解决方法是：通过设置其命名空间里的可执行函数，来限制 eval() 和 exec() 的执行范围。</p>
<hr>
<h2 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h2><p>所谓函数式编程，是指代码中每一块都是不可变的，都由纯函数的形式组成。</p>
<h3 id="认识函数式编程思想"><a href="#认识函数式编程思想" class="headerlink" title="认识函数式编程思想"></a>认识函数式编程思想</h3><p>纯函数构成？ &gt;&gt;&gt;&gt; 是指函数本身相互独立、互不影响，对于 <strong>相同的输入，总会有相同的输出。</strong></p>
<p>前面我们知道，既然变量可以指向函数，而函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数。函数式编程的一大特点 &gt;&gt;&gt;&gt; 即 <strong>允许把函数本身作为参数传入另一个函数，还允许返回一个函数（高阶函数）。</strong></p>
<p>怎么理解呢？？？</p>
<p>先来看一个让列表中的元素值都变为原来的两倍的函数实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multiply_2</span>(<span class="params"><span class="built_in">list</span></span>):</span></span><br><span class="line">    <span class="keyword">for</span> index <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">0</span>, <span class="built_in">len</span>(<span class="built_in">list</span>)):</span><br><span class="line">        <span class="built_in">list</span>[index] *= <span class="number">2</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span></span><br></pre></td></tr></table></figure>

<p>需要注意的是，这段代码不是一个纯函数的形式，因为列表中元素的值被改变了（“引用传递”），如果多次调用 <code>multiply_2()</code> 函数，那么每次得到的结果都不一样。</p>
<p>如何修改为纯函数的形式的实现呢？ &gt;&gt;&gt;&gt;</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multiply_2_pure</span>(<span class="params"><span class="built_in">list</span></span>):</span></span><br><span class="line">    new_list = []</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> <span class="built_in">list</span>:</span><br><span class="line">        new_list.append(item * <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> new_list</span><br></pre></td></tr></table></figure>

<p><strong>纯粹的函数式编程 &gt;&gt;&gt;&gt;</strong></p>
<p>事实上，纯粹的函数式编程语言（比如 Scala），其编写的函数中是没有变量的，因此可以保证，只要输入是确定的，输出就是确定的；而允许使用变量的程序设计语言，由于函数内部的变量状态不确定，同样的输入，可能得到不同的输出。</p>
<p>对于 <strong>Python</strong> 而言，是允许使用变量的，所以它 <strong>并不是一门纯函数式编程语言。</strong></p>
<hr>
<p>Python 仅对函数式编程提供了部分支持，主要包括 <code>map()</code>、<code>filter()</code> 和 <code>reduce()</code> 这 3 个函数，它们通常都结合 <code>lambda</code> 匿名函数一起使用。接下来逐一介绍:</p>
<h3 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h3><p>map() 函数的功能是依次对可迭代对象中的每个元素，都调用指定的函数进行处理，并返回一个可迭代的（Iterable） <code>map</code> 对象。</p>
<p>map() 函数的基本语法格式如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">map</span>(function, iterable)</span><br></pre></td></tr></table></figure>

<p>其中，<code>function</code> 参数表示要传入一个函数，其可以是内置函数、自定义函数或者 <code>lambda</code> 匿名函数；<code>iterable</code> 表示一个或多个可迭代对象，可以是列表、字符串、字典、集合、元组等。</p>
<blockquote>
<p>需要注意的是，该函数返回的是一个 <code>map</code> 对象，不能直接输出，可以通过 <code>for</code> 循环或者 <code>list()/tuple()</code> 等函数来显示。</p>
</blockquote>
<p>实例演示一下 &gt;&gt;&gt;&gt;</p>
<p>比如我们有一个函数 <code>f(x)=x*x</code>，要把这个函数作用在一个 list <code>[1, 2, 3, 4, 5, 6, 7, 8, 9]</code> 上，使用 <code>map()</code> 实现原理图如下：</p>
<div align=center><img src='https://cdn.jsdelivr.net/gh/TheNightIsYoung/HexoImageBed0/Img/map.png'></div>

<p>来看一下 Python map 实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">listDemo = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>]</span><br><span class="line">list_res = <span class="built_in">map</span>(<span class="keyword">lambda</span> x: x*x, listDemo)</span><br><span class="line"></span><br><span class="line">print(<span class="built_in">list</span>(list_res))</span><br><span class="line"><span class="comment"># [1, 4, 9, 16, 25, 36, 49, 64, 81]</span></span><br></pre></td></tr></table></figure>

<p>注意，map() 函数可传入多个可迭代对象作为参数 &gt;&gt;&gt;&gt;</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">listDemo1 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">listDemo2 = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line">new_list = <span class="built_in">map</span>(<span class="keyword">lambda</span> x,y: x + y, listDemo1,listDemo2)</span><br><span class="line">print(<span class="built_in">type</span>(new_list))</span><br><span class="line">print(<span class="built_in">list</span>(new_list))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output</span></span><br><span class="line"><span class="comment"># &lt;class &#x27;map&#x27;&gt;</span></span><br><span class="line"><span class="comment"># [4, 6, 8, 10, 12]</span></span><br></pre></td></tr></table></figure>

<p>由于 <code>map()</code> 函数是直接由用 C 语言写的，运行时不需要通过 Python 解释器间接调用，并且内部做了诸多优化，所以相比其他方法，此方法的运行效率最高。</p>
<hr>
<h3 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h3><p>Python 内建的 <code>filter()</code> 函数可用于过滤序列。</p>
<p>filter() 函数的功能是对 <code>iterable</code> 中的每个元素，都使用 <code>function</code> 函数判断，然后根据返回值是 <code>True</code> 还是 <code>False</code> 决定保留还是丢弃该元素，最后将返回 <code>True</code> 的元素组成一个新的可遍历的 <code>filter</code> 对象。</p>
<p>filter() 函数的基本语法格式如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">filter</span>(function, iterable)</span><br></pre></td></tr></table></figure>

<p>此格式中，funcition 参数表示要传入一个用于过滤的函数，iterable 表示一个待处理的可迭代对象。</p>
<p>【例 1】 list 中，删掉偶数，只保留奇数：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">listDemo = [<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>]</span><br><span class="line">list_res = <span class="built_in">filter</span>(<span class="keyword">lambda</span> x: x % <span class="number">2</span> == <span class="number">1</span>, listDemo)</span><br><span class="line">print(<span class="built_in">list</span>(list_res))</span><br><span class="line"><span class="comment"># [1, 3, 5, 7, 9]</span></span><br></pre></td></tr></table></figure>

<p>【例 2】 把一个序列中的空字符串删掉：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">listDemo = [<span class="string">&#x27;A&#x27;</span>, <span class="string">&#x27;&#x27;</span>, <span class="string">&#x27;B&#x27;</span>, <span class="literal">None</span>, <span class="string">&#x27;C&#x27;</span>, <span class="string">&#x27;  &#x27;</span>]</span><br><span class="line">list_res = <span class="built_in">filter</span>(<span class="keyword">lambda</span> x: x <span class="keyword">and</span> x.strip(), listDemo)</span><br><span class="line">print(<span class="built_in">list</span>(list_res))</span><br><span class="line"><span class="comment"># [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;]</span></span><br></pre></td></tr></table></figure>

<p>可见用 <code>filter()</code> 这个高阶函数，关键在于正确实现一个 “筛选” 函数。</p>
<hr>
<h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce()"></a>reduce()</h3><p>reduce() 函数通常用来对一个集合做一些累积操作。其基本语法格式为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reduce(function, iterable)</span><br></pre></td></tr></table></figure>

<p>其中，function 规定必须是一个包含 2 个参数的函数；iterable 表示可迭代对象。</p>
<blockquote>
<p>注意，reduce() 内置函数在 Python 3.x 中已经被移除，相应功能已放入了 <code>functools</code> 模块。故使用前，需 <code>from functools import reduce</code> 导入 reduce。</p>
</blockquote>
<p>如何理解 reduce() 要求 function 需要两个参数？怎样的累积操作？ &gt;&gt;&gt;&gt;</p>
<p><code>reduce</code> 把一个函数（必须接收两个参数）作用在一个序列 <code>[x1, x2, x3, ...]</code> 上，初始时 <code>reduce</code> 会从 <code>iterable</code> 中获取最开始的两个元素（x1 &amp;&amp; x2）进行 function 处理（得结果 f_d_1），然后将结果（f_d_1）继续和下一个元素（x3）进行 function 处理（得结果 f_d_2），这就是累积过程，继续…..直至完成最后一个元素的累积，其效果就是：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">reduce(function, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4)</span><br></pre></td></tr></table></figure>

<p>–</p>
<p>【 例 1】 序列求和：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line">listDemo = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br><span class="line">val = reduce(<span class="keyword">lambda</span> x,y: x + y, listDemo)</span><br><span class="line">print(val)</span><br><span class="line"><span class="comment"># 25</span></span><br></pre></td></tr></table></figure>

<p>当然求和运算可以直接用 Python 内建函数 <code>sum()</code>，不适用 <code>reduce</code>（优先考虑）也可以。</p>
<p>【 例 2】 list(tuple) 序列转数字：</p>
<p>但是如果要把一个类似于 <code>[1, 3, 5, 7, 9]</code> 的序列变换成整数<code>13579</code>，<code>reduce</code> 就可以派上用场：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line">listDemo = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">9</span>]</span><br><span class="line">res_value = reduce(<span class="keyword">lambda</span> x,y: x * <span class="number">10</span> + y, listDemo)</span><br><span class="line">print(res_value)</span><br><span class="line"><span class="comment"># 13579</span></span><br></pre></td></tr></table></figure>

<p>这个例子本身没多大用处，但是如果考虑到字符串 <code>str </code>也是一个序列，对上面的例子稍加改动，配合 <code>map()</code>，我们就可以写出把 <code>str</code> 转换为 <code>int</code> 的函数：</p>
<p>【例 3】 数字字符串转数字（类似于 int(str) 一样的功能）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> reduce</span><br><span class="line"></span><br><span class="line">DIGITS = &#123;<span class="string">&#x27;0&#x27;</span>: <span class="number">0</span>, <span class="string">&#x27;1&#x27;</span>: <span class="number">1</span>, <span class="string">&#x27;2&#x27;</span>: <span class="number">2</span>, <span class="string">&#x27;3&#x27;</span>: <span class="number">3</span>, <span class="string">&#x27;4&#x27;</span>: <span class="number">4</span>, <span class="string">&#x27;5&#x27;</span>: <span class="number">5</span>, <span class="string">&#x27;6&#x27;</span>: <span class="number">6</span>, <span class="string">&#x27;7&#x27;</span>: <span class="number">7</span>, <span class="string">&#x27;8&#x27;</span>: <span class="number">8</span>, <span class="string">&#x27;9&#x27;</span>: <span class="number">9</span>&#125;</span><br><span class="line">digits_str = <span class="string">&quot;13579&quot;</span></span><br><span class="line">res_value = reduce(<span class="keyword">lambda</span> x,y: x * <span class="number">10</span> + y, <span class="built_in">map</span>(<span class="keyword">lambda</span> x: DIGITS[x], digits_str))</span><br><span class="line">print(<span class="built_in">type</span>(res_value), res_value)</span><br><span class="line"><span class="comment"># &lt;class &#x27;int&#x27;&gt; 13579</span></span><br></pre></td></tr></table></figure>

<p>也就是说，假设 Python 没有提供 <code>int()</code> 函数，你完全可以自己写一个把字符串转化为整数的函数。</p>
<hr>
<h3 id="函数式编程小节"><a href="#函数式编程小节" class="headerlink" title="函数式编程小节"></a>函数式编程小节</h3><p>通常来说，当对集合中的元素进行一些操作时，如果操作非常简单，比如相加、累积这种，那么应该优先考虑使用 map()、filter()、reduce() 实现。另外，在数据量非常多的情况下（比如机器学习的应用），一般更倾向于函数式编程的表示，因为效率更高。</p>
<p>当然，在数据量不多的情况下，使用 for 循环等方式也可以。不过，如果要对集合中的元素做一些比较复杂的操作，考虑到代码的可读性，通常会使用 for 循环。</p>
<hr>
<h2 id="partial-偏函数"><a href="#partial-偏函数" class="headerlink" title="partial 偏函数"></a>partial 偏函数</h2><p>Python 的 <code>functools </code>模块提供了很多有用的功能，其中一个就是偏函数（Partial function）。要注意，这里的偏函数和数学意义上的偏函数不一样。</p>
<p>简单的理解偏函数，它是对原始函数的二次封装，是将现有函数的部分参数预先绑定为指定值，从而得到一个新的函数，该函数就称为偏函数。</p>
<p>相比原函数，偏函数具有较少的可变参数，从而降低了函数调用的难度。</p>
<p>定义偏函数，需使用 partial 关键字（位于 functools 模块中），其语法格式如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">偏函数名 = partial(func, *args, **kwargs)</span><br></pre></td></tr></table></figure>

<p>其中，func 指的是要封装的原函数，<code>*args</code> 和 <code>**kwargs</code> 分别用于接收无关键字实参和关键字实参。</p>
<p>【例 1】</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> partial</span><br><span class="line"><span class="comment"># 定义个原函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">display</span>(<span class="params">name,age</span>):</span></span><br><span class="line">    print(<span class="string">&quot;name:&quot;</span>, name, <span class="string">&quot;age:&quot;</span>, age)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义偏函数，其封装了 display() 函数，并为 name 参数设置了默认参数</span></span><br><span class="line">GaryFun = partial(display,name = <span class="string">&#x27;Gary&#x27;</span>)</span><br><span class="line"><span class="comment"># 由于 name 参数已经有默认值，因此调用偏函数时，可以不指定</span></span><br><span class="line">GaryFun(age = <span class="number">13</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"><span class="comment"># name: Gary age: 13</span></span><br></pre></td></tr></table></figure>

<p>注意，当前偏函数调用时，必须采用关键字参数的形式给 age 形参传参，因为如果以无关键字参数的方式，该实参将试图传递给 name 形参，Python解释器会报 TypeError 错误。</p>
<p>结合以上示例不难分析出，偏函数的本质是将函数式编程、默认参数和冗余参数结合在一起，通过偏函数传入的参数调用关系，与正常函数的参数调用关系是一致的。</p>
<p>偏函数通过将任意数量（顺序）的参数，转化为另一个带有剩余参数的函数对象，从而实现了截取函数功能（偏向）的效果。在实际应用中，可以使用一个原函数，然后将其封装多个偏函数，在调用函数时全部调用偏函数，一定程序上可以提高程序的可读性。</p>
<hr>
<h2 id="sorted-内置排序函数"><a href="#sorted-内置排序函数" class="headerlink" title="sorted 内置排序函数"></a>sorted 内置排序函数</h2><p>排序也是在程序中经常用到的算法。无论使用冒泡排序还是快速排序，排序的核心是比较两个元素的大小。</p>
<p>如果是数字，我们可以直接比较；但如果是字符串或者两个 dict 呢？直接比较数学上的大小是没有意义的，因此，比较的过程必须通过函数抽象出来。</p>
<p><strong>[1] &gt;&gt;&gt;&gt; list(int)</strong></p>
<p>我们前面提到过的，Python内置的 <code>sorted()</code> 函数就可以对 list 进行排序：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>([<span class="number">36</span>, <span class="number">5</span>, -<span class="number">12</span>, <span class="number">9</span>, -<span class="number">21</span>])</span><br><span class="line">[-<span class="number">21</span>, -<span class="number">12</span>, <span class="number">5</span>, <span class="number">9</span>, <span class="number">36</span>]</span><br></pre></td></tr></table></figure>

<p>此外，<code>sorted()</code> 函数也是一个高阶函数，它还可以接收一个 <code>key</code> 函数来实现自定义的排序，例如按绝对值大小排序：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>([<span class="number">36</span>, <span class="number">5</span>, -<span class="number">12</span>, <span class="number">9</span>, -<span class="number">21</span>], key=<span class="built_in">abs</span>)</span><br><span class="line">[<span class="number">5</span>, <span class="number">9</span>, -<span class="number">12</span>, -<span class="number">21</span>, <span class="number">36</span>]</span><br></pre></td></tr></table></figure>

<p>key 指定的函数将作用于 list 的每一个元素上，并根据 key 函数返回的结果进行排序。对比原始的 list 和经过 <code>key=abs</code> 处理过的 list：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">list</span> = [<span class="number">36</span>, <span class="number">5</span>, -<span class="number">12</span>, <span class="number">9</span>, -<span class="number">21</span>]</span><br><span class="line"></span><br><span class="line">keys = [<span class="number">36</span>, <span class="number">5</span>,  <span class="number">12</span>, <span class="number">9</span>,  <span class="number">21</span>]</span><br></pre></td></tr></table></figure>

<p>然后 <code>sorted() </code>函数按照 keys 进行排序，并按照对应关系返回 list 相应的元素。</p>
<hr>
<p><strong>[2] &gt;&gt;&gt;&gt; list(str)</strong></p>
<p>我们再看一个字符串排序的例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>([<span class="string">&#x27;bob&#x27;</span>, <span class="string">&#x27;about&#x27;</span>, <span class="string">&#x27;Zoo&#x27;</span>, <span class="string">&#x27;Credit&#x27;</span>])</span><br><span class="line">[<span class="string">&#x27;Credit&#x27;</span>, <span class="string">&#x27;Zoo&#x27;</span>, <span class="string">&#x27;about&#x27;</span>, <span class="string">&#x27;bob&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>默认情况下，对字符串排序，是按照ASCII的大小比较的，由于<code>&#39;Z&#39; &lt; &#39;a&#39;</code>，结果，大写字母<code>Z</code>会排在小写字母<code>a</code>的前面。</p>
<p>现在，我们提出排序应该忽略大小写，按照字母序排序。要实现这个算法，不必对现有代码大加改动，只要我们能用一个key函数把字符串映射为忽略大小写排序即可。忽略大小写来比较两个字符串，实际上就是先把字符串都变成大写（或者都变成小写），再比较。</p>
<p>这样，我们给 <code>sorted</code> 传入key函数，即可实现忽略大小写的排序：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">sorted</span>([<span class="string">&#x27;bob&#x27;</span>, <span class="string">&#x27;about&#x27;</span>, <span class="string">&#x27;Zoo&#x27;</span>, <span class="string">&#x27;Credit&#x27;</span>], key=<span class="built_in">str</span>.lower)</span><br><span class="line">[<span class="string">&#x27;about&#x27;</span>, <span class="string">&#x27;bob&#x27;</span>, <span class="string">&#x27;Credit&#x27;</span>, <span class="string">&#x27;Zoo&#x27;</span>]</span><br></pre></td></tr></table></figure>

<p>要进行反向排序，不必改动 key 函数，可以传入第三个参数 <code>reverse=True</code>：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; sorted([&#39;bob&#39;, &#39;about&#39;, &#39;Zoo&#39;, &#39;Credit&#39;], key&#x3D;str.lower, reverse&#x3D;True)</span><br><span class="line">[&#39;Zoo&#39;, &#39;Credit&#39;, &#39;bob&#39;, &#39;about&#39;]</span><br></pre></td></tr></table></figure>

<p>从上述例子可以看出，高阶函数的抽象能力是非常强大的，而且，核心代码可以保持得非常简洁。</p>
<blockquote>
<p>用 <code>sorted()</code> 排序的关键在于实现一个映射函数。</p>
</blockquote>
<hr>
</div><div class="article-licensing box"><div class="licensing-title"><p>Python 中的函数升阶</p><p><a href="https://www.orangeshare.cn/2018/01/11/python-zhong-de-han-shu-sheng-jie/">https://www.orangeshare.cn/2018/01/11/python-zhong-de-han-shu-sheng-jie/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>Author</h6><p>Waldeinsamkeit</p></div></div><div class="level-item is-narrow"><div><h6>Posted on</h6><p>2018-01-11</p></div></div><div class="level-item is-narrow"><div><h6>Updated on</h6><p>2022-04-04</p></div></div><div class="level-item is-narrow"><div><h6>Licensed under</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="icon" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a><a class="icon" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/Python/">Python</a></div><div class="notification is-danger">You need to set <code>install_url</code> to use ShareThis. Please set it in <code>_config.yml</code>.</div></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">Like this article? Support the author with</h3><div class="buttons is-centered"><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>Alipay</span><span class="qrcode"><img src="/" alt="Alipay"></span></a><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>Wechat</span><span class="qrcode"><img src="/" alt="Wechat"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2018/01/12/python-mian-xiang-dui-xiang-bian-cheng-zhi-lei-he-dui-xiang/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Python 面向对象编程之类和对象</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2018/01/10/python-zhong-de-han-shu/"><span class="level-item">Python 中的函数</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">Comments</h3><div class="notification is-danger">You forgot to set the <code>shortname</code> for Disqus. Please set it in <code>_config.yml</code>.</div></div></div></div><!--!--><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen  order-3 is-sticky"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="Waldeinsamkeit"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Waldeinsamkeit</p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">67</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">9</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">33</p></a></div></div></nav></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">Catalogue</h3><ul class="menu-list"><li><a class="level is-mobile" href="#lambda-匿名函数"><span class="level-left"><span class="level-item">1</span><span class="level-item">lambda 匿名函数</span></span></a></li><li><a class="level is-mobile" href="#重新认识闭包函数"><span class="level-left"><span class="level-item">2</span><span class="level-item">重新认识闭包函数</span></span></a></li><li><a class="level is-mobile" href="#Python-解释器-eval-amp-amp-exec"><span class="level-left"><span class="level-item">3</span><span class="level-item">Python 解释器 eval &amp;&amp; exec</span></span></a></li><li><a class="level is-mobile" href="#函数式编程"><span class="level-left"><span class="level-item">4</span><span class="level-item">函数式编程</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#认识函数式编程思想"><span class="level-left"><span class="level-item">4.1</span><span class="level-item">认识函数式编程思想</span></span></a></li><li><a class="level is-mobile" href="#map"><span class="level-left"><span class="level-item">4.2</span><span class="level-item">map()</span></span></a></li><li><a class="level is-mobile" href="#filter"><span class="level-left"><span class="level-item">4.3</span><span class="level-item">filter()</span></span></a></li><li><a class="level is-mobile" href="#reduce"><span class="level-left"><span class="level-item">4.4</span><span class="level-item">reduce()</span></span></a></li><li><a class="level is-mobile" href="#函数式编程小节"><span class="level-left"><span class="level-item">4.5</span><span class="level-item">函数式编程小节</span></span></a></li></ul></li><li><a class="level is-mobile" href="#partial-偏函数"><span class="level-left"><span class="level-item">5</span><span class="level-item">partial 偏函数</span></span></a></li><li><a class="level is-mobile" href="#sorted-内置排序函数"><span class="level-left"><span class="level-item">6</span><span class="level-item">sorted 内置排序函数</span></span></a></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="When Art Meets Tech" height="28"></a><p class="is-size-7"><span>&copy; 2022 Waldeinsamkeit</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p></div></div></div></div></footer><script src="https://cdnjs.loli.net/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" async></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/cookieconsent/3.1.1/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/js/lightgallery.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>
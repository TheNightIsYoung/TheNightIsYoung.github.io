<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Python 中的异常处理机制 - When Art Meets Tech</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="When Art Meets Tech"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="When Art Meets Tech"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta description="在程序运行过程中，总会遇到各种各样的错误，这会使得程序运行结果和预期不符，严重时甚至会导致程序奔溃。 在编码过程中使用合理的 异常处理机制，可以帮助程序在运行出现错误时，捕获并且并处理这些错误，进而尝试恢复程序的执行，或者进行一些程序崩溃前的必要工作（如内存中的数据写入文件等）。异常处理机制对于编写一个良好的、健壮的程序是至关重要的。"><meta property="og:type" content="blog"><meta property="og:title" content="Python 中的异常处理机制"><meta property="og:url" content="https://www.orangeshare.cn/2018/01/14/python-zhong-de-yi-chang-chu-li-ji-zhi/"><meta property="og:site_name" content="When Art Meets Tech"><meta property="og:description" content="在程序运行过程中，总会遇到各种各样的错误，这会使得程序运行结果和预期不符，严重时甚至会导致程序奔溃。 在编码过程中使用合理的 异常处理机制，可以帮助程序在运行出现错误时，捕获并且并处理这些错误，进而尝试恢复程序的执行，或者进行一些程序崩溃前的必要工作（如内存中的数据写入文件等）。异常处理机制对于编写一个良好的、健壮的程序是至关重要的。"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/TheNightIsYoung/HexoImageBed0/Img/Exctption_Class.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/TheNightIsYoung/HexoImageBed0/Img/Exctption_Class_search.gif"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/TheNightIsYoung/HexoImageBed0/Img/Exctption_Construction_Flow.png"><meta property="article:published_time" content="2018-01-14T00:40:29.000Z"><meta property="article:modified_time" content="2022-04-14T05:27:05.432Z"><meta property="article:author" content="Waldeinsamkeit"><meta property="article:tag" content="Python"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://cdn.jsdelivr.net/gh/TheNightIsYoung/HexoImageBed0/Img/Exctption_Class.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.orangeshare.cn/2018/01/14/python-zhong-de-yi-chang-chu-li-ji-zhi/"},"headline":"When Art Meets Tech","image":["https://cdn.jsdelivr.net/gh/TheNightIsYoung/HexoImageBed0/Img/Exctption_Class.png","https://cdn.jsdelivr.net/gh/TheNightIsYoung/HexoImageBed0/Img/Exctption_Class_search.gif","https://cdn.jsdelivr.net/gh/TheNightIsYoung/HexoImageBed0/Img/Exctption_Construction_Flow.png"],"datePublished":"2018-01-14T00:40:29.000Z","dateModified":"2022-04-14T05:27:05.432Z","author":{"@type":"Person","name":"Waldeinsamkeit"},"description":"在程序运行过程中，总会遇到各种各样的错误，这会使得程序运行结果和预期不符，严重时甚至会导致程序奔溃。 在编码过程中使用合理的 异常处理机制，可以帮助程序在运行出现错误时，捕获并且并处理这些错误，进而尝试恢复程序的执行，或者进行一些程序崩溃前的必要工作（如内存中的数据写入文件等）。异常处理机制对于编写一个良好的、健壮的程序是至关重要的。"}</script><link rel="canonical" href="https://www.orangeshare.cn/2018/01/14/python-zhong-de-yi-chang-chu-li-ji-zhi/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css"><link rel="stylesheet"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/cookieconsent/3.1.1/cookieconsent.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/pace/1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.2.0"></head>    <body class="is-3-column">    <nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="When Art Meets Tech" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Hexo Search" href="https://hexo.io/zh-cn/"><i class="fab fa-hotjar"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="Catalogue" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal"><i class="fas fa-angle-double-right"></i>Python 中的异常处理机制</h1><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><i class="far fa-calendar-alt"> </i><time dateTime="${date_xml(page.date)}" title="${date_xml(page.date)}">2018-01-14</time></span><span class="level-item is-hidden-mobile"><i class="far fa-calendar-check"> </i><time dateTime="${date_xml(page.updated)}" title="${date_xml(page.updated)}">2022-04-14</time></span><span class="level-item"><a class="link-muted" href="/categories/Python/">Python</a></span><span class="level-item">an hour read (About 7458 words)</span></div></div><div class="content"><p>在程序运行过程中，总会遇到各种各样的错误，这会使得程序运行结果和预期不符，严重时甚至会导致程序奔溃。</p>
<p>在编码过程中使用合理的 <strong>异常处理机制</strong>，可以帮助程序在运行出现错误时，捕获并且并处理这些错误，进而尝试恢复程序的执行，或者进行一些程序崩溃前的必要工作（如内存中的数据写入文件等）。异常处理机制对于编写一个良好的、健壮的程序是至关重要的。</p>
<a id="more"></a>

<h2 id="异常引入"><a href="#异常引入" class="headerlink" title="异常引入"></a>异常引入</h2><p>开发人员在编写程序时，难免会遇到各种各样的错误。</p>
<p>有的错误是编写人员疏忽造成的语法错误，比如缩进错误，语法格式使用错误等，这种错误是必须修复的。</p>
<p>有的错误是程序内部隐含逻辑问题造成的数据错误（调试时很方便检出），这种错误需要仔细分析相应的逻辑流程进行处理。</p>
<p>有的错误是由于用户输入造成的数据错误，比如让用户输入 URL 地址，结果得到一个空字符串，这种错误可以通过检查用户输入来做相应的处理。</p>
<p>还有一类错误是程序运行时与系统的规则冲突造成的系统错误，完全无法在程序运行过程中预测的，比如写入文件的时候，磁盘满了，写不进去了；或者从网络抓取数据，网络突然断掉了等等。这种错误在程序中通常是必须处理的，否则，程序会因为各种问题终止并退出。</p>
<p>总的来说，Python 中编写程序时遇到的错误可大致分为两类：</p>
<ol>
<li>语法错误；</li>
<li>运行时错误。</li>
</ol>
<h3 id="语法错误"><a href="#语法错误" class="headerlink" title="语法错误"></a>语法错误</h3><p>语法错误，是指解析代码时出现的错误。</p>
<p>当代码不符合 Python 语法规则时，Python 解释器在解析时就会报出 <code>SyntaxError</code> 语法错误，与此同时还会明确指出最早解析到错误的语句。</p>
<p>例如，Python 3 中已不再支持下面这种写法，运行时，解释器会报错误：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span> <span class="string">&quot;Hello,World!&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># File &quot;&lt;stdin&gt;&quot;, line 1</span></span><br><span class="line"><span class="comment">#     print &quot;Hello,World!&quot;</span></span><br><span class="line"><span class="comment">#           ^</span></span><br><span class="line"><span class="comment"># SyntaxError: Missing parentheses in call to &#x27;print&#x27;.</span></span><br></pre></td></tr></table></figure>

<p>除此之外，其它 <strong>常见的语法错误类型如下表 &gt;&gt;&gt;&gt;</strong></p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>错误类型</td>
<td>含义</td>
</tr>
<tr>
<td>SyntaxError：unexpected EOF while parsing</td>
<td>语法错误：多了无法解析的符号，检查是否多了或者少了括号。</td>
</tr>
<tr>
<td>SyntaxError：invalid character in identifier</td>
<td>有无效标识符，检查一下是否使用中文符号。</td>
</tr>
<tr>
<td>SyntaxError -&gt; IndentationError: expected an indented block</td>
<td>解析时缩进错误：检查一下代码的缩进是否正确。</td>
</tr>
<tr>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>语法错误多是开发者疏忽导致的，属于真正意义上的错误，是解释器无法容忍的，只有将程序中的所有语法错误全部纠正，程序才能执行。</p>
<p><strong>需要注意的是 &gt;&gt;&gt;&gt;</strong></p>
<p>语法错误并不需要异常处理机制的参与，它由开发人员自己保证，我们更关注的是程序运行时产生的错误（异常）。</p>
<hr>
<h3 id="运行时异常"><a href="#运行时异常" class="headerlink" title="运行时异常"></a>运行时异常</h3><p>运行时异常，即程序在语法上都是正确的，但在运行时发生了错误。</p>
<p>实例演示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">1</span>/<span class="number">0</span></span><br><span class="line"><span class="comment"># Traceback (most recent call last):</span></span><br><span class="line"><span class="comment">#   File &quot;&lt;pyshell#2&gt;&quot;, line 1, in &lt;module&gt;</span></span><br><span class="line"><span class="comment">#     a = 1/0</span></span><br><span class="line"><span class="comment"># ZeroDivisionError: division by zero</span></span><br></pre></td></tr></table></figure>

<p>可以看到，用 1 除以 0，并赋值给 a 。因为 0 作除数是没有意义的，所以运行后会产生 <code>ZeroDivisionError</code> 错误。在输出结果中，前两段指明了错误的位置，最后一句表示出错的类型。</p>
<p>Python 中，把这种运行时产生错误的情况叫做 <strong>异常（Exceptions）</strong>。除此以外，Python 中异常情况包括很多种类，常见错误类型接下文。</p>
<hr>
<h3 id="常见异常类型"><a href="#常见异常类型" class="headerlink" title="常见异常类型"></a>常见异常类型</h3><p>Python 中的错误类型也是类，它们都是从 <code>BaseException</code> 类派生的，常见见下表。更多的错误类型和其继承关系请参见：<a target="_blank" rel="noopener" href="https://docs.python.org/3/library/exceptions.html#exception-hierarchy">Exception hierarchy</a>。</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>错误类型</td>
<td>具体</td>
<td>含义</td>
</tr>
<tr>
<td>IndexError</td>
<td>list index out of range</td>
<td>索引错误：数据超出索引范围，检查一下是否数据使用越界。</td>
</tr>
<tr>
<td>TypeError</td>
<td>must be str, not int …</td>
<td>数据类型错误：不同类型数据之间的无效操作。比如字符串和数字直接拼接，此时检查一下数据类型是否使用错误。</td>
</tr>
<tr>
<td>KeyError</td>
<td>KeyError:’fond’</td>
<td>键错误：字典中没有该的 key（“fond”）对应的值，检查一下键名或者字典数据是否正确。</td>
</tr>
<tr>
<td>ValueError</td>
<td>substring not found</td>
<td>值错误：输入的数据类型跟要求的不符合。</td>
</tr>
<tr>
<td>NameError</td>
<td>name ‘a’ is not defined</td>
<td>未初始化对象：变量没有被定义就使用了，或者变量被删除后再次使用。</td>
</tr>
<tr>
<td>AttributeError</td>
<td>‘tuple’ object has no attribute ‘remove’</td>
<td>对象属性错误：当试图访问的对象属性不存在时抛出的异常</td>
</tr>
<tr>
<td>SystemExit</td>
<td>SystemExit</td>
<td>解释器请求退出，出现在 exit() 函数后。</td>
</tr>
<tr>
<td>IOError</td>
<td>IOError</td>
<td>输入/输出操作失败</td>
</tr>
<tr>
<td>ImportError</td>
<td>ModuleNotFoundError</td>
<td>导入模块/对象失败，检查一下模块是否存在或者能够正常使用。</td>
</tr>
<tr>
<td>UnicodeError</td>
<td>UnicodeDecodeError / UnicodeEncodeError / UnicodeTranslateError</td>
<td>Unicode 解码/编码/转换/时的错误：请检查字符解码/编码/转换。</td>
</tr>
<tr>
<td>AssertionError</td>
<td>AssertionError</td>
<td>当 assert 关键字后的条件为假时，程序运行会停止并抛出 AssertionError 异常</td>
</tr>
</tbody></table>
<hr>
<h2 id="引入异常处理机制"><a href="#引入异常处理机制" class="headerlink" title="引入异常处理机制"></a>引入异常处理机制</h2><p>当一个程序发生异常时，代表该程序在执行时出现了非正常的情况，无法再执行下去。默认情况下，程序是要终止的。</p>
<p>什么？！！你说你编写的程序不会出错？</p>
<p>请记住，无论你是多么优秀的程序员，你都不能保证自己的程序永远不会出错。就算你的程序没有错，用户也不一定按照你设定的规则来使用你的程序，总有一些小白或者极客会“玩弄”你的程序。</p>
<p>除此以外，你也不能保证程序的运行环境永远稳定，比如网络可能无法连接，磁盘写满 ……</p>
<p>总之，你只可以保证你的程序语法正确（?），其它的…</p>
<p>但是，作为一个负责任的程序员，我们要让自己的程序尽可能的健壮 &gt;&gt;&gt;&gt; <strong>代码要有异常处理</strong></p>
<p>即，当程序运行过程中异常产生后，可以使用捕获异常的方式获取这个异常的名称，再通过其他的逻辑代码尝试恢复程序的执行，或者进行一些程序崩溃前的必要工作，这种根据异常做出相应逻辑处理的过程叫作 <strong>异常处理</strong>。</p>
<p>自然而然的引发一个问题 &gt;&gt;&gt;&gt;</p>
<p>那么，应该如何捕获和处理异常呢？？？</p>
<p>幸运的时，所有的高级语言通常都内置了一套 <code>try...except...finally...</code> 用于捕获以及处理异常的 <strong>异常处理机制</strong>，Python 当然也不例外。</p>
<hr>
<p>异常处理机制是现代编程语言不可或缺的能力，它已经成为衡量一门编程语言是否成熟和健壮的标准之一。</p>
<h2 id="Python-中的异常处理机制"><a href="#Python-中的异常处理机制" class="headerlink" title="Python 中的异常处理机制"></a>Python 中的异常处理机制</h2><p>先来看 Python 中的基本异常处理结构：<code>try except</code> 语句块，它是 Python 异常处理机制的核心结构。</p>
<h3 id="try-except-异常处理"><a href="#try-except-异常处理" class="headerlink" title="try except 异常处理"></a>try except 异常处理</h3><p>Python 中，使用 <strong>try except</strong> 语句块捕获并处理异常的基本语法结构如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># 可能产生异常的代码块</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span> [ (Error1, Error2, ... ) [<span class="keyword">as</span> e] ]:</span><br><span class="line">    <span class="comment"># 处理异常的代码块1</span></span><br><span class="line"><span class="keyword">except</span> [ (Error3, Error4, ... ) [<span class="keyword">as</span> e] ]:</span><br><span class="line">    <span class="comment"># 处理异常的代码块2</span></span><br><span class="line"><span class="keyword">except</span>  [Exception]:</span><br><span class="line">    <span class="comment"># 处理其它异常</span></span><br></pre></td></tr></table></figure>

<p><strong>[1] &gt;&gt;&gt;&gt; 语法结构说明</strong></p>
<p>关于 try except 语法结构说明分为两个部分：结构说明 &amp;&amp; 参数说明。</p>
<p><strong>1）–&gt;</strong> 结构说明</p>
<p>try except 结构中，try 块有且仅有一个，但 except 代码块可以有多个（&gt;=0），并且每个 except 块都可以同时处理多种异常。</p>
<p>注意，except 代码块至少要有一个（没有 finally 块时，见后文），否则会产生语法错误（SyntaxError）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># SyntaxError: invalid syntax</span></span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line"><span class="comment"># SyntaxError: unexpected EOF while parsing</span></span><br></pre></td></tr></table></figure>

<p><strong>2）–&gt;</strong> 参数说明</p>
<p><code>[]</code> 括起来的参数部分可以选择使用，也可以省略。其中各部分的含义如下：</p>
<ul>
<li>(Error1, Error2,…) 、(Error3, Error4,…)：其中，Error1、Error2、Error3 和 Error4 都是具体的异常类型（参见常见异常类型）。显然，一个 except 块可以同时处理多种异常；</li>
<li>[as e]：作为可选参数，表示给异常类型起一个别名 e，这样做的好处是方便在 except 块中调用异常类型；</li>
<li>[Exception]：作为可选参数，可以代指程序可能发生的所有异常情况，其通常用在最后一个 except 块。</li>
</ul>
<p><strong>[2] &gt;&gt;&gt;&gt; 执行流程说明</strong></p>
<p>1）首先执行 try 中的代码块，如果执行过程中出现异常，系统会自动解析生成一个对应异常类型，并将该异常提交给 Python 解释器，此过程称为捕获异常。</p>
<p>2）当 Python 解释器收到异常对象时，会寻找能处理该异常对象的 except 块（取决于 except 语句中异常类型参数），如果找到合适的 except 块，则把该异常对象交给该 except 块处理，这个过程被称为处理异常。如果 Python 解释器找不到处理异常的 except 块，则程序运行终止，Python 解释器也将退出。</p>
<p>注意，如果此段程序没有用 try 包裹，又或者没有为该异常配置处理它的 except 块，则 Python 解释器将无法处理，程序就会停止运行；反之，不管程序代码块是否处于 try 块中，甚至包括 except 块中的代码，只要执行该代码块时出现了异常，系统都会自动解析生成对应类型的异常，捕获后由相应 except 处理完成，则程序可以继续执行。</p>
<hr>
<p>来看一个实例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">print(<span class="string">&quot;Begin To Run&quot;</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    a = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;输入被除数：&quot;</span>))</span><br><span class="line">    b = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;输入除数：&quot;</span>))</span><br><span class="line">    c = a / b</span><br><span class="line">    print(<span class="string">&quot;相除的结果是：&quot;</span>, c )</span><br><span class="line">    </span><br><span class="line"><span class="keyword">except</span> (ValueError, ArithmeticError): <span class="comment"># 处理 ValueError &amp; ArithmeticError 异常的 except 块</span></span><br><span class="line">    print(<span class="string">&quot;程序发生了数字格式异常、算术异常之一&quot;</span>)</span><br><span class="line">    print(<span class="string">&quot;进行特定异常处理&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span> : <span class="comment"># 其它不确定异常(省略 Exception 参数)</span></span><br><span class="line">    print(<span class="string">&quot;未知异常&quot;</span>)</span><br><span class="line">    print(<span class="string">&quot;进行异常处理&quot;</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">&quot;Continue To Run&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>程序运行结果为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Begin To Run</span><br><span class="line">输入被除数： <span class="number">3</span></span><br><span class="line">输入除数： <span class="number">0</span></span><br><span class="line">程序发生了数字格式异常、算术异常之一</span><br><span class="line">进行特定异常处理</span><br><span class="line">Continue To Run</span><br></pre></td></tr></table></figure>

<p>可以看到，第一个 except 块使用（ValueError, ArithmeticError）来指定可以处理的异常类型，这就表明该 except 块可以同时处理这 2 种类型的异常；第二个 except 块使用省略异常类的 except 语句（except Exception），它并未指定具体要处理的异常类型，表示可处理所有类型的异常，一般会作为异处理的最后一个 except 块。</p>
<p>上面，由于 try 块中引发了异常，并被 Python 解释器捕获，并找到第一个 except 块可处理相应异常，处理后，程序继续执行，输出 <code>Continue To Run</code>。</p>
<hr>
<p><strong>[3] &gt;&gt;&gt;&gt; 获取发生的特定异常相关信息</strong></p>
<p>上面，我们已经可以捕获程序中可能发生的异常，并对其进行处理。</p>
<p>但是，由于一个 except 可以同时处理多个异常，那么我们如何知道当前处理的到底是哪种类型的异常呢？</p>
<p>事实上，每种异常类型都具有了如下几个属性和方法，通过调用它们，就可以获取当前处理异常类型的相关信息：</p>
<ul>
<li>args：返回异常信息的描述字符串；</li>
<li>str(e)：返回异常信息，但不包括异常信息的类型；</li>
<li>repr(e)：返回较全的异常信息，包括异常信息的类型。</li>
</ul>
<p>基于此，我们可以给捕获到的异常类型起一个别名 e（as e），就可以访问其属性输出相应异常信息了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="number">1</span>/<span class="number">0</span></span><br><span class="line"><span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">    <span class="comment"># 访问异常的描述信息</span></span><br><span class="line">    print(e.args)</span><br><span class="line">    print(<span class="built_in">str</span>(e))</span><br><span class="line">    print(<span class="built_in">repr</span>(e))</span><br><span class="line"></span><br><span class="line"><span class="comment"># (&#x27;division by zero&#x27;,)</span></span><br><span class="line"><span class="comment"># division by zero</span></span><br><span class="line"><span class="comment"># ZeroDivisionError(&#x27;division by zero&#x27;,)</span></span><br></pre></td></tr></table></figure>

<p>从程序中可以看到，由于 except 可能接收多种异常，因此为了操作方便，直接给每一个进入到此 except 块的异常，起一个统一的别名 e。</p>
<blockquote>
<p>注意，在 Python 2.x 的早期版本中，除了使用 <code>as e</code> 这个格式，还可以将其中的 as 用逗号 <code>,</code> 代替（即 exception Exception, as）。</p>
</blockquote>
<hr>
<h3 id="深入解读异常处理块查找机制"><a href="#深入解读异常处理块查找机制" class="headerlink" title="深入解读异常处理块查找机制"></a>深入解读异常处理块查找机制</h3><p>我们知道，当位于 try 块中的程序执行出现异常时，会将该种异常捕获，同时找到对应的 except 块处理该异常。</p>
<p>那么这里就有一个问题，Python 解释器是如何找到对应的 except 块的呢？？？</p>
<p><strong>[1] &gt;&gt;&gt;&gt; 异常类</strong></p>
<p>我们知道，一个 try 块也可以对应多个 except 块，一个 except 块可以同时处理多种异常，并且如果我们想使用一个 except 块处理所有异常还可以使用省略异常类型的 except 关键字（或 Exception）。</p>
<p>你肯定困惑过，为什么 Exception 异常可以对应所有的异常处理？？？这就不得不提到异常类了。</p>
<p>事实上，异常也是类。为了表示程序中可能出现的各种异常，Python 提供了大量的异常类，这些异常类之间有严格的继承关系。如下（异常类详情请参见 <a target="_blank" rel="noopener" href="https://docs.python.org/3/library/exceptions.html#exception-hierarchy">Exception Hierarchy</a>）：</p>
<div align=center> <img src='https://cdn.jsdelivr.net/gh/TheNightIsYoung/HexoImageBed0/Img/Exctption_Class.png'> </div>

<p>可以看出，BaseException 是 Python 中所有异常类的基类，但对于我们来说，最主要的是 Exception 类，因为程序中可能出现的各种异常，都继承自 Exception。</p>
<p>了解了异常类以及其继承关系之后，就可以开始解读异常处理块的查找机制了 &gt;&gt;&gt;&gt;</p>
<p><strong>[2] &gt;&gt;&gt;&gt; 查找机制</strong></p>
<p>当 try 块捕获到异常对象后，Python 解释器会拿这个异常类型依次和各个 except 块指定的异常类进行比较，如果捕获到的这个异常类，<strong>和某个 except 块后的异常类一样，又或者是该异常类的子类</strong>，那么 Python 解释器就会调用这个 except 块来处理异常。</p>
<p>反之，Python 解释器会继续比较，直到和最后一个 except 比较完，如果没有比对成功，则证明该异常无法处理。</p>
<p>异常处理块查找机制示意图如下所示：</p>
<div align=center> <img src='https://cdn.jsdelivr.net/gh/TheNightIsYoung/HexoImageBed0/Img/Exctption_Class_search.gif'> </div>

<p>简单的异常捕获的例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    a = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;输入被除数 a：&quot;</span>))</span><br><span class="line">    b = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;输入除数 b：&quot;</span>))</span><br><span class="line">    print( a/b )</span><br><span class="line">    </span><br><span class="line"><span class="keyword">except</span> ValueError:</span><br><span class="line">    print(<span class="string">&quot;数值错误：程序只能接收整数参数&quot;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">except</span> ArithmeticError:</span><br><span class="line">    print(<span class="string">&quot;算术错误：除数不能为 0&quot;</span>)</span><br><span class="line">    </span><br><span class="line"><span class="keyword">except</span> Exception:</span><br><span class="line">    print(<span class="string">&quot;未知异常&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>该程序中，根据用户输入 a 和 b 值的不同，可能会导致 ValueError、ArithmeticError 异常：</p>
<ol>
<li>如果用户输入的 a 或者 b 是其他字符，而不是数字，会发生 ValueError 异常，try 块会捕获到该类型异常，同时 Python 解释器会调用第一个 except 块处理异常；</li>
<li>如果用户输入的 a 和 b 是数字，但 b 的值为 0，由于在进行除法运算时除数不能为 0，因此会发生 ArithmeticError 异常，try 块会捕获该异常，同时 Python 解释器会调用第二个 except 块处理异常；</li>
<li>当然，程序运行过程中，还可能由于其他因素出现异常，try 块都可以捕获，同时 Python 会调用最后一个 except 块来处理。</li>
</ol>
<hr>
<p><strong>[3] &gt;&gt;&gt;&gt; except 块异常类型定义规则</strong></p>
<p>当一个 try 块配有多个 except 块时，这些 except 块应遵循这样一个排序规则，即可处理全部异常的 except 块（参数为 Exception，也可以省略）要放到所有 except 块的后面</p>
<p>并且，所有父类异常的 except 块要放到子类异常的 except 块的后面。这意味着，一旦父类放于前面，它不但捕获该类型的错误，还把其子类也“一网打尽”，会导致其子类的 except 块永远也无法执行到（无意义的 except 块）。</p>
<p>例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    foo()</span><br><span class="line"><span class="keyword">except</span> ValueError <span class="keyword">as</span> e:</span><br><span class="line">    print(<span class="string">&#x27;ValueError&#x27;</span>)</span><br><span class="line"><span class="keyword">except</span> UnicodeError <span class="keyword">as</span> e:</span><br><span class="line">    print(<span class="string">&#x27;UnicodeError&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>第二个 except 永远也处理 UnicodeError 异常，因为 UnicodeError 是 ValueError 的子类，如果有，也被第一个 except 给处理了。</p>
<hr>
<h3 id="try-except-通用形式"><a href="#try-except-通用形式" class="headerlink" title="try except 通用形式"></a>try except 通用形式</h3><p>我们知道，try except 语句块结构是 Python 异常处理机制中的核心结构。</p>
<p>但在实际使用过程中，还可以根据实际需要在 try except 语句块结构基础上添加  else 块和 finally 块结构（都是可选的），这样就变为：</p>
<ul>
<li>try except else 语句块结构</li>
<li>try except finally 语句块结构</li>
<li>try except else finally 语句块结构</li>
</ul>
<h4 id="try-except-else-异常处理"><a href="#try-except-else-异常处理" class="headerlink" title="try except else 异常处理"></a>try except else 异常处理</h4><p>Python 异常处理还提供了一个 else 机制，也就是原有 try except 语句的基础上再添加一个 else 块，即 try except else 结构。</p>
<p>try except else 语句块结构如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># 可能产生异常的代码块</span></span><br><span class="line"><span class="keyword">except</span> [ (Error1, Error2, ... ) [<span class="keyword">as</span> e] ]:</span><br><span class="line">    <span class="comment"># 处理异常的代码块</span></span><br><span class="line"><span class="keyword">except</span>  [Exception]:</span><br><span class="line">    <span class="comment"># 处理其它异常</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># 没有捕获异常时执行</span></span><br></pre></td></tr></table></figure>

<p>注意：使用 else 包裹的代码，<strong>只有当 try 块没有捕获到任何异常时，才会得到执行</strong>；反之，如果 try 块捕获到异常，即便调用对应的 except 处理完异常，else 块中的代码也不会得到执行。</p>
<p>实例如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    result = <span class="number">20</span> / <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&#x27;请输入除数:&#x27;</span>))</span><br><span class="line">    print(result)</span><br><span class="line"><span class="keyword">except</span> ValueError:</span><br><span class="line">    print(<span class="string">&#x27;必须输入整数&#x27;</span>)</span><br><span class="line"><span class="keyword">except</span> ArithmeticError:</span><br><span class="line">    print(<span class="string">&#x27;算术错误，除数不能为 0&#x27;</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">&#x27;没有出现异常&#x27;</span>)</span><br><span class="line">    </span><br><span class="line">print(<span class="string">&quot;Continue to run&quot;</span>)</span><br><span class="line"><span class="comment"># 请输入除数: 4</span></span><br><span class="line"><span class="comment"># 5.0</span></span><br><span class="line"><span class="comment"># 没有出现异常</span></span><br><span class="line"><span class="comment"># Continue to run</span></span><br></pre></td></tr></table></figure>

<p>你可能会困惑，既然 Python 解释器按照顺序执行代码，那么 else 块有什么存在的必要呢？直接将 else 块中的代码编写在 try except 块的后面，不是一样吗？</p>
<p>事实上，<strong>else 的功能，只有当 try 块捕获到异常时才能显现出来。</strong>在这种情况下，else 块中的代码不会得到执行的机会。如下运行：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 请输入除数: &quot;2&quot;</span></span><br><span class="line"><span class="comment"># 必须输入整数</span></span><br><span class="line"><span class="comment"># Continue to run</span></span><br></pre></td></tr></table></figure>

<hr>
<h4 id="try-except-finally-异常处理"><a href="#try-except-finally-异常处理" class="headerlink" title="try except finally 异常处理"></a>try except finally 异常处理</h4><p>Python 异常处理机制还提供了一个 finally 语句，通常用来为 try 块中的程序做扫尾清理工作。</p>
<p>try except finally 基本结构如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment"># 可能产生异常的代码块</span></span><br><span class="line"><span class="keyword">except</span> [ (Error1, Error2, ... ) [<span class="keyword">as</span> e] ]:</span><br><span class="line">    <span class="comment"># 处理异常的代码块</span></span><br><span class="line"><span class="keyword">except</span>  [Exception]:</span><br><span class="line">    <span class="comment"># 处理其它异常</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># 没有捕获异常时执行</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    <span class="comment"># 是否捕获到异常都需要执行</span></span><br></pre></td></tr></table></figure>

<p>结构说明：和 else 语句不同，<strong>finally 只要求和 try 搭配使用</strong>，而至于该结构中是否包含 except 以及 else，对于 finally 都不是必须的（else 必须和 try except 搭配使用）。</p>
<p>在整个异常处理机制中，finally 语句块的功能是：<strong>无论 try 块是否发生异常，最终都要进入 finally 语句，并执行其中的代码块。</strong></p>
<p><strong>[1] &gt;&gt;&gt;&gt; finally 语句块作用</strong></p>
<p>Python 垃圾回收机制，只能帮我们回收变量、类对象、函数等占用的内存，而无法自动完成类似关闭文件、数据库连接等这些的工作。</p>
<p>基于上述 finally 语句块的特性，在某些情况下，当 try 块中的程序打开了一些物理资源（文件、数据库连接等）时，由于这些资源必须手动回收，而回收工作通常就可以放在 finally 块中。</p>
<p>当然了，回收这些物理资源并不是必须使用 finally 块，但使用 finally 块是比较好的选择。</p>
<p>这是由于，try 块不适合做资源回收工作，因为一旦 try 块中的某行代码发生异常，则其后续的代码将不会得到执行；其次 except 和 else 也不适合，它们都可能不会得到执行；而 finally 块中的代码，无论 try 块是否发生异常，该块中的代码都会被执行。</p>
<p><strong>[2] &gt;&gt;&gt;&gt; 演示实例</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    a = <span class="built_in">int</span>(<span class="built_in">input</span>(<span class="string">&quot;请输入 a 的值:&quot;</span>))</span><br><span class="line">    print(<span class="number">20</span>/a)</span><br><span class="line"><span class="keyword">except</span>:</span><br><span class="line">    print(<span class="string">&quot;发生异常！&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    print(<span class="string">&quot;执行 else 块中的代码&quot;</span>)</span><br><span class="line">   </span><br><span class="line"><span class="keyword">finally</span> :</span><br><span class="line">    print(<span class="string">&quot;执行 finally 块中的代码&quot;</span>)</span><br></pre></td></tr></table></figure>

<p><strong>1）–&gt;</strong> 正常运行此程序：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">请输入 a 的值: <span class="number">4</span></span><br><span class="line"><span class="number">5.0</span></span><br><span class="line">执行 <span class="keyword">else</span> 块中的代码</span><br><span class="line">执行 <span class="keyword">finally</span> 块中的代码</span><br></pre></td></tr></table></figure>

<p>可以看到，当 try 块中代码未发生异常时，except 块不会执行，else 块和 finally 块中的代码会被执行。</p>
<p><strong>2）–&gt;</strong> 运行中产生异常：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">请输入 a 的值: <span class="number">0</span></span><br><span class="line">发生异常！</span><br><span class="line">执行 <span class="keyword">finally</span> 块中的代码</span><br></pre></td></tr></table></figure>

<p>可以看到，当 try 块中代码发生异常时，except 块得到执行，而 else 块中的代码将不执行，finally 块中的代码仍然会被执行。</p>
<p><strong>3）–&gt;</strong> 程序异常退出情况</p>
<p>finally 块的强大还远不止此，即便当 try 块发生异常，且没有合适和 except 处理异常时，finally 块中的代码也会得到执行。例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment">#发生异常</span></span><br><span class="line">    print(<span class="number">20</span>/<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">finally</span> :</span><br><span class="line">    print(<span class="string">&quot;执行 finally 块中的代码&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 执行 finally 块中的代码</span></span><br><span class="line"><span class="comment"># Traceback (most recent call last):</span></span><br><span class="line"><span class="comment">#   File &quot;D:\python3.6\1.py&quot;, line 3, in &lt;module&gt;</span></span><br><span class="line"><span class="comment">#     print(20/0)</span></span><br><span class="line"><span class="comment"># ZeroDivisionError: division by zero</span></span><br></pre></td></tr></table></figure>

<p>可以看到，当 try 块中代码发生异常，导致程序崩溃时，在崩溃前 Python 解释器也会执行 finally 块中的代码。</p>
<hr>
<h4 id="try-except-else-finally-异常处理通用形式"><a href="#try-except-else-finally-异常处理通用形式" class="headerlink" title="try except else finally 异常处理通用形式"></a>try except else finally 异常处理通用形式</h4><p>Python 通用的异常处理语法结构如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="comment">#业务实现代码</span></span><br><span class="line"><span class="keyword">except</span> Exception1 <span class="keyword">as</span> e:</span><br><span class="line">    <span class="comment">#异常处理块1</span></span><br><span class="line">    ...</span><br><span class="line"><span class="keyword">except</span> Exception2 <span class="keyword">as</span> e:</span><br><span class="line">    <span class="comment">#异常处理块2</span></span><br><span class="line">    ...</span><br><span class="line"><span class="comment">#可以有多个 except</span></span><br><span class="line">...</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment">#正常处理块</span></span><br><span class="line"><span class="keyword">finally</span> :</span><br><span class="line">    <span class="comment">#资源回收块</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>异常处理结构流程图如下：</p>
<div align=center> <img src='https://cdn.jsdelivr.net/gh/TheNightIsYoung/HexoImageBed0/Img/Exctption_Construction_Flow.png'> </div>

<p>整个异常处理结构中，只有 try 块是必需的，也就是说：</p>
<ul>
<li>如果没有 try 块，则不能有后面的 except 块、else 块和 finally 块。但是也不能只使用 try 块，要么使用 try except 结构，要么使用 try finally 结构；</li>
<li>except 块、else 块、finally 块都是可选的，当然也可以同时出现</li>
<li>可以有多个 except 块，但捕获父类异常的 except 块应该位于捕获子类异常的 except 块的后面；</li>
<li>多个 except 块必须位于 try 块之后，finally 块必须位于所有的 except 块之后。</li>
<li>要使用 else 块，其前面必须包含 try 和 except。</li>
</ul>
<p><strong>程序退出情况下 finally 运行说明 &gt;&gt;&gt;&gt;</strong></p>
<p><strong>[1] &gt;&gt;&gt;&gt; break、continue、return 退出情况</strong></p>
<p>finally 语句不管异常是否发生都会执行。不仅如此，无论是正常退出、遇到异常退出，还是通过 break、continue、return 语句退出，finally 语句块都会执行。</p>
<p><strong>[2] &gt;&gt;&gt;&gt; 解释器退出（os._exit(1)）情况</strong></p>
<p>如果 try 块、except 块中调用了退出 Python 解释器的方法，则 finally 语句将无法得到执行。否则不管在 try 块、except 块中执行怎样的代码，出现怎样的情况，异常处理的 finally 块总会被执行。</p>
<p>实例演示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    os._exit(<span class="number">1</span>)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    print(<span class="string">&quot;执行finally语句&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>运行程序，没有任何输出。</p>
<p><strong>[3] &gt;&gt;&gt;&gt;  return、raise 中止语句</strong></p>
<p>尽量避免在 finally 块里使用 return 或 raise 等导致方法中止的语句，它将会导致 try 块、except 块中的 return、raise 语句失效。如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span>():</span></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        print(<span class="string">&quot;try 块&quot;</span>)</span><br><span class="line">        <span class="comment"># 因为 finally 块中包含了 return 语句</span></span><br><span class="line">        <span class="comment"># 所以下面的 return 语句失去作用</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">finally</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line"></span><br><span class="line">print(test())</span><br><span class="line"></span><br><span class="line"><span class="comment"># try 块</span></span><br><span class="line"><span class="comment"># False</span></span><br></pre></td></tr></table></figure>

<p>仔细思考一下，无论是否产生异常（不考虑解释器退出情况），finally 块均会执行。此时如果，try 块、except 块中包含 return、raise，而 finally 块也包含相应 return、raise 中止语句时，解释器到底该返回哪一个？？？</p>
<p>如果 Python 程序在执行 try 块、except 块包含有 return 或 raise 语句，则 Python 解释器执行到该语句时，会先去查找 finally 块，如果没有 finally 块，程序才会立即执行 return 或 raise 语句。</p>
<p>反之，如果找到 finally 块，系统立即开始执行 finally 块，只有当 finally 块执行完成后，系统才会再次跳回来执行 try 块、except 块里的 return 或 raise 语句。如果此时 finally 块里也使用了 return 或 raise 等导致方法中止的语句，finally 块己经中止了方法，系统将不会跳回去执行 try 块、except 块里的任何代码。</p>
<hr>
<h3 id="Raise-手动抛出异常"><a href="#Raise-手动抛出异常" class="headerlink" title="Raise 手动抛出异常"></a>Raise 手动抛出异常</h3><p>raise 语句的基本语法格式为：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">raise</span> [exceptionName [(reason)]]</span><br></pre></td></tr></table></figure>

<p>说明，用 <code>[]</code> 括起来的为可选参数，其作用是指定抛出的异常类型的名称，以及相应异常的描述信息。如果可选参数全部省略，则 raise 会把当前 Python 解释器检测到的上下文错误原样抛出；如果仅省略 (reason)，则在抛出指定异常时，将不附带任何的异常描述信息。</p>
<p>也就是说，raise 语句有如下三种常用的用法：</p>
<ul>
<li><strong>raise：</strong>可选参数全部缺省。该语句会把当前 Python 解释器自动检测到的上下文错误原样抛出，如没有检测到其它上下文异常则默认引发 <code>RuntimeError</code> 异常；</li>
<li><strong>raise exceptionName：</strong>raise 后带一个异常类型名称，表示手动抛出一个指定的 <code>exceptionName</code> 类型的异常（该指定异常是 Python 内置的异常类型或用户自定义异常）；</li>
<li><strong>raise exceptionName(reason)：</strong>在抛出指定类型异常的同时，附带异常的描述信息。</li>
</ul>
<p>你可能会感到非常困惑，我们都是想方设法地让程序正常运行，为什么还要手动抛出异常呢？？？</p>
<p>通常情况下，手动让程序引发异常，很多时候并不是为了让其崩溃，而是针对程序运行中可能出现的异常进行手动捕获并处理。事实上，raise 语句引发的异常通常结合 try except（else finally）异常处理结构来捕获并进行处理。</p>
<p>实例演示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        a = <span class="built_in">input</span>(<span class="string">&quot;Please enter a number: &quot;</span>)</span><br><span class="line">        <span class="comment"># 判断用户输入的是否为数字</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">not</span> a.isdigit()):</span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">&quot;Input must be a number!!!&quot;</span>)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">except</span> ValueError <span class="keyword">as</span> e:</span><br><span class="line">        print(<span class="string">&quot;引发异常：&quot;</span>, <span class="built_in">repr</span>(e))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Please enter a number:  sdf3</span></span><br><span class="line"><span class="comment"># 引发异常： Input must be a number!!!</span></span><br><span class="line"><span class="comment"># Please enter a number:  22</span></span><br></pre></td></tr></table></figure>

<p>程序执行时，当用户输入的不是数字时，程序会进入 if 判断语句，并执行 raise 引发 ValueError 异常。但由于其位于 try 块中，因为 raise 抛出的异常会被 try 捕获，并由 except 块进行处理。</p>
<p>可以看到，虽然程序中使用了 raise 语句引发异常，但程序的执行是正常的，手动抛出的异常并不会导致程序崩溃。</p>
<p><strong>无参 raise &gt;&gt;&gt;&gt;</strong></p>
<p><strong>1）–&gt;</strong> 上下文中已引发过异常</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    a = <span class="built_in">input</span>(<span class="string">&quot;Please enter a number: &quot;</span>)</span><br><span class="line">    <span class="comment"># 判断用户输入的是否为数字</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">not</span> a.isdigit()):</span><br><span class="line">        <span class="keyword">raise</span> ValueError(<span class="string">&quot;Input must be a number!!!&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span> ValueError <span class="keyword">as</span> e:</span><br><span class="line">    print(<span class="string">&quot;引发异常：&quot;</span>, <span class="built_in">repr</span>(e))</span><br><span class="line">    <span class="keyword">raise</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Please enter a number:  wer</span></span><br><span class="line"><span class="comment"># 引发异常： Input must be a number!!!</span></span><br><span class="line"><span class="comment"># Traceback (most recent call last)</span></span><br><span class="line"><span class="comment">#   File &quot;test.py&quot;, line 4, in &lt;module&gt;()</span></span><br><span class="line"><span class="comment">#    ----&gt; 5         raise ValueError(&quot;Input must be a number!!!&quot;)</span></span><br><span class="line"><span class="comment"># ValueError: Input must be a number!!!</span></span><br></pre></td></tr></table></figure>

<p>这里重点关注位于 except 块中的 raise，由于在其之前我们已经手动引发了 ValueError 异常，因此这里当再使用 raise 语句时，它会再次引发一次。</p>
<p><strong>2）–&gt;</strong> 上下文中未引发过异常</p>
<p>需要注意的是，在没有引发过异常的程序使用无参的 raise 语句时，它默认引发的是 RuntimeError 异常。例如：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    a = <span class="built_in">input</span>(<span class="string">&quot;Please enter a number: &quot;</span>)</span><br><span class="line">    <span class="comment"># 判断用户输入的是否为数字</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="keyword">not</span> a.isdigit()):</span><br><span class="line">        <span class="keyword">raise</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">except</span> RuntimeError <span class="keyword">as</span> e:</span><br><span class="line">    print(<span class="string">&quot;引发异常：&quot;</span>, <span class="built_in">repr</span>(e))</span><br><span class="line"></span><br><span class="line"><span class="comment"># Please enter a number:  abc</span></span><br><span class="line"><span class="comment"># 引发异常： RuntimeError(&#x27;No active exception to reraise&#x27;,)</span></span><br></pre></td></tr></table></figure>


</div><div class="article-licensing box"><div class="licensing-title"><p>Python 中的异常处理机制</p><p><a href="https://www.orangeshare.cn/2018/01/14/python-zhong-de-yi-chang-chu-li-ji-zhi/">https://www.orangeshare.cn/2018/01/14/python-zhong-de-yi-chang-chu-li-ji-zhi/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>Author</h6><p>Waldeinsamkeit</p></div></div><div class="level-item is-narrow"><div><h6>Posted on</h6><p>2018-01-14</p></div></div><div class="level-item is-narrow"><div><h6>Updated on</h6><p>2022-04-14</p></div></div><div class="level-item is-narrow"><div><h6>Licensed under</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="icon" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a><a class="icon" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/Python/">Python</a></div><div class="notification is-danger">You need to set <code>install_url</code> to use ShareThis. Please set it in <code>_config.yml</code>.</div></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">Like this article? Support the author with</h3><div class="buttons is-centered"><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>Alipay</span><span class="qrcode"><img src="/" alt="Alipay"></span></a><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>Wechat</span><span class="qrcode"><img src="/" alt="Wechat"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2018/01/20/python-shu-ju-fen-xi-zhi-numpy-shu-xue-ji-suan-ku/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Python 数据分析之 NumPy 数学计算库</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2018/01/13/python-mian-xiang-dui-xiang-bian-cheng-zhi-lei-de-te-shu-shu-xing-he-fang-fa/"><span class="level-item">Python 面向对象编程之类的特殊属性和方法</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">Comments</h3><div class="notification is-danger">You forgot to set the <code>shortname</code> for Disqus. Please set it in <code>_config.yml</code>.</div></div></div></div><!--!--><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen  order-3 is-sticky"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="Waldeinsamkeit"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Waldeinsamkeit</p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">118</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">13</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">43</p></a></div></div></nav></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">Catalogue</h3><ul class="menu-list"><li><a class="level is-mobile" href="#异常引入"><span class="level-left"><span class="level-item">1</span><span class="level-item">异常引入</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#语法错误"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">语法错误</span></span></a></li><li><a class="level is-mobile" href="#运行时异常"><span class="level-left"><span class="level-item">1.2</span><span class="level-item">运行时异常</span></span></a></li><li><a class="level is-mobile" href="#常见异常类型"><span class="level-left"><span class="level-item">1.3</span><span class="level-item">常见异常类型</span></span></a></li></ul></li><li><a class="level is-mobile" href="#引入异常处理机制"><span class="level-left"><span class="level-item">2</span><span class="level-item">引入异常处理机制</span></span></a></li><li><a class="level is-mobile" href="#Python-中的异常处理机制"><span class="level-left"><span class="level-item">3</span><span class="level-item">Python 中的异常处理机制</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#try-except-异常处理"><span class="level-left"><span class="level-item">3.1</span><span class="level-item">try except 异常处理</span></span></a></li><li><a class="level is-mobile" href="#深入解读异常处理块查找机制"><span class="level-left"><span class="level-item">3.2</span><span class="level-item">深入解读异常处理块查找机制</span></span></a></li><li><a class="level is-mobile" href="#try-except-通用形式"><span class="level-left"><span class="level-item">3.3</span><span class="level-item">try except 通用形式</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#try-except-else-异常处理"><span class="level-left"><span class="level-item">3.3.1</span><span class="level-item">try except else 异常处理</span></span></a></li><li><a class="level is-mobile" href="#try-except-finally-异常处理"><span class="level-left"><span class="level-item">3.3.2</span><span class="level-item">try except finally 异常处理</span></span></a></li><li><a class="level is-mobile" href="#try-except-else-finally-异常处理通用形式"><span class="level-left"><span class="level-item">3.3.3</span><span class="level-item">try except else finally 异常处理通用形式</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Raise-手动抛出异常"><span class="level-left"><span class="level-item">3.4</span><span class="level-item">Raise 手动抛出异常</span></span></a></li></ul></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="When Art Meets Tech" height="28"></a><p class="is-size-7"><span>&copy; 2024 Waldeinsamkeit</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p></div></div></div></div></footer><script src="https://cdnjs.loli.net/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" async></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/cookieconsent/3.1.1/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/js/lightgallery.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>
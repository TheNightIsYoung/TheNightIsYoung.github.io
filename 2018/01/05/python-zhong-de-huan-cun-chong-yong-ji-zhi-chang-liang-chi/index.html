<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Python 中的缓存重用机制（常量池） - When Art Meets Tech</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="When Art Meets Tech"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="When Art Meets Tech"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta description="为了减少高频使用的数据创建时申请内存和销毁时撤销内存的开销，Python 中引入了 Python 缓冲重用机制（常量池）以提高程序执行的效率。"><meta property="og:type" content="blog"><meta property="og:title" content="Python 中的缓存重用机制（常量池）"><meta property="og:url" content="https://www.orangeshare.cn/2018/01/05/python-zhong-de-huan-cun-chong-yong-ji-zhi-chang-liang-chi/"><meta property="og:site_name" content="When Art Meets Tech"><meta property="og:description" content="为了减少高频使用的数据创建时申请内存和销毁时撤销内存的开销，Python 中引入了 Python 缓冲重用机制（常量池）以提高程序执行的效率。"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://www.orangeshare.cn/img/og_image.png"><meta property="article:published_time" content="2018-01-05T13:57:09.000Z"><meta property="article:modified_time" content="2022-03-15T04:07:31.369Z"><meta property="article:author" content="Waldeinsamkeit"><meta property="article:tag" content="Python"><meta property="article:tag" content="Constants Pool"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.orangeshare.cn/2018/01/05/python-zhong-de-huan-cun-chong-yong-ji-zhi-chang-liang-chi/"},"headline":"When Art Meets Tech","image":["https://www.orangeshare.cn/img/og_image.png"],"datePublished":"2018-01-05T13:57:09.000Z","dateModified":"2022-03-15T04:07:31.369Z","author":{"@type":"Person","name":"Waldeinsamkeit"},"description":"为了减少高频使用的数据创建时申请内存和销毁时撤销内存的开销，Python 中引入了 Python 缓冲重用机制（常量池）以提高程序执行的效率。"}</script><link rel="canonical" href="https://www.orangeshare.cn/2018/01/05/python-zhong-de-huan-cun-chong-yong-ji-zhi-chang-liang-chi/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Oxanium:wght@300;400;600&amp;family=Roboto+Mono"><link rel="stylesheet" href="/css/cyberpunk.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/cookieconsent/3.1.1/cookieconsent.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/pace/1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.2.0"></head>    <body class="is-3-column">    <nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="When Art Meets Tech" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Hexo Search" href="https://hexo.io/zh-cn/"><i class="fab fa-hotjar"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="Catalogue" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal"><i class="fas fa-angle-double-right"></i>Python 中的缓存重用机制（常量池）</h1><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><i class="far fa-calendar-alt"> </i><time dateTime="${date_xml(page.date)}" title="${date_xml(page.date)}">2018-01-05</time></span><span class="level-item is-hidden-mobile"><i class="far fa-calendar-check"> </i><time dateTime="${date_xml(page.updated)}" title="${date_xml(page.updated)}">2022-03-15</time></span><span class="level-item"><a class="link-muted" href="/categories/Python/">Python</a></span><span class="level-item">38 minutes read (About 5770 words)</span></div></div><div class="content"><p>为了减少高频使用的数据创建时申请内存和销毁时撤销内存的开销，Python 中引入了 <strong>Python 缓冲重用机制（常量池）</strong>以提高程序执行的效率。</p>
<a id="more"></a>

<h2 id="何为缓存重用？"><a href="#何为缓存重用？" class="headerlink" title="何为缓存重用？"></a>何为缓存重用？</h2><p>Python 缓冲重用机制，实际上就是在 Python 解释器启动时就从内存空间中开辟出一小部分，专门用来存储高频使用的数据，以大大减少高频使用的数据创建时申请内存和销毁时撤销内存的开销。</p>
<p>Python 在存储数据时，会根据数据的读取频繁程度以及内存占用情况来考虑，是否按照一定的规则将数据存储在缓存中，这些缓存中的数据是不会被 GC（Garbage Collector）回收的。</p>
<hr>
<p>那么问题来了，内存重用机制适用于哪些基本数据类型呢？或者说哪些基本数据类型的常量会被存放到常量池中呢？</p>
<h2 id="缓存哪些数据类型？"><a href="#缓存哪些数据类型？" class="headerlink" title="缓存哪些数据类型？"></a>缓存哪些数据类型？</h2><p>Python 是否将指定数据存入缓存（常量池）中的规则：</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>是否可以重用</th>
<th>生效范围</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>范围在 [-5, 256] 之间的小整数</td>
<td>如果之前在程序中创建过，就直接存入缓存，后续不再创建</td>
<td>全局</td>
<td>小整数池</td>
</tr>
<tr>
<td>bool 类型</td>
<td>如果之前在程序中创建过，就直接存入缓存，后续不再创建</td>
<td>全局</td>
<td>bool 常量池</td>
</tr>
<tr>
<td>字符串类型数据</td>
<td>如果之前在程序中创建过，就直接存入缓存，后续不再创建</td>
<td>全局</td>
<td>字符串常量池</td>
</tr>
<tr>
<td>大于 256 的整数 Or 大于 0 的浮点型小数</td>
<td>只要在本代码块内创建过，就直接缓存，后续不再创建</td>
<td>本代码块</td>
<td></td>
</tr>
<tr>
<td>小于 0 的浮点型小数 Or 小于 -5 的整数</td>
<td>不进行缓存，每次都需要额外创建</td>
<td></td>
<td>不使用常量池</td>
</tr>
</tbody></table>
<hr>
<h2 id="实验验证"><a href="#实验验证" class="headerlink" title="实验验证"></a>实验验证</h2><p><strong>实验展示缓存重用机制（常量池机制） &gt;&gt;&gt;&gt;</strong> 通过一段程序来演示 Python 缓存机制的规则:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 范围在 [-5, 256] 之间的小整数</span></span><br><span class="line">int1 = -<span class="number">5</span></span><br><span class="line">int2 = -<span class="number">5</span></span><br><span class="line">print(<span class="string">&quot;&#123;[-5, 256] 情况下的两个变量&#125;：&quot;</span>, <span class="built_in">id</span>(int1), <span class="built_in">id</span>(int2), int1 <span class="keyword">is</span> int2)</span><br><span class="line"><span class="comment"># bool类型</span></span><br><span class="line">bool1 = <span class="literal">True</span></span><br><span class="line">bool2 = <span class="literal">True</span></span><br><span class="line">print(<span class="string">&quot;&#123;bool 类型情况下的两个变量&#125;：&quot;</span>, <span class="built_in">id</span>(bool1), <span class="built_in">id</span>(bool2), bool1 <span class="keyword">is</span> bool2)</span><br><span class="line"><span class="comment"># 对于字符串</span></span><br><span class="line">s1 = <span class="string">&quot;3344&quot;</span></span><br><span class="line">s2 = <span class="string">&quot;3344&quot;</span></span><br><span class="line">print(<span class="string">&quot;&#123;字符串情况下的两个变量&#125;&quot;</span>, <span class="built_in">id</span>(s1), <span class="built_in">id</span>(s2), s1 <span class="keyword">is</span> s2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 大于 256 的整数</span></span><br><span class="line">int3 = <span class="number">9527</span></span><br><span class="line">int4 = <span class="number">9527</span></span><br><span class="line">print(<span class="string">&quot;&#123;大于 9527 的整数情况下的两个变量&#125;&quot;</span>, <span class="built_in">id</span>(int3), <span class="built_in">id</span>(int4), int3 <span class="keyword">is</span> int4)</span><br><span class="line"><span class="comment"># 大于 0 的浮点数</span></span><br><span class="line">f1 = <span class="number">9527.0</span></span><br><span class="line">f2 = <span class="number">9527.0</span></span><br><span class="line">print(<span class="string">&quot;&#123;大于 0 的浮点数情况下的两个变量&#125;&quot;</span>, <span class="built_in">id</span>(f1), <span class="built_in">id</span>(f2), f1 <span class="keyword">is</span> f2)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 小于 0 的浮点数</span></span><br><span class="line">f3 = -<span class="number">2.45</span></span><br><span class="line">f4 = -<span class="number">2.45</span></span><br><span class="line">print(<span class="string">&quot;&#123;小于 0 的浮点数情况下的两个变量&#125;&quot;</span>, <span class="built_in">id</span>(f3), <span class="built_in">id</span>(f4), f3 <span class="keyword">is</span> f4)</span><br><span class="line"><span class="comment"># 小于 -5 的整数</span></span><br><span class="line">n1 = -<span class="number">6</span></span><br><span class="line">n2 = -<span class="number">6</span></span><br><span class="line">print(<span class="string">&quot;&#123;小于 -5 的整数情况下的两个变量&#125;&quot;</span>, <span class="built_in">id</span>(n1), <span class="built_in">id</span>(n2), n1 <span class="keyword">is</span> n2)</span><br></pre></td></tr></table></figure>

<blockquote>
<p>代码中，<strong>id()</strong> 内置函数可以用于获取变量对象的内存地址。<strong>is：</strong>比较的是 <strong>两个实例对象是不是完全相同</strong>，<strong>是不是同一个对象（占用的内存地址是否相同，内容相同）</strong>。</p>
</blockquote>
<p>运行该程序，其输出结果为：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;[-5, 256] 情况下的两个变量&#125;： 1801941456 1801941456 True</span><br><span class="line">&#123;bool 类型情况下的两个变量&#125;： 1801461008 1801461008 True</span><br><span class="line">&#123;字符串情况下的两个变量&#125; 2335217145592 2335217145592 True</span><br><span class="line">&#123;大于 256 的整数情况下的两个变量&#125; 2335216742288 2335216742288 True</span><br><span class="line">&#123;大于 0 的浮点数情况下的两个变量&#125; 2335210240160 2335210240160 True</span><br><span class="line">&#123;小于 0 的浮点数情况下的两个变量&#125; 2335210240112 2335210240136 False</span><br><span class="line">&#123;小于 -5 的整数情况下的两个变量&#125; 2335216742352 2335216742160 False</span><br></pre></td></tr></table></figure>

<p>以上输出结果中，每行都输出了 2 个相对应的变量所在的内存地址，如果相等，则表明 Python 内部对其使用了缓存机制，反之则没有。可对照以上输出结果来理解 【数据存入缓存（常量池）规则】 中具体说明。</p>
<hr>
<h3 id="神奇的-9527"><a href="#神奇的-9527" class="headerlink" title="神奇的 9527"></a>神奇的 9527</h3><p>对于 【数据存入缓存（常量池）规则】 中所提到的代码块，Python 中的函数和类都被认为是在程序中开辟了一块新的代码块。以函数为例，函数内部的代码分属一个代码块，函数外部的代码属于另一个代码块。</p>
<p>Python 缓存机制在不同的代码块中也会有不同的表现。在上面例子代码的基础上，继续编写如下程序：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fun</span>():</span></span><br><span class="line">    <span class="comment"># [-5,256]</span></span><br><span class="line">    int1 = -<span class="number">5</span></span><br><span class="line">    print(<span class="string">&quot;&#123;fun 中 -5 的存储状态&#125;&quot;</span>,<span class="built_in">id</span>(int1), <span class="built_in">id</span>(int2), int1 <span class="keyword">is</span> int2)</span><br><span class="line">    <span class="comment"># bool类型</span></span><br><span class="line">    bool3 = <span class="literal">True</span></span><br><span class="line">    print(<span class="string">&quot;&#123;fun 中 bool 类型的存储状态&#125;&quot;</span>, <span class="built_in">id</span>(bool3), <span class="built_in">id</span>(bool2), bool3 <span class="keyword">is</span> bool3)</span><br><span class="line">    <span class="comment"># 字符串类型</span></span><br><span class="line">    s1 = <span class="string">&quot;3344&quot;</span></span><br><span class="line">    print(<span class="string">&quot;&#123;fun 中 3344 字符串的存储状态&#125;&quot;</span>, <span class="built_in">id</span>(s1), <span class="built_in">id</span>(s2), s1 <span class="keyword">is</span> s2)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 大于 256</span></span><br><span class="line">    int3 = <span class="number">9527</span></span><br><span class="line">    print(<span class="string">&quot;&#123;fun 中 9527 的存储状态&#125;&quot;</span>, <span class="built_in">id</span>(int3), <span class="built_in">id</span>(int4), int3 <span class="keyword">is</span> int4)</span><br><span class="line">    <span class="comment"># 浮点类型</span></span><br><span class="line">    f1 = <span class="number">9527.0</span></span><br><span class="line">    print(<span class="string">&quot;&#123;fun 中 256.4 的存储状态&#125;&quot;</span>,<span class="built_in">id</span>(f1), <span class="built_in">id</span>(f2), f1 <span class="keyword">is</span> f2)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 小于 -5</span></span><br><span class="line">    n1 = -<span class="number">6</span></span><br><span class="line">    print(<span class="string">&quot;&#123;fun 中 -6 的存储状态&#125;&quot;</span>, <span class="built_in">id</span>(n1), <span class="built_in">id</span>(n2), n1 <span class="keyword">is</span> n2)</span><br><span class="line">   </span><br><span class="line">fun()</span><br></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;fun 中 -5 的存储状态&#125; 140403724199328 140403724199328 True</span><br><span class="line">&#123;fun 中 bool 类型的存储状态&#125; 140403724013120 140403724013120 True</span><br><span class="line">&#123;fun 中 3344 字符串的存储状态&#125; 140403700614512 140403700614512 True</span><br><span class="line">&#123;fun 中 9527 的存储状态&#125; 140403702968720 140403704573872 False</span><br><span class="line">&#123;fun 中 9527.0 的存储状态&#125; 140403704701576 140403704701216 False</span><br><span class="line">&#123;fun 中 -6 的存储状态&#125; 140403702970768 140403702970800 False</span><br></pre></td></tr></table></figure>

<p>根据输出结果可以分析出：</p>
<ul>
<li>从 -5 、bool 类型以及字符串 “3344” 的输出结果可以得知，无论是在同一代码块，还是不同的代码块，它们都使用相同的缓存内容；</li>
<li>从 9527 和 9527.0 的输出结果可以得知，如果位于同一代码块，则使用相同的缓存内容；反之，则不使用；</li>
<li>从 -6 的输出结果得知，Python 没有对其缓存进行操作。</li>
</ul>
<hr>
<h2 id="全流程验证-Python-解释器内部使用常量池机制"><a href="#全流程验证-Python-解释器内部使用常量池机制" class="headerlink" title="全流程验证 Python 解释器内部使用常量池机制"></a>全流程验证 Python 解释器内部使用常量池机制</h2><p>这里再来附一篇关于 <strong>全流程验证 Python 解释器内部使用常量池机制</strong> 的博文：</p>
<p>转载至 <code>nickchen</code> 的博文 <a target="_blank" rel="noopener" href="https://www.cnblogs.com/nickchen121/p/14498198.html">通过代码验证 Python 解释器内部使用了常量池</a></p>
<p>全文如下：</p>
<h3 id="变量的引入"><a href="#变量的引入" class="headerlink" title="变量的引入"></a>变量的引入</h3><p><strong>[1] –&gt; 为什么要有变量？</strong></p>
<p>我们知道，Python 世界就可以看作现实世界的【镜像】，我们想要做到的就是在镜像世界里面高效地解决现实世界里的繁琐任务。这首先就要求 Python 【镜像世界】中必然存在与现实世界物体（研究对象）对应的抽象表达，比如现实世界中最常见的数字、文字、图像、声音等等，在 Python 世界统一被称为：【数据】，有了数据才有后续的一切。</p>
<p>计算机语言开发者们为了使用计算机语言的人更好的在计算机中去描述这些实物数据，便在计算机语言中引入了变量这个概念，Python 也不例外。简单点说，变量就是用来描述世间万物的。</p>
<p><strong>[2] –&gt; 定义变量</strong></p>
<p>为了在计算机书写方便，定义一变量也有一定的规则，在这里我们仅说说Python中变量的定义规则，首先我们先定义两个变量：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">&quot;xuexi&quot;</span></span><br><span class="line">year = <span class="number">2021</span></span><br></pre></td></tr></table></figure>

<p>上述代码中我们便定义了两个变量，从上面定义的两个变量中，我们可以看到，变量的组成分为三个部分：</p>
<ol>
<li>变量名：反应变量值所描述的意义，并且可以用来引用变量值；</li>
<li>赋值运算符：赋值；</li>
<li>变量值：存放数据，用来记录现实世界中的某种状态。</li>
</ol>
<hr>
<h3 id="常量引入"><a href="#常量引入" class="headerlink" title="常量引入"></a>常量引入</h3><p>上面简单讲解了 Python 中的变量，通过字面意思，可以看到变量其实是一个变化的量，例如，下面这个实例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">year = <span class="number">2021</span></span><br><span class="line">year = year + <span class="number">1</span></span><br><span class="line">print(year) <span class="comment"># 输出结果：2022</span></span><br></pre></td></tr></table></figure>

<p>刚开始我们赋予了 <code>year</code> 一个变量值为 <code>2021</code>，当我们对 year 进行加 <code>1</code> 操作时，可以发现 <code>year</code> 值变成了 <code>2022</code> 。对于上述现象我们不难理解，因为之前说过 Python 中变量是用来描述世间万物的，世间万物在现实中是可以变化的，变量当然也可以随之变化。</p>
<p>但是在某个局部范围内，变量可能是不会变化的，例如在 2021 年这一年，都只会是 2021 年，没有人会说 2021 年是 2022 年。如果你有丰富的开发经验，会明白变量定义出来不是存放在那里给你看的，更多的是要拿来用的。也就是说如果在 2021 年中的某个程序需要使用 <code>year</code> 这个变量，但这个变量是不需要进行修改的。为了防止误操作对 <code>year</code> 这个变量进行了修改，计算机语言便设计了常量这个概念，也就是说，<strong>常量相对于变量是一个不会变化的量。</strong></p>
<p>在 Python 中，有没有常量呢？不严格的讲，其实是有的，只是在定义常量的时候常量名必须的全大写，例如，下面这个实例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">YEAR = <span class="number">2021</span></span><br><span class="line">YEAR = YEAR + <span class="number">1</span></span><br><span class="line">print(YEAR) <span class="comment"># 输出结果：2022</span></span><br></pre></td></tr></table></figure>

<p>上面这个常量的实例令人大吃一惊，因为使用常量 <code>YEAR</code> 后和使用变量 <code>year</code> 的结果一致，也就是说常量 <code>YEAR</code> 遭到了更改。但是，稍微解释你就明白了。</p>
<p>在 Python 中，虽然也和其他很多计算机语言一样拥有常量这个概念，但更多的是约定俗成的，Python 并没有严格的对常量进行控制，只是规定常量名必须全部大写。原因很简单：都是常量了，你为什么还要修改？？？</p>
<hr>
<h3 id="常量池引入"><a href="#常量池引入" class="headerlink" title="常量池引入"></a>常量池引入</h3><p>上面讲到常量就是一个不会变化的变量，严格的讲，在 Python 中是没有常量这个概念的。但是，在 Python 中又有另外一种例外，那就是常量池，为了搞清楚常量池，首先我们得弄明白 Python 的几个小知识，接下来一一叙说。</p>
<h4 id="Python-解释器"><a href="#Python-解释器" class="headerlink" title="Python 解释器"></a>Python 解释器</h4><p>上面提及到 Python 是计算机用来描述世间万物的一种语言，由于计算机没有人脑那么强大，计算机更多的只是认识高低压电频，再通过对高低压电频的转化进而编码成我们看到的一个又一个字符，也就是说计算机是无法直接认识利用Python写下的字符的（此处涉及计算机组成原理，不多做介绍）。</p>
<p>也就是说，当我们利用 Python 写下一个又一个字符并且交给电脑时，需要通过编码这个过程，而这个编码的过程有时候也被称为解释。解释的原理就相当于从中文转成英文，只不过此时不是需要让英文使用者看懂中文，而是让计算机能够看懂 Python。</p>
<p>中文转成英文的时候，可能需要一个翻译员或一个翻译软件，利用 Python 写下的字符转化为计算机能看懂的语言同样如此，这个转化过程也需要一个外物的帮助——Python 解释器。</p>
<hr>
<h4 id="Python-变量存储机制"><a href="#Python-变量存储机制" class="headerlink" title="Python 变量存储机制"></a>Python 变量存储机制</h4><p>假设我们使用 Python 解释器定义了以下一个变量：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">year = <span class="number">2021</span></span><br></pre></td></tr></table></figure>

<p>现在假设江西师范大学相当于电脑内存，每当有一批新学生进入师大时，师大都会开辟出一个新教室给这批新同学使用，并且会给每一个教室一个独一无二的教室牌号。由于把师大看作是内存，这批新同学就可以看成是变量值，而教室牌号就是变量名。也就是说，对于师大这个大内存，每定义一个变量 <code>year = 2021</code>，就会在这个大内存中开辟一个小空间，小空间中放变量值 <code>2021</code>，然后大内存会给这个小空间定义一个变量名 <code>year</code>，此时变量名<code>year</code> 指向变量值<code> 2021</code>。</p>
<p>上面说到每当 Python 解释器解释一个变量时，会将这个变量存放到内存中的一个小空间中，但如何知道这个小空间的具体位置呢？此处介绍 Python 的一个内置函数 <code>id()</code>，通过这个函数可以获取某一个变量所在的内存地址，例如下面这个实例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">year = <span class="number">2021</span></span><br><span class="line">print(<span class="built_in">id</span>(year))</span><br></pre></td></tr></table></figure>
<hr>
<h4 id="Python-垃圾回收机制"><a href="#Python-垃圾回收机制" class="headerlink" title="Python 垃圾回收机制"></a>Python 垃圾回收机制</h4><p>对于上述师大的例子，此处再做延伸。由于那一批学生所在班级新转来了几位同学，需要那一批学生更换更大一点教室，也就是给他们一个新的教室。那么学校应该会这样处理，首先开辟一个新的教室，然后拿下那一批学生原有教室的教室牌号更换到这个新教室，最后会清空原有教室。</p>
<p>在 Python 中，也是如此，如果到了新的一年，我们会重新定义一个 <code>year</code> 变量，也就是 <code>year = 2022</code> 。如果这是在同一个程序中如此做，Python 会沿用上述更换教室的方法，它首先会解除 <code>year</code> 和 <code>2021</code> 的连接，开辟一个新内存存放变量值 <code>2022</code> ，让 <code>year</code> 与 <code>2022</code> 连接。此时，会发现 <code>2021</code> 这个变量值只有变量值而没有变量名，因此这个没有变量名的变量值会变成 Python 眼中的一个垃圾变量，从而触发 Python 垃圾回收机制(GC)，对这个 2021 所在的内存空间进行回收。</p>
<p>为了更好地理解 Python 垃圾回收机制，可以看下面这个例子：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">year = <span class="number">2021</span></span><br><span class="line">print(<span class="built_in">id</span>(year)) <span class="comment"># 输出 2867780266704</span></span><br><span class="line">print(year) <span class="comment"># 输出 2021</span></span><br><span class="line"></span><br><span class="line">year = <span class="number">2022</span></span><br><span class="line">print(<span class="built_in">id</span>(year)) <span class="comment"># 输出 2867780267824</span></span><br><span class="line">print(year) <span class="comment"># 输出 2022</span></span><br></pre></td></tr></table></figure>

<p>通过上述例子，可以看到当新定义了一个 <code>year</code> 变量时，<code>year</code> 会与新的变量进行一个连接。当然，此处所说的垃圾回收机制只是为了引入 <strong>引用计数</strong> 这个概念，并不是完全正确的解释，并且上述实例还无法证明变量值 <code>2021</code> 所在内存是否被回收，下面将通过引用计数的实例会进一步说明并重新解释垃圾回收机制。</p>
<hr>
<h4 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h4><p>上面讲到如果某个变量值绑定着变量名，就是一个正常的变量，如果该变量值没有绑定着门牌号，这个变量就是一个垃圾变量，对于垃圾变量，Python 会触发垃圾回收机制回收这个变量所占有的内存。进而可以想到，Python 中一个变量名一定只能对应一个变量值。</p>
<p>在这里我们就不能沿用师大这个例子了，而得引出一个新的名词——引用计数。</p>
<p>为了解释引用计数，我们首先得明白在Python中，当定义了一个变量值为 <code>2021</code> 的变量时，它可以表示年份、也可以表示山的高度……也就是说一个变量名只能对应一个变量值，但是一个变量值可以对应不同的变量名，这种设计也是比较合理的。</p>
<p>现在我们引出引用计数这个概念，当相同的变量值被赋予不同的变量名时，变量值每增加一个变量名的赋予，则该变量值的引用计数加1。由于我们可以通过 Python 内置 <code>sys</code> 模块中的 <code>getrefcount()</code> 函数获取某一个变量的引用计数（<code>getrefcount</code> 输出值默认从 3 开始），可以通过下面这个例子感受下:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># 引用计数初始值为3</span></span><br><span class="line">print(sys.getrefcount(<span class="number">2021</span>)) <span class="comment"># 输出为 3</span></span><br><span class="line"></span><br><span class="line">year = <span class="number">2021</span></span><br><span class="line">print(sys.getrefcount(<span class="number">2021</span>)) <span class="comment"># 输出为 4</span></span><br><span class="line"></span><br><span class="line">height = <span class="number">2021</span></span><br><span class="line">print(sys.getrefcount(<span class="number">2021</span>)) <span class="comment"># 输出为 5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> year</span><br><span class="line">print(sys.getrefcount(<span class="number">2021</span>)) <span class="comment"># 输出为 4</span></span><br></pre></td></tr></table></figure>

<p>从上述代码可以看出变量值 <code>2021</code> 的引用计数由于每一次赋予新的变量名，引用计数都会增加，而当我们利用 <code>del</code> 关键字删除变量值 <code>2021</code> 的一个变量名 <code>year</code> 时，引用计数则会减少。</p>
<p>为了更加严谨的表达引用计数，此处不得不再次深入，引用计数字面意思可以理解为引用的次数，也就是说上面的例子其实并不严谨，更严谨的讲，只有当一个变量值每一次被直接或间接引用时，引用计数才会增加，在 Python 中让引用计数增加共有三种方法：</p>
<ol>
<li>变量被创建，变量值引用计数加 1</li>
<li>变量被引用，变量值引用计数加 1</li>
<li>变量作为参数传入到一个函数，变量值引用计数加 2</li>
</ol>
<p>具体看下述实例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line"><span class="comment"># 引用计数初始值为3</span></span><br><span class="line">print(sys.getrefcount(<span class="number">2021</span>)) <span class="comment"># 输出为 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 变量被创建，变量值引用计数加 1</span></span><br><span class="line">year = <span class="number">2021</span></span><br><span class="line">print(sys.getrefcount(<span class="number">2021</span>)) <span class="comment"># 输出为 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 变量被引用，变量值引用计数加1</span></span><br><span class="line">height = year</span><br><span class="line">print(sys.getrefcount(<span class="number">2021</span>)) <span class="comment"># 输出为 5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 变量作为参数传入到一个函数，变量值引用计数加 2</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span>(<span class="params">year</span>):</span></span><br><span class="line">    print(sys.getrefcount(year)) </span><br><span class="line"></span><br><span class="line">func(year) <span class="comment"># 输出为 7</span></span><br></pre></td></tr></table></figure>

<p>Python 中既然有增加引用计数的方法， 也当然会减少引用计数的方法，共有以下 4 种：</p>
<ol>
<li>变量值对应的变量名被销毁</li>
<li>变量值对应的变量名被赋予新的值</li>
<li>变量值对应的变量名离开它的作用域</li>
<li>变量值对应的变量名的容器被销毁</li>
</ol>
<hr>
<h4 id="重新认识-Python垃圾回收机制"><a href="#重新认识-Python垃圾回收机制" class="headerlink" title="重新认识 Python垃圾回收机制"></a>重新认识 Python垃圾回收机制</h4><p>有了 <code>getrefcount()</code> 方法并通过引用计数，我们就可以解开垃圾回收机制遗留的一个问题——如何判断是否触发了垃圾回收机制。每当一个变量定义，他的 <code>getrefcount</code> 默认输出值为 <code>3</code>，而如果该变量值被垃圾回收机制回收，则它的 <code>getrefcount</code> 输出值回到 3，可以通过下面实例验证上述猜想：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">print(sys.getrefcount(<span class="number">2021</span>)) <span class="comment"># 输出为 3</span></span><br><span class="line"></span><br><span class="line">year = <span class="number">2021</span></span><br><span class="line">print(sys.getrefcount(<span class="number">2021</span>)) <span class="comment"># 输出为 4</span></span><br><span class="line">print(<span class="built_in">id</span>(year)) <span class="comment"># 输出 4499932720</span></span><br><span class="line">print(year) <span class="comment"># 输出 2021</span></span><br><span class="line"></span><br><span class="line">year = <span class="number">2022</span></span><br><span class="line">print(sys.getrefcount(<span class="number">2021</span>)) <span class="comment"># 输出为 3</span></span><br><span class="line">print(<span class="built_in">id</span>(year)) <span class="comment"># 输出 4499932560</span></span><br><span class="line">print(year) <span class="comment"># 输出 2022</span></span><br></pre></td></tr></table></figure>

<p>通过上述实例，可以发现由于变量值 <code>2021</code> 对应的变量名被新的变量值 <code>2022</code> 引用，它的 <code>getrefcount</code> 输出值为 <code>3</code>，引用计数变成了 <code>0</code> ，因此可以证明 Python 触发了垃圾回收机制。</p>
<p>如果对上述验证 Python 触发垃圾回收机制的实例深入挖掘，会发现当把 <code>year</code> 赋给变量值 <code>2022</code> 时，变量值的 <code>2021</code> 的引用计数为 <code>0</code>，此时触发了 Python 的垃圾回收机制，那么是否可以表明只有当变量值 <code>2021</code> 的引用计数为 <code>0</code> 时才能触发垃圾回收机制呢？而不是上一次说的当变量值的变量名被新的变量值被引用了才会销毁呢？因为变量值可以对应多个变量名，下面通过下述实例验证：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line"></span><br><span class="line">print(sys.getrefcount(<span class="number">2021</span>)) <span class="comment"># 输出为 3</span></span><br><span class="line"></span><br><span class="line">year = <span class="number">2021</span></span><br><span class="line">print(sys.getrefcount(<span class="number">2021</span>)) <span class="comment"># 输出为 4</span></span><br><span class="line"></span><br><span class="line">height = <span class="number">2021</span></span><br><span class="line">print(sys.getrefcount(<span class="number">2021</span>)) <span class="comment"># 输出为 5</span></span><br><span class="line"></span><br><span class="line">year = <span class="number">2022</span></span><br><span class="line">print(sys.getrefcount(<span class="number">2021</span>)) <span class="comment"># 输出为 4</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">del</span> height</span><br><span class="line">print(sys.getrefcount(<span class="number">2021</span>)) <span class="comment"># 输出为 3</span></span><br></pre></td></tr></table></figure>

<p>通过上述实例，可以发现由于定义一个变量后，该变量对应的变量值引用计数可以不断增加，而只要引用计数不为 <code>0</code>，那么 Python 就一直还在内存中保留着这个变量值并且对其引用，只有当该变量的引用计数为 <code>0</code> 时，Python 才会触发垃圾回收机制对该变量值进行回收，这才是比较正确的垃圾回收机制。当然，如果深入，Python 的回收机制还有分代回收，此处不做延展，了解上述这些就足矣了解接下来讲的小整数池。</p>
<hr>
<h4 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h4><p>在上述各个知识的打通之后，现在可以正式引入常量池这个概念。上面讲到在 Python 中严格的讲是没有常量这个概念的，即使你通过约定俗成的方法定义了一个常量，但这个常量也只是一个变量，也就是说只要你对这个常量做出修改，这个常量原有对应的常量值引用计数就会变成 <code>0</code>，由于常量等同于变量，它一样会被 Python 垃圾回收机制回收。</p>
<p>但是在 Python 中，存在着一些例外，这些例外就是一个小整数池，顾名思义，小整数池表示的是从 <code>-5</code> 到 <code>256</code> 范围内的整数，这些整数定义出来后就是一个常量，也就是说他们的引用计数即使为 <code>0</code>，也不会被 Python 的垃圾回收机制回收。</p>
<p>通过垃圾回收机制判断小整数池中的整数是否会被垃圾回收机制回收，可用如下实例证明:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; a = 5</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; id(a)</span></span><br><span class="line">4529334480</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; del a</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; b = 5</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; id(b)</span></span><br><span class="line">4529334480</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; a = 257</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; id(a)</span></span><br><span class="line">4533920752</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; del a</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; b = 257 <span class="comment"># 消除分代回收对结果的影响</span></span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; del b</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; b = 257</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt; id(b)</span></span><br><span class="line">4531031792</span><br><span class="line"><span class="meta">&gt;</span><span class="bash">&gt;&gt;</span></span><br></pre></td></tr></table></figure>

<p>从上述实例中可以看出，变量值5即使被垃圾回收机制回收后，再次创建变量值为 <code>5</code> 的变量，该变量的内存地址始终无变化，即该变量未被垃圾回收机制回收，小整数池中的其他整数同理；而变量值 <code>257</code> 却已经被垃圾回收机制回收，非小整数池中的其他变量同理。</p>
<p>当然，还可以通过下述方法查看这些小整数池的整数的内存地址的变化，如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">256</span></span><br><span class="line">b = <span class="built_in">int</span>(<span class="string">&quot;256&quot;</span>)</span><br><span class="line">print(<span class="built_in">id</span>(a), <span class="built_in">id</span>(b))  <span class="comment"># 4544968752 4544968752</span></span><br><span class="line"></span><br><span class="line">a = <span class="number">257</span></span><br><span class="line">b = <span class="built_in">int</span>(<span class="string">&quot;257&quot;</span>)</span><br><span class="line">print(<span class="built_in">id</span>(a), <span class="built_in">id</span>(b))  <span class="comment"># 4548719792 4546289360</span></span><br><span class="line"></span><br><span class="line">a = -<span class="number">5</span></span><br><span class="line">b = <span class="built_in">int</span>(<span class="string">&quot;-5&quot;</span>)</span><br><span class="line">print(<span class="built_in">id</span>(a), <span class="built_in">id</span>(b))  <span class="comment"># 4544960400 4544960400</span></span><br><span class="line"></span><br><span class="line">a = -<span class="number">6</span></span><br><span class="line">b = <span class="built_in">int</span>(<span class="string">&quot;-6&quot;</span>)</span><br><span class="line">print(<span class="built_in">id</span>(a), <span class="built_in">id</span>(b))  <span class="comment"># 4690036912 4546289360</span></span><br></pre></td></tr></table></figure>

<p>对于上述实例，在 Python 中，由于每生成一个变量便会开辟一个新的内存空间给该变量，但是上述实例表明当变量值为 <code>-5</code> 和 <code>256</code> 时，每次开辟的内存空间地址都是一样的；而当变量值不属于 <code>[-5, 256]</code> 时，每次定义变量值时，内存空间的地址都是不一样的。</p>
<hr>
</div><div class="article-licensing box"><div class="licensing-title"><p>Python 中的缓存重用机制（常量池）</p><p><a href="https://www.orangeshare.cn/2018/01/05/python-zhong-de-huan-cun-chong-yong-ji-zhi-chang-liang-chi/">https://www.orangeshare.cn/2018/01/05/python-zhong-de-huan-cun-chong-yong-ji-zhi-chang-liang-chi/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>Author</h6><p>Waldeinsamkeit</p></div></div><div class="level-item is-narrow"><div><h6>Posted on</h6><p>2018-01-05</p></div></div><div class="level-item is-narrow"><div><h6>Updated on</h6><p>2022-03-15</p></div></div><div class="level-item is-narrow"><div><h6>Licensed under</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="icon" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a><a class="icon" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/Python/">Python</a><a class="link-muted mr-2" rel="tag" href="/tags/Constants-Pool/">Constants Pool</a></div><div class="notification is-danger">You need to set <code>install_url</code> to use ShareThis. Please set it in <code>_config.yml</code>.</div></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">Like this article? Support the author with</h3><div class="buttons is-centered"><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>Alipay</span><span class="qrcode"><img src="/" alt="Alipay"></span></a><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>Wechat</span><span class="qrcode"><img src="/" alt="Wechat"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2018/01/06/python-zi-fu-chuan-zhi-ge-shi-hua-shu-chu/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Python 字符串之格式化输出</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2018/01/05/python-zi-fu-chuan-zhi-unicode-bian-ma/"><span class="level-item">Python 字符串之 Unicode 编码</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">Comments</h3><div class="notification is-danger">You forgot to set the <code>shortname</code> for Disqus. Please set it in <code>_config.yml</code>.</div></div></div></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1 is-sticky"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="Waldeinsamkeit"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Waldeinsamkeit</p><p class="is-size-6 is-block">Web, AI Engineer</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Earth, Galactic System</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">60</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">9</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">32</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/TheNightIsYoung" target="_blank" rel="noopener">Follow</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="DockerHub" href="https://hub.docker.com/"><i class="fab fa-docker"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Gitee" href="https://gitee.com/explore"><i class="fab fa-gofore"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="MDEditor" href="http://www.mdeditor.com/"><i class="fab fa-canadian-maple-leaf"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="WangYiYun" href="https://music.163.com/"><i class="fas fa-headphones-alt"></i></a></div></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">Catalogue</h3><ul class="menu-list"><li><a class="level is-mobile" href="#何为缓存重用？"><span class="level-left"><span class="level-item">1</span><span class="level-item">何为缓存重用？</span></span></a></li><li><a class="level is-mobile" href="#缓存哪些数据类型？"><span class="level-left"><span class="level-item">2</span><span class="level-item">缓存哪些数据类型？</span></span></a></li><li><a class="level is-mobile" href="#实验验证"><span class="level-left"><span class="level-item">3</span><span class="level-item">实验验证</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#神奇的-9527"><span class="level-left"><span class="level-item">3.1</span><span class="level-item">神奇的 9527</span></span></a></li></ul></li><li><a class="level is-mobile" href="#全流程验证-Python-解释器内部使用常量池机制"><span class="level-left"><span class="level-item">4</span><span class="level-item">全流程验证 Python 解释器内部使用常量池机制</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#变量的引入"><span class="level-left"><span class="level-item">4.1</span><span class="level-item">变量的引入</span></span></a></li><li><a class="level is-mobile" href="#常量引入"><span class="level-left"><span class="level-item">4.2</span><span class="level-item">常量引入</span></span></a></li><li><a class="level is-mobile" href="#常量池引入"><span class="level-left"><span class="level-item">4.3</span><span class="level-item">常量池引入</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Python-解释器"><span class="level-left"><span class="level-item">4.3.1</span><span class="level-item">Python 解释器</span></span></a></li><li><a class="level is-mobile" href="#Python-变量存储机制"><span class="level-left"><span class="level-item">4.3.2</span><span class="level-item">Python 变量存储机制</span></span></a></li><li><a class="level is-mobile" href="#Python-垃圾回收机制"><span class="level-left"><span class="level-item">4.3.3</span><span class="level-item">Python 垃圾回收机制</span></span></a></li><li><a class="level is-mobile" href="#引用计数"><span class="level-left"><span class="level-item">4.3.4</span><span class="level-item">引用计数</span></span></a></li><li><a class="level is-mobile" href="#重新认识-Python垃圾回收机制"><span class="level-left"><span class="level-item">4.3.5</span><span class="level-item">重新认识 Python垃圾回收机制</span></span></a></li><li><a class="level is-mobile" href="#常量池"><span class="level-left"><span class="level-item">4.3.6</span><span class="level-item">常量池</span></span></a></li></ul></li></ul></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div></div><!--!--></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="When Art Meets Tech" height="28"></a><p class="is-size-7"><span>&copy; 2022 Waldeinsamkeit</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p></div></div></div></div></footer><script src="https://cdnjs.loli.net/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" async></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/cookieconsent/3.1.1/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/js/lightgallery.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>
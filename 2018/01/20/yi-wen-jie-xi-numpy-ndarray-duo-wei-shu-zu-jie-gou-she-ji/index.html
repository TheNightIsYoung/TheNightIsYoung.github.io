<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>一文解析 NumPy ndarray 多维数组结构设计 - When Art Meets Tech</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="When Art Meets Tech"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="When Art Meets Tech"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta description="从 NumPy ndarray 的内存布局以及设计哲学，深入浅析 ndarray 多维数组的结构设计，以及相关属性。"><meta property="og:type" content="blog"><meta property="og:title" content="一文解析 NumPy ndarray 多维数组结构设计"><meta property="og:url" content="https://www.orangeshare.cn/2018/01/20/yi-wen-jie-xi-numpy-ndarray-duo-wei-shu-zu-jie-gou-she-ji/"><meta property="og:site_name" content="When Art Meets Tech"><meta property="og:description" content="从 NumPy ndarray 的内存布局以及设计哲学，深入浅析 ndarray 多维数组的结构设计，以及相关属性。"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://s2.loli.net/2023/04/06/R5GZvx9wJsSKTQi.png"><meta property="og:image" content="https://s2.loli.net/2023/04/09/Vv92QBS31zmeNXa.jpg"><meta property="og:image" content="https://s2.loli.net/2023/04/09/kEQAYu7eDTx5I4G.png"><meta property="og:image" content="https://s2.loli.net/2023/04/09/3dfmZRkjhJPgEzS.png"><meta property="og:image" content="https://s2.loli.net/2023/04/09/c2alCPetmjrQzq7.png"><meta property="og:image" content="https://s2.loli.net/2023/04/10/6Uk4tHTbPljvMRe.gif"><meta property="og:image" content="https://s2.loli.net/2023/04/10/emgGQytw4kLSx5u.jpg"><meta property="og:image" content="https://s2.loli.net/2023/04/10/XOHjdIAmyJteZ9k.jpg"><meta property="og:image" content="https://s2.loli.net/2023/04/11/aWORJ9gbXSeHtv2.jpg"><meta property="og:image" content="https://s2.loli.net/2023/04/18/iVegYu9zEN5BIj1.jpg"><meta property="og:image" content="https://s2.loli.net/2023/04/18/kHCKEquZM9JlgiB.jpg"><meta property="article:published_time" content="2018-01-20T14:32:25.000Z"><meta property="article:modified_time" content="2023-05-05T10:23:29.534Z"><meta property="article:author" content="Waldeinsamkeit"><meta property="article:tag" content="Python"><meta property="article:tag" content="Data Analysis"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://s2.loli.net/2023/04/06/R5GZvx9wJsSKTQi.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.orangeshare.cn/2018/01/20/yi-wen-jie-xi-numpy-ndarray-duo-wei-shu-zu-jie-gou-she-ji/"},"headline":"When Art Meets Tech","image":["https://s2.loli.net/2023/04/06/R5GZvx9wJsSKTQi.png","https://s2.loli.net/2023/04/09/Vv92QBS31zmeNXa.jpg","https://s2.loli.net/2023/04/09/kEQAYu7eDTx5I4G.png","https://s2.loli.net/2023/04/09/3dfmZRkjhJPgEzS.png","https://s2.loli.net/2023/04/09/c2alCPetmjrQzq7.png","https://s2.loli.net/2023/04/10/6Uk4tHTbPljvMRe.gif","https://s2.loli.net/2023/04/10/emgGQytw4kLSx5u.jpg","https://s2.loli.net/2023/04/10/XOHjdIAmyJteZ9k.jpg","https://s2.loli.net/2023/04/11/aWORJ9gbXSeHtv2.jpg","https://s2.loli.net/2023/04/18/iVegYu9zEN5BIj1.jpg","https://s2.loli.net/2023/04/18/kHCKEquZM9JlgiB.jpg"],"datePublished":"2018-01-20T14:32:25.000Z","dateModified":"2023-05-05T10:23:29.534Z","author":{"@type":"Person","name":"Waldeinsamkeit"},"description":"从 NumPy ndarray 的内存布局以及设计哲学，深入浅析 ndarray 多维数组的结构设计，以及相关属性。"}</script><link rel="canonical" href="https://www.orangeshare.cn/2018/01/20/yi-wen-jie-xi-numpy-ndarray-duo-wei-shu-zu-jie-gou-she-ji/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Oxanium:wght@300;400;600&amp;family=Roboto+Mono"><link rel="stylesheet" href="/css/cyberpunk.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/cookieconsent/3.1.1/cookieconsent.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/pace/1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.2.0"></head>    <body class="is-3-column">    <nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="When Art Meets Tech" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Hexo Search" href="https://hexo.io/zh-cn/"><i class="fab fa-hotjar"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="Catalogue" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal"><i class="fas fa-angle-double-right"></i>一文解析 NumPy ndarray 多维数组结构设计</h1><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><i class="far fa-calendar-alt"> </i><time dateTime="${date_xml(page.date)}" title="${date_xml(page.date)}">2018-01-20</time></span><span class="level-item is-hidden-mobile"><i class="far fa-calendar-check"> </i><time dateTime="${date_xml(page.updated)}" title="${date_xml(page.updated)}">2023-05-05</time></span><span class="level-item"><a class="link-muted" href="/categories/Data-Analysis/">Data Analysis</a></span><span class="level-item">40 minutes read (About 5973 words)</span></div></div><div class="content"><p>从 NumPy ndarray 的内存布局以及设计哲学，深入浅析 ndarray 多维数组的结构设计，以及相关属性。</p>
<a id="more"></a>

<h2 id="What-is-NumPy"><a href="#What-is-NumPy" class="headerlink" title="What is NumPy?"></a>What is NumPy?</h2><p>官方描述 &gt;&gt;&gt;</p>
<blockquote>
<p>NumPy provides an N-dimensional array type, the <strong>ndarray</strong>, which describes a collection of <strong>“items” of the same type</strong>. The items can be <strong>indexed</strong> using for example N integers.</p>
</blockquote>
<p>ndarray 是 NumPy 中的 <font color="yellow">多维数组</font>，由 <font color="yellow">数据类型相同</font> 的元素组成的元素序列，且可以被 <font color="yellow">索引</font>。</p>
<p>如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义一个三维数组：</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arr = np.array([[[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]], [[<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>], [<span class="number">9</span>, <span class="number">10</span> ,<span class="number">11</span>]]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arr</span><br><span class="line">array([[[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>],</span><br><span class="line">        [ <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>]],</span><br><span class="line"></span><br><span class="line">       [[ <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>],</span><br><span class="line">        [ <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">type</span>(arr)</span><br><span class="line">&lt;<span class="class"><span class="keyword">class</span> &#x27;<span class="title">numpy</span>.<span class="title">ndarray</span>&#x27;&gt;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"># 数组元素类型：</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">arr</span>.<span class="title">dtype</span></span></span><br><span class="line"><span class="class"><span class="title">dtype</span>(<span class="params"><span class="string">&#x27;int32&#x27;</span></span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"># 数组维度：</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">arr</span>.<span class="title">ndim</span></span></span><br><span class="line"><span class="class">3</span></span><br><span class="line"><span class="class"># 数组形状：</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">arr</span>.<span class="title">shape</span></span></span><br><span class="line"><span class="class">(<span class="params"><span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span></span>)</span></span><br><span class="line"><span class="class"># 数组维间距（步幅）：</span></span><br><span class="line"><span class="class">&gt;&gt;&gt; <span class="title">arr</span>.<span class="title">strides</span></span></span><br><span class="line"><span class="class">(<span class="params"><span class="number">24</span>, <span class="number">12</span>, <span class="number">4</span></span>)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class"># 索引：</span></span><br><span class="line">&gt;&gt;&gt; arr[0, 1, 1]</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arr[<span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line">array([<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>])</span><br></pre></td></tr></table></figure>

<p>NumPy <strong>数值计算库的核心特性</strong> &gt;&gt;&gt; <font color="green">定义了一个 n 维数组对象，ndarray 对象（NumPy 数组也就是 ndarray 多维数组），拥有丰富的数学函数，以及对高维数组的直接处理能力。</font></p>
<hr>
<h2 id="Ndarray-的内存布局"><a href="#Ndarray-的内存布局" class="headerlink" title="Ndarray 的内存布局"></a>Ndarray 的内存布局</h2><p>首先给出 ndarray 的内存布局示意图：</p>
<div align=center><img src="https://s2.loli.net/2023/04/06/R5GZvx9wJsSKTQi.png"></div>

<p>可大致划分成 2 部分 &gt;&gt;&gt;数据部分和解释方式：</p>
<ol>
<li><code>raw array data</code> ：为一个连续的 Memory Block，存储着原始数据，以类似 <code>C</code> 或 <code>Fortran</code> 中的数组进行连续存储；</li>
<li><code>metadata</code> ：对上面内存块的解释方式。</li>
</ol>
<p>其中，metadata 包含如下信息：</p>
<ul>
<li><code>dtype</code>：数据类型 &gt;&gt;&gt; 指定了数组中每个元素占用多少个字节，这几个字节怎么解释（例如：<code>int32</code>、<code>float32</code> 等 NumPy 数据类型）；</li>
<li><code>ndim</code>（dim count）：数组维度（数值） &gt;&gt;&gt; 数组有多少维；</li>
<li><code>shape</code>（dimensions）：数组形状（元组） &gt;&gt;&gt; 每个维度上的元素数量；</li>
<li><code>strides</code>：维间距或步幅（元组） &gt;&gt;&gt; 到达当前维下一个相邻数据需要前进的字节数；</li>
</ul>
<p>以上 4 个信息构成了 ndarray 的 <code>indexing schema</code> &gt;&gt;&gt; <strong>如何索引到指定位置的数据，以及这个数据该怎么解释。</strong></p>
<p>除此之外的信息还有：字节序（大端小端）、读写权限、C-order（行优先存储） or Fortran-order（列优先存储）等，如下所示:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>arr.flags</span><br><span class="line">  C_CONTIGUOUS : <span class="literal">True</span></span><br><span class="line">  F_CONTIGUOUS : <span class="literal">False</span></span><br><span class="line">  OWNDATA : <span class="literal">True</span></span><br><span class="line">  WRITEABLE : <span class="literal">True</span></span><br><span class="line">  ALIGNED : <span class="literal">True</span></span><br><span class="line">  WRITEBACKIFCOPY : <span class="literal">False</span></span><br><span class="line">  UPDATEIFCOPY : <span class="literal">False</span></span><br></pre></td></tr></table></figure>

<p>可以很清晰看出，Ndarray 内存设计 &gt;&gt;&gt; <strong>将数组的 数据部分 &amp;&amp; 解释方式 进行了分离。</strong></p>
<hr>
<h2 id="Ndarray-的设计哲学"><a href="#Ndarray-的设计哲学" class="headerlink" title="Ndarray 的设计哲学"></a>Ndarray 的设计哲学</h2><p>事实上， Ndarray 数组的设计哲学就在于 <strong>数据存储 &amp;&amp; 与其解释方式</strong> 的分离，或者说 &gt;&gt;&gt; <strong>副本（copy）</strong> &amp;&amp; <strong>视图（view）</strong> 分离。这种分离方式，让尽可能多的操作发生在 解释方式（view）上，而尽量少地操作实际存储数据的内存区域。</p>
<p>简单来说，副本和视图是使用原数组的两种不同方式。先来看一个样例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arr = np.arange(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(arr)</span><br><span class="line">[<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"><span class="comment"># 整数数组索引：</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(arr[[<span class="number">1</span>, <span class="number">2</span>]])</span><br><span class="line">[<span class="number">1</span> <span class="number">2</span>]</span><br><span class="line"><span class="comment"># 切片（Slice）</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(arr[<span class="number">1</span>:<span class="number">3</span>])</span><br><span class="line">[<span class="number">1</span> <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># base 属性：</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(arr.base)</span><br><span class="line"><span class="literal">None</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(arr[[<span class="number">1</span>, <span class="number">2</span>]].base)</span><br><span class="line"><span class="literal">None</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(arr[<span class="number">1</span>:<span class="number">3</span>].base)</span><br><span class="line">[<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># flags.owndata 属性：</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(arr.flags.owndata)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(arr[[<span class="number">1</span>, <span class="number">2</span>]].flags.owndata)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(arr[<span class="number">1</span>:<span class="number">3</span>].flags.owndata)</span><br><span class="line"><span class="literal">False</span></span><br></pre></td></tr></table></figure>

<p>样例分析：虽然 <code>a[[1, 2]]</code> 和 <code>a[1:3]</code> 的输出结果相同，但从 <code>base</code> &amp;&amp; <code>flags.owndata</code> 属性的输出结果来看，两者是有差别的。这是因为，<code>a[[1, 2]]</code> 得到的是原数组的副本（copy），而 <code>a[1:3]</code> 得到的是原数组的视图（view）。</p>
<p>那么 <code>base</code> &amp;&amp; <code>flags.owndata</code> 属性到底代表数组的什么？！！</p>
<p>| ==================================== 👇👇👇 <strong>base &amp;&amp; flags.owndata</strong> 👇👇👇 ==================================== |</p>
<p>我们提到过，Numpy 数组的内部结构包括：数据部分（数据存储区）&amp;&amp; 解释方式（数据结构信息区）。</p>
<p>数据存储区是用于存储数组的数据 &gt;&gt;&gt; <strong>Numpy 数组中的数据可以指向其它数组中的数据，这样多个数组可以共用同一个数据（数据共享）</strong>。</p>
<ul>
<li><code>ndarray.base</code>：用于判断数组中的数据是否来自于别的数组；</li>
<li><code>ndarray.flags.owndata</code>：用于判断数组是否是数据的所有者；</li>
</ul>
<p>就上例而言，<code>arr.base</code> 和 <code>arr[[1, 2]].base</code> 返回的都是 <code>None</code>，说明两个数组中的数据均来自于自生。而 <code>arr.flags.owndata</code> 和 <code>arr[[1, 2]].flags.owndata</code> 返回的都是 <code>True</code>，说明两个数组都是数据的所有者。</p>
<p>我们再使用 <code>ndarray.ctypes.data</code> 属性来查看一下数组中数据（Memory Block）的物理地址验证一下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>arr.ctypes.data</span><br><span class="line"><span class="number">2302028351600</span></span><br><span class="line"><span class="comment"># 原始数组 arr 中数据 Memory Block 的物理地址范围：</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">&#x27;data buff address from &#123;0&#125; to &#123;1&#125;&#x27;</span>.<span class="built_in">format</span>(arr.ctypes.data, arr.ctypes.data + arr.nbytes))</span><br><span class="line">data buff address <span class="keyword">from</span> <span class="number">2302028351600</span> to <span class="number">2302028351616</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 仍位于 arr 的数据块中，共享数据，是原数组的视图（view）</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arr[<span class="number">1</span>:<span class="number">3</span>].ctypes.data</span><br><span class="line"><span class="number">2302028351604</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 已不在 arr 的数据块中，拥有自己的数据块，是原数组的副本（copy）</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arr[[<span class="number">1</span>, <span class="number">2</span>]].ctypes.data</span><br><span class="line"><span class="number">2302028205472</span></span><br></pre></td></tr></table></figure>

<p>| ================================================== <strong>Split Line</strong> =============================================== |</p>
<p>重新来看：<code>a[[1, 2]]</code> 得到的是原数组的副本（copy），而 <code>a[1:3]</code> 得到的是原数组的视图（view）？</p>
<ul>
<li>视图是对原数组的引用，或者自身没有数据，与原数组共享数据；</li>
<li>副本是对原数组的完整拷贝，虽然由原数组中数据拷贝而来，但是它相对于原数组是独立的；</li>
</ul>
<hr>
<h3 id="视图（View）"><a href="#视图（View）" class="headerlink" title="视图（View）"></a>视图（View）</h3><p>NumPy 中满足如下可产生原数组的视图（View）：</p>
<ul>
<li>对原数组的引用；</li>
<li>自身没有数据，与原数组共享数据；</li>
</ul>
<p>如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arr = np.arange(<span class="number">12</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arr</span><br><span class="line">array([ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>])</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">### =========== 1. 赋值引用 =========== ###</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cite_of_arr = arr</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>cite_of_arr</span><br><span class="line">array([ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 内存地址相同（id），为同一数组，只是一个别名：</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(arr)</span><br><span class="line"><span class="number">1910433736304</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="built_in">id</span>(cite_of_arr)</span><br><span class="line"><span class="number">1910433736304</span></span><br><span class="line"><span class="comment"># 既然是同一个数组，故：</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(arr.base)</span><br><span class="line"><span class="literal">None</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(cite_of_arr.base)</span><br><span class="line"><span class="literal">None</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(arr.flags.owndata)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(cite_of_arr.flags.owndata)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="comment">### ================================= ###</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### =========== 2. view() 函数 =========== ###</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>view_of_arr = arr.view()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>view_of_arr.shape = (<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>view_of_arr</span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">       [ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>],</span><br><span class="line">       [ <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]])</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(arr.base)</span><br><span class="line"><span class="literal">None</span></span><br><span class="line"><span class="comment"># view_of_arr 数组不是其数据的所有者，数据共享于 arr：</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(view_of_arr.base)</span><br><span class="line">[ <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span> <span class="number">10</span> <span class="number">11</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(arr.flags.owndata)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(view_of_arr.flags.owndata)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># ndarray.view() 操作产生的是 view 视图，只是对数据的解释方式发生变化（形状变化），数据物理地址相同：</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arr.ctypes.data</span><br><span class="line"><span class="number">1910429914608</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>view_of_arr.ctypes.data</span><br><span class="line"><span class="number">1910429914608</span></span><br><span class="line"><span class="comment">### ===================================== ###</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### =========== 3. reshape 操作 =========== ###</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>reshape_of_arr = arr.reshape(<span class="number">4</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>reshape_of_arr</span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>],</span><br><span class="line">       [ <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>],</span><br><span class="line">       [ <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>],</span><br><span class="line">       [ <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]])</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(arr.base)</span><br><span class="line"><span class="literal">None</span></span><br><span class="line"><span class="comment"># reshape_of_arr 数组不是其数据的所有者，数据共享于 arr：</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(reshape_of_arr.base)</span><br><span class="line">[ <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span> <span class="number">10</span> <span class="number">11</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(arr.flags.owndata)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(reshape_of_arr.flags.owndata)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># reshape 操作产生的是 view 视图，只是对数据的解释方式发生变化（形状变化），数据物理地址相同：</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arr.ctypes.data</span><br><span class="line"><span class="number">1910429914608</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>reshape_of_arr.ctypes.data</span><br><span class="line"><span class="number">1910429914608</span></span><br><span class="line"><span class="comment">### ======================================= ###</span></span><br><span class="line"></span><br><span class="line"><span class="comment">### =========== 4. ndarray.T 转置操作 =========== ###</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>transpose_of_arr = reshape_of_arr.T</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>transpose_of_arr</span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">3</span>,  <span class="number">6</span>,  <span class="number">9</span>],</span><br><span class="line">       [ <span class="number">1</span>,  <span class="number">4</span>,  <span class="number">7</span>, <span class="number">10</span>],</span><br><span class="line">       [ <span class="number">2</span>,  <span class="number">5</span>,  <span class="number">8</span>, <span class="number">11</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># reshape_of_arr 数组不是其数据的所有者，数据共享于 arr：</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(transpose_of_arr.base)</span><br><span class="line">[ <span class="number">0</span>  <span class="number">1</span>  <span class="number">2</span>  <span class="number">3</span>  <span class="number">4</span>  <span class="number">5</span>  <span class="number">6</span>  <span class="number">7</span>  <span class="number">8</span>  <span class="number">9</span> <span class="number">10</span> <span class="number">11</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(transpose_of_arr.flags.owndata)</span><br><span class="line"><span class="literal">False</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Transpose 转置操作产生的是 view 视图，只是对数据的解释方式发生变化（形状变化），数据物理地址相同：</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>transpose_of_arr.ctypes.data</span><br><span class="line"><span class="number">1910429914608</span></span><br></pre></td></tr></table></figure>

<p>视图原理剖析示意图 &gt;&gt;&gt;</p>
<div align=center><img src='https://s2.loli.net/2023/04/09/Vv92QBS31zmeNXa.jpg'></div>

<p>可见，<strong>view() 函数 &amp;&amp; reshape 操作 &amp;&amp; transpose  &amp;&amp; Slice 操作生成的是原数组视图（view）</strong>，共用原数组 <code>arr</code> 数据存储区中的数据，但由于它们都有属于自己的数据结构信息区，因此可以将 <code>arr</code> 数组中的原始数据以自己的方式进行表达（指定不同的形状、dtype 等）。</p>
<p>view 机制的好处显而易见，省内存，同时速度快~~~</p>
<hr>
<h3 id="副本（Copy）"><a href="#副本（Copy）" class="headerlink" title="副本（Copy）"></a>副本（Copy）</h3><p>副本是对原数组的完整拷贝，虽然由原数组中数据拷贝而来，但是它相对于原数组是独立的。</p>
<p>使用 <strong>copy() 函数 &amp;&amp; 数组高级索引方法</strong>，均可以返回数组的副本（Copy）。</p>
<p>如下所示：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arr = np.arange(<span class="number">12</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arr</span><br><span class="line">array([ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># copy 函数生成副本：</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>copy_of_arr = arr.copy()</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>copy_of_arr</span><br><span class="line">array([ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># # copy_of_arr 数组是其数据的所有者，拷贝但独立于 arr：</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(arr.base)</span><br><span class="line"><span class="literal">None</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(copy_of_arr.base)</span><br><span class="line"><span class="literal">None</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(arr.flags.owndata)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(copy_of_arr.flags.owndata)</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># </span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arr.ctypes.data</span><br><span class="line"><span class="number">1910429914608</span></span><br><span class="line"><span class="comment"># 原始数组 arr 中数据 Memory Block 的物理地址范围：</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print(<span class="string">&#x27;data buff address from &#123;0&#125; to &#123;1&#125;&#x27;</span>.<span class="built_in">format</span>(arr.ctypes.data, arr.ctypes.data + arr.nbytes))</span><br><span class="line">data buff address <span class="keyword">from</span> <span class="number">1910429914608</span> to <span class="number">1910429914656</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 可见，ndarray.copy() 操作产生的是 copy 副本，数据物理地址不相同：</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>copy_of_arr.ctypes.data</span><br><span class="line"><span class="number">1910429916208</span></span><br></pre></td></tr></table></figure>

<p>副本图原理剖析示意图 &gt;&gt;&gt;</p>
<div align=center><img src='https://s2.loli.net/2023/04/09/kEQAYu7eDTx5I4G.png'></div>

<p>由于副本和原数组是相互独立的，改变副本或者原数组中的元素值，相对应的原数组和副本中的元素值并不会发生改变！！！</p>
<hr>
<h3 id="设计的优异性"><a href="#设计的优异性" class="headerlink" title="设计的优异性"></a>设计的优异性</h3><p>为什么 <code>ndarray</code> 可以这样设计？！！</p>
<p>由于 <code>ndarray</code> 是为数组和矩阵运算服务的，ndarray <strong>数组中的所有数据都是同一种类型（设计核心依据）</strong>（如 <code>int32 &amp;&amp; float64...</code>），其稠密地排列在一起（元素序列）。取出时根据 dtype 现 copy 一份数据组装成 <code>scalar</code> 对象输出。</p>
<p>这样极大地节省了空间，scalar对象中除了数据之外的域没必要重复存储，同时因为连续内存的原因，可以按秩访问，速度也要快得多。</p>
<div align=center><img src='https://s2.loli.net/2023/04/09/3dfmZRkjhJPgEzS.png'></div>

<p>👇👇👇 <strong>Ndarray 性能优势</strong> 👇👇👇</p>
<p>这里，可以将 <code>ndarray</code> 与 Python 中的 <code>list</code> 对比一下 &gt;&gt;&gt;&gt;</p>
<p>List 可以容纳不同类型的对象，像 string、int、tuple 等都可以放在一个 List 里。故 List 中存放的是对象的引用，再通过引用找到具体的对象，这些对象所在的物理地址并不是连续的，如下所示：</p>
<div align=center><img src='https://s2.loli.net/2023/04/09/c2alCPetmjrQzq7.png'></div>

<p>所以相对 ndarray &gt;&gt;&gt;</p>
<ul>
<li>List 访问到数据需要多跳转 1 次，List 只能做到对对象引用的按秩访问，对具体的数据并不是按秩访问，所以效率上 ndarray 比 List 要快得多；</li>
<li>空间上，ndarray 只把数据紧密存储，而 List 需要把每个对象的所有域值都存下来，所以 ndarray 比 List 要更省空间。</li>
</ul>
<p>ndarray 设计机制的好处显而易见，省内存，同时速度快~~~</p>
<hr>
<h2 id="N-Darray-的理解"><a href="#N-Darray-的理解" class="headerlink" title="N-Darray 的理解"></a>N-Darray 的理解</h2><p>如何合理的想象多维数组？？？</p>
<p>以图书馆来举例：</p>
<p><strong>一维数组</strong> &gt;&gt;&gt; 一条线（一个行/列向量）</p>
<p><strong>二维数组</strong> &gt;&gt;&gt; 一页纸</p>
<p><strong>三维数组</strong> &gt;&gt;&gt; 一本书（多页纸）</p>
<p><strong>四维数组</strong> &gt;&gt;&gt; 书架（多本书）</p>
<p><strong>五维数组</strong> &gt;&gt;&gt; 图书室 2201（多个书架）</p>
<p><strong>六维数组</strong> &gt;&gt;&gt; 图书馆某一层，2楼/3楼（多个图书室）</p>
<p><strong>七维数组</strong> &gt;&gt;&gt; 整个图书馆</p>
<p>…</p>
<p>…</p>
<p><strong>第 N 维数组</strong> &gt;&gt;&gt; … 宇宙 …</p>
<p>| ================================================== <strong>Split Line</strong> =============================================== |</p>
<p>👇👇👇 <strong>关于 Ndarray 中的一维行向量、列向量的理解</strong> 👇👇👇</p>
<p>你可能听过这样的说法：“写数组的时候是横着写的，而其实数组是列向量（更直观）”。</p>
<p>许久以来都有一个疑问 &gt;&gt;&gt; <strong>NumPy 中的一维向量究竟是 行向量 还是 列向量 呢？？？</strong></p>
<p><font color="red">↓↓↓↓↓↓ 测试思路（向量点乘维度要对应的特性） ↓↓↓↓↓↓</font></p>
<ol>
<li>构建一个 <code>4*2</code> 的数组 arr 和一个一维的长度为 <code>2</code> 的 Numpy 向量 vec；</li>
<li>使用 arr 点乘 vec &gt;&gt;&gt; 点乘 <code>np.dot(arr, vec)</code> 不报错，说明一维向量为 <code>2*1</code> 的列向量；如果报错，说明向量肯定不是列向量。</li>
<li>如果不报错，先将 vec 转置，然后继续使用点乘 <code>np.dot(arr, vec)</code> &gt;&gt;&gt; 如果还不报错，说明一维向量 vec 既可以当做列向量也可以当做行向量。</li>
</ol>
<p>先来进行第 <code>1 &amp;&amp; 2</code> 步测试：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arr = np.array([[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]]).T</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arr</span><br><span class="line">array([[<span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">       [<span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">       [<span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">       [<span class="number">1</span>, <span class="number">1</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arr.shape</span><br><span class="line">(<span class="number">4</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>vec = np.array([<span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>vec</span><br><span class="line">array([<span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>vec.shape</span><br><span class="line">(<span class="number">2</span>,)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.dot(arr, vec)</span><br><span class="line">array([<span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>])</span><br></pre></td></tr></table></figure>

<p>可见，一维向量 vec 可以作为列向量与矩阵 arr 相乘。</p>
<p>继续进行第 <code>3</code> 步测试：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arr = np.array([[<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>], [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]]).T</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arr</span><br><span class="line">array([[<span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">       [<span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">       [<span class="number">1</span>, <span class="number">1</span>],</span><br><span class="line">       [<span class="number">1</span>, <span class="number">1</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arr.shape</span><br><span class="line">(<span class="number">4</span>, <span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>vec = np.array([<span class="number">2</span>, <span class="number">3</span>]).T</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>vec</span><br><span class="line">array([<span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>vec.shape</span><br><span class="line">(<span class="number">2</span>,)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.dot(arr, vec)</span><br><span class="line">array([<span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>, <span class="number">5</span>])</span><br></pre></td></tr></table></figure>

<p>居然也可以进行点乘，Amazing！！！说明 NumPy 中的一维向量既可以作为行向量，也可以作为列向量存在。</p>
<p>总结下来，可以得到如下结论：</p>
<p><strong>[1] &gt;&gt;&gt;&gt;</strong> 一维数组的转置仍是自己本身，这点根据上述实验的一维向量 vec 的 shape 就能看出来，vec.T（转置后）维度不变。</p>
<p><strong>[2] &gt;&gt;&gt;&gt;</strong> NumPy 中的一维向量，可以认为它既不是行向量也不是列向量，只是一个长度为 2 的一维向量。也可以把理解为它既可以做行向量同时也能做列向量，具体是行向量还是列向量根据与他进行点乘的矩阵而定。</p>
<p><strong>[3] &gt;&gt;&gt;&gt;</strong> NumPy 一维向量既可以做行向量也可以做列向量，对于任意一个给定的一维向量，你无法确定它到底是行向量还是列向量。故，习惯上用二维矩阵而不是一维矩阵来表示行向量和列向量，因为二维必定能够确定他是行向量还是列向量。</p>
<p>对于 3，见下例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 行向量：</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>row_vec = np.array([[<span class="number">2</span>, <span class="number">3</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>row_vec</span><br><span class="line">array([[<span class="number">2</span>, <span class="number">3</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>row_vec.shape</span><br><span class="line">(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列向量：</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>col_vec = np.array([[<span class="number">2</span>], [<span class="number">3</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>col_vec</span><br><span class="line">array([[<span class="number">2</span>],</span><br><span class="line">       [<span class="number">3</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>col_vec.shape</span><br><span class="line">(<span class="number">2</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="Ndarray-属性详解"><a href="#Ndarray-属性详解" class="headerlink" title="Ndarray 属性详解"></a>Ndarray 属性详解</h2><p>这一章节，我们将深入了解 Ndarray 数组中行列优先、维度、轴、形状，以及维间距等…</p>
<h3 id="C-F-Order"><a href="#C-F-Order" class="headerlink" title="C/F Order"></a>C/F Order</h3><p>前面提到过，Ndarray 数组中有一个 <code>order</code> 属性，是指数组的内存布局，常见的有：<code>C-Order</code>(行优先) &amp;&amp; <code>Fortran-Order</code>（列优先）。</p>
<p>其中，<code>C-Order</code> 是指类似于 C 语言中数组内存布局，而 <code>Fortran-Order</code> 是指类似于 Fortran 语言数组内存布局。</p>
<p>那么 &gt;&gt;&gt;&gt; <font color="red">Fortran 的列优先是什么含义，与 C 语言行优先有何区别？？？</font></p>
<p>| ================================================== <strong>Split Line</strong> =============================================== |</p>
<p>Fortran 也好，C 也好，操作的数组都存在于内存中，而 <strong>内存中是没有行列概念的</strong>。一维/二维/三维数组，都是 “一条线（序列）” 一样的存储在内存中。在这个层面上，Fortran 与 C 没有区别。</p>
<p>如下范例，内存中存储了 8 个数据：1，2，3，4，5，6，7，8（蓝色框）。</p>
<p>假设（真实地址相似） &gt;&gt;&gt; 由于数组中元素数据类型相同，每个元素所占的字节数固定（<code>int32 &amp;&amp; float32</code>），为 4 个字节。它们对应内存中的地址为（连续内存区）：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0x0041F100</span> , <span class="number">0x0041F104</span> , <span class="number">0x0041F108</span> ...... <span class="number">0x0041F11C</span></span><br></pre></td></tr></table></figure>

<div align=center><img src='https://s2.loli.net/2023/04/10/6Uk4tHTbPljvMRe.gif'></div>

<p>不同的是，Fortran 和 C 会以不同的命名习惯来对内存中的数据进行 “命名” 以实现索引，并通过各自的习惯来寻找对应的地址（索引）。</p>
<p>这是由于高级语言通常不会直接访问内存地址，所以 Fortran 和 C 使用数组来 “命名” 这些内存地址，并且通过（数组 + 下标）的索引方式来访问这些内存地址。</p>
<p><strong>1D-Ndarray</strong> &gt;&gt;&gt; 如果把这一段内存地址视为 <code>8</code> 元素的一维数组，Fortran 和 C 的规则差别不大，Fortran 默认以 <code>1</code> 开头，而 C 则以 <code>0</code> 开头（索引）&lt;&lt;&lt;&lt; Ndarray 都是从零开始。</p>
<p><strong>2D-Ndarray</strong> &gt;&gt;&gt; 如果把这一段内存地址视为 <code>2*4</code> 元素的二维数组，则 Fortran 和 C 还有另一个差异（结合示意图理解）：</p>
<ul>
<li>Fortran 会先变化前面的维度，即顺序为 <code>a(1,1) , a(2,1) ....</code> 前面的 1 先变化为 2，后面维度始终保持为 1。直到循环完毕后，再将后面的维度加一，即 <code>a(1,2) , a(2,2).....</code>；</li>
<li>C 语言则相反，会先变化后面的维度，即顺序为 <code>a[0][0] , a[0][1] ....</code> 后面的 0 先变化为 1，前面维度始终保持为 0。直到循环完毕后，再将前面的维度加一，即 <code>a[1][0] , a[1][1].....</code>。</li>
</ul>
<p>因此，对于二维数组来说，Fortran 的 <code>a(m, n)</code> 默认情况下，对应于 C 语言的 <code>a[n-1][m-1]</code>。</p>
<p>从 Ndarray 设计哲学来看，C/F Order 是对于 Memory Block 中数据的一种解释方式~~~</p>
<hr>
<p>可见，对于数组中行列的说法很容易混淆。并且，对于高维数组是不存在真正的行和列的，轴（axis）才是始终有意义的表达方式。</p>
<h3 id="维度-轴（Axis）"><a href="#维度-轴（Axis）" class="headerlink" title="维度/轴（Axis）"></a>维度/轴（Axis）</h3><p>事实上，对于 Ndarray 轴和维度的概念是通用的。</p>
<p>以三维数组为例，其包含列（Row）、行（Col）、页（Page）三个维度 &gt;&gt;&gt; </p>
<p>再来看其轴（axis），它包括 0、1、2 三个轴（即 axis=0 &amp;&amp; axis=1 &amp;&amp; axis=2）。其中，<code>axis=0</code> 代表的是页（Page）这一维；<code>axis=1</code> 代表的是列（Row）这一维；<code>axis=2</code> 代表的是行（Col）这一维。</p>
<p>也就是说，<strong>axis 越小，其代表的层次（维度）越高。</strong></p>
<p>你应该记得，前面我们说过：对于多维数组（N-Dim）的显示结果和与列表（List）相同，每多嵌套一层，就代表多一个维度（凭借此你可以很轻易的判断出某个 ndarray 数组的维度）。</p>
<p>简单来说，就是 “<strong>最外面的括号代表着 axis=0，依次往里的括号对应的 axis 的计数就依次加 1</strong>”。</p>
<p>| ================================================== <strong>Split Line</strong> =============================================== |</p>
<p><font color="red"> ↓↓↓↓↓↓ 2D Ndarray ↓↓↓↓↓↓ </font></p>
<p>举个例子，假设二维 ndarray 数组：<code>[[0, 1], [2, 3]]</code>，其 axis 的对应方式就是：</p>
<div align=center><img src='https://s2.loli.net/2023/04/10/emgGQytw4kLSx5u.jpg'></div>

<p>相应轴上的求和（sum）运算推理（确认各轴上元素，求和），先以二维数组为例：</p>
<div align=center><img src='https://s2.loli.net/2023/04/10/XOHjdIAmyJteZ9k.jpg'></div>

<p>各轴元素对应情况解析 &gt;&gt;&gt;</p>
<div align=center><img src='https://s2.loli.net/2023/04/11/aWORJ9gbXSeHtv2.jpg'></div>

<p>代码验证上述推论过程：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = np.arange(<span class="number">4</span>).reshape(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line">array([[<span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">       [<span class="number">2</span>, <span class="number">3</span>]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Axis 0:</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.<span class="built_in">sum</span>(x, axis=<span class="number">0</span>)</span><br><span class="line">array([<span class="number">2</span>, <span class="number">4</span>])</span><br><span class="line"><span class="comment"># Axis 1:</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.<span class="built_in">sum</span>(x, axis=<span class="number">1</span>)</span><br><span class="line">array([<span class="number">1</span>, <span class="number">5</span>])</span><br></pre></td></tr></table></figure>

<p>哎？！！貌似出来的结果比我们推导的结果的括号要少一些。这是因为诸如 <code>np.sum</code> 这种函数中有一个参数叫 <code>keepdims</code>，其默认值是 <code>False</code>，此时它会把多余的括号给删掉。假如我们把它设为 <code>True</code> 的话，就可以得到和推导中一致的结果了：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.<span class="built_in">sum</span>(x, axis=<span class="number">0</span>, keepdims=<span class="literal">True</span>)</span><br><span class="line">array([[<span class="number">2</span>, <span class="number">4</span>]])</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.<span class="built_in">sum</span>(x, axis=<span class="number">1</span>, keepdims=<span class="literal">True</span>)</span><br><span class="line">array([[<span class="number">1</span>],</span><br><span class="line">       [<span class="number">5</span>]])</span><br></pre></td></tr></table></figure>

<p>| ================================================== <strong>Split Line</strong> =============================================== |</p>
<p><font color="red"> ↓↓↓↓↓↓ 3D Ndarray ↓↓↓↓↓↓ </font></p>
<p>下面来看一个更 “高维” 一点的样例（三维）：</p>
<div align=center><img src="https://s2.loli.net/2023/04/18/iVegYu9zEN5BIj1.jpg"></div>

<p>代码验证上述推论过程：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = np.arange(<span class="number">8</span>).reshape((<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line">array([[[<span class="number">0</span>, <span class="number">1</span>],</span><br><span class="line">        [<span class="number">2</span>, <span class="number">3</span>]],</span><br><span class="line"></span><br><span class="line">       [[<span class="number">4</span>, <span class="number">5</span>],</span><br><span class="line">        [<span class="number">6</span>, <span class="number">7</span>]]])</span><br><span class="line"></span><br><span class="line"><span class="comment"># Axis 0:</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.<span class="built_in">sum</span>(x, axis=<span class="number">0</span>)</span><br><span class="line">array([[ <span class="number">4</span>,  <span class="number">6</span>],</span><br><span class="line">       [ <span class="number">8</span>, <span class="number">10</span>]])</span><br><span class="line"><span class="comment"># Axis 1:</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.<span class="built_in">sum</span>(x, axis=<span class="number">1</span>)</span><br><span class="line">array([[ <span class="number">2</span>,  <span class="number">4</span>],</span><br><span class="line">       [<span class="number">10</span>, <span class="number">12</span>]])</span><br><span class="line"><span class="comment"># Axis 2:</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.<span class="built_in">sum</span>(x, axis=<span class="number">2</span>)</span><br><span class="line">array([[ <span class="number">1</span>,  <span class="number">5</span>],</span><br><span class="line">       [ <span class="number">9</span>, <span class="number">13</span>]])</span><br></pre></td></tr></table></figure>

<p>以及：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Axis 0:</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.<span class="built_in">sum</span>(x, axis=<span class="number">0</span>, keepdims=<span class="literal">True</span>)</span><br><span class="line">array([[[ <span class="number">4</span>,  <span class="number">6</span>],</span><br><span class="line">        [ <span class="number">8</span>, <span class="number">10</span>]]])</span><br><span class="line"><span class="comment"># Axis 1:</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.<span class="built_in">sum</span>(x, axis=<span class="number">1</span>, keepdims=<span class="literal">True</span>)</span><br><span class="line">array([[[ <span class="number">2</span>,  <span class="number">4</span>]],</span><br><span class="line"></span><br><span class="line">       [[<span class="number">10</span>, <span class="number">12</span>]]])</span><br><span class="line"><span class="comment"># Axis 2:</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.<span class="built_in">sum</span>(x, axis=<span class="number">2</span>, keepdims=<span class="literal">True</span>)</span><br><span class="line">array([[[ <span class="number">1</span>],</span><br><span class="line">        [ <span class="number">5</span>]],</span><br><span class="line"></span><br><span class="line">       [[ <span class="number">9</span>],</span><br><span class="line">        [<span class="number">13</span>]]])</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="形状（Shape）"><a href="#形状（Shape）" class="headerlink" title="形状（Shape）"></a>形状（Shape）</h3><p>通过对 Ndarray 维度/轴的认识，我们已经知道 &gt;&gt;&gt;&gt; <font color="red"> 哪个 axis 对应于数组中的哪些元素。</font></p>
<p>接下来，通过 <code>ndarray.transpose</code> 转置函数来认识一下数组形状（Shape）的本质。</p>
<p>从纸面上来看，如果一个高维数组 <code>arr</code> 的 shape 是 <code>(2, 3, 4)</code>，那么 transpose 的作用就是把这个 shape 中各个数的顺序改一改。如下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arr = np.arange(<span class="number">24</span>).reshape((<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arr</span><br><span class="line">array([[[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">        [ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>],</span><br><span class="line">        [ <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]],</span><br><span class="line"></span><br><span class="line">       [[<span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>],</span><br><span class="line">        [<span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>],</span><br><span class="line">        [<span class="number">20</span>, <span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>]]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arr.shape</span><br><span class="line">(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>arr.transpose(<span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>).shape</span><br><span class="line">(<span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure>

<p>可以看到 &gt;&gt;&gt;&gt; <strong>数组 shape 中的各个数就是对应 axis 上的元素个数（层次由高到低）。</strong></p>
<p>如上述实例中数组 <code>arr</code>，其示意图如下：</p>
<div align=center><img src='https://s2.loli.net/2023/04/18/kHCKEquZM9JlgiB.jpg'></div>

<p><font color="red">↓↓↓↓↓↓ 换一种思路理解 ↓↓↓↓↓↓</font></p>
<p>数组 <code>arr</code> 中共有 24 个元素 &gt;&gt;&gt;&gt;</p>
<p>在 <code>axis=0</code> 轴上，只有两个元素（橙色矩阵）。可以理解为：<font color="green">在 axis=0 这个 axis 上，每隔 24 / 2 = 12 个数就跳一下</font>。</p>
<p>在 <code>axis=1</code> 轴上，由于一个橙色矩阵中只有 <code>24 / 2 = 12</code> 个数。可以理解为：<font color="green">在 axis=1 这个 axis 上，每隔 12 / 3 = 4 个数就跳一下</font>。</p>
<p>在 <code>axis=2</code> 轴上，由于一个蓝色向量中只有 <code>12 / 3 = 4</code> 个数。可以理解为：<font color="green">在 axis=2 这个 axis 上，每隔 4 / 4 = 1 个数就跳一下</font>。</p>
<p>哎，我们得到一个元组 &gt;&gt;&gt; <strong>(12, 4, 1)</strong> &lt;&lt;&lt; <strong>这就是维间距/步幅（Strides） &lt;&lt;&lt; 记录了每个 axis 上跳过的数。</strong></p>
<p>| ================================================== <strong>Split Line</strong> =============================================== |</p>
<p>激动人心的时刻到了：</p>
<p><strong>transpose 的本质，其实就是对 axis/shape/strides 中各个数的顺序进行调换（换轴）。</strong>如上实例：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x.transpose(<span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>)</span><br><span class="line">array([[[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">        [<span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>]],</span><br><span class="line"></span><br><span class="line">       [[ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>],</span><br><span class="line">        [<span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>]],</span><br><span class="line"></span><br><span class="line">       [[ <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>],</span><br><span class="line">        [<span class="number">20</span>, <span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>]]])</span><br></pre></td></tr></table></figure>

<p>在 transpose(1, 0, 2) 后，相应的 strides 会变成 (4, 12, 1)。而从上图可以看出，transpose 的结果确实满足：</p>
<ul>
<li>axis=0 的 axis 上，每隔 4 个数跳一下；</li>
<li>axis=1 的 axis 上，每隔 12 个数跳一下；</li>
<li>axis=2 的 axis 上，每隔 1 个数跳一下。</li>
</ul>
<p>👇👇👇 <strong>需要注意</strong> 👇👇👇</p>
<p>有没有同学计算之后，认为换轴后 strides 会变成 (8, 4, 1)？？？</p>
<p>你需要注意的是，数组中数据元素是在一个连续的 Memory Block（<code>[0, 1, 2, 3, 4, ..., 23]</code>）存储的，而 <code>transpose</code> 仅是数据的一种解释行为，数据元素序列是不会变化的！！！</p>
<p>以 <code>axis=0</code> 轴为例，每隔 4 个数跳一下，指的是 &gt;&gt;&gt; 元素序列上元素每隔 4 个数跳一下，即跳到 axis=0 轴下一个元素 &gt;&gt;&gt; <code>[0, 1, 2, 3] --&gt; [4, 5, 6, 7] --&gt;[8, 9, 10, 11]</code>。</p>
<hr>
<h3 id="维间距-步幅（Strides）"><a href="#维间距-步幅（Strides）" class="headerlink" title="维间距/步幅（Strides）"></a>维间距/步幅（Strides）</h3><p>我们知道的是，执行换轴操作（<code>transpose</code>）后，会同时引发数组形状（Shape）和步幅（Strides）的变化，这是必然的！！！</p>
<p>代码验证上述推论过程：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x = np.arange(<span class="number">24</span>).reshape([<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x</span><br><span class="line">array([[[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">        [ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>],</span><br><span class="line">        [ <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]],</span><br><span class="line"></span><br><span class="line">       [[<span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>],</span><br><span class="line">        [<span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>],</span><br><span class="line">        [<span class="number">20</span>, <span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>]]])</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x.shape</span><br><span class="line">(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x.transpose(<span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>).shape</span><br><span class="line">(<span class="number">3</span>, <span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x.strides</span><br><span class="line">(<span class="number">48</span>, <span class="number">16</span>, <span class="number">4</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>x.transpose(<span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>).strides</span><br><span class="line">(<span class="number">16</span>, <span class="number">48</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure>

<p>哎，怎么和上面实例提到的 <code>Strides</code> 不一样啊？！！</p>
<p>事实上，<strong>维间距/步幅（Strides）记录的是 &gt;&gt;&gt;&gt; 每个 axis 轴上跳过的字节数（Bytes）</strong>。</p>
<p>所以，你需要在上面的基础上乘以每个元素的字节大小，验证一下：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>x.itemsize</span><br><span class="line"><span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>before_strides = [<span class="built_in">int</span>(item / x.itemsize) <span class="keyword">for</span> item <span class="keyword">in</span> (x.strides)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>before_strides</span><br><span class="line">[<span class="number">12</span>, <span class="number">4</span>, <span class="number">1</span>]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>before_strides = [<span class="built_in">int</span>(item / x.itemsize) <span class="keyword">for</span> item <span class="keyword">in</span> (x.transpose(<span class="number">1</span>, <span class="number">0</span>, <span class="number">2</span>).strides)]</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>before_strides</span><br><span class="line">[<span class="number">4</span>, <span class="number">12</span>, <span class="number">1</span>]</span><br></pre></td></tr></table></figure>

<p>👇👇👇 <strong>总结一下</strong> 👇👇👇</p>
<p>数组 x 以 96(24 个值 * 4 = 96) 个字节的形式存储在内存中，一个接一个(连续内存块)。数组的维间距/步幅告诉我们 &gt;&gt;&gt; 要沿着某个轴移到下一个位置，需要在内存中跳过多少个字节。</p>
<hr>
<h3 id="偏移量（Offset）"><a href="#偏移量（Offset）" class="headerlink" title="偏移量（Offset）"></a>偏移量（Offset）</h3><p>有时候，你会见到元素偏移量的说法，这里也来简单认识一下。</p>
<p>对于数组元素偏移量 &gt;&gt;&gt;&gt; <strong>当前数组元素的地址 与 数组首地址 的差值。</strong> &lt;&lt;&lt;&lt; 相对于首元素的偏移</p>
<p><font color="red">↓↓↓↓↓↓ 一维数组：A[N] ↓↓↓↓↓↓</font></p>
<p>对于一维数组，索引即偏移。</p>
<p><font color="red">↓↓↓↓↓↓ 二维数组：A[M][N] ↓↓↓↓↓↓</font></p>
<p>对于任一元素 <code>A[i][j]</code> 的偏移量的计算方法就是：<code>i*N+j</code>。</p>
<p><font color="red">↓↓↓↓↓↓ 三维数组：A[O][M][N] ↓↓↓↓↓↓</font></p>
<p>对于任一元素 <code>A[i][j][k]</code> 的偏移量的计算方法就是：<code>i*M*N + j*N + k</code>。</p>
<p>很好理解，不多解释~~~</p>
<hr>
<p>参考链接：</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/zengmingen/article/details/106894280">https://blog.csdn.net/zengmingen/article/details/106894280</a><br><a target="_blank" rel="noopener" href="https://www.cnblogs.com/shine-lee/p/12293097.html">https://www.cnblogs.com/shine-lee/p/12293097.html</a><br><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/199615109">https://zhuanlan.zhihu.com/p/199615109</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/doubleguy/article/details/121566140">https://blog.csdn.net/doubleguy/article/details/121566140</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_34035425/article/details/123251659">https://blog.csdn.net/qq_34035425/article/details/123251659</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/pql925/article/details/84583236">https://blog.csdn.net/pql925/article/details/84583236</a><br><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_43320208/article/details/121509309">https://blog.csdn.net/qq_43320208/article/details/121509309</a></p>
</div><div class="article-licensing box"><div class="licensing-title"><p>一文解析 NumPy ndarray 多维数组结构设计</p><p><a href="https://www.orangeshare.cn/2018/01/20/yi-wen-jie-xi-numpy-ndarray-duo-wei-shu-zu-jie-gou-she-ji/">https://www.orangeshare.cn/2018/01/20/yi-wen-jie-xi-numpy-ndarray-duo-wei-shu-zu-jie-gou-she-ji/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>Author</h6><p>Waldeinsamkeit</p></div></div><div class="level-item is-narrow"><div><h6>Posted on</h6><p>2018-01-20</p></div></div><div class="level-item is-narrow"><div><h6>Updated on</h6><p>2023-05-05</p></div></div><div class="level-item is-narrow"><div><h6>Licensed under</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="icon" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a><a class="icon" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/Python/">Python</a><a class="link-muted mr-2" rel="tag" href="/tags/Data-Analysis/">Data Analysis</a></div><div class="notification is-danger">You need to set <code>install_url</code> to use ShareThis. Please set it in <code>_config.yml</code>.</div></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">Like this article? Support the author with</h3><div class="buttons is-centered"><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>Alipay</span><span class="qrcode"><img src="/" alt="Alipay"></span></a><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>Wechat</span><span class="qrcode"><img src="/" alt="Wechat"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2018/02/01/the-pixel-matrix-representation-of-image/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">The Pixel Matrix Representation Of Image</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2018/01/20/python-shu-ju-fen-xi-zhi-numpy-shu-xue-ji-suan-ku/"><span class="level-item">Python 数据分析之 NumPy 数学计算库</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">Comments</h3><div class="notification is-danger">You forgot to set the <code>shortname</code> for Disqus. Please set it in <code>_config.yml</code>.</div></div></div></div><!--!--><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen  order-3 is-sticky"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="Waldeinsamkeit"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Waldeinsamkeit</p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">100</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">13</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">43</p></a></div></div></nav></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">Catalogue</h3><ul class="menu-list"><li><a class="level is-mobile" href="#What-is-NumPy"><span class="level-left"><span class="level-item">1</span><span class="level-item">What is NumPy?</span></span></a></li><li><a class="level is-mobile" href="#Ndarray-的内存布局"><span class="level-left"><span class="level-item">2</span><span class="level-item">Ndarray 的内存布局</span></span></a></li><li><a class="level is-mobile" href="#Ndarray-的设计哲学"><span class="level-left"><span class="level-item">3</span><span class="level-item">Ndarray 的设计哲学</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#视图（View）"><span class="level-left"><span class="level-item">3.1</span><span class="level-item">视图（View）</span></span></a></li><li><a class="level is-mobile" href="#副本（Copy）"><span class="level-left"><span class="level-item">3.2</span><span class="level-item">副本（Copy）</span></span></a></li><li><a class="level is-mobile" href="#设计的优异性"><span class="level-left"><span class="level-item">3.3</span><span class="level-item">设计的优异性</span></span></a></li></ul></li><li><a class="level is-mobile" href="#N-Darray-的理解"><span class="level-left"><span class="level-item">4</span><span class="level-item">N-Darray 的理解</span></span></a></li><li><a class="level is-mobile" href="#Ndarray-属性详解"><span class="level-left"><span class="level-item">5</span><span class="level-item">Ndarray 属性详解</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#C-F-Order"><span class="level-left"><span class="level-item">5.1</span><span class="level-item">C/F Order</span></span></a></li><li><a class="level is-mobile" href="#维度-轴（Axis）"><span class="level-left"><span class="level-item">5.2</span><span class="level-item">维度/轴（Axis）</span></span></a></li><li><a class="level is-mobile" href="#形状（Shape）"><span class="level-left"><span class="level-item">5.3</span><span class="level-item">形状（Shape）</span></span></a></li><li><a class="level is-mobile" href="#维间距-步幅（Strides）"><span class="level-left"><span class="level-item">5.4</span><span class="level-item">维间距/步幅（Strides）</span></span></a></li><li><a class="level is-mobile" href="#偏移量（Offset）"><span class="level-left"><span class="level-item">5.5</span><span class="level-item">偏移量（Offset）</span></span></a></li></ul></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="When Art Meets Tech" height="28"></a><p class="is-size-7"><span>&copy; 2023 Waldeinsamkeit</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p></div></div></div></div></footer><script src="https://cdnjs.loli.net/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" async></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/cookieconsent/3.1.1/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/js/lightgallery.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>
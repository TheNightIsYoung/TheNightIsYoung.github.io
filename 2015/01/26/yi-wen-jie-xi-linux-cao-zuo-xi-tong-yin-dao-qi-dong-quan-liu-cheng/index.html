<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>一文解析 Linux 操作系统引导启动全流程 - When Art Meets Tech</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="When Art Meets Tech"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="When Art Meets Tech"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta description="理解 Linux 操作系统开机引导和启动过程，对于操作系统配置，以及解决相关启动问题是至关重要的。"><meta property="og:type" content="blog"><meta property="og:title" content="一文解析 Linux 操作系统引导启动全流程"><meta property="og:url" content="https://www.orangeshare.cn/2015/01/26/yi-wen-jie-xi-linux-cao-zuo-xi-tong-yin-dao-qi-dong-quan-liu-cheng/"><meta property="og:site_name" content="When Art Meets Tech"><meta property="og:description" content="理解 Linux 操作系统开机引导和启动过程，对于操作系统配置，以及解决相关启动问题是至关重要的。"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://s2.loli.net/2024/03/09/PrVfm7YUwD1vndq.png"><meta property="og:image" content="https://s2.loli.net/2024/03/09/kMLqdApehmTU84H.png"><meta property="og:image" content="https://s2.loli.net/2024/03/10/etU4r9AilqXF1vE.png"><meta property="og:image" content="https://s2.loli.net/2024/03/10/y7rJ8gDpaGldVCs.png"><meta property="og:image" content="https://s2.loli.net/2024/03/10/PRqn37CpzUYydkj.png"><meta property="og:image" content="https://s2.loli.net/2024/03/16/CTjHmthvGY4X7RA.png"><meta property="og:image" content="https://s2.loli.net/2024/03/10/wqrxYtD4AMyJN21.png"><meta property="og:image" content="https://s2.loli.net/2024/03/10/MYFTPadZ2rWyVbo.png"><meta property="og:image" content="https://s2.loli.net/2024/03/10/ElSRvOnb5sQ4ahr.png"><meta property="og:image" content="https://s2.loli.net/2024/03/10/cLjUYlEDhfVgsCa.png"><meta property="og:image" content="https://s2.loli.net/2024/03/10/k8wQ4aTKCbAgFqy.jpg"><meta property="og:image" content="https://s2.loli.net/2024/03/10/jYQnMRPaNBp3SiW.jpg"><meta property="og:image" content="https://s2.loli.net/2024/03/16/wHfOAuM2CvDl5cy.png"><meta property="article:published_time" content="2015-01-26T02:40:29.000Z"><meta property="article:modified_time" content="2024-03-16T12:29:24.970Z"><meta property="article:author" content="Waldeinsamkeit"><meta property="article:tag" content="Operate System"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://s2.loli.net/2024/03/09/PrVfm7YUwD1vndq.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.orangeshare.cn/2015/01/26/yi-wen-jie-xi-linux-cao-zuo-xi-tong-yin-dao-qi-dong-quan-liu-cheng/"},"headline":"When Art Meets Tech","image":["https://s2.loli.net/2024/03/09/PrVfm7YUwD1vndq.png","https://s2.loli.net/2024/03/09/kMLqdApehmTU84H.png","https://s2.loli.net/2024/03/10/etU4r9AilqXF1vE.png","https://s2.loli.net/2024/03/10/y7rJ8gDpaGldVCs.png","https://s2.loli.net/2024/03/10/PRqn37CpzUYydkj.png","https://s2.loli.net/2024/03/16/CTjHmthvGY4X7RA.png","https://s2.loli.net/2024/03/10/wqrxYtD4AMyJN21.png","https://s2.loli.net/2024/03/10/MYFTPadZ2rWyVbo.png","https://s2.loli.net/2024/03/10/ElSRvOnb5sQ4ahr.png","https://s2.loli.net/2024/03/10/cLjUYlEDhfVgsCa.png","https://s2.loli.net/2024/03/10/k8wQ4aTKCbAgFqy.jpg","https://s2.loli.net/2024/03/10/jYQnMRPaNBp3SiW.jpg","https://s2.loli.net/2024/03/16/wHfOAuM2CvDl5cy.png"],"datePublished":"2015-01-26T02:40:29.000Z","dateModified":"2024-03-16T12:29:24.970Z","author":{"@type":"Person","name":"Waldeinsamkeit"},"description":"理解 Linux 操作系统开机引导和启动过程，对于操作系统配置，以及解决相关启动问题是至关重要的。"}</script><link rel="canonical" href="https://www.orangeshare.cn/2015/01/26/yi-wen-jie-xi-linux-cao-zuo-xi-tong-yin-dao-qi-dong-quan-liu-cheng/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css"><link rel="stylesheet"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/cookieconsent/3.1.1/cookieconsent.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/pace/1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.2.0"></head>    <body class="is-3-column">    <nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="When Art Meets Tech" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Hexo Search" href="https://hexo.io/zh-cn/"><i class="fab fa-hotjar"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="Catalogue" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal"><i class="fas fa-angle-double-right"></i>一文解析 Linux 操作系统引导启动全流程</h1><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><i class="far fa-calendar-alt"> </i><time dateTime="${date_xml(page.date)}" title="${date_xml(page.date)}">2015-01-26</time></span><span class="level-item is-hidden-mobile"><i class="far fa-calendar-check"> </i><time dateTime="${date_xml(page.updated)}" title="${date_xml(page.updated)}">2024-03-16</time></span><span class="level-item"><a class="link-muted" href="/categories/OS/">OS</a></span><span class="level-item">41 minutes read (About 6123 words)</span></div></div><div class="content"><p>理解 Linux 操作系统开机引导和启动过程，对于操作系统配置，以及解决相关启动问题是至关重要的。</p>
<a id="more"></a>

<p>更多相关系列博文请参考：</p>
<p><a href="https://www.orangeshare.cn/2015/01/26/yi-wen-jie-xi-linux-cao-zuo-xi-tong-yin-dao-qi-dong-quan-liu-cheng/">一文解析 Linux 操作系统引导启动全流程</a></p>
<p><a href="https://www.orangeshare.cn/2015/02/03/yi-wen-jie-xi-linux-xi-tong-qi-dong-he-jin-cheng-guan-li/">一文解析 Linux 系统启动和进程管理</a></p>
<hr>
<h2 id="Linux-OS-引导启动流程"><a href="#Linux-OS-引导启动流程" class="headerlink" title="Linux OS 引导启动流程"></a>Linux OS 引导启动流程</h2><p>首先，通过 Linux 引导启动图解来了解系统引导启动的整个流程，可以基本分为以下几个步骤：</p>
<p>POST &gt;&gt;&gt; BIOS &gt;&gt;&gt; MBR &gt;&gt;&gt; GRUB &gt;&gt;&gt; Kernel &gt;&gt;&gt; Init &gt;&gt;&gt; RunLevel</p>
<p><img src="https://s2.loli.net/2024/03/09/PrVfm7YUwD1vndq.png"></p>
<p>下面逐步剖析说明系统引导过程（CentOS 6.9）：</p>
<p>| ================================================== <strong>Split Line</strong> =============================================== |</p>
<h3 id="BIOS"><a href="#BIOS" class="headerlink" title="BIOS"></a>BIOS</h3><p>Linux 主机开机上电后，<font color="orange">首先会加载位于主板 EPPROM 芯片中的 BIOS（Basic Input/Output System）系统固件程序（用于初始化硬件组件）</font>，同时会从 CMOS 芯片中读取用户自定义和系统自动记录的 BIOS 配置（BIOS 无法存储配置，CMOS 电池掉电会重置 BIOS 设置）。</p>
<p><font color="orange">然后会进行 POST（Power On Self Test）加电自检过程</font>（也称为 BIOS 上电自检） &gt;&gt;&gt; 就是根据主板 BIOS 中的设置对主机各种硬件设备（CPU、Memory、Mainboard、Disk、CMOS Chip）进行检测，<font color="orange">以确认主机硬件基本功能是否正常？！！</font></p>
<p>此时，可能会出现 <font color="red">两种异常情况</font>：</p>
<ul>
<li>如果出现致命故障：停机，并且由于初始化过程还没完成，所以不会出现任何提示信号；</li>
<li>如果出现一般故障：会发出声音等提示信号，等待故障清除；</li>
</ul>
<p>若未出现故障（主机硬件基本功能正常），则 POST 加电自检通过。</p>
<p><font color="orange">BIOS 上电自检通过后，会按照 BIOS 中预设的启动顺序（Boot Sequence)逐一查找可引导启动的磁盘设备</font>（HDisk/CD-ROM/Removable/Floppy），也就是根据启动顺序去依次查找磁盘设备头是否存在有效 MBR（Master Boot Record）主引导记录？！！若第一个磁盘不存在 MBR，则会继续查找第二个磁盘……</p>
<p><font color="orange">找到可引导启动的设备后，BIOS 会将系统控制权移交给可引导设备。</font></p>
<hr>
<p>此时，<font color="orange">会从可引导设备的第一个扇区（引导扇区）中读取 MBR 主引导记录信息</font>：</p>
<h3 id="MBR"><a href="#MBR" class="headerlink" title="MBR"></a>MBR</h3><p>MBR（Master Boot Record），存储于可引导启动磁盘的头部（ 0 磁道 0 扇区），占用 512 字节。MBR 主要是用来告诉从可启动设备的哪个分区来加载 Boot loader 引导加载程序。</p>
<p>512 字节 MBR 包括如下内容：</p>
<ul>
<li>446 bytes：用于存储 BootLoader 程序（GRUB1/GRUB2/LILO…），包含操作系统名称，操作系统内核位置等信息，主要功能是加载内核到内存中运行；</li>
<li>64 bytes：用于存储 Partition Table（分区表）信息，每个主分区占用 16 字节（这就是为啥一块硬盘只能有 4 个主分区啦^_^）；</li>
<li>2 bytes：分区表有效性标记</li>
</ul>
<blockquote>
<p>不同于 MBR 分区格式，对于较大磁盘设备的 GPT 分区格式，引导加载程序的位置会略有变化。</p>
</blockquote>
<p><font color="orange">将其加载到内存中，运行引导装载器/程序 GRUB</font>（Boot Loader 目前常用的是 GRUB）。</p>
<hr>
<h3 id="GRUB1-GRUB2"><a href="#GRUB1-GRUB2" class="headerlink" title="GRUB1/GRUB2"></a>GRUB1/GRUB2</h3><p>GRUB（Grand Unified BootLoader）是多系统启动程序，它是目前流行的大部分 Linux 发行版本的主要引导加载程序，用于计算机寻找操作系统内核并加载其到内存的智能程序。</p>
<p>关于 GRUB1 &amp;&amp; GRUB2 更多的描述，可以参见后文【Reff Reading】中相关描述。</p>
<p>可见，<font color="red">GRUB 的主要目的就是 &gt;&gt;&gt; 查找和加载 Kernel 到内存。</font></p>
<p><font color="orange">GRUB 执行过程分为三个阶段（Stages）</font>，以 GRUB1 为例：</p>
<p><strong>[1] &gt;&gt;&gt; Stage1</strong></p>
<p><font color="green">Stage 1 代码存在于 MBR 分区。</font></p>
<p>BIOS 加电自检通过后，会从可引导设备的引导扇区读取 MBR 主引导记录，并将其载入内存，并开始执行 GRUB/BootLoader 主程序。</p>
<p>由于引导代码（即阶段 1 代码）实际所占用的空间大小仅为 446 字节（也被称为引导镜像 [boot.img]），非常的小，它不可能非常智能。<font color="orange">Stage1 的主要工作就是查找并加载第二段 BootLoader 程序（Stage2）。</font></p>
<p>但此时文件系统还未挂载，MBR 中只记录了分区表（只能通过 MBR 中的分区表来识别分区），不能理解文件系统结构，于是就有了 stage1_5。因此 <font color="orange">Stage1 还需要定位并加载 Stage1_5 的程序。</font></p>
<p>Stage1_5 程序代码必须位于 MBR 记录之后。</p>
<p>| ================================================== <strong>Split Line</strong> =============================================== |</p>
<p><strong>[2] &gt;&gt;&gt; Stage1_5</strong></p>
<p><font color="green">Stage1_5 程序必须位于 MBR 引导记录与设备第一个分区之间的位置。</font></p>
<p>MBR（扇区 0）和 第一个分区（开始位置在扇区 63）之间遗留下 62 个 512 字节的扇区（共 31744 字节），此区域有足够大小的空间用来存储 Stage1_5 程序（代码镜像 [core.img]）</p>
<p>因为有更大的存储空间用于 Stage1_5，且该空间足够容纳一些通用的文件系统驱动程序（EXT/FAT/NTFS…）。你可以理解为 <font color="orange">Stage1_5 通过加载自身携带的文件系统驱动来实现 MBR 分区表中分区文件系统的识别，让 Stage1 中的 BootLoader 能识别 Stage2 所在分区（主分区）上的文件系统。</font></p>
<p>Stage1_5 支持的文件系统：</p>
<p><img src="https://s2.loli.net/2024/03/09/kMLqdApehmTU84H.png"></p>
<p>| ================================================== <strong>Split Line</strong> =============================================== |</p>
<p><strong>[3] &gt;&gt;&gt; Stage2</strong></p>
<p>由于内核的相关文件位于 <code>/boot</code> 目录下，<font color="green">Stage2 程序必须位于 boot 目录所在的磁盘分区（/boot/grub）</font>。</p>
<p><font color="orange">Stage2 BootLoader 程序会根据 <code>/boot/grub/grub.conf</code> 文件查找 Kernel 的信息，然后开始加载 Kernel 程序到内存中。</font></p>
<p>对于 GRUB2 的 Stage2 还会从 <code>/boot/grub2/i386-pc</code> 目录下加载一些内核运行时模块。</p>
<p>来看一下 GRUB1 的配置文件：</p>
<p><img src="https://s2.loli.net/2024/03/10/etU4r9AilqXF1vE.png"></p>
<p>其中，<code>root (hd0,0)</code> 这个 root 并不是真正的根，而是 / 所在的位置。可以理解成 /boot 是处在 <code>(hd0,0)/boot</code>，而这里的（hd0,0) 指的是第一个磁盘的第一个分区。</p>
<p><font color="orange">当 Kernel 程序被检测并在加载到内存中，GRUB 就将控制权交接给 了 Kernel 程序。</font></p>
<hr>
<h3 id="Kernel"><a href="#Kernel" class="headerlink" title="Kernel"></a>Kernel</h3><p>Kernel 内核文件很小，只保留了最基本的模块，以一种自解压的压缩格式存储以节省空间，它与一个初始化的虚拟内存磁盘映像和存储设备映射表都存储于 <code>/boot</code> 目录之下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">initramfs-3.10.0-1127.el7.x86_64.img</span><br><span class="line">System.map-3.10.0-1127.el7.x86_64</span><br><span class="line">vmlinuz-0-rescue-b7ee23f3e71aae428045b321afa67185</span><br><span class="line">vmlinuz-3.10.0-1127.el7.x86_64</span><br></pre></td></tr></table></figure>

<p><font color="orange">选定的内核被加载到内存中，首先必须从压缩格式解压自身</font>，接下来内核将会接管控制并完成 &gt;&gt;&gt;  探测硬件 –&gt; 加载驱动 –&gt; 挂载根文件系统 –&gt; 切换至根文件系统（rootfs）–&gt; 运行 /sbin/init 完成系统初始化。</p>
<p>流程没有问题，但由于 <font color="red">Kernel 为了精简，只保留了最基本的模块，并没有各种硬件或文件系统的驱动程序，就无法识别 rootfs 所在的设备，故产生了 initrd（Initial RAM Disk）这个虚拟内存磁盘镜像文件。</font></p>
<p>事实上，上面 GRUB 在加载内核同时（Stage2），也把 initrd 加载到内存中并运行，产生一个临时的虚拟根文件系统（rootfs）来替代真实的根文件系统。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 挂载 initramfs.img 方法</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> mkdir /home/centos/temp</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cp /boot/initramfs-3.10.0-1127.el7.x86_64.img /home/centos/temp/initrd.gz -a</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> /home/centos/temp</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gunzip ./initrd.gz</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cpio -ivmd &lt; ./initrd</span></span><br></pre></td></tr></table></figure>

<p>initrd 文件展开后的目录如下：</p>
<p><img src="https://s2.loli.net/2024/03/10/y7rJ8gDpaGldVCs.png"></p>
<p>Linux 根目录下文件：</p>
<p><img src="https://s2.loli.net/2024/03/10/PRqn37CpzUYydkj.png"></p>
<p>可以看到，initrd 文件其实是一个虚拟的根文件系统，里面包含 bin、lib、lib64、sys、var、etc、sysroot、 dev、proc、tmp 等根目录，其中装载了必要的驱动模块。将内核与真正的根建立联系，内核通过它加载根文件系统的驱动程序，然后以读写方式挂载根文件系统。</p>
<p><font color="orange">当 Kernel 加载启动时，可以从 initrd 文件中装载驱动模块，直到挂载真正的 rootfs，然后将 initrd 从内存中移除。当根文件系统被挂载后，开始装载第一个进程（/sbin/init）&lt;&lt;&lt; pid=1，之后就将控制权交接给了 System V init 程序。</font></p>
<p>| ================================================== <strong>Split Line</strong> =============================================== |</p>
<p><font color="red">↓↓↓↓↓↓ SystemV &amp;&amp; Upstart &amp;&amp; Systemd ↓↓↓↓↓↓</font></p>
<p>Linux 系统中支持三种 Init 方式：</p>
<ul>
<li>System V initialization：Linux 最古老、最广为流传的（串行执行 shell 脚本启动服务）初始化系统</li>
<li>Upstart：是一个使用基于事件（Event）的 System-V Init 初始化系统的替代品；最初为 Ubuntu 发行版开发，以适合所有 Linux 发行版为目标的</li>
<li>Systemd：是新一代的（并行启动服务进程）初始化系统，已成为目前大多数 Linux 发行版（CentOS 7/Ubuntu）中流行且广泛适应的标准初始化系统，大有取代 Upstart 之势；</li>
</ul>
<p>Systemd 运行的第一个 init 进程是（/lib/systemd/systemd 或 /usr/lib/systemd/systemd）；而 Upstart 运行第一个 init 进程是 Upstart init（/sbin/init splash）。</p>
<hr>
<p>以 System V initialization 为例：</p>
<h3 id="Init"><a href="#Init" class="headerlink" title="Init"></a>Init</h3><p><font color="orange">挂载完成根文件系统之后，执行第一个用户进程 init &gt;&gt;&gt; /sbin/init（所有进程的父进程），然后开始进行 OS 初始化。</font></p>
<p>/etc 目录下的 init 相关的脚本：</p>
<p><img src="https://s2.loli.net/2024/03/16/CTjHmthvGY4X7RA.png"></p>
<p>init 首先运行 <code>/etc/init/rcS.conf</code> 脚本：</p>
<p><img src="https://s2.loli.net/2024/03/10/wqrxYtD4AMyJN21.png"></p>
<p>可见，在  rcS.conf 脚本中首先调用了 <code>/etc/rc.d/rc.sysinit</code> 进行系统的初始化设置，来看看：</p>
<p><img src="https://s2.loli.net/2024/03/10/MYFTPadZ2rWyVbo.png"></p>
<p>事实上，init 执行 /etc/rc.d/rc.sysinit 的初始化将会做很多设置：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">1、获得网络环境 </span><br><span class="line">2、挂载设备 </span><br><span class="line">3、开机启动画面Plymouth（取替了过往的 RHGB） </span><br><span class="line">4、判断是否启用SELinux </span><br><span class="line">5、显示于开机过程中的欢迎画面 </span><br><span class="line">6、初始化硬件 </span><br><span class="line">7、用户自定义模块的加载 </span><br><span class="line">8、配置内核的参数 </span><br><span class="line">9、设置主机名 </span><br><span class="line">10、同步存储器 </span><br><span class="line">11、设备映射器及相关的初始化 </span><br><span class="line">12、初始化软件磁盘阵列（RAID） </span><br><span class="line">13、初始化 LVM 的文件系统功能 </span><br><span class="line">14、检验磁盘文件系统（fsck） </span><br><span class="line">15、设置磁盘配额(quota) </span><br><span class="line">16、重新以可读写模式挂载系统磁盘 </span><br><span class="line">17、更新quota（非必要） </span><br><span class="line">18、启动系统虚拟随机数生成器 </span><br><span class="line">19、配置机器（非必要） </span><br><span class="line">20、清除开机过程当中的临时文件 </span><br><span class="line">21、创建ICE目录 </span><br><span class="line">22、启动交换分区（swap） </span><br><span class="line">23、将开机信息写入/var/log/dmesg文件中</span><br></pre></td></tr></table></figure>

<p><font color="orange">执行系统初始化后，会执行 /etc/inittab 来设定系统运行的默认级别</font>：</p>
<p><img src="https://s2.loli.net/2024/03/10/ElSRvOnb5sQ4ahr.png"></p>
<p>可见，Linux 系统中共有 [0-6] 七个运行级别，分别对应不同的登录模式。</p>
<p>关于 Systemd/Upstart 工具启动守护进程进行系统初始化，可以参见后文【Reff Reading】中相关描述。</p>
<hr>
<h3 id="RunLevel"><a href="#RunLevel" class="headerlink" title="RunLevel"></a>RunLevel</h3><p>Runlevel 运行级别，不同的运行级别下，系统会启动的不一样服务。</p>
<p><font color="orange">设定玩系统默认运行级别以后，接着调用 /etc/rc.d/rc 脚本，这个脚本会根据默认运行级别参数，分别执行 /etc/rc.d/rcN.d 目录下的不同脚本</font>：</p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Run level 0 – /etc/rc.d/rc0.d/</span><br><span class="line">Run level 1 – /etc/rc.d/rc1.d/</span><br><span class="line">Run level 2 – /etc/rc.d/rc2.d/</span><br><span class="line">Run level 3 – /etc/rc.d/rc3.d/</span><br><span class="line">Run level 4 – /etc/rc.d/rc4.d/</span><br><span class="line">Run level 5 – /etc/rc.d/rc5.d/</span><br><span class="line">Run level 6 – /etc/rc.d/rc6.d/</span><br></pre></td></tr></table></figure>

<p>目录名中的 <code>rc</code> 表示 “run command”；<code>d</code> 表示 directory。运行程序目录下的脚本只有 K 和 S 开头的文件：K 开头的文件为开机需要执行关闭的服务，S 开头的文件为开机需要执行开启的服务：</p>
<p><img src="https://s2.loli.net/2024/03/10/cLjUYlEDhfVgsCa.png"></p>
<p>需要注意的是，为了方别系统管理更新，七个 <code>/etc/rc.d/rcN.d</code> 目录里列出的程序，都设为链接文件，全部指向另外一个目录 <code>/etc/rc.d/init.d</code>（d 表示目录，与程序 init 区分）。通过这一特性，如果你要手动关闭或重启某个进程，直接到目录 /etc/init.d 中寻找启动脚本（以网络服务为例）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sudo /etc/init.d/network restart</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo /etc/init.d/network stop</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> sudo /etc/init.d/network start</span></span><br></pre></td></tr></table></figure>

<p>最后会执行 <code>/etc/rc.d/rc.local</code> 这个脚本，可以根据自己的需求将一些执行命令或者脚本写到其中，当开机时就可以加载。</p>
<p><font color="orange">最后执行完 /etc/rc.d/rc.local 脚本后，系统启动完成</font>~~~</p>
<hr>
<h3 id="Login-In"><a href="#Login-In" class="headerlink" title="Login In"></a>Login In</h3><p>系统引导启动、初始化完成后，Init 给出用户登录提示符（login）或者图形化登录界面，等待用户登入。</p>
<p>用户输入用户和密码登陆后，系统会为用户分配一个用户 ID（uid）和组 ID（gid），这两个 ID 是用户的身份标识，用于检测用户运行程序时的身份验证。</p>
<p><font color="orange">用户登录成功后，整个系统启动流程运行完毕！！！</font></p>
<hr>
<h2 id="Reff-Reading"><a href="#Reff-Reading" class="headerlink" title="Reff Reading"></a>Reff Reading</h2><p>推荐阅读部分，通过这一章节的阅读可以帮助你更好的理解 Linux 系统引导启动的全流程：</p>
<p>| ================================================== <strong>Split Line</strong> =============================================== |</p>
<h3 id="关于-GRUB1-GRUB2"><a href="#关于-GRUB1-GRUB2" class="headerlink" title="关于 GRUB1/GRUB2"></a>关于 GRUB1/GRUB2</h3><p>GRUB（Grand Unified BootLoader）是多系统启动程序，它是目前流行的大部分 Linux 发行版本的主要引导加载程序，用于计算机寻找操作系统内核并加载其到内存的智能程序。</p>
<p>GRUB2 跟 GRUB1 类似，支持从 Linux 内核选择之一引导启动。Red Hat 包管理器（DNF）支持保留多个内核版本，以防最新版本内核发生问题而无法启动时，可以恢复老版本的内核。</p>
<p>默认情况下，GRUB 提供了一个已安装内核的预引导菜单（GUN GRUB 界面），其中包括问题诊断菜单（recuse）以及恢复菜单（如果已经配置恢复镜像）。GRUB1 能够通过文件 <code>/boot/grub/grub.conf</code> 进行配置。GRUB2 通过 <code>/boot/grub2/grub.cfg</code> 进行配置。</p>
<p>GRUB1 现在已经逐步被弃用，在大多数现代发行版上它已经被 GRUB2 所替换，GRUB2 是在 GRUB1 的基础上重写完成。基于 Red Hat 的发行版大约是在 Fedora 15 和 CentOS/RHEL 7 时升级到 GRUB2 的。GRUB2 提供了与 GRUB1 同样的引导功能，但是 GRUB2 也是一个 <font color="green">类似主框架（mainframe）系统上的基于命令行的前置操作系统（Pre-OS）环境，使得在预引导阶段配置更为方便和易操作（grub &gt;）。</font></p>
<p>两个版本的 GRUB 的基本工作方式一致，其主要阶段也保持相同，都可分为 3 个阶段。</p>
<hr>
<h3 id="Systemd-启动流程分析"><a href="#Systemd-启动流程分析" class="headerlink" title="Systemd 启动流程分析"></a>Systemd 启动流程分析</h3><p>Systemd 是新一代的初始化系统（并行启动服务进程），已成为目前大多数 Linux 发行版（CentOS 7/Ubuntu）中流行且广泛适应的标准初始化系统，大有取代 Upstart 之势。</p>
<p><font color="orange">Systemd 运行的第一个 Init 进程是（/lib/systemd/systemd 或 /usr/lib/systemd/systemd）&lt;&lt;&lt; pid=1，是所有进程的父进程。</font></p>
<p>Systemd Init 进程会根据其配置文件（<code>/etc/systemd/system/default.target</code>），决定 Linux 系统应该启动达到哪个目标态（Target）？！！并且递归的处理它的依赖关系。</p>
<p>默认目标态一般为：<code>graphical.target（RunLevel 5）</code> 或者 <code>multi-user.target（RunLevel 3）</code>，下图展示关键服务配置的启动依赖：</p>
<p><img src="https://s2.loli.net/2024/03/10/k8wQ4aTKCbAgFqy.jpg"></p>
<p>下面逐步剖析说明 systemd 启动的 4 个关键步骤：</p>
<p>| ================================================== <strong>Split Line</strong> =============================================== |</p>
<p><strong>[Step 1] &gt;&gt;&gt;</strong> <font color="orange">systemd 执行默认 default.target 配置，决定 Linux 系统应该启动达到哪个目标态（Target）</font></p>
<p><code>default.target</code> 是一个指向真实的 target 文件的符号链接：</p>
<ul>
<li>对于桌面系统，其链接到 <code>graphical.target</code>，该文件相当于旧式 SystemV Init 方式的 <code>runlevel 5</code>；</li>
<li>对于一个服务器操作系统来说，default.target 更多是默认链接到 <code>multi-user.target</code>， 相当于 SystemV Init 系统的 <code>runlevel 3</code>；</li>
<li>emergency.target 相当于单用户模式。</li>
</ul>
<p>systemd 启动的目标态（target）和老版 SystemV Init 启动运行级别（runlevel）的对比：</p>
<p><img src="https://s2.loli.net/2024/03/10/jYQnMRPaNBp3SiW.jpg"></p>
<p>其中的，<strong>systemd 目标态别名</strong> 是为了 systemd 向前兼容 systemV Init 而提供。这个目标态别名允许系统管理员（包括我自己）用 systemV 命令（例如 init 3）改变运行级别。当然，该 <font color="red">systemV 命令是被转发到 systemd 进行解释和执行的。</font></p>
<p>| ================================================== <strong>Split Line</strong> =============================================== |</p>
<p><strong>[Step 2] &gt;&gt;&gt;</strong> <font color="orange">systemd 执行启动 default.target 所依赖的目标 basic.target 和 sysinit.target 初始化系统</font></p>
<p>你可以通过如下命令来查看依赖：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat /etc/systemd/system/default.target</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  This file is part of systemd.</span></span><br><span class="line"><span class="meta">#</span></span><br><span class="line"><span class="bash"><span class="comment">#  systemd is free software; you can redistribute it and/or modify it</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash">  under the terms of the GNU Lesser General Public License as published by</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  the Free Software Foundation; either version 2.1 of the License, or</span></span><br><span class="line"><span class="meta">#</span><span class="bash">  (at your option) any later version.</span></span><br><span class="line"></span><br><span class="line">[Unit]</span><br><span class="line">Description=Graphical Interface</span><br><span class="line">Documentation=man:systemd.special(7)</span><br><span class="line">Requires=multi-user.target</span><br><span class="line">Wants=display-manager.service</span><br><span class="line">Conflicts=rescue.service rescue.target</span><br><span class="line">After=multi-user.target rescue.service rescue.target display-manager.service</span><br><span class="line">AllowIsolate=yes</span><br></pre></td></tr></table></figure>

<p>After 中指定的 target 需要在 default.target 之前运行。</p>
<p>👇👇👇 <strong>关于状态检查点</strong> 👇👇👇</p>
<p><font color="green"><code>sysinit.target</code> 和 <code>basic.target</code> 目标态可以被视作启动过程中的状态检查点。</font></p>
<p>尽管 systemd 的设计初衷是并行启动系统服务，但是部分服务或目标态是其它服务或目标态的启动的前提。因此，系统将暂停于 检查点 直到其所要求的服务和目标态都满足为止。</p>
<p><font color="red">For sysinit.target 状态</font></p>
<p>sysinit.target 状态的到达，是以其所依赖的所有资源模块都正常启动为前提的，如：文件系统挂载、交换文件设置、设备管理器的启动、随机数生成器种子设置、低级别系统服务初始化、加解密服务启动等都必须完成，但是 <font color="green">在 sysinit.target 中这些服务与模块是可以并行启动的。</font></p>
<p><font color="red">For basic.target 状态</font></p>
<p>systemd 接下来启动 basic.target，启动其所要求的所有单元。 basic.target 通过启动下一目标态所需的单元而提供了更多的功能，这包括各种可执行文件的目录路径、通信 sockets，以及定时器等。<font color="green">在 basic.target 中这些服务与模块也是可以并行启动的。</font></p>
<p>| ================================================== <strong>Split Line</strong> =============================================== |</p>
<p><strong>[Step 3] &gt;&gt;&gt;</strong> <font color="orange">systemd 启动最终 graphical.target 下的本机与服务器服务</font></p>
<p>由于当前 default.target 指向 graphical.target 目标态，那么这一步就启动对应的目标态下服务。它的服务存在于 <code>/etc/systemd/system/graphical.target.wants</code> 目录中：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ll /etc/systemd/system/graphical.target.wants/</span></span><br><span class="line">total 0</span><br><span class="line">lrwxrwxrwx. 1 root root 47 Mar  7 01:30 accounts-daemon.service -&gt; /usr/lib/systemd/system/accounts-daemon.service</span><br><span class="line">lrwxrwxrwx. 1 root root 61 Mar  7 01:31 initial-setup-reconfiguration.service -&gt; /usr/lib/systemd/system/initial-setup-reconfiguration.service</span><br><span class="line">lrwxrwxrwx. 1 root root 44 Mar  7 01:31 rtkit-daemon.service -&gt; /usr/lib/systemd/system/rtkit-daemon.service</span><br><span class="line">lrwxrwxrwx. 1 root root 39 Mar  7 01:31 udisks2.service -&gt; /usr/lib/systemd/system/udisks2.service</span><br></pre></td></tr></table></figure>

<p>| ================================================== <strong>Split Line</strong> =============================================== |</p>
<p><strong>[Step 4] &gt;&gt;&gt;</strong> <font color="orange">systemd 最后执行 graphical.target 下的 /etc/rc.d/rc.local</font></p>
<p><font color="red">systemd 是可以兼容 systemv init 中的 rc.local 配置的，通过 rc-local.service 来实现兼容的。</font></p>
<p>你可以通过查看其配置文件来观察如何启动：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> systemctl cat rc-local.service</span></span><br><span class="line">[Unit]</span><br><span class="line">Description=/etc/rc.d/rc.local Compatibility</span><br><span class="line">ConditionFileIsExecutable=/etc/rc.d/rc.local</span><br><span class="line">After=network.target</span><br><span class="line"></span><br><span class="line">[Service]</span><br><span class="line">Type=forking</span><br><span class="line">ExecStart=/etc/rc.d/rc.local start</span><br><span class="line">TimeoutSec=0</span><br><span class="line">RemainAfterExit=yes</span><br></pre></td></tr></table></figure>

<p>systemd 在启动的很早时候就会判断 /etc/rc.local 是否存在并且是可执行的？！！</p>
<p>如果满足条件 &gt;&gt;&gt; 那么 systemd 会调用 /usr/lib/systemd/system-generators/ 下面的小程序来把 rc-local.service 服务加入到 default.target 中来。这样在后面的执行时就会触发 rc.local 的运行。</p>
<p>| ================================================== <strong>Split Line</strong> =============================================== |</p>
<p><font color="red">↓↓↓↓↓↓ 兼容 System V init 启动 ↓↓↓↓↓↓</font></p>
<p>systemd 也会查看老式的 systemV init 目录（/etc/init.d/）中是否存在相关启动文件，若存在，则 systemd 根据这些配置文件的内容启动对应的服务。在 Fedora 系统中，过时的网络服务就是通过该方式启动的一个实例：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls /etc/init</span></span><br><span class="line">init.d/  inittab</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls /etc/init.d/</span></span><br><span class="line">functions  netconsole  network  README</span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Upstart-启动流程分析"><a href="#Upstart-启动流程分析" class="headerlink" title="Upstart 启动流程分析"></a>Upstart 启动流程分析</h3><p>Upstart 是一个使用基于事件（Event）的 System-V Init 初始化系统的替代品，最初为 Ubuntu 发行版开发，以适合所有 Linux 发行版为目标。</p>
<p>而 <font color="orange">Upstart 运行的第一个 init 进程是 Upstart init（/sbin/init splash）&lt;&lt;&lt; pid=1，是所有进程的父进程。</font></p>
<p>对于 Upstart 而言，/etc/init（/etc/event.d）配置目录是关键，里面全是作业配置文件（控制作业的启动/停止）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls /etc/init</span></span><br><span class="line">acpid.conf                   container-detect.conf     hwclock.sh.conf             mounted-tmp.conf                  rcS.conf             tty6.conf</span><br><span class="line">alsa-utils.conf              control-alt-delete.conf   irqbalance.conf             mounted-var.conf                  rc-sysinit.conf      udev.conf</span><br><span class="line">anacron.conf                 cron.conf                 kmod.conf                   mountkernfs.sh.conf               resolvconf.conf      udevmonitor.conf</span><br><span class="line">apparmor.conf                cups-browsed.conf         lightdm.conf                mountnfs-bootclean.sh.conf        rfkill-restore.conf  udevtrigger.conf</span><br><span class="line">apport.conf                  cups.conf                 mountall-bootclean.sh.conf  mountnfs.sh.conf                  rfkill-store.conf    ufw.conf</span><br><span class="line">avahi-cups-reload.conf       dbus.conf                 mountall.conf               mtab.sh.conf                      rsyslog.conf         upstart-file-bridge.conf</span><br><span class="line">avahi-daemon.conf            failsafe.conf             mountall-net.conf           networking.conf                   setvtrgb.conf        upstart-socket-bridge.conf</span><br><span class="line">bluetooth.conf               failsafe-x.conf           mountall-reboot.conf        network-interface.conf            shutdown.conf        upstart-udev-bridge.conf</span><br><span class="line">bootmisc.sh.conf             flush-early-job-log.conf  mountall.sh.conf            network-interface-container.conf  ssh.conf             ureadahead.conf</span><br><span class="line">checkfs.sh.conf              friendly-recovery.conf    mountall-shell.conf         network-interface-security.conf   thermald.conf        ureadahead-other.conf</span><br><span class="line">checkroot-bootclean.sh.conf  gpu-manager.conf          mountdevsubfs.sh.conf       network-manager.conf              tty1.conf            usb-modeswitch-upstart.conf</span><br><span class="line">checkroot.sh.conf            hostname.conf             mounted-debugfs.conf        passwd.conf                       tty2.conf            wait-for-state.conf</span><br><span class="line">console.conf                 hostname.sh.conf          mounted-dev.conf            procps.conf                       tty3.conf            whoopsie.conf</span><br><span class="line">console-font.conf            hwclock.conf              mounted-proc.conf           procps-instance.conf              tty4.conf</span><br><span class="line">console-setup.conf           hwclock-save.conf         mounted-run.conf            rc.conf                           tty5.conf</span><br></pre></td></tr></table></figure>

<p>Ubuntu Upstart 为了兼容原 System V Init 方式的服务，其启动大概流程如下图所示：</p>
<p><img src="https://s2.loli.net/2024/03/16/wHfOAuM2CvDl5cy.png"></p>
<p>| ================================================== <strong>Split Line</strong> =============================================== |</p>
<p>下面逐步剖析说明 Upstart 启动的关键步骤：</p>
<p><strong>[1] &gt;&gt;&gt;</strong> 设备上电后，由 Grub 加载内核 Kernel，内核在完成初始化后会执行第一个进程 init 进程 &lt;&lt;&lt; Upstart init；</p>
<p><strong>[2] &gt;&gt;&gt;</strong> Upstart init 在进行自身的一些初始化之后，会发出 startup 事件；</p>
<p><strong>[3] &gt;&gt;&gt;</strong> startup 事件会触发 mountall 等作业（/etc/init 下的作业配置文件，其中包含 start on startup 语句)；</p>
<p><strong>[4] &gt;&gt;&gt;</strong> mountall 作业中会发射（emits）：virtual-filesystems &amp; local-filesystems &amp; remote-filesystems &amp; all-swaps &amp; filesystem &amp; mounting &amp; mounted 事件；</p>
<p><strong>[5] &gt;&gt;&gt;</strong> 其中，mounted 事件会触发 container-detect 作业，从而发出 container 事件去触发 network-interface-container 作业，其又发出 net-device-added 事件去触发 network-interface 作业，进而发出 static-network-up 事件，static-network-up 事件和 filesystem 事件一起去触发 rc-sysinit 作业；rc-sysinit 最后会调用 telinit “$[DEFAULT_RUNLEVEL]” 去改变运行等级，从而发出 runlevel 事件触发 rc 作业；</p>
<p><strong>[6] &gt;&gt;&gt;</strong> 在 /etc/init/rc.conf 中会调用 /etc/init.d/rc $RUNLEVEL，到这里就和 System V Init（/etc/init/rcS.conf）类似了~~~</p>
<p><strong>[7] &gt;&gt;&gt;</strong> 会去 /etc/rcN.d 目录下执行所有脚本，以启动相应运行等级的系统服务。</p>
<hr>
</div><div class="article-licensing box"><div class="licensing-title"><p>一文解析 Linux 操作系统引导启动全流程</p><p><a href="https://www.orangeshare.cn/2015/01/26/yi-wen-jie-xi-linux-cao-zuo-xi-tong-yin-dao-qi-dong-quan-liu-cheng/">https://www.orangeshare.cn/2015/01/26/yi-wen-jie-xi-linux-cao-zuo-xi-tong-yin-dao-qi-dong-quan-liu-cheng/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>Author</h6><p>Waldeinsamkeit</p></div></div><div class="level-item is-narrow"><div><h6>Posted on</h6><p>2015-01-26</p></div></div><div class="level-item is-narrow"><div><h6>Updated on</h6><p>2024-03-16</p></div></div><div class="level-item is-narrow"><div><h6>Licensed under</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="icon" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a><a class="icon" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/Operate-System/">Operate System</a></div><div class="notification is-danger">You need to set <code>install_url</code> to use ShareThis. Please set it in <code>_config.yml</code>.</div></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">Like this article? Support the author with</h3><div class="buttons is-centered"><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>Alipay</span><span class="qrcode"><img src="/" alt="Alipay"></span></a><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>Wechat</span><span class="qrcode"><img src="/" alt="Wechat"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2015/01/27/linux-installation-tutorial/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Linux Installation tutorial</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2015/01/25/a-quick-guide-to-linux-servers/"><span class="level-item">A Quick Guide To Linux Servers</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">Comments</h3><div class="notification is-danger">You forgot to set the <code>shortname</code> for Disqus. Please set it in <code>_config.yml</code>.</div></div></div></div><!--!--><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen  order-3 is-sticky"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="Waldeinsamkeit"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Waldeinsamkeit</p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">118</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">13</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">43</p></a></div></div></nav></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">Catalogue</h3><ul class="menu-list"><li><a class="level is-mobile" href="#Linux-OS-引导启动流程"><span class="level-left"><span class="level-item">1</span><span class="level-item">Linux OS 引导启动流程</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#BIOS"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">BIOS</span></span></a></li><li><a class="level is-mobile" href="#MBR"><span class="level-left"><span class="level-item">1.2</span><span class="level-item">MBR</span></span></a></li><li><a class="level is-mobile" href="#GRUB1-GRUB2"><span class="level-left"><span class="level-item">1.3</span><span class="level-item">GRUB1/GRUB2</span></span></a></li><li><a class="level is-mobile" href="#Kernel"><span class="level-left"><span class="level-item">1.4</span><span class="level-item">Kernel</span></span></a></li><li><a class="level is-mobile" href="#Init"><span class="level-left"><span class="level-item">1.5</span><span class="level-item">Init</span></span></a></li><li><a class="level is-mobile" href="#RunLevel"><span class="level-left"><span class="level-item">1.6</span><span class="level-item">RunLevel</span></span></a></li><li><a class="level is-mobile" href="#Login-In"><span class="level-left"><span class="level-item">1.7</span><span class="level-item">Login In</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Reff-Reading"><span class="level-left"><span class="level-item">2</span><span class="level-item">Reff Reading</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#关于-GRUB1-GRUB2"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">关于 GRUB1/GRUB2</span></span></a></li><li><a class="level is-mobile" href="#Systemd-启动流程分析"><span class="level-left"><span class="level-item">2.2</span><span class="level-item">Systemd 启动流程分析</span></span></a></li><li><a class="level is-mobile" href="#Upstart-启动流程分析"><span class="level-left"><span class="level-item">2.3</span><span class="level-item">Upstart 启动流程分析</span></span></a></li></ul></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="When Art Meets Tech" height="28"></a><p class="is-size-7"><span>&copy; 2024 Waldeinsamkeit</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p></div></div></div></div></footer><script src="https://cdnjs.loli.net/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" async></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/cookieconsent/3.1.1/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/js/lightgallery.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>
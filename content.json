{"pages":[],"posts":[{"title":"Eclipse 2020 Shortcut Key","text":"Eclipse 2020 版本常用快捷键。 注释快捷键1 –&gt; ctrl+shift+/ 使用 /* */（块注释）自动注释掉选择的代码块。 问题：注释后多行语句乱码（合并为一行），取消注释无法恢复。 Solution：Window –&gt; Perference –&gt; Java –&gt; Code Style –&gt; Formatter –&gt; 取名（my_add_annotation）–&gt; Edit –&gt; Comments（左侧）–&gt; 勾掉：Enable block comment formatting –&gt; Apply –&gt; OK –&gt; Apply and Close; 2 –&gt; ctrl+shift+\\ 取消 /* */（块注释）注释。 3 –&gt; ctrl+/ 使用 //（行注释）自动 注释或取消注释 选择的多行代码。 4 –&gt; ctrl+shift+j 快速为文档，类，方法等添加模板注释。 注释模板修改： Window –&gt; Preferences –&gt; Java –&gt; Code Style –&gt; Code Templates –&gt; Comments –&gt; Types –&gt; Edit； ============================================= 文档注释模板格式： 12345678910/** * Project Name: ${project_name} * Class Name: ${type_name} * Created By: ${user} * Created At: ${date} ${time} * E-Mail: ${name:git_config(user.name)} * @Version * * ${tags} */ ============================================= 编辑快捷键1 –&gt; ctrl+d 删除当前光标所在行。 2 –&gt; ctrl+shift+enter 在当前行上插入一行。 3 –&gt; shift+enter 在当前行下插入一行。 4 –&gt; alt+/ 自动补全代码或者提示代码。 问题：Eclipse 编写代码不能自动补全，而需要不停的按 ALT+/ 或者检测到 . 才会进行补全。 Solution：Window –&gt; Perference –&gt; Java –&gt; Editor –&gt; Content Assist –&gt; Auto activation triggers for Java（右侧，只有一个 . 存在） –&gt; 改为：**.abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ** –&gt; Apply –&gt; OK; 这样，就可以通过代码补全，自动生成 main，getter，setter，toString 等方法了。 5 –&gt; ctrl+shift+o 自动引入包和删除无用包。 6 –&gt; ctrl+shift+f 格式化代码。 问题：使用搜狗输入法/微软输入法，会和 “繁/简体切换” 快捷键冲突。 Solution：关闭输入法 “繁/简体切换 ” 快捷键“ 。 7 –&gt; alt+↑/↓ 移动一行或多行。 8 –&gt; ctrl+alt+↑/↓ 复制选择的一行或多行代码块。 9 –&gt; F3 快速查看源码。 窗口快捷键1 –&gt; alt+← 全局 后退历史记录。 2 –&gt; alt+→ 全局 前进历史记录。 3 –&gt; ctrl+o 快速 Outline 视图：查看当前文件中的类、方法名。 4 –&gt; ctrl+PgDn/PgUp 选项卡之间快速切换。 5 –&gt; ctrl+h 全局搜索对话框。 6 –&gt; ctrl+f 当前文件搜索、替换对话框。 Debug 模式快捷键1 –&gt; F11 Debug 模式运行程序。 2 –&gt; F5 单步调试进入函数内部。 3 –&gt; F6 单步调试不进入函数内部。 4 –&gt; F8 一直执行到下一个断点。 5 –&gt; F7 由函数内部返回到调用处。 6 –&gt; alt+shift+x 正常运行应用。","link":"/2017/10/11/eclipse-2020-shortcut-key/"},{"title":"Git 使用指南之 Git 中的黑魔法","text":"git stash，git cherry-pick，git rebase，未完待续 版权说明： 本文思路以及内容主要来自廖雪峰老师的 Git 教程 （强烈推荐膜拜原文），并结合个人使用所作，只作为学习记录使用。如内容有侵权请联系删除，禁止转载！ 更多 Git 相关内容，请关注博主 Git 博文系列： 之一 &gt;&gt;&gt; Git 使用指南之初识 之二 &gt;&gt;&gt; Git 使用指南之时光穿梭机 之三 &gt;&gt;&gt; Git 使用指南之远程仓库 之四 &gt;&gt;&gt; Git 使用指南之分支管理 之五 &gt;&gt;&gt; Git 使用指南之 WorkFlow (工作流) 之六 &gt;&gt;&gt; Git 使用指南之 Git 自定义 之七 &gt;&gt;&gt; Git 使用指南之 HEAD 指针 之八 &gt;&gt;&gt; Git 使用指南之 Git 中的黑魔法","link":"/2017/07/07/git-shi-yong-zhi-nan-zhi-git-zhong-de-hei-mo-fa/"},{"title":"Git 使用指南之 HEAD 指针","text":"HEAD 指针说明，未完待续 版权说明： 本文思路以及内容主要来自廖雪峰老师的 Git 教程 （强烈推荐膜拜原文），并结合个人使用所作，只作为学习记录使用。如内容有侵权请联系删除，禁止转载！ 更多 Git 相关内容，请关注博主 Git 博文系列： 之一 &gt;&gt;&gt; Git 使用指南之初识 之二 &gt;&gt;&gt; Git 使用指南之时光穿梭机 之三 &gt;&gt;&gt; Git 使用指南之远程仓库 之四 &gt;&gt;&gt; Git 使用指南之分支管理 之五 &gt;&gt;&gt; Git 使用指南之 WorkFlow (工作流) 之六 &gt;&gt;&gt; Git 使用指南之 Git 自定义 之七 &gt;&gt;&gt; Git 使用指南之 HEAD 指针 之八 &gt;&gt;&gt; Git 使用指南之 Git 中的黑魔法","link":"/2017/07/06/git-shi-yong-zhi-nan-zhi-head-zhi-zhen/"},{"title":"Git 使用指南之 Git 自定义","text":"Git 中支持自定义 忽略文件，使得 Git 自动忽略这些文件，不再被 track。还支持为 Git 中的命令配置简单、易用的 别名，这在频繁使用包含较为复杂参数的命令时极有成效！甚至当你不想使用 Github 或者 Gitee 时，你可以选择自定义 搭建一台 Git 服务器 作为私有仓库使用。 版权说明： 本文思路以及内容主要来自廖雪峰老师的 Git 教程 （强烈推荐膜拜原文），并结合个人使用所作，只作为学习记录使用。如内容有侵权请联系删除，禁止转载！ 更多 Git 相关内容，请关注博主 Git 博文系列： 之一 &gt;&gt;&gt; Git 使用指南之初识 之二 &gt;&gt;&gt; Git 使用指南之时光穿梭机 之三 &gt;&gt;&gt; Git 使用指南之远程仓库 之四 &gt;&gt;&gt; Git 使用指南之分支管理 之五 &gt;&gt;&gt; Git 使用指南之 WorkFlow (工作流) 之六 &gt;&gt;&gt; Git 使用指南之 Git 自定义 之七 &gt;&gt;&gt; Git 使用指南之 HEAD 指针 之八 &gt;&gt;&gt; Git 使用指南之 Git 中的黑魔法 忽略特殊文件场景描述：日常项目中，很多时候你必须把某些文件放到 Git 工作目录中，但又不能提交它们，比如保存了数据库密码的配置文件啦，等等…每次 git status 都会显示 Untracked files ...，有强迫症的看官心里肯定不爽。 解决方法 &gt;&gt;&gt;&gt; Git 考虑到了大家的感受，通过 Git 工作区的根目录下创建一个特殊的 .gitignore 文件，然后把要忽略的文件名填进去，Git 就会自动忽略这些文件。 GitHub Ignore Repo不需要你从头去写 .gitignore 文件，GitHub 已经为我们准备了各种工程项目（Pyhont、Java…）的配置文件，只需要组合一下就可以使用了。所有配置文件可以直接在线浏览： 传送门 —&gt; https://github.com/github/gitignore Ignore Document Policy设置忽略文件，要遵循忽略文件的原则： 忽略操作系统自动生成的文件，比如缩略图等； 忽略编译生成的中间文件、可执行文件等：也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如 Java 编译产生的 .class 文件； 忽略你自己的带有敏感信息的配置文件，比如存放密码、口令的配置文件； 忽略配置文件需要提交。 举个例子 &gt;&gt;&gt;&gt; 假设你在 Windows 下进行 Python 开发，Windows 会自动在有图片的目录下生成隐藏的缩略图文件，如果有自定义目录，目录下就会有 Desktop.ini 文件，因此你需要忽略 Windows 自动生成的垃圾文件： 1234# Windows:Thumbs.dbehthumbs.dbDesktop.ini 然后，继续忽略 Python 编译产生的 .pyc、.pyo、dist 等文件或目录： 1234567# Python:*.py[cod]*.so*.egg*.egg-infodistbuild 加上你自己定义的文件，最终得到一个完整的 .gitignore 文件，内容如下： 12345678910111213141516# Windows:Thumbs.dbehthumbs.dbDesktop.ini# Python:*.py[cod]*.so*.egg*.egg-infodistbuild# My configurations:db.inideploy_key_rsa 最后一步就是把 .gitignore 也提交到 Git，就完成了！！！ 当然，检验 .gitignore 的标准是 git status 命令是不是说 working directory clean。 Git-Ignore More.gitignore 配置文件配置不精确导致某些特殊需要文件被忽略 &gt;&gt;&gt;&gt; 有些时候，你想添加一个文件（App.class）到 Git，但发现添加不了，原因是这个文件被 .gitignore 忽略了： 1234$ git add App.classThe following paths are ignored by one of your .gitignore files:App.classUse -f if you really want to add them. 输出信息提示：如果你确实想添加该文件，可以用 -f 强制添加到 Git： 1$ git add -f App.class 忽略规则配置文件检查（推荐） 如果由于 .gitignore 配置文件配置不精确导致某些特殊需要文件被忽略，你需要找出来到底哪个规则给过滤掉了，这时可以用 git check-ignore 命令检查： 12$ git check-ignore -v App.class.gitignore:3:*.class App.class Git 告诉我们：.gitignore 的第 3 行规则忽略了该文件，于是我们就可以知道应该修订哪个规则。 事实上，很多时候都是由于个人编写的规则排除了部分文件，如下内容： 1234# 排除所有.开头的隐藏文件:.*# 排除所有.class文件:*.class 发现：.* 这个规则把 .gitignore 排除了，并且 App.class 需要被添加到版本库，但也被 *.class 规则排除了。 虽然可以使用 git add -f 强制添加进去，但不要破坏 .gitignore 规则，这个时候可以添加两条 例外规则： 12345678# 排除所有.开头的隐藏文件:.*# 排除所有.class文件:*.class# 不排除 .gitignore 和 App.class:!.gitignore!App.class 例外规则：把指定文件排除在 .gitignore 规则外的写法就是 ! + 文件名，只需把例外文件添加进去即可。 配置别名配置别名是针对 Git 中常用的较长，不容易记忆，或者参数太多太长的命令，为其配置精简别名，以简化使用。 配置配置别名的命令格式如下（注意添加 --global 的影响）： 12345# 为 git status 设置全局命令别名：git st$ git config --global alias.st status# 在当前仓库，为 git status 设置命令别名：git st$ git config alias.st status 大多数开发人员配置的别名（以全局配置为例）： 123$ git config --global alias.co checkout$ git config --global alias.ci commit$ git config --global alias.br branch 一个优秀的 git log 设置方案： 1git config --global alias.lg &quot;log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' --abbrev-commit&quot; 来看看效果： 1234567891011121314151617181920212223242526$ git log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' --abbrev-commit* 6a9789d - (HEAD -&gt; master, tag: v1.0, origin/master) Tag Test (3 hours ago) &lt;TheNightIsYoung&gt;* fb50835 - Dealing Merge Conflict (5 days ago) &lt;TheNightIsYoung&gt;|\\| * c07648e - (FeatureA) Merge conflic test in FeatureA (5 days ago) &lt;TheNightIsYoung&gt;* | 7d23fef - Merge conflic test in master (5 days ago) &lt;TheNightIsYoung&gt;* | 28157d9 - Merge with no-ff (5 days ago) &lt;TheNightIsYoung&gt;|\\ \\| * | 02636d0 - Func-Add Permission(no-ff) (5 days ago) &lt;TheNightIsYoung&gt;| * | b324182 - Func-Add User(no-ff) (5 days ago) &lt;TheNightIsYoung&gt;|/ /* | 8a39810 - Func-Add Permission (5 days ago) &lt;TheNightIsYoung&gt;* | 3d6d64d - Func-Add User (5 days ago) &lt;TheNightIsYoung&gt;* | 5f264b1 - (tag: v1.2) Merge branch 'featureB' (5 days ago) &lt;TheNightIsYoung&gt;|\\ \\| |/|/|| * 4528426 - (featureB) Add BTest File For featureB (5 days ago) &lt;TheNightIsYoung&gt;* | fc2702b - Add ATest File For (5 days ago) &lt;TheNightIsYoung&gt;|/* 79c3a2c - Add git_rm_test.txt (8 days ago) &lt;TheNightIsYoung&gt;* fe3235b - git tracks changes (8 days ago) &lt;TheNightIsYoung&gt;* d6ddc31 - Git local data management test (8 days ago) &lt;TheNightIsYoung&gt;* 0f5a696 - understand how stage works (8 days ago) &lt;TheNightIsYoung&gt;* ebba382 - Add test code (8 days ago) &lt;TheNightIsYoung&gt;* da1fadc - Add help info (8 days ago) &lt;TheNightIsYoung&gt; 自己动手设置一下，效果显著~~~ 删除有时候，我们想要删除配置好的别名删除怎么办？这时，需要借助配置文件。 我们知道，配置 Git 的时候，加上 --global 是针对当前用户起作用的；如果不加，那只针对当前的仓库起作用。 首先，我们需要知道配置文件放在什么位置？ 1 –&gt; 仓库配置文件 仓库的配置文件都放在 .git/config 文件中： 12345678910111213141516$ cat .git/config [core] repositoryformatversion = 0 filemode = true bare = false logallrefupdates = true ignorecase = true precomposeunicode = true[remote &quot;origin&quot;] url = git@github.com:michaelliao/learngit.git fetch = +refs/heads/*:refs/remotes/origin/*[branch &quot;master&quot;] remote = origin merge = refs/heads/master[alias] last = log -1 别名就在 [alias] 后面，要删除别名，直接把对应的行删掉即可。 2 –&gt; 当前用户的 Git 配置文件 而当前用户的 Git 配置文件放在用户主目录（~）下的一个隐藏文件 .gitconfig 中： 123456789$ cat .gitconfig[alias] co = checkout ci = commit br = branch st = status[user] name = Your Name email = your@email.com 配置别名也可以直接修改这个文件。","link":"/2017/07/05/git-shi-yong-zhi-nan-zhi-git-zi-ding-yi/"},{"title":"HTML 教程之初识 HTML","text":"网站是由一个一个网页构成的，要想理解网站是什么？首先要理解网页是什么？？？度娘上 Search 网页编程，你会发现 HTML 几乎无孔不入… 事实上也正是如此，“HTML” 是每一个学习网页制作 Learner 的第一站。 什么是网页？我们日常网上冲浪所看到的网页，其实就是放在服务器上的一个个文件。当我们浏览网页时，这个文件会被从服务器下载到我们本地的电脑，然后再由浏览器解析，渲染出各种漂亮的界面，比如文本、图片、视频、表格等等。 事实上，网页文件的后缀有很多种，比如 .html、.php、.jsp、.asp 等，相信读者在浏览器的地址栏里也都见到过: https://www.w3school.com.cn/html/index.asp https://www.runoob.com/html/html-tutorial.html … 但不管网页的后缀是什么，它的本质都是一样的，就是由 HTML 代码构成的纯文本文件。 你可以使用任意一款文本编辑器，例如：记事本、VS Code、Notepad++、Sublime Text 等，打开网页文件，可以看到类似如下内容： 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;My First HTML Page&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;My First Title&lt;/h1&gt;&lt;p&gt;My First Paragraph&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 这就是 HTML 代码！！！ 事实上，真实网页的 HTML 代码远比上述代码复杂。你可以在任意一个网页上单击鼠标右键，然后在弹出菜单中选择 View Page Source（查看网页源代码），就可以查看当前网页的 HTML 代码；或者在任意一个网页上 &gt;&gt;&gt; Ctrl + S 将网页另存，然后使用任意文本编辑器打开网页文件查看页面代码。 什么是 HTML？首先你应该知道 –&gt; HTML 指的是超文本标记语言 (Hyper Text Markup Language)，是一种用来“描述网页”的语言。但是请注意，HTML 不是一种编程语言，而是一种标记语言（Markup Language），更准确的说是一种“标记标签（Markup Tag，也称为：HTML Tag）”语言。 简言之，HTML 就是一种使用 标记标签（Markup Tag/HTML Tag） 来描述网页的语言。 浏览器通过解析这些 HTML 标签，来渲染出各种我们看到的网页界面和效果。 HTML Markup TagHTML 标记标签通常被称之为 HTML 标签（HTML Tag）： HTML 标签是由 尖括号 包围的关键词，如 ； HTML 标签通常是 成对出现 的，比如 &lt;html&gt; ... &lt;/html&gt; &amp;&amp; &lt;b&gt; ... &lt;/b&gt;。也有一些单标签：&lt;br/&gt;； HTML 标签对中，第一个是 开始标签（开放标签），第二个是 结束标签（闭合标签）。 HTML 文档 == Web 页面我们使用 HTML Tag 编写符合 HTML 语言规范的 HTML 文档 的过程，就是一个个描述或制作网页的过程。 因此，HTML 文档也被称为 网页（Web Page），很多时候 HTML 文档也被称为 HTML 页面。 HTML 文档（Web Page）是由：HTML 标签 和纯文本构成。HTML 文档的后缀名：.html &amp; .htm，以上两种后缀名没有区别，都可以使用。 My First HTML Page这里，首先给出一个 Hello World 级别的 HTML 页面代码（如下）来作为后续 Web Page 编写 Demo： 当然，这里仅仅是为了演示，你不用过多的关注下面给出的 HTML 文档的具体内容，您将在下面的章节中学到它们的含义 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;title&gt;My First HTML Page&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;My First Title&lt;/h1&gt;&lt;p&gt;My First Paragraph&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 你可以发现：上面的 HTML 描述，确实是由 HTML 标签 和纯文本所构成。 正餐开始了…您可以依照以下四步来创建您的第一个 HTML 网页: Select Text Editor选择一款合适的文本编辑器 &gt;&gt;&gt;&gt; 当然，你可以使用专业的 HTML 编辑器来编辑 HTML。不过，新手推荐使用简单文本编辑器来学习 HTML，比如 Notepad++ (PC) 或 TextEdit (Mac)。一款简单的文本编辑器是学习 HTML 的好方法。 这里，为大家推荐两款款常用的编辑器： VS Code &gt;&gt;&gt; [https://code.visualstudio.com/] Sublime Text &gt;&gt;&gt; [http://www.sublimetext.com/] 下载以及安装完成之后，启动你所选择的文本编辑器，创建一个普通 TXT 文本。 Edict HTML Or Describe Your Web Page这里您直接使用本小结开始给出的 “HTML 页面描述 Demo” 中代码即可，将其内容复制到您所创建的 TXT 文本中。 Save As HTML在编辑器文件菜单选择 “Save As”，将其“另存为” HTML 文档，例如：MyFirstHTMLPage.html。 注意，这里要将文档后缀由 .txt 变更为 .html 或 .htm。 这样你就完成一个 HTML 文档（Web Page）的编写了~~~~ View In Web Explorer当我们完成了一个 HTML 文档的编写（或者描述完一个网页后），我们会迫不及待的想要 View 网页的效果： Web 浏览器（如Google Chrome、Internet Explorer、Firefox、Safari）可用于读取 HTML 文件，并将其作为网页显示。浏览器并不是直接显示 HTML 标签，它会通过解析 HTML 文档中使用的标签来决定如何展现 HTML页面 的内容给用户。 你可以直接将 HTML 文档拖拽到浏览器，或者使用双击 HTML 文档（MyFirstHTMLPage.html）的方式，使用 Web 浏览器预览你所制作的网页。 什么是网站？我们知道，Web Page 就是一个个的 HTML 文档。而一个网站由很多网页组成，可以将多个网页放在一个文件夹中，这个文件夹还可以嵌套其它子文件夹，最终形成一个类似如下树状结构： Domain Access通过域名访问网站 ↓↓↓↓↓↓↓↓ 假设我们给顶级目录 GameShow 绑定一个域名 www.domain.com，那么用户就可以通过 www.domain.com 来访问 GameShow 文件夹中的所有文件（包括子文件夹），例如： www.domain.com/index.html www.domain.com/Python/ www.domain.com/Python/download.html www.domain.com/PHP/index.html 可以认为 –&gt; 网站就是一个绑定了域名的文件夹，该文件夹中可以包含子文件夹以及各种各样的文件，这些文件都可以通过域名来访问。 当我们在地址栏中输入一个 URL 时，它其实已经展示了服务器上的目录结构，例如 http://c.biancheng.net/linux/index.html，就表示访问 linux 目录下的 index.html 文件（页面）。 IP Address Access通过 IP Address 访问网站 ↓↓↓↓↓↓↓↓ 当然，你也可以不绑定域名，只要在服务器上设置某个文件夹（GameShow）提供 Web 服务，用户也可以通过 IP 地址来访问。 互联网上的所有服务器都是通过 IP 地址来定位的，域名只是 IP 地址的一种别名，帮助用户记住网站的链接以及品牌（www.taobao.com &amp;&amp; cn.aliyun.com）。 实际上，使用域名（Domain）访问网站时，浏览器会先通过 DNS 域名解析服务器 拿到域名对应的 IP 地址（域名解析），然后再通过 IP 地址请求服务器上的文件。 网站可以认为是放在服务器上的一个文件夹，它包含了很多网页文件以及很多子文件夹。用户访问网站就是读取文件的内容，用户分享数据就是修改文件的内容，或者删除现有的文件，或者创建一个新的文件。 网站的作用是把计算机上的数据（文章、博客、图片、视频等）分享出去，让别人也能获取到有用的信息；同时，别人也能发布自己的数据（发布文章、留言、上传视频等），让网站的内容更加丰富。","link":"/2019/01/01/html-jiao-cheng-zhi-chu-shi-html/"},{"title":"Hello Hexo Matery World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment Begin To Edit ArticleDoc Front-Matter PolicyFront-matter 选项中的所有内容均为 非必填 的。推荐至少填写 title 和 date 的值。 配置选项 默认值 描述 title Markdown 的文件标题 文章标题，强烈建议填写此选项 date 文件创建时的日期时间 发布时间，强烈建议填写此选项，且最好保证全局唯一 author 根 _config.yml 中的 author 文章作者 img featureImages 中的某个值 文章特征图，推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.如: http://xxx.com/xxx.jpg top true 推荐文章（文章是否置顶），如果 top 值为 true，则会作为首页推荐文章 cover false v1.0.2版本新增，表示该文章是否需要加入到首页轮播封面中 coverImg 无 v1.0.2版本新增，表示该文章在首页轮播封面需要显示的图片路径，如果没有，则默认使用文章的特色图片 password 无 文章阅读密码，如果要对文章设置阅读验证密码的话，就可以设置 password 的值，该值必须是用 SHA256 加密后的密码，防止被他人识破。前提是在主题的 config.yml 中激活了 verifyPassword 选项 toc true 是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。前提是在主题的 config.yml 中激活了 toc 选项 mathjax false 是否开启数学公式支持 ，本文章是否开启 mathjax，且需要在主题的 _config.yml 文件中也需要开启才行 summary 无 文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要 categories 无 文章分类，本主题的分类表示宏观上大的分类，只建议一篇文章一个分类 tags 无 文章标签，一篇文章可以多个标签 keywords 文章标题 文章关键字，SEO 时需要 reprintPolicy cc_by 文章转载规则， 可以是 cc_by, cc_by_nd, cc_by_sa, cc_by_nc, cc_by_nc_nd, cc_by_nc_sa, cc0, noreprint 或 pay 中的一个 注意: 如果 img 属性不填写的话，文章特色图会根据文章标题的 hashcode 的值取余，然后选取主题中对应的特色图片，从而达到让所有文章都的特色图各有特色。 date 的值尽量保证每篇文章是唯一的，因为本主题中 Gitalk 和 Gitment 识别 id 是通过 date 的值来作为唯一标识的。 如果要对文章设置阅读验证密码的功能，不仅要在 Front-matter 中设置采用了 SHA256 加密的 password 的值，还需要在主题的 _config.yml 中激活了配置。有些在线的 SHA256 加密的地址，可供你使用：开源中国在线工具、chahuo、站长工具。 您可以在文章md文件的 front-matter 中指定 reprintPolicy 来给单个文章配置转载规则 以下为文章的 Front-matter 示例。 The Simple Demo1234---title: typora-vue-theme主题介绍date: 2017-12-18 00:55:00--- The Most Complete Demo1234567891011121314151617---title: Hello, Hexo Worlddate: 2017-12-18 00:55:00author: Waldeinsamkeitimg: /source/images/xxx.jpgtop: truecover: truecoverImg: /images/1.jpgpassword: 8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92toc: falsemathjax: falsesummary: 这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要categories: Markdowntags: - Hexo - Markdown---","link":"/2017/09/23/hello-hexo-matery-world/"},{"title":"Java Hello World","text":"相信这里你已经对 Java 有了基本的了解，并且你已经完成了 Java 开发环境的基本搭建。你可能会很疑惑上面我们配置的开发环境是否真的可以运行 Java 应用程序？而不是通过简单的 java –version 来判断。看完本篇博文你会了解一个完整 Java 应用程序的基本开发过程。 Hello Java World在开始后续的学习之前，我们先给出一个经典的 Java 程序 Demo（HelloWorld）： 1234567891011/** * * My First Java Code * */public class HelloJava { public static void main(String[] args) { // TODO Auto-generated method stub System.out.println(&quot;Hello, Java World!&quot;); }} 先来看一下，上诉的 Java 程序有什么样的含义，具体 Java 语句的用法会在后续的学习中深入了解，这里不用深究。 上述代码的含义是，我们运行上述 Java 程序后，会在屏幕打印一行文字：Hello, Java World! 编写 Java 源程序Java 源程序可以使用任何一个文本编辑器（记事本、Sublime、Notepad++…）来编写，这里以 Windows 下的记事本为例： 1）新建一个空白记事本，然后如实地将我们上面给出的 Java 程序内容编写进去。 2）将写完代码后的文件另存为 HelloJava.java，保存类型选择“所有文件”，接着单击“保存”按钮，保存文件到任一文件夹中。 重新打开选用记事本打开编写好的 Java 源程序文件，如下： 提示：保存的 Java 源程序文件名中不能出现空格，类似 “Hello Java.java” 的文件名在编译时会出现找不到文件的错误。 编译源程序将 Java 源程序编写并保存到文件之后，还需要进行编译才能运行。编译 Java 源程序使用的是 JDK 中的 javac 编译器。你需要在 CMD 下执行： 1javac HelloJava.java 此时如果没有任何其他信息，表示该源程序通过了编译；否则会输出错误编译信息，这时说明程序中存在错误，必须根据错误提示，重新在记事本中打开 HelloJava.java 文件修改出错代码，修改完成后保存修改到文件，然后回到命令提示符窗口重新编译（可能要反复几次，修改程序中出现的多个编写错误），直到编译通过为止。 实在通过不了，你可以直接复制我上面给出的代码。 javac HelloJava.java 命令的作用是让 Java 编译器获取 Java 应用程序 HelloJava.java 的源代码，把它编译成符合 Java 虚拟机规范的字节码文件。 这时，你会发现在 HelloJava.java 同目录下生成一个新文件 HelloJava.class，此文件便是我们所说的字节码文件，它也是 JVM 上的可执行文件。 运行字节码文件编译完成后，我们就可以使用 Java 解释器（java）运行 Java 源程序所对应的字节码文件（.class）了，命令如下： 1java HelloJava 你会发现，DOS 下输出如下： Hello, Java World! 到这里，你已经成功运行了你写好的 Java 源程序了！ 注意，运行字节码文件时，无需使用 .class 全名。 Hello World 执行详解从上面的过程中，你肯定不难归纳出 Java 程序的运行必须经过的 3 个步骤： 编写：使用文本编辑器编写，最终形成后缀名为 .java 的 Java 源文件。 编译：是指使用 Java 编译器对源文件进行错误排査的过程，编译后将生成后缀名为 .class 的字节码文件，而不是不像 C 语言那样的可执行文件。 运行：是指使用 Java 解释器将字节码文件翻译成机器代码，执行并显示结果。 Java 程序运行流程示意图如下： 详细说明： 1.字节码文件，是一种二进制文件，是一种和任何具体机器环境及操作系统环境无关的中间代码，这就意味着 任何安装了 JDK 平台编译后生成的字节码文件是相同的。 2.编程人员和计算机都无法直接读懂字节码文件。 3.Java 解释器负责将字节码文件翻译成具体硬件环境和操作系统平台下的机器代码，以便执行。也就是说，Java解释器依托的 JVM 是平台相关的，不同平台下的 JVM 是不同的，相同的字节码文件会被翻译成不同的机器代码。 Java 虚拟机（JVM）是运行 Java 程序的软件环境，Java 解释器是 Java 虚拟机的一部分。 4.JVM 把不同软、硬件平台的具体差别隐藏起来，从而实现了真正的二进制代码级的跨平台移植。 Java 的这种运行机制如下： Java IDE事实上，我们在实际开发 Java 程序时，会使用 Java IDE（Java Integrated Development Environment，Java 集成开发环境）。 即我们会选择一款合适的 IDE 工具来完成 Java 程序的编写 &amp; 编译 &amp; 运行。 Java IDE 可以为我们提供如下功能： 提供代码编辑功能； 快捷方式调用：javac，java….. 可视化界面； 文档自动编写 … IDE 帮助我们把 Java 程序开发过程中的编写、分析、编译、调试、文档生成、字节码混淆、打包压缩、发布部署一系列任务等集成到一个可视化界面，极大的方便了开发人员的工作，提升了编程效率。 Java IDE 推荐：Eclipse / Intellij IDEA 关于反编译在 JDK 安装与配置博文中，JDK 安装目录详解时，我们提到过 javap 反编译器，不知道你是否还记得？？？ Java 程序经过编译后生成的 .class 文件中，包含有大量的源程序信息，很容易被反编译，拿到我们源程序信息。 例如，我们使用 javap 对上面我们的 Hello Java World Demo 进行反编译： 123456$ javap HelloJavaCompiled from &quot;HelloJava.java&quot;public class HelloJava { public HelloJava(); public static void main(java.lang.String[]);} 关于字节码混淆怎么办？事实上，我们可以使用 Java 代码混淆器来进行字节码混淆。 IDE 集成的字节码混淆功能，能够对字节码文件进行代码混淆，防止源程序不被解读。 代码混淆一般原理： 对 .class 文件或 .jar 文件中的字节码进行修改，使其不能被很好的反编译，或者反编译不容易阅读。","link":"/2017/10/10/java-hello-world/"},{"title":"Hexo 预安装环境部署之 Node.js","text":"Hexo 是一个快速、简洁且高效的博客框架。Hexo 通过 Node.js 所带来的超快生成速度，可利用靓丽的主题在几秒内瞬间完成静态网页渲染。因此安装 Hexo 前，我们必须完成 Node.js 应用程序的下载和安装。 更多 Hexo 博客框架内容，请关注博主 Hexo 博文系列： 一文学会 Hexo 轻量级框架的博客搭建【持续更新】 Hexo 预安装环境部署之 Node.js Git 使用指南之初识 打造沉浸式写作体验，你需要试试-Markdown-Editor 基于图床的博客图片存储解决方案 稳定快速、高效免费的图床方案-Github-jsDelivr-PicGo Hexo 博客多设备协同管理问题【持续更新】 Node.js了解一定网页基础的同学肯定听说过 JavaScript。Node.js 是一个基于 Chrome JavaScript 运行时建立的一个平台。简单的说， Node.js 就是运行在服务端的 JavaScript。 当然不了解 JavaScript 的同学也不要慌张，我们只需要将 Node.js 理解为：是 Hexo 用来渲染我们博客页面的插件即可。毕竟这里我们更关注的 Node.js 下载和安装，并不关心其原理以及使用。 开始安装之前，这里先给出 Node.js 安装包及源码下载地址。截至目前， Node.js 最新可供下载安装版本为：v10.15.0 (includes npm 6.4.1)。官网下载界面如下，我们可以根据不同平台的下载要求获取相应的安装包： 当然，你也可以从 Node.js 历史版本 获取到较老的历史版本。 下面我们来看不同平台（Windows、Linux 以及 Mac）下 Node.js：v10.15.0 (includes npm 6.4.1) LST（长期支持版本） 的下载以及安装方法： Windows 平台下安装 Node.js这里我们提供了两种 Windows 平台下来安装 Node.js 的方式： 使用 MSI Windows 安装包方式首先打开 Node.js 官网下载地址，下载最新版本 Node.js MSI 安装包：node-v10.15.0-x64.msi 注意：要使用 MSI 安装应用程序 （例如：node-XYZ.msi）, Windows 系统必须支持 Microsoft Installer 2.0。需要看看你的机器是否支持 MSI，Windows XP 和更高版本 已经有 MSI，很多老机器也可以安装 MSI。安装时，只要保存安装文件（**.msi**）到本地计算机，然后运行它即可完成安装（安装时，根据提示 Next 即可）。 下面我们正式开始 node-v10.15.0-x64.msi 的安装过程： 步骤 1 : 双击下载后的安装包 node-v10.15.0-x64.msi 开启安装界面，然后点击 Next 。如下所示： 步骤 2 : 勾选接受协议许可选项，然后点击 Next: 步骤 3 : Node.js 默认安装目录为 C:\\Program Files\\nodejs 。 你可以自定义修改存储目录（这里我存储于：E:\\nodejs），然后点击 Next： 步骤 4 : 点击树形图标来选择你需要的安装模式（默认为：Node.js runtime，这里我们选择：online documentation shortcuts）, 然后点击 Next 进入 Setup 界面。 步骤 5 : 点击 Install（安装） 开始安装 Node.js。 然后点击 Next，等待安装完成点击 Finish 即可： 步骤 6：DOS 安装检测 首先检测系统 PATH 环境变量中是否成功配置了 Node.js（这是关键的），日志信息输出如下： 12345PATH=C:\\WINDOWS\\system32;C:\\WINDOWS;C:\\WINDOWS\\System32\\Wbem;C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\;C:\\WINDOWS\\System32\\OpenSSH\\;E:\\TortoiseSVN\\bin;E:\\Git\\cmd;E:\\nodejs\\;C:\\Users\\xxxxxx\\AppData\\Local\\Microsoft\\WindowsApps;E:\\Anaconda3\\Scripts;E:\\Anaconda3;C:\\Users\\xxxxxx\\AppData\\Roaming\\npm 可以看到 E:\\nodejs\\ 路径已经被成功添加到系统环境变量 Path 中。否则请手动添加系统环境变量。 此时我们来查看安装好的 Node.js 版本号： 12C:\\Users&gt;node -vv10.15.0 至此，使用 “MSI Windows 安装包” 的方式安装 Node.js 的过程已经全部完成。 使用 EXE Windows 二进制文件方式首先打开 Node.js 官网下载地址，下载最新版本 Node.js Binary 安装包：node-v10.15.0-win-x64.zip。 使用 Windows 二进制文件安装 Node.js 比较简单。直接解压安装包，然后双击安装目录下的：node.exe 等待即可…… 注意，node.exe 安装过程中会出现如下安装窗口： 安装版本测试： 查看已安装 Node.js 版本号，信息如下表示安装成功： 12C:\\Users&gt;node -vv10.15.0 如果没显示正确版本号，请手动添加系统环境变量。 Linux 平台下安装 Node.js 注意：Linux 上安装 Node.js 需要安装 Python 2.6 / 2.7 ，不建议安装 Python 3.0 以上版本。 Linux 平台下，我们也提供了两种 Node.js 的 v10.15.0 (includes npm 6.4.1) LST（长期支持版本）的安装方式： 使用已编译好的包Node.js 官网提供了已经编译好的 linux Node.js 安装包，解压即用： 123456789# 下载相应版本安装包（下载目录为：/usr/software）：$ wget -c https://nodejs.org/dist/v10.15.0/node-v10.15.0-linux-x64.tar.xz＃ 解压：$ tar -zxvf node-v10.15.0-linux-x64.tar.xz# Node.js 安装版本测试：＄ cd node-v10.15.0-linux-x64$ ./bin/node -vv10.15.0 注意，你可以在 https://nodejs.org/dist 中查找到其它支持的 node.js 版本进行下载。 注意，解压文件的 bin 目录底下包含了 node、npm 等命令，为了方便系统调用，我们可以使用 ln 设置命令软链接： 12ln -s /usr/software/node-v10.15.0-linux-x64/bin/npm /usr/local/bin/ ln -s /usr/software/node-v10.15.0-linux-x64/bin/node /usr/local/bin/ 使用源码安装1）Ubuntu 这一小节我们来看如何在 Ubuntu OS 环境下使用源码安装 Node.js： 步骤一：前往 Node.js 官网下载地址 获取其源码（source code）下载链接，然后进行下载： 1$ wget -c https://nodejs.org/dist/v10.15.0/node-v10.15.0.tar.gz 步骤二：开放目录权限： 1$ sudo chmod -R 755 node 步骤三：依次执行如下命令编译源码： 1234$ cd node-v10.15.0$ sudo ./configure$ sudo make$ sudo make install 步骤四：设置 Node.js 环境变量，并且完成 source： 123456789# 打开全局配置文件增加如下配置：$ vim /etc/profile# Set for node.jsexport NODE_HOME=/usr/local/node/10.15.0export PATH=$PATH:$NODE_HOME/bin# 使配置文件生效：$ source /etc/profile |——————————————————— 补充：Ubuntu 还可以通过 apt-get 命令 直接安装： 12sudo apt-get install nodejssudo apt-get install npm ———————————————————| 步骤五：检测是否安装成功： 12$ node --versionv10.15.0 2）Centos 这一小节我们来看如何在 Centos OS 环境下使用源码安装 Node.js： 步骤一：前往 Node.js 官网下载地址 获取其源码（source code）下载链接，然后进行下载： 1$ wget -c https://nodejs.org/dist/v10.15.0/node-v10.15.0.tar.gz 步骤二：解压源码文件： 1$ tar -zxvf node-v10.15.0.tar.gz 步骤三：依次执行如下命令编译安装源码： 1234cd node-v10.15.0./configure --prefix=/usr/local/node/10.15.0makemake install 步骤四：设置 Node.js 环境变量，并且完成 source： 123456789# 打开全局配置文件增加如下配置：$ vim /etc/profile# Set for node.jsexport NODE_HOME=/usr/local/node/10.15.0export PATH=$PATH:$NODE_HOME/bin# 使配置文件生效：$ source /etc/profile 步骤五：验证是否安装配置成功： 1$ node -v Mac 平台下安装 Node.js这里我们提供两种方式来在 Mac OS 上安装 Node.js： 1）使用 pkg 安装包 前往 Node.js 官网下载地址 下载最新 Node 版本 .pkg 安装包，进行安装即可。 2）使用包管理器 1$ brew install node","link":"/2017/09/20/hexo-yu-an-zhuang-huan-jing-bu-shu-zhi-node-js/"},{"title":"JAVA 中的 JVM &amp; JRE &amp; JDK ?","text":"我们知道，任何语言或者软件的运行都依赖环境，Java 必然也不例外。Java 语言的开发运行，也离不开 Java 语言的运行环境 JRE。没有 JRE 的支持，Java 语言便无法运行。当然，如果还想编译 Java 程序，搞搞小开发的话，JRE 是明显不够了，这时候就需要 JDK。 那么， JDK，JRE 和 JVM 有什么区别以及联系呢？ JVM &amp; JRE &amp; JDK很多 Java 初学者肯定会或多或少产生过这样的疑问： JDK，JVM 和 JRE ？？？三者有什么区别？又有什么联系呢？ 所以，这里来整理一下三者的关系和区别： JDK（Java Development Kid，Java 开发工具包）：是针对 Java 开发人员的产品，是整个 Java 的核心，包括了 Java 运行环境 JRE、Java 工具和 Java 基础类库。 JRE（Java Runtime Environment，Java 运行环境）是运行 JAVA 程序所必须的环境的集合，包含 JVM 标准实现及 Java 核心类库。 JVM（Java Virtual Machine，Java 虚拟机）是整个 Java 实现跨平台的最核心的部分，能够运行以 Java 语言编写的软件程序。 还不明白？！直接上图： 可以看出： JDK = JRE + 多种 Java 开发工具 JRE = JVM + 各种类库 JDK &gt; JRE &gt; JVM –**&gt; Java IDE ** 那么，加入 Java IDE 的话，IDE 应该处于什么位置呢？？ JAVA IDE &gt; JDK &gt; JRE &gt; JVM","link":"/2017/10/09/java-zhong-de-jvm-jre-jdk/"},{"title":"Java, Write Once, And Run Any Where","text":"Java 语言特点中提到过，Java 是平台无关的。Java 的平台无关性具体表现在于 “一次编写，到处运行（Write Once，Run any Where）”，因此采用 Java 语言编写的程序具有很好的可移植性，编译之后可以直接在不同的平台上运行。 Java平台无关性为什么需要平台无关性平台无关（跨平台），用一句话来阐述就是 ”Write once, and run anywhere“，也就是说：语言在计算机上的运行不受不同平台的约束，一次编写，到处运行。 就比如说我们在 Windows 下面写出来的一段 Java 程序，换成 Linux or Mac os 系统里面，一样可以正常运行并且输出相同的结果。 Java 的这种跨平台的特性，很大程度上依赖于 JVM（Java Virtual Machine），但注意不仅限于 JVM。 Java 如何支持平台无关性1 –&gt; Java 平台本身 Java 平台中的 Java API（Application Programming Interface，Java 应用编程接口），提供了一套独立于操作系统的标准接口，作为 Java 程序和所在平台（硬件与操作系统）之间的缓冲角色，这样开发编写 Java 程序只与 Java 平台打交道，而不需要了解平台硬件或操作系统细则。 2 –&gt; Java 字节码 不同平台下，Java 程序经过 Java 编译器会被编译成 同样的 二进制 的 Java 字节码文件（class文件）。class 文件可以在任何平台（Win or Linux or Mac）生成，也可以被任何平台的 JVM 装载运行。 Java 字节码是 Java 平台无关的基石，真正的平台无关。 3 –&gt; JVM 虚拟机机制 Java 的平台无关性很大程度上依赖于 JVM（Java Virtual Machine），JVM 是可以执行 Java 字节码的虚拟进程。JVM 能够将 相同的字节码 编译成与平台相关的 不同的机器码，从而进一步再解释执行。 JVM 机制百度百科上 JVM 的专业解释如下： Java 虚拟机（Java Virtual Machine，简称 JVM）是一种用于计算设备的规范，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。 Java 虚拟机包括一套字节码指令集、一组寄存器、一个栈、一个垃圾回收堆和一个存储方法域。JVM 屏蔽了与具体操作系统平台相关的信息，使 Java 程序只需生成在 Java 虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。JVM 在执行字节码时，实际上最终还是把字节码解释成具体平台上的机器指令执行。 ============================================== 通俗的说： JVM，也就是 Java 虚拟机，就属于 Java 平台的一部分，包含于 JRE 的下面。 解释执行当你需要执行某个 Java 程序时，由 JVM 帮你进行进一步编译（JIT，Just In Time）和解释执行，它负责将编译生成的字节码文件翻译成特定平台下的机器码然后运行。 注意： 1. 编译的结果不是生成机器码，而是生成字节码，字节码不能直接运行。必须通过 JVM 翻译成机器码才能运行。2. 不同平台下编译生成的字节码是一样的，但是由 JVM 翻译成的机器码却不一样。 因此，运行 Java 程序必须有 JVM 的支持，即使你将 Java 程序打包成可执行文件（例如 .exe），仍然需要 JVM 的支持。 平台相关性JVM 屏蔽了与具体操作系统平台相关的信息，可以得知，JVM 是平台相关的。 事实上也正是如此，JVM 分为很多个系统版本的，你编写好的 Java 程序，无论到哪个平台上，Windows 也好，Linux 也好，Mac 也罢，只需要安装对应平台 JVM，便可以成功编译和执行。 这里我们知道： 跨平台的是字节码（Java 程序），不是 JVM。JVM 是平台相关的，不同平台下需要安装不同版本的 JVM。 Java API待续…","link":"/2017/10/09/java-write-once-and-run-any-where/"},{"title":"Java 中的 final 修饰符","text":"Java 中 final 修饰符的使用。 final 修饰变量我们知道，final 修饰符可用来修饰变量。 final 修饰变量（基本数据类型，或引用数据类型）时，三大原则： 当定义的 final 变量为成员变量（类或结构中的属性）时，必须在定义时就明确设定它的初始值，否者直接会报错无法通过编译，并且如果再次对其进行赋值将会提示编译错误。 当定义的 final 变量为 方法中（方法内，或方法块内）的局部变量 时，可以直接定义时赋值，也可以由开发者在声明后，第一次使用该变量之前，显式的赋初始值，实例化该变量； 当定义的 final 变量为 方法上的局部变量（参数） 时，是为了防止数据在方法体中被修改，这时参数的值（或引用）在方法体内是不能不能被重新赋值的。 根据 Java 中数据类型的分类，这里 final 修饰符修饰的变量的使用场景我们需要注意以下两种，使用上是有细微差异的（两个注意）： final 修饰符修饰基本数据类型的变量 final 修饰符修饰引用数据类型的变量 1 –&gt; 修饰基本数据类型的变量时 final 修饰基本数据类型的变量时，基本类型的值是不能够改变的。 2 –&gt; 修饰引用数据类型的变量时 final 修饰引用数据类型的变量时，引用类型变量所指的引用是不能够改变的（地址不变），但是引用类型变量的值是可以改变的（地址所指向存储空间值可变）。 详细使用样例差异，可见下文原则 1~3 中样例。 原则一当定义的 final 变量为成员变量（类或结构中的属性）时，必须在定义时就明确设定它的初始值，否者直接会报错无法通过编译，并且如果再次对其进行赋值将会提示编译错误。 1 –&gt; 基本数据类型 12345678910public class HelloJava { static final int i = 3; // 声明时，显式初始化 public static void main(String[] args) { // TODO Auto-generated method stub System.out.println(i); } } 关于 final 前面的 staitc 修饰符，这里可以不用深究，你就当没看见。 输入： 1203 2 –&gt; 引用数据类型 12345678910public class HelloJava { static final String str1 = &quot;this is a test&quot;; // 声明时，显式初始化 public static void main(String[] args) { // TODO Auto-generated method stub System.out.println(str1); } } 输入： 12nullthis is a test 下面这样的表达可以么？（先忽略之后的注释） 1234567891011121314151617181920public class HelloJava { static final int i; // 编译不通过，声明时，未初始化 static final int j = 3; static final String str1; // 编译不通过，声明时，未初始化 static final String str2 = null; static final int[] a_test = {2,3,4}; public static void main(String[] args) { // TODO Auto-generated method stub j = 1; // 编译错误，再次对 final 修饰成员变量进行赋值操作 System.out.println(j); System.out.println(str2); a_test = {1,2}; // 编译错误，引用类型变量所指的引用是不能够改变的 a_test[0] = 2; // 编译可通过，引用类型变量的值是可以改变的 } } =========================================== final 修饰的成员变量的另一种赋值方法（构造函数）： 1234567public class FinalDemo { final int age; public FinalDemo(int age){ this.age=age; // 编译通过 }} 你可以想想上述赋值方法成立的原因…. 原则二当定义的 final 变量为 方法中（方法内，或方法块内）的局部变量 时，可以直接定义时赋值，也可以由开发者在声明后，第一次使用该变量之前，显式的赋初始值，实例化该变量。 1 –&gt; 基本数据类型 12345678910111213public class HelloJava { public static void main(String[] args) { final int i_test = 3; // 变量声明时，进行初始化 System.out.println(i_test); final int j_test; j_test = 1; // 变量声明后，使用前，进行初始化 System.out.println(j_test); } } 输出： 1231 2 –&gt; 引用数据类型 12345678910111213public class HelloJava { public static void main(String[] args) { // TODO Auto-generated method stub final String i_test = &quot;abc&quot;; System.out.println(i_test); final String j_test; j_test = &quot;def&quot;; System.out.println(j_test); } } 输出： 12abcdef 下面这样的表达可以么？（先忽略之后的注释） 12345678910111213141516public class HelloJava { public static void main(String[] args) { // TODO Auto-generated method stub int i = 1; final String str; if (i &gt; 0) { str = &quot;this is a test&quot;; str = &quot;test&quot;; // 编译错误，块内使用前多次初始化赋值 str.length(); // 编译可通过，块内使用前已初始化赋值 } else { str.length(); // 编译错误，块内使用前未初始化赋值 } } } 原则三当定义的 final 变量为 方法上的局部变量（参数） 时，是为了防止数据在方法体中被修改，这时参数的值（或引用）在方法体内是不能被重新赋值的。 但需要谨记上文的 两个注意。 1 –&gt; 基本数据类型 1234567891011public class HelloJava { public static void main(String[] args) { // TODO Auto-generated method stub } public static void checkValue(final int a) { a = 234; // 编译错误，基本类型的值在方法内部是不能够改变的 } } 2 –&gt; 引用数据类型 123456789101112public class HelloJava { public static void main(String[] args) { // TODO Auto-generated method stub } public static void checkValue(final int[] a) { a = {2,3,4}; // 编译错误，a 变量的引用是不能够改变的 a[0] = 3; // 编译可通过，a 变量所指向的存储中的值是能够修改的 } } final 修饰类final 修饰类时，可以继承其他类，但是不可以被继承的，使用方式跟其它类一样。 123class Parent{}final class Person extends Parent{}class child extends Person{} final 修饰方法final 修饰方法时，不可以被覆盖（不可以重写），但可以继承使用。 123456789class Parent { // final 修饰的方法，不可以被覆盖，但可以继承使用 public final void method1(){} public void method2(){} // 普通方法}class Child extends Parent { // 普通 method2 方法，支持重写 public final void method2(){}}","link":"/2017/10/13/java-zhong-de-final-xiu-shi-fu/"},{"title":"Java 程序设计基础之数据类型","text":"前面我们在介绍 Java 中的字面值以及变量时提到过，Java 中的数据类型分类：基本数据类型（Primitive Type）和引用数据类型（Reference Type），本文我们来详细解读 Java 的数据类型定义以及应用，本文学习之后重新回顾之前的内容，可以帮助你更好的理解前文。 Java 中的数据类型结构如图： 下面我们分别来看两种数据类型的说明： Java 中的基本数据类型Java 中包含八种基本的数据类型，都是 Java 基础语言中预先定义好的。 基本数据类型包括：byte（字节型）、short（短整型）、int（整型）、long（长整型）、boolean（布尔型）、char（字符型）、float（单精度浮点型）、和 double （双精度浮点型）共 8 种。 所有的基本数据类型的大小（所占用的字节数，数据取值范围）都已明确规定，在各种不同的平台上保持不变，这一特性有助于提高 Java 程序的可移植性。 类型名称 关键字 占用内存 取值范围 字节型 byte 1 字节 -128~127 短整型 short 2 字节 -32768~32767 整型 int 4 字节 -2147483648~2147483647 长整型 long 8 字节 -9223372036854775808L~9223372036854775807L 单精度浮点型 float 4 字节 +/-3.4E+38F（6~7 个有效位） 双精度浮点型 double 8 字节 +/-1.8E+308 (15 个有效位） 字符型 char 2 字节 ISO 单一字符集，也可以看作是一种整数类型，相当于无符号整数类型 布尔型 boolean 1 字节 true 或 false 整数类型Java 定义了 4 种整数类型变量用于存放整型字面值： 字节型（byte） 短整型（short） 整型（int） 长整型（long） 使用说明如下： 名称 说明 byte byte 类型是最小的整数类型。当用户从网络或文件中处理数据流时，或者处理可能与 Java 的其他内置类型不直接兼容的未加工的二进制数据时，该类型非常有用。 short short 类型限制数据的存储为先高字节，后低字节，这样在某些机器中会出错，因此该类型很少被使用。 int int 类型是最常使用的一种整数类型。 long 对于大型程序常会遇到很大的整数，当超出 int 类型所表示的范围时就要使用 long 类型。 这些都是有符号的值，具体区别在于不同类型的整型，最大值，最小值不一样，见小节开始。 如果试图给 byte 类型的变量赋予超出其范围的值（300），就会产生编译错误 1234567891011public class HelloWorld{ public static void main(String[] args){ byte b = 1; short s = 200; int i = 300; long l = 400L; byte b2 = 200; // 编译错误 }} 字符型Java 语言中的字符类型（char）使用两个字节的 Unicode 编码表示，它支持世界上所有语言，可以使用单引号字符或者整数（0~65535）对 char 型赋值。 超过一个字符，或整数超过 65535 就会产生编译错误。 123456789public class HelloWorld{ public static void main(String[] args){ char c = '中'; char c2 = '中国'; // char 只能存放一个字符，超过一个字符就会产生编译错误 char c3 = 'ab'; // char 只能存放一个字符，超过一个字符就会产生编译错误 }} 前面我们知道，字符型字面值中的字符可以八进制或者十六进制，八进制使用 ‘反斜杠加3位八进制数字’ 表示，例如 ‘\\141’ 表示字母 a。十六进制使用 ‘\\u加上4为十六进制的数’ 表示，如 ‘\\u0061’ 表示字符 a。 Java 只允许转义不超过 0377 的八进制数来表示字符。0377 是占满 8 位的数，但 Java 中的 char 是 16 位，所以无法表达所有 char 值。 其实 Java 允许转义八进制数表示字符是来源于 C 语言，C 中字符类型只占 8 位，所以才有这个限制。Java 是推荐使用转义十六进制数来表示 char 的。 如果不用转义，换一种方式，你可以用“把八进制数表示为整型，再把整型转为 char 类型”来实现八进制数到 char 的转换。用 ‘卷’ 举例，它的八进制数值为 051567，可以这样：char c = (char)051567; Unicode 字符集（char）通常用十六进制表示，范围从\\uOOOO ~ \\uFFFF，刚好占满（0~65535）。 布尔类型布尔类型（boolean）用于对两个数值或表达式通过逻辑运算，判断结果是“真”还是“假”。 只能是取 true 和 false 这两个值中的一个。 在 Java 语言中，布尔类型的值不能转换成任何数据类型，true 常量不等于 1，而 false 常量也不等于 0。这两个值只能赋给声明为 boolean 类型的变量，或者用于布尔运算表达式中。 浮点类型浮点类型是带有小数部分的数据类型，也叫实型。 浮点型数据包括单精度浮点型（float）和双精度浮点型（double），代表有小数精度要求的数字。 一个值要能被真正看作 float，它必须以 f（或 F）后缓结束；否则，会被当作 double 值。对 double 值来说，d（或 D）后缓是可选的。 123456789public class HelloWorld{ public static void main(String[] args){ double d = 123.45; float f = 54.321; //该行会出现编译错误，因为 54.321 默认是 double 型的 float f2 = 54.321f; }} String说起数据类型，不得不提的就是字符串类型，是使用双引号引起来的单个或多个字符。 事实上，Java 中 String 类型其实 并不是基本类型，是一个类，并且是 Immutable（不可变）类型的，一旦创建就不能够被改变。 引用类型所谓引用数据类型就是对一个对象的引用。 引用数据类型是建立在基本数据类型的基础上，包括数组、类和接口。 Java 语言中不支持 C++ 中的指针类型、结构类型、联合类型和枚举类型。 引用类型还有一种特殊的 null 类型。因为 null 类型没有名称，所以不可能声明一个 null 类型的变量或者转换到 null 类型。 在实际开发中，程序员可以忽略 null 类型，把 null 只当作是引用类型的一个特殊字面值，用于给引用类型赋初始值，并且不要把一个 null 值赋给基本数据类型的变量。。 数据类型转换数据类型的转换是在所赋值的数值类型和被变量接收的数据类型不一致时发生的，它需要从一种数据类型转换成另一种数据类型。也就是说，不同类型之间的数据可以互相转换。 但是要注意，满足一定的规则才可以互相转换： 精度高的数据类型就像容量大的杯子，可以放更大的数据精度低的数据类型就像容量小的杯子，只能放更小的数据小杯子往大杯子里倒东西，大杯子怎么都放得下大杯子往小杯子里倒东西，有的时候放的下，有的时候就会有溢出 所以根据以上两种情况，Java 中的数据类型的转换可以分为 隐式转换（自动类型转换） 显式转换（强制类型转换） 隐式转换自动转换规则：低精度类型向高精度类型进行转换，会进行自动转换。 这里有一个 拓宽转换（widening conversion）原则：在运算过程中，由于不同的数据类型会转换成同一种数据类型，所以整型、浮点型以及字符型都可以参与混合运算。最终结果会自动转发成高精度的字面值。 123456789101112public class HelloJava { public static void main(String[] args) { // TODO Auto-generated method stub float c_test = 10 + 10.0 + 'a'; // 编译错误，将 double 型字面值赋直接给 float short a = 1; short b = 2; short c = a+b; // 编译错误，将 int 型字面值赋直接给 short } } 任何运算单元的长度，超过 int,那么运算结果就按照最长的长度计算。不超过 int,那么运算结果就按照 int 来计算 自动转换规则： 数值型数据的转换：byte→short→int→long→float→double。 字符型转换为整型：char→int→long→float→double。 需要注意的是，虽然 short 和 char 都是16位的，长度是一样的，但是彼此之间，依然需要进行强制转换。byte 也不能自动转换为 char，而且 char 也不能自动转换为 byte。 这里的强制转换，就是我们下面要提到的显示转换。 – &gt; 自动类型提升有好处，但它也会引起令人疑惑的编译错误。引发一个问题： 12byte b = 50;b = b * 2; // Type mismatch: cannot convert from int to byte 第二行会报 “类型不匹配：无法从int转换为byte” 错误。 该程序试图将一个完全合法的 byte 型的值 50*2 再存储给一个 byte 型的变量。但是当表达式求值的时候，操作数被自动的提升为 int 型，计算结果也被提升为 int 型。这样表达式的结果现在是 int 型，不强制转换它就不能被赋为 byte 型。 所以应该使用一个显示的强制类型转换，例如： 12byte b = 50;b = (byte)(b*2); 显示转换当两种数据类型不兼容（byte &lt;–&gt; char），或目标类型的取值范围小于源类型时，自动转换将无法进行，这时就需要进行显示的强制类型转换。其语法格式如下： 1(type)variableName 但是注意，强制转换的意思就是，转是可以转的，但是不对转换之后的值负责。 风险自担，后果自负 就像我们前面说的，大杯子往小杯子里倒东西，有的时候放的下，有的时候就会有溢出。当出现溢出时，不也就意味着数据丢失么？所以使用显示转换时要注意！！！ 显示转化可使用场景如下：","link":"/2017/10/14/java-cheng-xu-she-ji-ji-chu-zhi-shu-ju-lei-xing/"},{"title":"Java 程序设计基础","text":"要想编写规范、可读性高的 Java 程序，就必须熟练掌握 Java 基本语法。基本语法是所有编程语言都必须掌握的基础知识，也是整个程序代码不可缺少的重要部分。随后的章节开始学习 Java 的基础语法部分，主要分为 4 部分内容：数据类型，变(常)量，运算符，以及控制流程语句，这也是构成 Java 程序最基础的 4 个部分，敲黑板！ 其中，数据类型和运算符不仅定义了语言的规范，还决定了可以执行什么样的操作；变量是用来存储指定类型的数据；而控制流程根据用户的输入决定程序要进入什么流程，即要做什么？如何做？ 在开始正式的学习之前，我们需要先了解一些 Java 基本语法最最基本的定义： Java 标识符 &amp; 关键字任何一种计算机语言都离不开标识符和关键字，本小节将详细介绍 Java 的标识符、关键字（保留字）。 标识符所有编程语言中的 标识符，都是为 变量、方法、类、对象以及文件、工程 等进行命名的，可以有一个或多个字符。 标识符构成规则Java 语言规定的，标识符的构成规则如下： 标识符可以由任意多的 字母（AZ 和 az），数字（0~9），下划线（_），dollar 符（$），Unicode 字符集中符号（大于 0xC0 ）的所有符号组合构成。注意不包含空格！！！ 必须以字母，dollar 符以及下划线开头，不可以是数字。 运算符，关键字（保留字）以及标准方法名不可以作为标识符。 注意：标识符中可以包含 关键字 &amp; 标准方法名。 标识符命名规范一个良好的编程习惯要求命名标识符时，应赋予它 ”意义“（非强制）。 见名知义：代码命名神奇 –&gt; CodeIF； 包名全部小写； 类名各单词首字母大写（大驼峰命名法） 变量名，方法，类的实例：第一个单词字母小写，其它单词首字母大写（小驼峰命名法）； 常量名全部大写； 参数的名尽量使用一个单词的情况下，命名明确； 数组命名使用：”类型[] 数组名” 的形式。 驼峰命名法： 小驼峰式（little camel-case）–&gt; 第一个单词首字母小写，后面其他单词首字母大写。 大驼峰式（big camel-case）–&gt; 每个单词的第一个字母都大写; 关键字关键字（或者保留字）是语言中已经被赋予了特殊含义的专有单词，Java 编译器有特殊的意义，不能在程序中做其他目的使用。 保留字是为 Java 预留的关键字，它们虽然现在没有作为关键字，但在以后的升级版本中有可能作为关键字。 Java 语言目前定义了 51 个关键字，这些关键字不能作为标识符使用： 数据类型：boolean、int、long、short、byte、float、double、char、class、interface。 流程控制：if、else、do、while、for、switch、case、default、break、continue、return、try、catch、finally。 修饰符：public、protected、private、final、void、static、strict、abstract、transient、synchronized、volatile、native。 动作：package、import、throw、throws、extends、implements、this、supper、instanceof、new。 保留字：true、false、null、goto、const。 Java 注释注释不是编程语句，编译时会被编译器忽略。 Java 支持以下三种注释方式： 单行注释以双斜杠 “//” 标识，只能注释一行内容： 123456public class HelloJava { public static void main(String[] args) { // 这是一个单行注释 System.out.println(&quot;Hello, Java World!&quot;); }} 多行注释包含在 “/*” 和 “*/” 之间，能注释很多行的内容，也成为 块注释。 为了可读性（美观）比较好，一般首行和尾行不写注释信息: 123456789public class HelloJava { /** * 这是一个多行注释 */ public static void main(String[] args) { // TODO Auto-generated method stub System.out.println(&quot;Hello, Java World!&quot;); }} 注意：多行注释可以嵌套单行注释，但是不能嵌套多行注释和文档注释。 文档注释包含在 “/**” 和 “*/” 之间，也能注释多行内容，只在类、接口、方法、成员变量上面，用来描述其作用。 注释后，鼠标放在类和方法上面会自动显示出我们注释的内容 1234567891011121314151617/** * Project Name: HelloJava * Class Name: HelloJava * Created By: xxxxxx * Created At: xxxx年xx月xx日 上午3:31:44 * E-Mail: * @Version * */public class HelloJava { public static void main(String[] args) { // TODO Auto-generated method stub System.out.println(&quot;Hello, Java World!&quot;); }} 注意：文档注释能嵌套单行注释，但是不能嵌套多行注释和文档注释 Java 平台提供了 javadoc 工具，使用 Java 源代码中的文档注释，来生成 API 说明文档。 语句Java 程序中，语句是最小的组成单位，每个语句必须使用分号作为结束符。 除此之外，Java 对语句无任何其他限制，开发人员可以很随意地用符合自己风格的方式编写语句。 1 –&gt; 一个语句放在多行 123String str = &quot;Apple &quot;+&quot;Banner &quot;+&quot;Pear &quot;+&quot; Orange&quot;; 由于 Java 使用分号作为语句的结束符，所以上面的 3 行代码会被 Java 认为是一条语句，因为这 3 行中只有一个分号。但是，我们不推荐使用这种方式来编写语句（不符合编码规范）。 2 –&gt; 多个语句放在一行 使用分号作为分隔符，将多个语句放在一行来编写也是允许的： 1int a=0,b,c;b=a+10;b++;c=a*b;System.out.println(c); 但也不这样推荐。 3 –&gt; 空语句 所谓空语句（Empty Statement），它在程序中什么都不做，也不包含具有实际性的语句。 空语句的语法格式如下： 1; // 其实就是一个分号 表达式表达式是由变量、操作符以及方法调用所构成的结构。在表达式后面添加分号，就成了独立的表达式语句。 样例： 12int i = 5; System.out.println(5); 注意： ; 也是一个完整的表达式，即使没有任何变量、操作符以及方法调用。 1234567public class HelloWorld { public static void main(String[] args) { //一个空;也是一个表达式 ; ; }} 语句块从 { 开始 到对应的 } 结束，即为一个语句块，也称为：复合语句，是很多个语句的组合。 123456789public class HelloWorld { //类对应的块 public static void main(String[] args) { //主方法对应的块 System.out.println(&quot;abc&quot;); } { // 这是正确的语法 System.out.println(&quot;this is a test&quot;); }} Java 编码规范 程序最开始编写导入包和类语句，即 import 语句，import 语句可以有多行，编写完 import 语句后空一行; 定义 public 类，顶格书写。类的主体左括号 “{” 不换行书写，右括号 “}” 顶格书写； 定义 public 类中的变量，缩进书写； 定义方法用缩进书写，方法的左括号 “{” 不换行书写，右括号 “}” 和方法首行第一个字符对齐；方法体要再次缩进书写，最后一个变量定义和第一个方法定义之间、方法和方法之间最好空一行； 方法名和紧跟在其后的左括号 “(” 无空格，该左括号和其后的标识符之间无空格。多个参数之间的逗号和前一个参数紧靠，与后一个参数空一格。 在一行内只写一个语句，并采用空格、空行来保证语句容易阅读。 关于编码规范，可以以权威公司（Google 等）编码规范为参考。 Java 包名(Package)命名规范每个 Java 开发人员都可以开发自己的 Java 项目，Coder 可以为 Java 项目中的包定义各种各样满足命名规范定义的名字。 但是，我们需要尽可能保障每个 Java Package 命名的唯一性，尤其是在你上传编写好的 Java 库到第三方平台供他人使用时，这尤为重要（第三方平台一般会进行唯一性检验，成功后才允许你上传，否则认为包名冲突了）。 这就要求我们，尽可能的在 Package 命名时： 为自己定义的包名前加上唯一的前缀 1 –&gt; 公司项目命名 一般公司项目中，包名的命名规则可定义为如下： com.公司名.项目名.模块名 2 –&gt; 团队项目 一般公司项目中，包名的命名规则可定义为如下： team.公司名.项目名.模块名 3 –&gt; 个人项目命名 那么，我们的个人项目又怎么命名呢？ indi（individual）–&gt; 个人发起，但非自己独自完成的项目（可公开或私有项目），但 Copyright 主要属于发起者。 命名规则如下: indi.发起者名.项目名.模块名 pers（personal）–&gt; 个人发起，独自完成，可分享的项目，Copyright 属于个人。 命名规则如下: pers.个人名.项目名.模块名 人发起，独自完成，非公开的私人使用的项目，Copyright 属于个人。 命名规则如下: priv.个人名.项目名.模块名","link":"/2017/10/12/java-cheng-xu-she-ji-ji-chu/"},{"title":"Java 程序设计基础之 Java 变量","text":"变(常)量——Java 程序中最基础的元素。我们在前面提到过，Java 字面值是 Java 数据具体、直观的表现，就是一个具体的值。事实上， Java 中字面值的主要功能就是来给变量、常量进行赋值用的。程序设计语言中变量的引入是至关重要的，有了变量后续的一切才是有意义的。 Java 变量什么是变量变量你可以将其看成是一个个带有名字的小盒子，用来存放我们的数据（字面值），方便后续在程序中引用（使用），这是有意义的。 严格来说， 在 Java 中，变量是指向计算机内存中的某一存储区域的引用，该区域有自己的名称（变量名）和数据类型（变量类型）。 事实上，变量的类型是，变量所指向的存储区域中所存储数据的类型。 该区域的数据可以在同一类型范围内不断的变化~ 变量定义Java 语言是强类型（Strongly Typed）语言，强类型包含以下两方面的含义： 所有的变量必须先定义（声明）、后使用 指定数据类型的变量只能接受类型与之匹配的值 定义（声明）变量，就是要告诉编译器这个变量的数据类型，和变量的名称，编译器才知道它能存放什么样的数据，需要分配多少空间给它，以及如何找到它。 1 –&gt; 声明变量 在 java 中用户可以通过指定数据类型和标识符来声明变量，其基本语法如下所示： DataType identifier; 或者： DataType identifier=value; 注意：同一代码块范围内不允许有多个相同命名的变量。 2 –&gt; 初始化变量 初始化变量是指为变量指定一个明确的初始值，变量声明后并不会分配内存空间，只有赋值之后才会分配内存。 初始化变量有两种方式： 声明时直接赋值 先声明、后赋值。 123456// 声明时直接赋值char usersex='female';// 先声明、后赋值String username;username = &quot;Wangyi&quot;; 多个同类型的变量可以同时定义或者初始化，但是多个变量中间要使用逗号分隔，声明结束时用分号分隔。 123# Java 编码规范中不推荐使用String username,address,phone,tel; // 声明多个变量int num1=12,num2=23,result=35; // 声明并初始化多个变量 Java 中初始化变量时需要注意以下事项： 变量是类或者结构中的字段（属性），如果没有显式地初始化，默认状态下会创建变量并初始化为【默认值】，默认值见：【数据类型默认值对照表】。 方法中的变量必须显式地初始化，否则在 使用该变量时 就会出错 常量常量，一种特殊的变量！ 当使用 final 关键字来修饰一个变量时，就成为一个 常量，也称为 final 变量。Java 语言使用 final 关键字来定义一个常量，其语法如下所示： final dataType variableName = value 常量有很多种说法，比如不能改变等等。但更为准确的描述是： 当一个变量被 final 修饰的时候，该变量 只有一次赋值的机会！！！ ========================================== You Need Know More: final 关键字不仅可以用来修饰基本数据类型的常量（或引用类型的变量），还可以用来修饰类、和方法。 当定义的 final 变量为成员变量（类或结构中的属性）时，必须在定义时就设定它的初始值（没有显式初始化，会被隐式初始化为0），如果再次对其进行赋值将会提示编译错误 当定义的 final 变量为方法中的局部变量时，则需要开发者在声明后，第一次使用该变量之前，显式的赋初始值，实例化该变量 Java 中 final 修饰符的用法详细见：Java 中的 final 修饰符，你可以看到 final 修饰类，方法的使用场景。 变量的作用域变量的作用域，也称为：变量的有效范围。 变量的有效范围是指：程序代码中能够访问该变量的区域，若超出该区域进行访问，则在编译时会出现错误。 在程序中，一般会根据变量的有效范围将变量划分为： 成员变量 局部变量 成员变量成员变量是指：定义在类下面，不属于任何一个方法的变量。 别名：字段，属性，Field 作用域是：从变量声明的位置开始，整个类都可以访问得到 类中的成员变量，根据是否有无 static 修饰符修饰，可以分为： 1 –&gt; 实例变量 无 static 修饰符修饰；访问方式：对象名.变量名；生命周期：只要对象被当作引用，实例变量就将存在。 2 –&gt; 类变量（静态变量） 有 static 修饰符修饰；访问方式：类名.变量名（推荐，编码规范），或对象名.变量名；生命周期：其生命周期取决于类的生命周期，类被垃圾回收机制彻底回收时才会被销毁。 注意：Java 中 static 关键字只作用于成员变量，局部变量无法使用 static 修饰。 示例代码如下： 变量声明代码如下所示： 12345678public class DataTest { String name; int age; static final String website = &quot;orangeshare.cn&quot;; static String url = &quot;https://www.orangeshare.cn&quot;;} 测试类代码如下所示： 12345678910111213141516171819public class HelloJava { public static void main(String[] args) { // TODO Auto-generated method stub DataTest dataTest = new DataTest(); // 创建类的对象 // 实例变量调用方法（对象名.变量名）： System.out.println(dataTest.name); System.out.println(dataTest.age); // 类变量调用方法（类.变量名）： System.out.println(DataTest.website); System.out.println(DataTest.url); // 类变量调用方法（对象名.变量名）： System.out.println(dataTest.website); System.out.println(dataTest.url); } } 上面，name 和 age 显示系统默认初始化的值，website 和 URL 显示初始化的值。且用 static final 修饰的变量必须赋予初始值。 关于 static 修饰符的用法详细见：Java 中的 static 修饰符。 局部变量局部变量是指：在方法或者方法代码块中定义的变量。 别名：参数 根据其所处的位置可以分为三种： 1 –&gt; 方法局部变量（方法内定义） 作用域是：从定义这个变量开始到方法结束这一段时间内有效。 2 –&gt; 方法参数变量（形参） 作用域是：整个方法内均有效。局部变量在使用前必须主动初始化值。 3 –&gt; 代码块局部变量（代码块内定义） 作用域是：从定义这个变量开始到代码块结束这一段时间内有效。 观察下面程序是否可正常运行： 123456789101112131415public class HelloJava { public static void main(String[] args) { // TODO Auto-generated method stub System.out.println(&quot;Hello, Java World!&quot;); for (int i = 0; i &lt; 5; i++) { } System.out.println(i); // 无效作用域 } } 重名问题想象一种场景：如果局部变量和成员变量重名，那么在方法中调用打印标识符时，显示的是局部变量的值，还是成员变量的值？ java 采用局部优先的思想。局部变量可以和成员变量相同，使用标识符调用时，优先使用局部变量。想调用成员变量怎么办？如果该变量是实例变量，可使用 this.变量名，否者可使用 类.变量名。 数据类型默认值对照表 数据类型 初始值 boolean false char ‘/uoooo’(null) byte (byte)0 short (short)0 int 0 long 0L float 0.0f double 0.0d 引用型（String等） null 注：引用型数据类型包括：类(class)、接口（interface）、数组（Array）、字符串（String），默认值都为 null。","link":"/2017/10/13/java-cheng-xu-she-ji-ji-chu-zhi-java-bian-liang/"},{"title":"Java 程序设计基础之字面值","text":"所有计算机编程语言的设计初衷，都是为了高效地解决现实世界里的繁琐任务。所谓巧妇难为无米之炊，第一步要做的就是从现实实体中提取出，可用于计算机输入的表达。比如现实世界中最常见的数字、文字、图像、声音等等，在 Java 世界统一被称为：【数据】，有了数据才有后续的一切。 Java 字面值字面值就是数据。 一个具体的数字（3.2，996），或是一个字符串（”I love China“）——文本，都是一个字面值。 字面值，本身就是一个具体（固定的）的值，也只是一个值，是数据最具体，直观的表现。 符合 Java 字面值定义的字面值示例：10，100，3.14，true，false，”I am a Chinese”，’A’，‘b’ 字面值类型我们知道，数据在现实世界中是分门别类的，比如整数、小数、文本等等。将其映射到 Java 中也是一样的。 Java 中对数据的数据类型也是有明确分类定义的，分为：基本数据类型（Primitive Type）和引用数据类型（Reference Type）。 后续章节，我们会更加深入的了解 Java 中定义的数据类型以及其使用。这里如有不理解的地方，不要深究，等待深入学习之后再来进行回顾就一目了然了。 这里，探讨字面值类型的主要目的，是为了明确： Java 中我们可以使用什么数据类型的变量或者常量存储字面值，或是特定数据类型变量或者常量可以使用什么类型的字面值进行赋值，这是关键的！ 根据 Java 的基本数据类型和引用类型，Java 中的字面值类型大致可分为：整型字面值、浮点字面值、布尔型字面值、字符和字符串字面值 以及 特殊字面值 五大类 整型字面值Java 的整型字面值值主要有如下 4 种形式（4 种进制表示）： 十进制数形式（默认）：基 10, 包含从 0-9 的数字。如：54、-67、0。 八进制形式：基 8, 包含从 0-7 的数字，八进制字面值的表示 以 0 开头，如：0125 表示十进制数 85，-013 表示十进制数 -11。 十六进制形式：基 16, 包含从 0-9 的数字，和从 A-F 的字母。十六进制字面值的表示 以 0x 或 0X 开头，如 ：0x100 表示十进制数 256，-0x16 表示十进制数 -22。 二进制形式: 基 2, 包含 0 和 1。二进制字面值的表示 以 0b 或 0B 开头，如：0b11010。 –&gt; 默认情况下，整型字面值对应的是 基本数据类型——整数类型 中的 int 类型（整型），默认在内存中占 32 位。 –&gt; 当整型字面值以 l 或者 L 结尾时（建议使用大写的 L 而非小写的 l，因为容易和 1 混淆），对应的是 基本数据类型——整数类型 中的 long 类型（长整型），表示一个长整型数，它在内存中占 64 位。 –&gt; 如果你可以确定整型字面值（不以 L 结尾）在 基本数据类型——整数类型 中的 byte， short 取值范围之内，你可以把它赋值给 byte(8 bit)， short(16 bit) 类型（字节型，短整型），Java 会自动完成转换，如果试图将超出范围的字面值赋给某一类型（比如把 128 赋给 byte 类型），编译通不过。 浮点型字面值Java 的浮点字面值主要有如下 2 种形式： 小数：如 12.34、-98.0。 科学记数法形式：如 1.75e5 ，2.38E3，其中 e 或 E 之前必须有数字，且 e 或 E 之后的数字必须为整数。 默认情况下（或以 d 或者 D 结尾，写不写都行），浮点字面值是具有双精度型（double）的，对应的是 基本数据类型——浮点类型 中的 double 类型（双精度浮点型），在内存中占 64 位。 当浮点字面值以 f 或者 F 结尾的时，对应的是 基本数据类型——浮点类型 中的 float 类型（单精度浮点型），在内存中占 64 位。 布尔型字面值Java 的布尔型字面值，对应的是 基本数据类型——布尔类型 ，即 boolean 类型。 只有两个值，即 false（假）和 true（真）。 字符型和字符串字面值1 –&gt; 字符型字面值 Java 中的字符型字面值，是用单引号（英文输入）引起来的一个字符，如 ‘e’、E’。 注意，字符型字面值中的字符可以八进制或者十六进制，八进制使用 ‘反斜杠加3位八进制数字’ 表示，例如 ‘\\141’ 表示字母 a。十六进制使用 ‘\\u加上4为十六进制的数’ 表示，如 ‘\\u0061’ 表示字符 a。 不能直接输入的字符，可以使用 转义字符，如 ‘\\n’，‘\\t’，‘\\r’。常见的转义字符序列有： \\ddd(八进制) 、 \\uxxxx(十六进制Unicode字符)、'（单引号）、&quot;（双引号）、\\ （反斜杠）\\r（回车符） \\n（换行符） \\f（换页符） \\t（制表符） \\b（回格符） 2 –&gt; 字符串字面值 字符串字面值则使用双引号引起来的单个或多个字符。如：“I love China” 字符串字面值中同样可以包含字符字面值中的 转义字符序列。字符串必须位于同一行或者使用 + 运算符，因为Java 没有续行转义序列。 Java 字符串字面值中的单引号和双引号不可混用。字符串中包含双引号时，需要对其进行转义处理。 特殊字面值null 是 Java 数据类型中的一种特殊数据类型。 这里将其也看作是一种特殊字面值，它可以赋值给 Java 中的任意 引用类型。 最后，再次重申一遍：字面值就是一个具体的值。 可以看出，Java 字面值和前面我们说过的，Java 标识符和关键字一样，都是 Java 语法中最最基础的定义。","link":"/2017/10/12/java-cheng-xu-she-ji-ji-chu-zhi-zi-mian-zhi/"},{"title":"MarkdownPad2 安装以及常见问题解决教程","text":"Markdown 是一种轻量级的，可以使用 普通文本编辑器编写 的标记语言。它允许所有的写作爱好者（Sharer）可以专注于内容而不是纠结于字体字号行间距等等排版问题（沉浸式写作），使用易读易写的纯文本格式编写文档，然后就可以转化成格式丰富优美的 HTML 页面或 PDF（所思即所得）。 MarkdownPad2 Setup And Crack In WindowsMarkdownPad2 可以在官网得到下载文件，传送门 –&gt; Markdown 官网，点击后自动下载，界面如下： 安装好后直接开始安装，一路 「Next」 即可，安装完成打开后会让升级到豪华版（Pro）。开始破解，点击 「Enter Key」 进入后输入账号密钥。此处提供一个来自网络上的账号（膜拜大佬吧）： Email address : Soar360@live.com License key： 1GBPduHjWfJU1mZqcPM3BikjYKF6xKhlKIys3i1MU2eJHqWGImDHzWdD6xhMNLGVpbP2M5SN6bnxn2kSE8qHqNY5QaaRxmO3YSMHxlv2EYpjdwLcPwfeTG7kUdnhKE0vVy4RidP6Y2wZ0q74f47fzsZo45JE2hfQBFi2O9Jldjp1mW8HUpTtLA2a5/sQytXJUQl/QKO0jUQY4pa5CCx20sV1ClOTZtAGngSOJtIOFXK599sBr5aIEFyH0K7H4BoNMiiDMnxt1rD8Vb/ikJdhGMMQr0R4B+L3nWU97eaVPTRKfWGDE8/eAgKzpGwrQQoDh+nzX1xoVQ8NAuH+s4UcSeQ== 直接粘贴后点击 「OK」 激活成功！至此 MarkdownPad2 安装以及破解已经完成。 Common Problem &amp;&amp; Solution汉化MarkdownPad2 汉化非常简单，已内置汉化包。选择左上角的 「TOOL」 下的 「option」 后在语言栏选择简体中文即可。 右侧无法预览MarkdownPad2 正常安装完成后，即可直接使用标记语言开始写作了，你可以直接在右侧实时预览效果（F5 开启预览功能）。 Win10 安装打开后，你可能会发现右侧预览栏无法显示: 查阅相关资料后需要安装一个插件: To fix this issue, please try installing the Awesomium 1.6.6 SDK. 安装也是全程 「next」 即可，安装过程如下： 安装成功后，关闭软件再次打开即可正常使用 Markdown 了！ 表格以及代码无法显示使用 Markdown 插入表格和代码有时会发现无法正常显示，事实上，你只需要更改一下 Markdown 处理器就可以了： 中文版： 工具 –&gt; 选项 –&gt; Markdown –&gt; Markdown 处理器改为: GitHub Flavored Markdown(Offling) 英文版： Tools –&gt; Options –&gt; MarkDown –&gt; Markdown Processor –&gt; GitHub Flavored Markdown(Offling) 【持续更新…】","link":"/2017/09/20/markdownpad2-an-zhuang-yi-ji-chang-jian-wen-ti-jie-jue-jiao-cheng/"},{"title":"Pycharm Community In Windows Tutorial","text":"PyCharm 是一款功能强大的 Python 集成开发环境，具有跨平台性（支持：macOS、 Windows、 Linux 等），鉴于方便日后参考，这里我们来介绍一下 PyCharm 在 Windows 平台下的安装以及简单使用（其它平台类似）。 这里，我们首先给出 Pycharm 官方下载地址 &gt;&gt;&gt;&gt; PyCharm Download Packages Addr 。 Download PyCharm Community进入该网站后，我们会看到如下界面: Professional 表示专业版，是收费版本；Community 是社区版，推荐安装免费的社区版。 PyCharm Community Setup[1] &gt;&gt;&gt;&gt; 当下载好以后，点击进行安装，【Next】 –&gt; 进入如下窗口。 可以自定义 Pycharm 的安装路径，假设我们存放于：E:\\Program Files 目录下。修改好以后，【Next】： [2] &gt;&gt;&gt;&gt; 接下来是选择 PyCharm Community 安装位数（根据自己的电脑选择安装 32-bit 还是 64-bit，目前主流应该都是 64-bit）等，【Next】： [3] &gt;&gt;&gt;&gt; 进入如下界面，点击 Install，静静的等待安装结束即可： 检查本地 Python 环境要想使用安装好的 PyCharm，我们必须保证本地下载安装有 Python 解释器（本地已经成功安装配置 Python），不然 Pycharm 只是一副没有灵魂的驱壳（其实相当于将 Python 解释器链接到 Pycharm 中，由 Pycharm 来进行管理解释执行 Python 脚本）。 关于本地安装配置 Python 语言环境（解释器）可以参见前面章节教程：&gt;&gt;&gt; Python 简介与开发环境搭建 &lt;&lt;&lt; 一文中关于 Windows 平台安装 Python 部分，这里由于篇幅原因不做赘述。 PyCharm Community 使用这一小节来看 Pycharm Community 版本安装之后的简单使用： 首次启动 PyCharm[1] &gt;&gt;&gt;&gt; Pycharm 安装好后，我们启动 PyCharm，–&gt; 同意软件许可 –&gt; 采用默认主题设置即可。完成后，显示如下界面： [2] &gt;&gt;&gt;&gt; 首次启动后一般会创建我们的第一个 Pycharm 工程，点击 Create New Project（创建一个新工程）： Location 是我们默认存放工程的目录（文件目录用于存放：工程项目代码以及 Virtualenv）。 untitled 指定当前工程项目的名字。 接下来是重点 &gt;&gt;&gt;&gt; [3] &gt;&gt;&gt;&gt; 点击 Project Interpreter......（用于查看项目选用的：Virtualenv 的详细信息，即 Python 解释程序或运行环境信息）： Virtualenv 是当前创建工程所选用的虚拟编译环境（前面我们提到过要将 Python 解释器内嵌到 Pycharm 中，故这里的虚拟编译环境是指 Python 运行环境（解释器）。例如，Python 解释器环境可以来源于：原生 Python、virtualenv、anaconda、docker 等等），可以将其看成一个独立的，当前项目的 Python 运行环境容器，封装了当前项目所有用到的库。 因此可以看到：默认的 New environment using 【Virtualenv】 方式（还支持：Virtualenv，Pipenv，以及 Conda 等方式；例如已安装 Anaconda 的话，还可以使用 Conda 封装好的虚拟环境。）。并且我们发现 Pycharm 设置项 Base Interpreter 中已经自动获取了系统中的 Python 3.7（多版本共存时，可选择不同 Python 版本的解释器）。 Location（第二个）表示：当前项目 Virtualenv 的存放路径（用于存放 Python 解释器、相关开发 Python 库等 Python 脚本运行相关）。 [4] &gt;&gt;&gt;&gt; 了解默认选项后，我们来自定义工程存放目录：通过修改最上面的 Location（第一个）路径，比如 F:\\PycharmProjects\\FirstProjects，来自定义工程存放目录。 注意，我们选择的路径需要为空，不然无法创建。【Create】 之后出现如下界面，这是 Pycharm 在配置环境，静静等待……最后点击 【close】 关掉提示就好了。 [5] &gt;&gt;&gt;&gt; 成功创建项目运行环境： [6] &gt;&gt;&gt;&gt; 修改 Pycharm 主题风格 可以通过 Files –&gt; Settings –&gt; Editor –&gt; Color Scheme 打开如下界面，选择喜欢的主题风格： 我个人比较喜欢 Twilight 主题风格。 [7] &gt;&gt;&gt;&gt; 设置字体 可以通过 Files –&gt; Settings –&gt; Editor –&gt; Font 打开字体设置。 个人推荐 Fonts 字体样式为 Monospaced, 大小 Size 设为 18，行间距 Line Height 设为 1.2。 工程项目开发前面我们已经成功创建了一个新的工程，下面我们来看如何在创建好的工程中编写以及运行 Python 脚本： [1] &gt;&gt;&gt;&gt; 选中 python_pycharm 项目右键，点击 【New】，选择 【Python File】（创建 Python 脚本）： 给 file（脚本）命名，点击 OK: [2] &gt;&gt;&gt;&gt; 系统会默认生成空白 HelloWorld.py 脚本文件： 向文件 HelloWorld.py 中写入如下内容并保存： 1print (&quot;Hello Python World!&quot;) [3] &gt;&gt;&gt;&gt; 如何运行写好的 HelloWorld.py 脚本？ 快捷键：ctrl + shift + F10 ，表示运行 HelloWorld.py。运行结果如下： 至此，你已经掌握了 Pycharm 的基本使用方法。下面我们来补充一些 Pycharm 使用过程中经常遇到的一些问题以及其解决办法。 修改 Pycharm 项目编译环境我们在首次启动 Pycharm 时提到过项目的默认 Virtualenv（编译/运行环境）配置，创建项目后我们还可以重新修改 Pycharm 项目编译环境，即使用非项目创建 Virtualenv。 点击 【File】 选择 【settings】，选择目标项目（如：PycharmProjects），可选择查看以及修改项目的 【Virtualenv】 相关配置项： 添加项目依赖的第三方库或模块如何在项目编译环境添加项目依赖的第三方库或模块？ 当项目依赖第三方库或模块，而我们的 Virtualenv 中不包含该第三方库或模块时，Pycharm 会有红线做警告标识，表示未导入的库或模块。 下面给出两种解决方法（这里我们只讨论 Virtualenv 中不存在第三方库或模块的情况，有时会存在检测不到的情况）： 1 –&gt; Virtualenv Add 点击 【File】 选择 【settings】，选择目标项目（如：PycharmProjects），我们可以查看到项目 Virtualenv 中 Python 解释器信息以及已安装 Python 扩展包。如果需要添加新的模块（Python 扩展包，例如：pymysql），可点击 【 + 】 号： 然后在搜索框直接搜索：pymysql，然后点安装 【Install Package】： 上述方法实质上是：使用 pip install pymysql 安装 pymysql 到当前的 Virtualenv 中。 2 –&gt; Alt + Enter 通过使用快捷键：alt + enter 的组合方式。 让鼠标光标到红线的这个位置 –&gt; 【alt + enter】 –&gt; 选择 【Install Package …】。如下： 提示安装包成功，此时发现红线警告的地方已经不警告了。同时发现 【lib library root/Lib/site-package】 目录下增加了 requests 模块，这就是刚刚引入的这个模块的文件。 项目二次开发如何打开已存在的项目文件进行二次开发？ [1] &gt;&gt;&gt;&gt; 进行 Pycharm 的界面当中之后，进行点击菜单中的 【file】 的选项菜单，点击 【open】： [2] &gt;&gt;&gt;&gt; 这样就会弹出了一个 open file or project 的窗口的界面当中，进行选中列表选中项目的文件。进行点击 【ok】 即可。 [3] &gt;&gt;&gt;&gt; 这样就会弹出了 【open project】 的窗口的，进行默认选中即可（可以选择打开的窗口），进行点击 【ok】 即可导入成功。","link":"/2018/01/02/pycharm-community-in-windows-tutorial/"},{"title":"Python First Lesson","text":"前面的博文中，我们已经成功搭建了 Python 学习以及开发环境。这里，我们来完成我们的 Python 第一课：Hello Python’s World。 Hello Python’s World交互式编程只是用来玩玩而已，真正的项目开发还是需要编写源文件的。 首先我们给出第一个使用 Python 脚本语言编写的代码文件 HelloWorld.py，代码内容如下： 1print(&quot;Welcome to Python world!&quot;) Select A Editor在 Python 的交互式命令行环境下写程序，好处是一边编写代码一边就能得到结果，坏处是没法保存，下次还想运行的时候，还得再敲一遍。所以一般我们使用交互式环境进行学习测试，而不是开发。 而实际学习以及工作时，我们通常是使用一个文本编辑器来写代码，写完了，保存为一个文件（Python 源文件），这样，程序就可以反复运行了。 Python 源文件（以 .py 后缀结尾）是一种纯文本文件，内部没有任何特殊格式（例如 BOM &gt;&gt;&gt; 标识文件编码格式的头字符），你需要选择一款合适的文本编辑器来打开、编辑它。 那么问题来了：文本编辑器到底哪家强？？？ 这里我们推荐两款文本编辑器：Sublime Text &amp;&amp; Visual Studio Code。 这两款文本编辑器都是免费、开源的，甚至为了方便编码可以内嵌各种丰富的插件，方便之后的使用拓展。 注意，不能使用写字板、Word、WPS 等排版工具编写 Python 源文件，其保存的不是纯文本文件，有内置的特殊格式或者特殊字符，这些会让代码变得“乱七八糟”，影响 Python 解释器的执行。 使用 Windows 下的记事本，保存时记得选择 【不带 BOM 的 Utf-8 编码】 形式保存，否则会在文件头带有特殊字符。不管是否影响 Python 解释器运行，这对使用来说是不合理的。 选择好源文件编辑器后，来看创建和编写 Python 源文件的要求： 源文件的命名以及后缀文件名一般是 英文字母、数字和下划线的组合，文件后缀必须为 .py。 任何编程语言的源文件都有特定的后缀，例如： C 语言源文件的后缀是：.c； C++ 源文件的后缀是：.cpp； JavaScript 源文件的后缀是：.js； C# 源文件的后缀是：.cs； Java 源文件的后缀是：.java 文件后缀只是用来区分不同的编程语言，并不会导致源文件的内部格式发生变化，源文件还是纯文本的。编译器（解释器）、编辑器和用户（程序员）都依赖后缀区分当前源文件属于哪种编程语言。 源文件的编码格式Python 源文件是一种纯文本文件，因此会涉及到文件编码格式的问题，也就是使用哪种编码来存储源代码。 Python 3.x 已经将 UTF-8 作为默认的源文件编码格式，上面推荐的两款编辑器都默认支持 UTF-8 编码。 如果你对编码格式不了解的话，请猛击链接学习 &gt;&gt;&gt; 【编程基础之编码详解】。 运行源文件安装好文本编辑器以及了解了 Python 源文件编写注意事项后， 我们将本章节开头给出的代码内容写入文件并命名为 HelloWorld.py。然后在命令行（Terminal or Shell）下进行运行： 123456# 先进入源文件所在目录：$ cd ~/Desktop# 使用 python 解释器解释执行脚本文件 HelloWorld.py$ python HelloWorld.pyWelcome to Python world! 期待你成功了~~~ 你必须在脚本存放目录下执行，如果当前目录下没有 HelloWorld.py 这个文件，运行 python HelloWorld.py 就会报错： 12$ python HelloWorld.pypython: can't open file 'hello.py': [Error 2] No such file or directory Linux &amp;&amp; Mac 下支持直接运行 Python 源文件 &gt;&gt;&gt;&gt;&gt; 每次执行源文件都需要调用解释器（python.exe），我们能不能像 .exe 文件那样直接运行 .py 文件呢？在 Windows 上是不行的，但是，在 Mac 和 Linux 上是可以的，方法是在 .py 文件的第一行加上一个特殊的注释： 123#!/usr/bin/env python3print(&quot;Welcome to Python world!&quot;) 或者： 123#!/usr/bin/python3print(&quot;Welcome to Python world!&quot;) 当然，运行前我们要保证执行源文件的可执行权限： 1$ chmod +x HelloWorld.py 运行： 123# Linux&amp;Unix 下直接运行脚本文件：HelloWorld.py$ ./HelloWorld.pyHello, Python World! Windows 系统不区分大小写，在 Windows 平台上输入源文件路径时可以不用注意大小写；但是类 Unix 系统（Mac OS X、Linux 等）都是区分大小写。 下面我们来看 Python 中最基本的语法 –&gt; 输入输出（Input/Output）： Input &amp;&amp; Output Function输出（Output）是我们接触到的第一个 Python 程序语句，例如 print(&quot;Welcome to Python world!&quot;)。 OutputPython 使用 print() 函数在屏幕上输出一段文本，输出结束后会自动换行。 [1] &gt;&gt;&gt; 输出字符串 print() 语句在括号中加上一串字符串（字符串要用 双或单 引号括起来，无区别），就可以向屏幕上输出指定的文字。字符串中可以包含英文、数字、中文以及各种符号。 比如输出 Hello, welcome to Python world!，用代码实现如下： 12&gt;&gt;&gt; print(&quot;Hello, welcome to Python world!&quot;)Hello, welcome to Python world! [2] &gt;&gt;&gt; 输出其它 Python 数据对象 当然，print() 语句也可以输出其它（Python 数据）对象，如数字、列表、元组、字典、集合等： 1234&gt;&gt;&gt; print(520)520&gt;&gt;&gt; print([1, &quot;python&quot;, 123])[1, 'python', 123] print() 函数中的连接符1 –&gt; 英文半角状态的逗号（,） print() 函数也可以同时接受多个字符串（或多个 Python 数据对象），用逗号 “,” 隔开，就可以连成一串输出。并且每遇到一个逗号 “,” 会自动输出一个空格（sep 参数定义，默认空格）。输出样式如下： 12345&gt;&gt;&gt; print('Welcome to Python world.','It is good.','why?')Welcome to Python world. It is good. why?&gt;&gt;&gt; print('First', 8888, 1.23, True)First 8888 1.23 True 注意，使用逗号（,）连接符的对象可以是任意的 Python 数据对象。 2 –&gt; 英文半角状态的加号（+） 除了使用逗号 “,” 隔开连接一串输出外，还可以使用【连接符 “+”】 来连成一串字符串输出。 12345&gt;&gt;&gt; print('Hello ' + 'LiHua,' + ' welcome to Python world.')Hello LiHua, welcome to Python world.&gt;&gt;&gt; print('First' + str(8888) + str(1.23) + str(True))First88881.23True 注意：和逗号 “,” 连接的区别在于 —&gt; 连接处不会输出空格，并且只可拼接（支持加法 [+] 操作的）同类型数据（字符串，列表，数字等）。 print() 函数中的 end 参数认真的同学肯定发现了：print() 函数之后 Python 系统会自动换行。如下面的代码： 12print(&quot;Hello, welcome to python world.&quot;)print(&quot;This is a print() function test.&quot;) 运行输出结果如下： 12Hello, welcome to python world.This is a print() function test. 那么，当我们不想 print() 之后自动换行，可以使用：end 参数。 end 参数可以用于指定 print 之后的分隔符，事实上，你可以看作当不调用 end 指定其它分隔符时，end 的默认分隔符是 ：换行（“\\n”）。 12print(&quot;Hello, welcome to python world.&quot;, end=&quot;;&quot;)print(&quot;This is a print() function test.&quot;) 运行输出结果如下： 1Hello, welcome to python world.;This is a print() function test. print() 函数的一般形式最后，我们给出 print() 函数的更一般形式： 1234567# print(value, ..., sep=' ', end='\\n', file=sys.stdout, flush=False)# Prints the values to a stream, or to sys.stdout by default. Optional keyword arguments:# file: a file-like object (stream); defaults to the current sys.stdout (Screen Output).# sep: string inserted between values, default a space.# end: string appended after the last value, default a newline.# flush: whether to forcibly flush the stream. Input现在，我们已经可以用 print() 输出你想要的结果了。但是，如果要让用户从电脑的输入设备（键盘）输入一些字符怎么办？？？ Python提供了一个 input()，可以让用户输入字符串，并存放到一个变量里。比如输入用户的名字： 123&gt;&gt;&gt; name = input()Michael&gt;&gt;&gt; 输入完成后，我们查看一下： 12&gt;&gt;&gt; print(name)Michael input() 函数友好的用户输入提醒通常我们为了程序的友好性，需要提示信息来告诉用户：“嘿，赶紧输入你的名字”。 input() 还可以让你显示一个字符串来提示用户。于是我们编辑一个新的脚本 Helloxxx.py ，内容如下： 12name = input(&quot;Please enter your name:&quot;)print('Hello,', name) 运行这个程序，你会发现，程序一运行，会首先打印出 please enter your name: ，这样，用户就可以根据提示进行输入。输入名字后，得到 Hello, xxx 的输出： 123$ python Helloxxx.pyplease enter your name: Michaelhello, Michael input() 函数的返回值类型对于 input() 函数来说，不管我们输入的是什么，不管你输入的是整数 1234，还是字符串，input() 函数的返回值都是 【字符串】 类型的。于是： 1234567891011choice = input('请输入您的选择 [1 or 2]：')#变量赋值# 注意这里：if choice == 1:#条件判断:条件1 print('霍格沃茨欢迎您的到来。')else:#条件判断：其他条件 print('您可是被梅林选中的孩子，我们不接受这个选项。') 你可以尝试一下输入1： 12输入您的选择：1您可是被梅林选中的孩子，我们不接受这个选项。 怎么办？？？？此时我们需要对 input() 返回值进行类型转换（这里不用深究类型转换，见后续博文）： 1234567891011choice = int(input('请输入您的选择 [1 or 2]：'))#变量赋值# 注意这里：if choice == 1:#条件判断:条件1 print('霍格沃茨欢迎您的到来。')else:#条件判断：其他条件 print('您可是被梅林选中的孩子，我们不接受这个选项。') 或者： 1234567891011# 变量赋值choice = input('请输入您的选择 [1 or 2]：')# 注意这里：if choice == '1':#条件判断:条件1 print('霍格沃茨欢迎您的到来。')else:#条件判断：其他条件 print('您可是被梅林选中的孩子，我们不接受这个选项。')","link":"/2018/01/04/python-first-lesson/"},{"title":"Python-Vers Management","text":"Foreword 设想 –&gt; 场景一：A 项目是一个爬虫项目，需要用到 requests、pyspider、scrapy 等包或框架；B 项目是一个 GUI 界面项目，需要用到 GUI 相关的包或库；这需要把所有用到的包安装到原生 Python 环境中，开发环境越来越臃肿。场景二：C 项目是一个 Python2.x 项目；D 项目是一个 Python3.x；两项目要求的 Python 版本不兼容。怎么办？！！ 前面提到过一个系统中是可以同时存在多个 Python 版本的，它可以完美的解决上述问题，但是你需要注意新添加的 Python 环境对系统既有环境的影响，这就涉及到系统中 多个 Python 版本的管理 问题。 更多 Python 版本管理以及运行环境相关内容，请关注博主相关博文系列： 之一 &gt;&gt;&gt; Python-Vers Management 之二 &gt;&gt;&gt; Pythoner 神器之 virtualenv 之三 &gt;&gt;&gt; 一文了解数据科学神器 Anaconda 之四 &gt;&gt;&gt; Jupyter Tutorial Python-Vers Introduction目前，Python 有两个主流的版本： 分别为：2.x 版本 和 3.x 版本。 Python 3.0 是一次重大的升级，为了避免引入历史包袱，Python 3.0 没有考虑与 Python 2.x 的兼容（不完全兼容），这也就导致很长时间以来，将现有应用从 Python 2.x 迁移到 Python 3.x 是一项不小的挑战。 虽说有 2to3 之类的转换工具可以进行代码的自动转换，但无法保证转换后的代码 100% 正确。而且，如果不做人工修改的话，转换后的代码性能可能还不如转换前。故很多 Python 2.x 的用户不愿意升级到 Python 3.0。 2.x &amp; 3.x 版本的不兼容，引发如下问题： 我们给出一种实际情况 &gt;&gt;&gt;&gt; 原生 Unix/Linux 系统已经自带有一个版本的 Python2，但它不是我们需要的 Python 版本，我们想要编译安装满足我们期待的 Python 版本（Python3）。 此时，我们将面临一种选择：是在原有版本基础上 Update（2.x –&gt; 3.x） 呢？还是去 Setup 一个新版本的 Python（原生版本 Python 也保留）？ Update 存在的问题 &gt;&gt;&gt;&gt; 事实上，由于 Python 2.x 和 Python 3.x 兼容性问题，将 Python 2.x 直接升级到 Python 3.x 会产生一些问题（例如：Centos 系统下的很多工具（yum、iotop 等）都依赖原生 Python 2.x 版本），直接升级后会导致无法使用。 Solution &gt;&gt;&gt;&gt; 所以，一般建议安装添加一个新版本的 Python（与系统原生 Python 版本共存），或者使用虚拟环境工具（Virtual Envs Tools）进行多版本管理（这里不用深究，Virtual Envs Tools 是一种优秀的 Python 多版本共存管理方案）。 多版本共存管理方案正如博文前言场景二中所描述，实际 Python 开发过程中，多 Python 版本开发环境是我们必然要面对的问题。 关键在于：如何保证多个 Python 版本安装、配置以及使用之间互相不产生影响呢？ 这就是当前小节讨论的内容，这里会对网络上主流的几种方案进行试验、分析。你可以根据自身情况选择一个适合开发场景的解决 Python 多版本共存冲突问题的解决方案。 Using Symbolic Link一个简单、快捷的解决多版本冲突问题的方案 &gt;&gt;&gt;&gt; 构建软链接 核心思想 &gt;&gt;&gt;&gt; 在系统原生 Python 版本的基础上，再安装（Add）一个新的期望版本的 Python 环境，且保证新安装 Python 不会影响原生环境，以实现期望版本和原生版本完美共存。 For Unix &amp; Linux Platform实际上，在介绍 Unix &amp; Linux 平台下安装 Python 时，已经给出了具体的解决方法: 1 –&gt; 源码编译安装 注意在使用源码安装过程中，不要勾选有关自动添加环境变量的选项（默认不勾选），安装成功后手动设置即可，否则会影响原生环境。 安装步骤见前面系列博文，这里不再赘述。 2 –&gt; 构建软链接 Unix &amp;&amp; Linux 下可以通过构建多个带有不同版本标识的 Python 软链接： 注意，为了避免不小心覆盖掉系统中原生的 Python 软链接，如：/usr/local/bin/pythonX 或 /usr/bin/pythonX，构建前最好先查询一下。 12345678910# 产生软连接时要注意系统中已存在的 Python 软链接，防止原生 Python 调用被覆盖掉！！！# 查看系统中所有既存的 python 链接信息：$ ll /usr/local/bin | grep &quot;python*&quot;# 确认 `/usr/local/bin` 下没有 `python3.5 &amp;&amp; python2.7` 软链接，再进行构建：## python 3.5 symbolic link$ ln -s /usr/local/python3.5/bin/python3.5 /usr/local/bin/python3.5# python 2.7 symbolic link$ ln -s /usr/local/python2.7/bin/python2.7 /usr/local/bin/python2.7 创建软链接后，在使用 Python 时，我们就可以通过特定软链接启动相应版本的 Python 解释器了： 12345678# 启动系统原生环境：python# 启动 python2.7 环境：python2.7# 启动 python3.5 环境：python3.5 For Windows Platform那么 Windows 下如何实现呢？？？Windows 下是通过设置环境变量来达成的。 1 –&gt; 二进制包安装 注意在使用二进制包安装过程中，不要勾选有关自动添加环境变量的选项（默认不勾选），安装成功后手动设置即可，否则会影响原生环境。 安装步骤见前面系列博文，这里不再赘述。 2 –&gt; 配置系统环境变量 推荐修改系统环境变量（PATH）中设置的 Python 安装目录路径即可，想用那个版本就指向那个版本。 思考：可能有些同学会将多个 Python 安装目录同时添加到系统的环境变量中，以期待可以同时使用多个版本的 Python。这是有问题的，系统搜索程序或可执行文件的路径（$PATH）是具有优先级的！，路径在系统 PATH 变量中设置（位置）越靠前，越先被检索到使用。 ================================================ 至此，我们就可以在当前系统中同时存在多个 Python 版本供我们选择使用！ 使用软链接 实现多版本冲突问题存在一定的缺陷： 不进行特殊安装、配置记录的话，一段时间后，容易引发系统中的 Python 版本管理混乱； Windows 下各版本 Python 环境切换繁琐，并且极易发生库管理混乱问题； 需要开发人员手动进行 Python 版本的管理，很繁琐。 那有没有更好的 Python 多版本共存的解决方案？？？ 答案肯定是有的！！！ Virtual Envs Tools（Recommended）除了上述给出的方法外，虚拟环境管理工具 是一种完美解决 Python 的多版本共存问题的最优解决方案。 什么是虚拟管理工具？Python 的正式学习之后，相信你肯定会对 “Python 实现其强大功能的前提，就是它具有数量庞大且功能相对完善的标准库和第三方库。通过对库的引用，能够快速实现对不同领域业务的开发。” 有比较深入的理解。 1 –&gt; 为什么引入虚拟环境管理工具？ 引入虚拟环境管理工具 –&gt; 可以帮助你完美解决： 不同学习、开发项目对 Python 环境的要求不同（可能使用 Python2.x，可能使用 Python3.x）; 配合包管理工具（Pip），管理以及维护 Python 中数量庞大的标准库和第三方库，这是复杂也是重要的！ 2 –&gt; 虚拟环境管理工具可以做什么? Virtual Envs Toos 可以创建任意多个虚拟环境（可以看作成一个个容器），使用时指定到（切换到）某一虚拟环境之后 Pip 安装的包、库就只会在这个环境（容器）下；并且各虚拟环境（容器）之间，以及虚拟环境和系统原生环境之间是隔离的（一个个相互独立、隔离的容器）。 假设某一个虚拟环境预计不再使用，可以直接删除掉相应虚拟环境，由于虚拟环境的独立、隔离性，不用关注文件残留、关联问题。 通俗来说，Virtual Envs Toos 可以为每个 Python 项目，甚至每个脚本各自建立一套 “独立、隔离” 的 Python 环境（环境中可以自定义特定的 Python 版本以及特定的依赖库）。NB~~~ virtualenv &amp;&amp; conda这里给出两种用于解决 Python 多版本共存冲突问题的虚拟环境管理工具（神器）： virtualenv conda virtualenv &amp; conda 都可以进行虚拟隔离环境管理，但两者之间也存在一定的 区别： 准确来说，virtualenv 仅仅是虚拟环境管理器，conda 相当于：virtualenv（虚拟隔离环境） + pip（包管理工具），也就是说 conda 同时具有虚拟环境管理和包管理的功能； 作为包管理器，pip 只能安装 python 的包，而 conda 还可以安装一些不是基于 Python 开发的工具软件，但遗憾的是，相较于 pip，conda 作为包管理器一般且会安装过多依赖。故推荐，在无特殊需求安装应用时，可以先选择使用 pip install packagename 进行安装，如果无法安装的话，再尝试使用 conda install packagename 进行安装。 作为虚拟环境，conda 虚拟环境是独立与于系统原生 Python 环境的，即无论系统 Python 解释器什么版本（哪怕 2.7），你也可以指定虚拟环境中 Python 版本为 3.6；而 virtualenv 是依赖系统主环境的，只能虚拟安装操作系统中已安装解释器版本的 Python 环境。 事实上，一般不单独使用 virtualenv 和 conda 工具进行 Python 版本管理，而 选用 virtualenv &amp;&amp; conda 的扩展应用 来进行管理 –&gt; virtualenv –&gt; virtualenvwrapper conda –&gt; conda in anaconda(miniconda) 这里是为了以一种更方便、高效、愉悦的方式来使用 virtualenv &amp;&amp; conda。 篇幅原因，关于 virtualenv(virtualenvwrapper) &amp;&amp; conda(anaconda/miniconda) 的使用方法可见相关系列博文： 之二 &gt;&gt;&gt; Pythoner 神器之 virtualenv 之三 &gt;&gt;&gt; 一文了解数据科学神器 Anaconda Python 中的版本管理方法一般 推荐使用 Anaconda ，除了不依赖操作系统级别的 Python 解释器，以及提供了 Python 包管理、虚拟环境功能之外，还包含了 Python 进行数据分析相关的 180+ 的科学包及其依赖项，你可以将其理解为一个 Python 的开发生态圈。","link":"/2018/01/02/python-vers-management/"},{"title":"Python 中的可变和不可变对象","text":"Python 中可变与不可变数据类型的解读。 在介绍 Python 基本数据结构时我们说过： 数值类型（Number）、字符串类型（String）以及元组（Tuple）是不可变类型，而列表（List）、集合（Set）和字典（Dict）是可变数据类型。 那，什么是可变和不可变类型？ 认识可变对象和不可变对象不可变对象： &gt;&gt;&gt;&gt; 是指 该对象所指向的内存中的元素值是不能被改变的。当需要改变某个变量时候，由于其所指的值不能被改变，只好把原来的值复制一份后再改变，这会开辟一个新的地址，变量再指向这个新的地址。 可变对象： &gt;&gt;&gt;&gt; 是指 该对象所指向的内存中的元素值可以被改变。变量（准确的说是引用）改变后，实际上是其所指的值直接发生改变，并没有发生复制行为，也没有开辟新的出地址，通俗点说就是原地改变。 不理解？往下看： is &amp;&amp; == &amp;&amp; id()在开始正式的解读之前，我们先来看几个必要的语法： [1] &gt;&gt;&gt;&gt; id(object) Python 中的 id(object) 函数可以用于获取元素对象的内存地址。语法规则如下： 1id(object) 样例如下： 123456&gt;&gt;&gt; str1 = &quot;id(object) function test&quot;&gt;&gt;&gt; num = 1.23&gt;&gt;&gt; id(str1)2419096572024&gt;&gt;&gt; id(num)2419065860360 [2] &gt;&gt;&gt;&gt; is &amp;&amp; == Python 中经常会用到对象之间的比较，可以用 ==，也可以用 is 。它们有什么区别？ is：比较的是 两个实例对象是不是完全相同，是不是同一个对象（占用的内存地址是否相同，内容相同）； ==：比较的是 两个对象的内容是否相等，即内存地址可以不一样，内容一样就可以了。 样例如下： 12345678910111213&gt;&gt;&gt; str1 = &quot;Python&quot;&gt;&gt;&gt; str2 = str1&gt;&gt;&gt; str1 is str2True&gt;&gt;&gt; id(str1)2419095062488&gt;&gt;&gt; id(str2)2419095062488&gt;&gt;&gt; str1 == str2True 不可变对象样例接下来，我们使用 is 判断两个对象的 id（内存地址）是否相同， 而使用 == 判断的则是内容是否相同。 [1] &gt;&gt;&gt;&gt; 数值类型（Number）: 12345678910&gt;&gt;&gt; num_a = 2&gt;&gt;&gt; id(num_a)140724509286176&gt;&gt;&gt; id(2)140724509286176&gt;&gt;&gt; num_a = 2 + 2&gt;&gt;&gt; id(num_a)140724509286240&gt;&gt;&gt; id(2)140724509286176 不考虑常量缓冲池啥的，我们可以这么理解：变量数值（Number 类型）从 2 -&gt; 4 ，不是使用原来数值 2 的内存空间（数值类型不可变），而是会在内存中新开辟一个空间。 [2] &gt;&gt;&gt;&gt; 字符串（String）： 123456&gt;&gt;&gt; str_test = &quot;good&quot;&gt;&gt;&gt; id(str_test)1365047640168&gt;&gt;&gt; str_test = &quot;good&quot; + &quot;boy&quot;&gt;&gt;&gt; id(str_test)1365047641792 可以发现，同样变量数值（字符串）变化后，其所对应的内存地址也会变化。 由于变量是不可变对象的引用，变量对应内存的值是不允许被改变。 故，当变量要改变时，相对于是创建了一个新对象，开辟一个新的地址，然后将变量（引用）再指向这个新的地址（所以前后 str_test 的 id 不一样）。 [3] &gt;&gt;&gt;&gt; 元组（Tuple）： 12345&gt;&gt;&gt; tup1 = (1, 2, 3)&gt;&gt;&gt; tup1[1] = 6Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: 'tuple' object does not support item assignment 可以发现，当我们想要更改元组对象 (1, 2, 3) 中元素值时被阻止。这就是因为元组为不可变对象，强行修改其元素值会报错。 有些人可能发现下面的例子，元组不是变化了么： 1234&gt;&gt;&gt; tup1 = (&quot;test&quot;, 1.023, [1, 2])&gt;&gt;&gt; tup1[2][0] = 888&gt;&gt;&gt; tup1('test', 1.023, [888, 2]) 直观上看，确实发现元组的值变了。但其实变的不是 tuple 的元素，而是 list 的元素。tuple 一开始指向的 list 并没有改成别的 list。所以，tuple 所谓的“不变”是说，tuple 的每个元素，指向永远不变。所以又如下： 123456&gt;&gt;&gt; tup1 = (&quot;test&quot;, 1.023, [1, 2])&gt;&gt;&gt; id(tup1[2])1365045699272&gt;&gt;&gt; tup1[2][0] = 888&gt;&gt;&gt; id(tup1[2])1365045699272 确实，tup1[2] 所对应的元素对象确实还是原来的，并没有变化。 可变对象样例[1] &gt;&gt;&gt;&gt; 列表（List）： 12345678&gt;&gt;&gt; list1 = [1, 2, 3]&gt;&gt;&gt; id(list1)1365046919496&gt;&gt;&gt; list1[1] = 888&gt;&gt;&gt; list1[1, 888, 3]&gt;&gt;&gt; id(list1)1365046919496 可以发现，此时我们修改列表实例中元素值时已经被允许。并且，修改变量之后，其地址并未发生变法，也就是没有开辟新空间。 List 赋值的情况 &gt;&gt;&gt;&gt; 12345&gt;&gt;&gt; list2 = list1&gt;&gt;&gt; print(id(list1), id(list2))1365046919496 1365046919496&gt;&gt;&gt; print(list1 is list2)True 将 list1 赋值给 list2，事实上，list1 是对对象的引用，list2 = list1 即引用的传递，现在两个引用都指向了同一个对象（地址）。所以其中一个变化，会影响到另外一个： 123&gt;&gt;&gt; list1[2] = 999&gt;&gt;&gt; list2[1, 888, 999] 而相对于元组不可变类型进行赋值，你会发现如下： 12345&gt;&gt;&gt; tup1 = (1, 2, 3)&gt;&gt;&gt; tup2 = tup1&gt;&gt;&gt; tup1 = (2, 3, 888)&gt;&gt;&gt; tup2(1, 2, 3) [2] &gt;&gt;&gt;&gt; 集合（Set）： 1234567&gt;&gt;&gt; set1 = {1, 2, 3}&gt;&gt;&gt; set2 = set1&gt;&gt;&gt; print(id(set1), id(set2))1365047636712 1365047636712&gt;&gt;&gt; set1.add(4)&gt;&gt;&gt; set2{1, 2, 3, 4} 可以发现，集合和上面列表（List）的情况是相同的，均为可变对象。 可变对象由于所指对象可以被修改，所以无需复制一份之后再改变，直接原地改变，所以不会开辟新的内存，改变前后 id 不变。对于赋值，传递的是引用，地址内部发生变化的话，两个变量值都会变化。 而对于不可变对象就不是这样了, 可以和这个对比一下： 12345&gt;&gt;&gt; test1 = 123&gt;&gt;&gt; test2 = test1&gt;&gt;&gt; test1 = 456&gt;&gt;&gt; test2123 [3] &gt;&gt;&gt;&gt; 深、浅拷贝： 如果只是简单的想拷贝，仅仅就是将内容拷贝过去，传递给新变量的是内容而不是引用。这在想使用列表的值又不想修改原列表的时候特别有用。可以看作浅拷贝： 1234&gt;&gt;&gt; list2 = [1,2,3]&gt;&gt;&gt; list3 = list2[:]&gt;&gt;&gt; print(id(list2), id(list3))1365046189192 1365047660616 那么，相反的，上面 List 的赋值可以看作是深拷贝，传递的是引用。 关于 Python 中的深、浅拷贝可参见： Python 中的深浅拷贝详解 可变不可变对参数传递的影响基于上述赋值思考，我们应该可以知道：作为函数参数，也应该是一样的，可变类型传递的是引用，不可变类型传递的是内容。 123456789101112&gt;&gt;&gt; test_list = [1, 2, 3, 4]&gt;&gt;&gt; test_str = 'HAHA'&gt;&gt;&gt; def change(alist):... alist.append(5)...&gt;&gt;&gt; def not_change(astr):... astr.lower()...&gt;&gt;&gt; change(test_list)&gt;&gt;&gt; not_change(test_str)&gt;&gt;&gt; print(test_list, test_str)[1, 2, 3, 4, 5] HAHA 当然了，如果不想改变原来列表的值，参数可以传入列表的拷贝：alsit[:]。 什么传递的是引用，传递的是内容？这太迷惑了！还是回归上面的可变、不可变对象理解：你可以认为函数接收到参数后，具体对参数的操作是在函数内完成的，就是参数元素对象已经进入函数，具体操作是否会影响传入前参数元素对象，这要遵循上面可变和不可变对象的说明。 Be Careful123456789101112131415&gt;&gt;&gt; a1 = [1, 2, 3]&gt;&gt;&gt; a2 = a1# 此时我们知道，内存地址是相同的：&gt;&gt;&gt; print(id(a1), id(a2))1365047156616 1365047156616# 此时，等式中，右边的 a2 还是和 a1 的 id 一样的。但一旦赋值成功，a2 就指向新的对象：&gt;&gt;&gt; a2 = a2 + [4]&gt;&gt;&gt; print(id(1), id(a2))140723501621904 1365047660808&gt;&gt;&gt; a3 = a1 + []&gt;&gt;&gt; print(id(1), id(a3))140723501621904 1365047660936&gt;&gt;&gt; print(a1, a2, a3)[1, 2, 3] [1, 2, 3, 4] [1, 2, 3] + 运算符可以将多个（同类型）序列连接起来，对于列表而言，相当于在第一个列表的末尾添加了另一个列表，生成一个新的列表返回。 如果这样写： 1234567&gt;&gt;&gt; a1 = [1, 2, 3]&gt;&gt;&gt; a2 = a1&gt;&gt;&gt; print(id(a1), id(a2))1365047156680 1365047156680&gt;&gt;&gt; a2 += [4]&gt;&gt;&gt; print(id(a1), id(a2))1365047156680 1365047156680 不同的地方在于 a2 += [4]，这句相当于调用了 a2.extend([4]) 相当于原地改变，并没有新的对象产生。","link":"/2018/01/08/python-zhong-de-ke-bian-he-bu-ke-bian-dui-xiang/"},{"title":"Python 中的可迭代对象(Iterable)","text":"Python 中的可迭代对象（iterable）？ Python 中可迭代对象（Iterable）并不是指某种具体的数据类型，它是指存储了元素的一个容器对象，且容器中的元素可以通过 __iter__( ) 方法或 __getitem__( ) 方法进行访问。 可迭代对象（Iterable）满足如下： [1] &gt;&gt;&gt;&gt; __iter__ 方法的作用是让对象可以用 for … in 循环遍历，而 getitem( ) 方法是让对象可以通过 实例名[index] 的方式访问实例中的元素。这两个方法的目的是 Python 实现一个通用的外部可以访问可迭代对象内部数据的接口。 [2] &gt;&gt;&gt;&gt; 一个可迭代对象是不能独立进行迭代的，Python 中，迭代是通过 for … in 来完成的。凡是可迭代对象都可以直接用 for… in… 循环访问。 [3] &gt;&gt;&gt;&gt; 常见的可迭代对象包括： 集合数据类型，如 list、tuple、dict、set、str 等； 生成器（generator），包括生成器和带 yield 的生成器函数（generator function） [4] &gt;&gt;&gt;&gt; 如何判断一个对象是可迭代对象呢？可以通过 collections 模块的 Iterable 类型判断，具体判断方法如下： 1234567891011from collections import Iterablemy_list = [1, 2, 3, 4]my_tuple = (1, 2, 3, 4)my_dict = {'a': 1, 'b':2}my_set = {1, 2, 3, 4}print(isinstance(my_list, Iterable)) # Trueprint(isinstance(my_tuple, Iterable))# Trueprint(isinstance(my_dict, Iterable)) # Trueprint(isinstance(my_set, Iterable)) # True","link":"/2018/01/07/python-zhong-de-ke-die-dai-dui-xiang-iterable/"},{"title":"Python 中的序列详解","text":"Python 中的数字类型（Number）、字符串类型（String）之后，后续应该要继续讲元祖（Tuple）、列表（List）之类的。但是元祖和列表都属于序列，掌握序列（Sequence）的相关知识可以帮我们更容易的学习后续内容，所以有必要先了解一下 Python 中的序列是什么？ Python 中的序列序列是一系列数据元素的有序集合，注意是有序的，它是 Python 中最基本的一种数据结构。 序列中的每个元素都被分配一个 数字 —- 它的位置，也就是我们说的元素的 索引。 第一个索引是 0，第二个索引是 1，依此类推……每个索引对应了一个 元素。 Python 包含 6 种内建的序列，包括 字符串（str）、元组（tuple）、列表（list）、Unicode 字符串、buffer 对象以及 range（xrange） 对象。 对于序列，都可以使用以下操作： 索引 切片 加（+） 乘（*） 成员检查 计算序列的长度 取序列中的最大、最小值 is &amp;&amp; == &amp;&amp; id()在开始正式的解读之前，我们先来看几个必要的语法： &gt;&gt;&gt; id()Python 中的 id() 内置函数，可用于获取对象的内存地址。语法规则如下： 1id(object) 样例如下： 123456&gt;&gt;&gt; str1 = &quot;id() function test&quot;&gt;&gt;&gt; num = 1.23&gt;&gt;&gt; id(str1)2419096572024&gt;&gt;&gt; id(num)2419065860360 &gt;&gt;&gt; is &amp;&amp; ==Python 中经常会用到对象之间的比较，可以用 ==，也可以用 is 。它们有什么区别？ is：比较的是 两个实例对象是不是完全相同，是不是同一个对象（占用的内存地址是否相同）； ==：比较的是 两个对象的内容是否相等，即内存地址可以不一样，内容一样就可以了。 样例如下： 12345678910111213&gt;&gt;&gt; str1 = &quot;Python&quot;&gt;&gt;&gt; str2 = str1&gt;&gt;&gt; str1 is str2True&gt;&gt;&gt; id(str1)2419095062488&gt;&gt;&gt; id(str2)2419095062488&gt;&gt;&gt; str1 == str2True 序列中的索引就像上面说的，序列中的每个元素都分配一个 数字 —- 它的位置，也就是我们说的元素的 索引。 [1] &gt;&gt;&gt;&gt; 两种索引方式： 正向索引：从前向后标记，第一个索引是 0，第二个索引是 1，依此类推。每个索引对应一个元素。 反向索引：序列中元素的索引也可以从后向前标记，最后一个索引是 -1，倒数第二个索引是 -2，以此类推。 [2] &gt;&gt;&gt;&gt; 可以通过索引获取序列中元素： 通过索引和 [] ，我们可以获取到相应索引位置的元素对象: 12345678910&gt;&gt;&gt; str_a = &quot;Python&quot;&gt;&gt;&gt; print(type(str_a))&lt;class 'str'&gt;&gt;&gt;&gt; str_b = str_a[2]&gt;&gt;&gt; print(str_b)t&gt;&gt;&gt; type(str_b)&lt;class 'str'&gt; 可以发现，字符串序列中通过索引取到的元素类型仍为字符串。 有个上面的知识储备，这里再重新认识一下序列是什么？！！ 序列到底是什么？所谓序列， 指的是一块可存放多个值的连续内存空间，这些值按一定顺序排列，可以是任何类型的对象元素，可通过值所在位置的编号（称为索引）获取相应的元素对象，并且取到的是元素原对象。 1234567891011&gt;&gt;&gt; list1 = [1]# 这里，你只需要了解 tup1 = () 可以创建一个元组即可&gt;&gt;&gt; tup1 = (&quot;Python&quot;, 123, list1)&gt;&gt;&gt; test = tup1[2]&gt;&gt;&gt; print(test, type(test))[1] &lt;class 'list'&gt;&gt;&gt;&gt; print(test is list1)True 发现确实如此，也就是说，我们可以将序列中的索引看作是一个特殊的变量，它指向的是相应对象元素的内存空间，或着说，它对应了元素对象的引用。 字符串作为序列怎么解释？！！ &gt;&gt;&gt;&gt; 不知道你发现没有：上面的说法套到字符串中略显变扭，因为字符串也是一个序列，难道字符串索引所对应的元素难道是一个个的字符（长度为一的字符串）对象？？？ 我们先假设字符串是将每个字符（长度为一的字符串）都存储在一个个内存空间中(连续)，字符串变量取得的是整个字符串，而索引则是每个字符的变量（引用）。来看一下假设结果如何： 123&gt;&gt;&gt; str_test = &quot;abcdabcd&quot;&gt;&gt;&gt; print(id(str1), id(str_test[0]), id(str_test[4]))139820050579888 139820053906072 139820053906072 我们发现，哎，好像 感觉 假设成立啊？ 那这样呢： 123456&gt;&gt;&gt; str1 = &quot;abcdabcd&quot;&gt;&gt;&gt; str2 = 'a'&gt;&gt;&gt; str3 = 'b'&gt;&gt;&gt; str4 = 'b'&gt;&gt;&gt; print(id(str1[0]), id(str1[4]), id(str2), id(str3), id(str4))2150485782008 2150485782008 2150485782008 2150485780328 2150485780328 看到这里你是不是明白了什么？!! &gt;&gt;&gt;&gt; 字符串是字符对象的引用的集合，所以我们使用英文的时候是不是最多只有创建 26 个字母，然后字符串只要重复引用就可以了。其他字符也同理。(是不有种常量缓存池的赶脚…) 关于常量缓存池请参见博文：Python 中的缓存重用机制（常量池）。 有了上面的理解，是不对序列的了解就更深一步了？ 序列支持操作博文开篇已经说明了序列支持 7 中操作： 序列中的索引和切片索引不用多介绍了，所谓切片就是通过 [:] 配合序列索引一次拿出多个对象，而索引一次只能拿出一个对象。 123&gt;&gt;&gt; str1 = &quot;abcdabcd&quot;&gt;&gt;&gt; print(str1[0:2])ab [1] &gt;&gt;&gt;&gt; 切片是前闭后开的： 上面返回的结果依然是一个字符串，这是要注意一个问题。还有就是 a[2] 明明是 c 才对，但结果我们并没有取到。 说明 &gt;&gt;&gt;&gt; 切片是不包括后界限的索引的，所以无法取到后界限索引所引用的元素（前闭后开）。 切片的其它用法 &gt;&gt;&gt;&gt; 1234567891011# 获取所有所有元素对象：&gt;&gt;&gt; print(str1[:])abcdabcd&gt;&gt;&gt; print(str1[0:])abcdabcd# 注意，反向索引，无法取到后界限索引对象：&gt;&gt;&gt; print(str1[:-1])abcdabc&gt;&gt;&gt; print(str1[-3:-1])bc [2] &gt;&gt;&gt;&gt; 切片小技巧： 先看一个元组切片的样例： 123&gt;&gt;&gt; tup1 = (&quot;Python&quot;, 123, [1,2])&gt;&gt;&gt; print(tup1[:2], type(tup1[:2]))('Python', 123) &lt;class 'tuple'&gt; 我们知道，对序列切片，只是从包含多个元素对象的序列中取出包含部分元素对象的序列。如上面元组切片，切片后仍然得到的是一个元组，可以得到几个元素对象。 此时，我们可以使用多个变量去接收这些元素，这样我们能得到独立的对象进行其它操作了： 123456789&gt;&gt;&gt; tup1 = (&quot;Python&quot;, 123, [1,2])&gt;&gt;&gt; str1, num = tup1[:2]&gt;&gt;&gt; print(str1, num)Python 123&gt;&gt;&gt; list1 = [&quot;Google&quot;, &quot;Edge&quot;, &quot;Firfox&quot;]&gt;&gt;&gt; test1,test2 = list1[0:2]&gt;&gt;&gt; print(test1, test2)Google Edge 是不很方便？可以参见后面关于序列解包（Unpack）的说明。 [3] &gt;&gt;&gt;&gt; 切片中的步长概念： 所谓的切片步长，就是每几个元素对象取一个。如下： 12&gt;&gt;&gt; print(tup1[::2])('Python', [1, 2]) 可以看到，对于 tup1 = (&quot;Python&quot;, 123, [1,2]) 我们每个 2 步长取一个元素的结果。 负向步长（即步长取值为负数） &gt;&gt;&gt;&gt; 可实现反序 12345&gt;&gt;&gt; tup1 = (&quot;Python&quot;, 123, [1,2])&gt;&gt;&gt; print(tup1[::2])('Python', [1, 2])&gt;&gt;&gt; print(tup1[::-1])([1, 2], 123, 'Python') 加（+）1234567&gt;&gt;&gt; tup1 = (&quot;Python&quot;, 123, [1,2])&gt;&gt;&gt; print(tup1 + tup1)('Python', 123, [1, 2], 'Python', 123, [1, 2])&gt;&gt;&gt; str1 = &quot;test&quot;&gt;&gt;&gt; print(str1 + str1)testtest 我们发现，同类型序列可以进行相加，并没有影响到原序列类型。 那么不同类型的序列相加呢？ &gt;&gt;&gt;&gt; 不同类型序列不可直接相加！！！ 1234&gt;&gt;&gt; print(tup1 + str1)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: can only concatenate tuple (not &quot;str&quot;) to tuple 果然不行~~~ 乘（*）乘法和加法类似，只是几个一样的序列相加而已： 1234567&gt;&gt;&gt; tup1 = (&quot;Python&quot;, 123, [1,2])&gt;&gt;&gt; str1 = &quot;test&quot;&gt;&gt;&gt; print(tup1 * 2)('Python', 123, [1, 2], 'Python', 123, [1, 2])&gt;&gt;&gt; print(str1 * 2)testtest 同样不会影响原序列。 成员检查（in &amp;&amp; not in）成员检查就是就是，判断元素对象是否（不）包含在序列中，返回的是布尔型值。如下： 123456789101112&gt;&gt;&gt; tup1 = (&quot;Python&quot;, 123, [1,2])&gt;&gt;&gt; str1 = &quot;test&quot;&gt;&gt;&gt; print(&quot;te&quot; in str1)True&gt;&gt;&gt; print(&quot;te&quot; not in str1)False&gt;&gt;&gt; print(123 in tup1)True&gt;&gt;&gt; print(123 not in tup1)False 序列长度计算其实就是 len() 内置函数的调用，该函数会返回序列容器中元素的数量。 12345&gt;&gt;&gt; tup1 = (&quot;Python&quot;, 123, [1,2])&gt;&gt;&gt; str1 = &quot;test&quot;&gt;&gt;&gt; print(len(tup1), len(str1))3 4 后面，你会发现：不仅仅是序列，集合（Set）和字典（Dict）也可以通过 len() 求元素个数。 取序列中的最大、最小值这里其实是内置函数 max() 和 max() 的使用，其会返回序列中的最大、最小值。 关于不同序列最大、最小等到具体小节会介绍。 序列解包（Unpack）序列中支持，通过序列解包的方式将序列中各元素对象分别赋给不同的变量，以获得单个元素的变量。 也就是说，可以直接使用序列元素个数对应数量的变量，来接收序列中的各个元素。 代码示例： 123456789101112131415str1 = &quot;abc&quot;str2, str3, str4 = str1print(&quot;str2: %s, str3: %s, str4: %s&quot; % (str2, str3, str4))# str2: a, str3: b, str4: clist1 = [&quot;Python&quot;, &quot;C/C++&quot;, &quot;Java&quot;]str5, str6, str7 = list1print(&quot;str5: %s, str6: %s, str7: %s&quot; % (str5, str6, str7))# str5: Python, str6: C/C++, str7: Java# 切片小技巧list2 = [&quot;Python&quot;, &quot;C/C++&quot;, &quot;Java&quot;]str8, str9 = list2[0:2]print(&quot;str8: %s, str9: %s&quot; % (str8, str9))# str8: Python, str9: C/C++ 新变量指向序列中各元素对象地址 &gt;&gt;&gt;&gt; 123456789101112131415list1 = [&quot;Python&quot;, [1,2], {&quot;good&quot;:2}]str1, list2, dict1 = list1print(&quot;str1: %s, list2: %s, dict1: %s&quot; % (str1, list2, dict1))# str1: Python, list2: [1, 2], dict1: {'good': 2}print(id(str1), id(list1[0]))print(id(list2), id(list1[1]))print(id(dict1), id(list1[2]))# 1609454214312 1609454214312# 1609512943496 1609512943496# 1609513158088 1609513158088list2[0] = &quot;update&quot;print(list1)# ['Python', ['update', 2], {'good': 2}] 序列支持的内置函数Python提供了几个内置函数，可用于实现与序列相关的一些常用操作: 函数 功能 len() 计算序列的长度，即返回序列中包含多少个元素。 max() 找出序列中的最大元素。 min() 找出序列中的最小元素。 list() 将序列转换为列表。 str() 将序列转换为字符串。 sum() 计算元素和。注意，对序列使用 sum() 函数时，做加和操作的必须都是数字，不能是字符或字符串，否则该函数将抛出异常，因为解释器无法判定是要做连接操作（+ 运算符可以连接两个序列），还是做加和操作。 sorted() 对元素进行排序。 reversed() 反向序列中的元素。返回一个逆序序列的迭代器（用于遍历该逆序序列） enumerate() 将序列组合为一个索引序列，多用在 for 循环中。","link":"/2018/01/06/python-zhong-de-xu-lie-xiang-jie/"},{"title":"Python 中的深浅拷贝详解","text":"Python 中的 浅拷贝（shallow copy） 和 深度拷贝（deep copy）。 一上来给出深、浅拷贝含义总是很迷惑的，这里会先从它们的操作方法说起，通过代码来理解两者的不同。 浅拷贝Python 中实现浅拷贝的三种方法： [1] &gt;&gt;&gt;&gt; 数据类型构造器 使用数据类型本身的构造器创建元素对象，是常见的浅拷贝的方法： 12345678910111213141516&gt;&gt;&gt; list1 = [1, 2, 3]&gt;&gt;&gt; list2 = list(list1)&gt;&gt;&gt; print(list2)[1, 2, 3]&gt;&gt;&gt; print(&quot;list1==list2 ?&quot;,list1==list2)list1==list2 ? True&gt;&gt;&gt; print(&quot;list1 is list2 ?&quot;,list1 is list2)list1 is list2 ? False&gt;&gt;&gt; set1= set([1, 2, 3])&gt;&gt;&gt; set2 = set(set1)&gt;&gt;&gt; print(set2){1, 2, 3}&gt;&gt;&gt; print(&quot;set1==set2 ?&quot;,set1==set2)set1==set2 ? True&gt;&gt;&gt; print(&quot;set1 is set2 ?&quot;,set1 is set2)set1 is set2 ? False 在上面程序中，list2 就是 list1 的浅拷贝，同理 set2 是 set1 的浅拷贝。 这里先不要深究浅拷贝的含义是什么，先观察其形式。 [2] &gt;&gt;&gt;&gt; 切片操作符 “：” 对于可变的序列（List），还可以通过切片操作符 “：” 来完成浅拷贝，例如： 12345678&gt;&gt;&gt; list1 = [1, 2, 3]&gt;&gt;&gt; list2 = list1[:]&gt;&gt;&gt; print(list2)[1, 2, 3]&gt;&gt;&gt; print(&quot;list1 == list2 ?&quot;,list1 == list2)list1 == list2 ? True&gt;&gt;&gt; print(&quot;list1 is list2 ?&quot;,list1 is list2)list1 is list2 ? False 在上面程序中，list2 就是 list1 的浅拷贝。 [3] &gt;&gt;&gt;&gt; Python 浅拷贝方法 Python 中提供了适用于任何数据类型的浅拷贝方法 –&gt; copy.copy() 函数。其用法如下： 123456789&gt;&gt;&gt; import copy&gt;&gt;&gt; list1 = [1, 2, 3]&gt;&gt;&gt; list2 = copy.copy(list1)&gt;&gt;&gt; print(list2)[1, 2, 3]&gt;&gt;&gt; print(&quot;list1 == list2 ?&quot;,list1 == list2)list1 == list2 ? True&gt;&gt;&gt; print(&quot;list1 is list2 ?&quot;,list1 is list2)list1 is list2 ? False 浅拷贝 &gt;&gt;&gt;&gt; 看到这里，你可能对浅拷贝有了初步的认识，这里引入浅拷贝的概念，可结合上述代码进行理解 &gt;&gt;&gt;&gt; 浅拷贝，指的是重新分配一块内存，创建一个新的对象，但新对象里面的元素是原对象中各个子对象的引用。 既然新对象元素是原对象子对象的引用，这意味着新对象中各个元素一一对应了原对象各子对象的引用，而原对象中各子对象数据类型是不定的，可以是可变的，也可以是不可变的，这就会产生一些问题。 对数据采用浅拷贝的方式时，如果原对象中的元素不可变，那倒无所谓；但如果元素可变，浅拷贝通常会出现一些问题，例如： 1234567891011121314151617181920&gt;&gt;&gt; list1 = [[1, 2], (30, 40)]&gt;&gt;&gt; list2 = list(list1)&gt;&gt;&gt; list1.append(100)&gt;&gt;&gt; print(&quot;list1:&quot;,list1)list1: [[1, 2], (30, 40), 100]&gt;&gt;&gt; print(&quot;list2:&quot;,list2)list2: [[1, 2], (30, 40)]&gt;&gt;&gt; list1[0].append(3)&gt;&gt;&gt; print(&quot;list1:&quot;,list1)list1: [[1, 2, 3], (30, 40), 100]&gt;&gt;&gt; print(&quot;list2:&quot;,list2)list2: [[1, 2, 3], (30, 40)]&gt;&gt;&gt; list1[1] += (50, 60)&gt;&gt;&gt; print(&quot;list1:&quot;,list1)list1: [[1, 2, 3], (30, 40, 50, 60), 100]&gt;&gt;&gt; print(&quot;list2:&quot;,list2)list2: [[1, 2, 3], (30, 40)] 此程序中，首先初始化了 list1 列表，包含一个列表和一个元组；然后对 list1 执行浅拷贝，赋予 list2。因为浅拷贝里的元素是对原对象元素的引用，因此 list2 中的元素和 list1 指向同一个列表和元组对象。 接着往下看，list1.append(100) 表示对 list1 的列表新增元素 100。这个操作不会对 list2 产生任何影响，因为 list2 和 list1 作为整体是两个不同的对象，并不共享内存地址。操作过后 list2 不变，list1 会发生改变。 再来看，list1[0].append(3) 表示对 list1 中的第一个列表新增元素 3。因为 list2 是 list1 的浅拷贝，list2 中的第一个元素和 list1 中的第一个元素，共同指向同一个列表，因此 list2 中的第一个列表也会相对应的新增元素 3。 最后是 list1[1] += (50, 60)，因为元组是不可变的，这里表示对 list1 中的第二个元组拼接，然后重新创建了一个新元组作为 list1 中的第二个元素，而 list2 中没有引用新元组，因此 list2 并不受影响。 | &gt;&gt;&gt;&gt; ==================================================================== 对于元组，使用 tuple() 或者切片操作符 ‘:’ 不会创建一份浅拷贝，相反它会返回一个指向相同元组的引用： 1234567891011121314&gt;&gt;&gt; tuple1 = (1, 2, 3)&gt;&gt;&gt; tuple2 = tuple(tuple1)&gt;&gt;&gt; print(tuple2)(1, 2, 3)&gt;&gt;&gt; print(&quot;tuple1 == tuple2 ?&quot;,tuple1 == tuple2)tuple1 == tuple2 ? True&gt;&gt;&gt; print(&quot;tuple1 is tuple2 ?&quot;,tuple1 is tuple2)tuple1 is tuple2 ? True&gt;&gt;&gt; tuple3 = tuple1[:]&gt;&gt;&gt; print(&quot;tuple1 == tuple3 ?&quot;,tuple1 == tuple3)tuple1 == tuple3 ? True&gt;&gt;&gt; print(&quot;tuple1 is tuple3 ?&quot;,tuple1 is tuple3)tuple1 is tuple3 ? True 可以看到，元组 (1, 2, 3) 只被创建一次，t1 和 t2 同时指向这个元组。 可以想到对于字符串其 tuple() 或者切片操作符 ‘:’ 也是一样的，这是由于 str &amp;&amp; tuple 是不可变对象， ==================================================================== &lt;&lt;&lt;&lt; | 通过上面浅拷贝的例子，你可以很清楚地看到使用浅拷贝可能带来的副作用。那么，怎么办？？？ 浅拷贝如果想避免拷贝可能带来的副作用，完整地拷贝一个新对象，而且对新对象中元素的操作不会影响到原对象，就需要使用深拷贝 &gt;&gt;&gt;&gt; 所谓 深拷贝，指的是重新分配一块内存，创建一个新的对象，并且将原对象中的元素，以递归的方式，通过创建新的子对象拷贝到新对象中。 也就是说，通过深拷贝可以使得新对象和原对象没有任何关联！！！ 那么，如何再 Python 中实现深拷贝呢？ &gt;&gt;&gt;&gt; [1] &gt;&gt;&gt;&gt; Python 深拷贝方法 Python 中以 copy.deepcopy() 来实现对象的深度拷贝： 123456789101112131415161718&gt;&gt;&gt; import copy&gt;&gt;&gt; list1 = [[1, 2], (30, 40)]&gt;&gt;&gt; list2 = copy.deepcopy(list1)&gt;&gt;&gt; list1.append(100)&gt;&gt;&gt; print(&quot;list1:&quot;,list1)list1: [[1, 2], (30, 40), 100]&gt;&gt;&gt; print(&quot;list2:&quot;,list2)list2: [[1, 2], (30, 40)]&gt;&gt;&gt; list1[0].append(3)&gt;&gt;&gt; print(&quot;list1:&quot;,list1)list1: [[1, 2, 3], (30, 40), 100]&gt;&gt;&gt; print(&quot;list2:&quot;,list2)list2: [[1, 2], (30, 40)]&gt;&gt;&gt; list1[1] += (50, 60)&gt;&gt;&gt; print(&quot;list1:&quot;,list1)list1: [[1, 2, 3], (30, 40, 50, 60), 100]&gt;&gt;&gt; print(&quot;list2:&quot;,list2)list2: [[1, 2], (30, 40)] 可以看到，无论 list1 如何变化，list2 都不变。因为此时的 list1 和 list2 完全独立，没有任何联系（通过深拷贝实现了解耦）。 [2] &gt;&gt;&gt;&gt; 深拷贝无限循环问题 深度拷贝也不是完美的，往往也会带来一系列问题。如果被拷贝对象中存在指向自身的引用，那么程序很容易陷入无限循环，例如： 1234567&gt;&gt;&gt; list1 = [1]&gt;&gt;&gt; list1.append(list1)&gt;&gt;&gt; print(list1)[1, [...]]&gt;&gt;&gt; list2 = copy.deepcopy(list1)&gt;&gt;&gt; print(list2)[1, [...]] 此例子中，列表 x 中有指向自身的引用，因此 x 是一个无限嵌套的列表。 但是当深度拷贝 x 到 y 后，程序并没有出现栈溢出的现象。这是为什么呢？ 其实，这是因为深度拷贝函数 deepcopy 中会维护一个字典，记录已经拷贝的对象与其 ID。拷贝过程中，如果字典里已经存储了将要拷贝的对象，则会从字典直接返回。","link":"/2018/01/08/python-zhong-de-shen-qian-kao-bei-xiang-jie/"},{"title":"Python 之 bytes &amp;&amp; bytearry 类型详解","text":"","link":"/2022/03/16/python-zhi-bytes-bytearry-lei-xing-xiang-jie/"},{"title":"Python 基础语法","text":"任何一种编程语言（Python、Java、C 等）都有自己的一套语法规则，编译器或者解释器就是负责把符合编程语言语法的程序代码转换成计算机 CPU 能够执行的机器码，然后执行。从这里开始，我们将正式开始 Python 程序设计语言语法规则 的学习。 Python 官方标准库地址 &gt;&gt;&gt; 【传送门】，从这里你可以获取到关于 Python 程序设计语言的所有说明文档。 在开始正式学习 Python 基础语法规则之前，我们先来说明一些 Python 编程中需要注意的最最基本的语法规则或编码规范： 标点符号的使用Python 默认语法中，标点符号都是 【半角英文】 输入。不小心用了中文标点的话，计算机会无法识别，然后报错： 1SyntaxError: invalid character in identifier 源文件编码Python3 源文件默认情况下（不明确指定），是以 UTF-8 进行编码的，所有字符串都是 unicode 字符串。 1# -*- coding: utf-8 -*- 当然你也可以为源码文件指定不同的编码： 1# -*- coding: GB2312 -*- 上述定义允许在源文件中使用 GB2312（simplified） 字符集中的字符编码，对应适合语言为简体中文。 标识符命名规范程序设计语言中，标识符（Identifier）就是用于给变量、常量、函数、类、对象以及模块等命名，以建立起名称与使用之间的关系。 但标识符的命名不是随意的，而是要遵守一定的命令规则，比如说： 【1】 标识符可以由字母、数字和下划线组成，不能包含空格、@、% 以及 $ 等特殊字符。 【2】 第一个字符必须是字母表中字母或下划线 &quot;_&quot;。 【3】 标识符对大小写敏感。 【4】 下划线开头的标识符是有特殊意义的： 以单下划线开头的标识符（如 _width），表示不能直接访问的类属性，其无法通过 from...import* 的方式导入； 以双下划线开头的标识符（如__add）表示类的私有成员； 以双下划线作为开头和结尾的标识符（如 __init__），是特殊方法专用标识符。代表类的构造函数。 因此，除非特定场景需要，应避免使用以下划线开头的标识符。 【5】 Python 中允许使用汉字作为标识符（避免使用），例如: 你好 = &quot;ni hao&quot;。 【6】 除了要遵守以上这几条规则外，不同场景下的标识符命名规范： 模块名全小写，多个单词可用下划线分割； 包名全小写，com.mr、com.mr.book； 常量全大写，多个单词可用下划线分割； 变量、函数名，类中的属性名、方法名全部小写，多个单词可用下划线分割； 类名首字母全大写，多个单词可用下划线分割。 =============================== 英文名 =============================== 【7】 英文名可参照 CODELF 给出，不可以使用 Python 关键字，不推荐使用 内置函数名。 困扰：取名字真难？！！对于英语水平高考即巅峰的同学（当然不是贬低）达到见面知义有一定难度。 这里推荐一个网站：CODELF。命名前可以输入中文看看网络大佬们都是如何进行命名的。 Python 保留字保留字即关键字，已经被 Python 系统赋予了特定的意义，我们不能把它们用作任何标识符名称。Python 的标准库提供了一个 keyword 模块，可以输出当前版本的所有关键字（35）： 123&gt;&gt;&gt; import keyword&gt;&gt;&gt; keyword.kwlist['False', 'None', 'True', 'and', 'as', 'assert', 'async', 'await', 'break', 'class', 'continue', 'def', 'del', 'elif', 'else', 'except', 'finally', 'for', 'from', 'global', 'if', 'import', 'in', 'is', 'lambda', 'nonlocal', 'not', 'or', 'pass', 'raise', 'return', 'try', 'while', 'with', 'yield'] 使用 Python 中的保留字作为标识符，则解释器会报错： 1SyntaxError: can't assign to keyword 注释注释是给开发人员看的，可以是任意你想写的内容，解释器会自动忽略掉注释。由于解释器忽略的属性也可用于代码测试。 1 –&gt; 行注释 Python 中单行注释以 # 开头，实例如下： 12345678#!/usr/bin/python3# 第一个注释print (&quot;Hello, Python1!&quot;)print (&quot;Hello, Python2!&quot;)print (&quot;Hello, Python3!&quot;)print (&quot;Hello, Python4!&quot;) # 第二个注释 说明多行代码的功能时，一般将注释放在代码的上一行；说明单行代码的功能时一般将注释放在代码的右侧。 2 –&gt; 块注释 多行注释可以用多个 # 行注释，还可以使用三个连续单引号 ''' ''' 或三个双引号 &quot;&quot;&quot; &quot;&quot;&quot; 实现： 123456789101112131415161718#!/usr/bin/python3 # 第一个注释# 第二个注释 '''使用 3 个单引号分别作为注释的开头和结尾可以一次性注释多行内容这里面的内容全部是注释内容''' &quot;&quot;&quot;使用 3 个双引号分别作为注释的开头和结尾可以一次性注释多行内容这里面的内容全部是注释内容&quot;&quot;&quot;print (&quot;Hello, Python!&quot;) 块注释通常用来为 Python 文件、模块、类或者函数等添加版权或者功能描述信息。 Python 语句1 –&gt; 语句行 Python 可以在同一行中使用分号 ; 来写多条语句，以下是一个简单的实例： 1name = &quot;Google&quot;; age = 20; job = &quot;IT&quot;; 2 –&gt; 跨行语句 Python 通常是一行写完一条语句，但如果语句很长，我们可以使用反斜杠 (\\) 来实现语句跨行，例如： 123456789# 表达式：total = item_one + \\ item_two + \\ item_three# 字符串（注意可能会引入空格，避免使用）：str_roll = &quot;This is the first lines \\ This is the second lines \\ This is the second lines&quot; Python 语法规范中，不推荐使用反斜杠实现语句跨行，这里你只需要知道有相关用法即可。推荐语句跨行方法见下文【Python 语句相关编码规范要求 &gt;&gt;&gt;&gt; 2】中说明。 | &gt;&gt;&gt; =============================== Python 语句相关编码规范要求 &gt;&gt;&gt;&gt; ============================= &lt;&lt;&lt; | 1】 每行只写一个语句，而且语句行尾不加（;）。 2】 Python 语法规则中规定 每行不超过 80 个字符。如果语句行过长时，建议使用圆括号 () 来实现语句跨行： Python 重要特性 &gt;&gt;&gt;&gt; 会将 圆括号 (), 中括号 [] 和花括号 {} 中的多行内容隐式的连接起来。 123456789101112131415# 函数过长，实现跨行：Yes: foo_bar(self, width, height, color='black', design=None, x='foo', emphasis=None, highlight=0)# If 条件过长，实现跨行： if (width == 0 and height == 0 and color == 'red' and emphasis == 'strong'):# 文本字符串过长，实现跨行：x = ('This will build a very long long ' 'long long long long long long string')# 表达式过长，实现跨行：total = (item_one + item_two + item_three) 避免宁缺毋滥的使用括号 ()，除非是用于实现跨行连接, 否则不要在返回语句或条件语句中使用括号，元组两边正常使用即可。 某些不便于跨行的特殊情况下 &gt;&gt;&gt;&gt; 可写于一行内（&gt; 80 chars） 长的导入模块语句; 注释里的 URL、路径以及其他的一些长标记； 不便于换行，不包含空格的模块级字符串常量，比如 url 或者路径。 3】 除非是在 with 语句需要三个以上的上下文管理器的情况下，否则不要使用反斜杠连接行。 123456789101112Yes: with very_long_first_expression_function() as spam, \\ very_long_second_expression_function() as beans, \\ third_thing() as eggs: place_order(eggs, beans, spam, beans)No: with VeryLongFirstExpressionFunction() as spam, \\ VeryLongSecondExpressionFunction() as beans: PlaceOrder(eggs, beans, spam, beans)Yes: with very_long_first_expression_function() as spam: with very_long_second_expression_function() as beans: place_order(beans, spam) 缩进Python 最具特色的就是使用 缩进 来表示代码块，不再需要使用大括号 {} 。 缩进有利有弊： 缩进的好处 –&gt; 是强迫你写出格式化的代码，但没有规定缩进是几个空格还是 Tab（但上下文要一致，不要混用 Tab 和 空格，否则会报错）。 按照约定俗成的管理，应该始终坚持使用 4 个空格的缩进。缩进不一致导致的错误： 1IndentationError: unindent does not match any outer indentation level 缩进的坏处 –&gt; 就是 “复制－粘贴” 功能失效了，这是最坑爹的地方。当你重构代码时，粘贴过去的代码必须重新检查缩进是否正确。 import &amp;&amp; from … import在 Python 中用 import 或者 from...import 来导入相应的模块从而调用其内置方法： 将整个模块(somemodule)导入，格式为： import somemodule 为方便模块使用，简写格式为：import somemodule as xxx 从某个模块中导入某个函数，格式为： from somemodule import somefunction 从某个模块中导入多个函数，格式为： from somemodule import firstfunc, secondfunc, thirdfunc 将某个模块中的全部函数导入，格式为： from somemodule import * Google Style 编码规范并不是只要遵循了上述 Python 基础语法规范，你就可以随心所欲的写脚本代码了。通常，在日常开发过程中，你必须遵循一定的编码规范，以提高代码的可读性。 这里，提供一个 Google Style 的 Python 风格规范。 工作项目中，你还可以使用编码规范的自动化工具来自动化规范你的编码，这是重要且合理的。","link":"/2018/01/04/python-ji-chu-yu-fa/"},{"title":"Python 字符串之 Unicode 编码","text":"Python 字符串也是一种数据类型，但是字符串比较特殊的是还有一个编码问题。Python2 中的字符编码是个老生常谈的话题，这一小节我们围绕字符串来看关于 Python3 中的字符编码问题。 开始 Pthon 字符串编码学习之前，请先了解：编程基础之编码详解，这是必要的。 Python 源代码文件的执行过程我们知道，磁盘上的文件都是以二进制字节码格式存放的，也就是说纯文本文件都是以某种特定编码的字节形式存放的。 对于程序源代码文件的字符编码是由编辑器指定的，比如我们使用 Pycharm 来编写 Python 程序时会指定工程编码和文件编码为 UTF-8，那么 Python 代码被保存到磁盘时就会被转换为 UTF-8 编码对应的字节（encode 过程）后写入磁盘。 当执行 Python 代码文件中的代码时，Python 解释器在读取 Python 代码文件中的字节串之后，需要将其转换为 unicode 字符串（decode 过程）之后（内存中）才执行后续操作。 Python 默认编码机制如果我们没有在代码文件开始的部分指定字符编码，Python 解释器就会使用哪种字符编码把从代码文件中读取到的字节转换为 unicode 字符呢？ Python 解释器提供了 “默认编码（default encoding）” 机制，来处理字节码。 Python2 的默认编码是 ASCII，故不能直接识别中文字符，需要显式指定字符编码；Python3 的默认编码 为 Unicode，可以识别中文字符。 1234567891011# 通过 sys.getdefaultencoding() 来获取 Python 解释器中默认编码：&gt;&gt;&gt; # Python2&gt;&gt;&gt; import sys&gt;&gt;&gt; sys.getdefaultencoding()'ascii' &gt;&gt;&gt; # Python3&gt;&gt;&gt; import sys&gt;&gt;&gt; sys.getdefaultencoding()'utf-8' [1] –&gt; UnicodeEncodeError 广为人知的 Python2 中文字符问题可以总结为一句话：当无法通过默认的字符编码对字节进行转换时，就会出现解码错误(UnicodeEncodeError)。 对于 Python2 来讲，Python 解释器在读取到中文字符的字节码尝试解码操作时，会先查看当前代码文件头部是否有指明当前代码文件中保存的字节码对应的字符编码是什么。如果没有指定则使用默认字符编码 “ASCII” 进行解码导致解码失败，导致如下错误： 12SyntaxError: Non-ASCII character '\\xc4' in file xxx.py on line 11, but no encoding declared; see http://python.org/dev/peps/pep-0263/ for details 对于 Python3 来讲，执行过程是一样的，只是 Python3 的解释器以 “UTF-8” 作为默认编码，但是这并不表示可以完全兼容中文问题。比如我们在 Windows 上进行开发时，经常遇到 Python工程及代码文件使用 GBK 编码的情况，也就是说 Python 代码文件是被转换成 GBK 格式的字节码保存到磁盘中的。Python3 的解释器执行该代码文件时，试图用 UTF-8 进行解码操作时，同样会解码失败，导致如下错误： 12SyntaxError: Non-UTF-8 code starting with '\\xc4' in file xxx.py on line 11, but no encoding declared; see http://python.org/dev/peps/pep-0263/ for details 2）Solution 创建一个 Python 工程之后先确认该工程的默认字符编码规则是否已经设置为 UTF-8； 为了兼容 Python2 和 Python3，在代码头部声明字符编码：-*- coding:utf-8 -*-。 字符串和字节串需要知道 &gt;&gt;&gt;&gt; unicode 才是真正的字符串，而用 ASCII、UTF-8、GBK 等字符编码表示的是字节串。 我们知道，字符是以字节的形式保存在文件中的。因此当我们在文件中定义的字符串被当做字节串也是可以理解的。但是，我们需要的是字符串，而不是字节串（是给计算机用来进行存储、处理和传输的）。一个优秀的编程语言，应该严格区分两者的关系。 遗憾的是，很多编程语言试图混淆 “字符串” 和 “字节串”，他们把字节串当做字符串来使用，PHP、Python2 就属于这种编程语言。而在 Python3 中可能已经意识到之前的错误，重新进行了字符串的设计，所以开始明确的区分字符串与字节。 最能说明这个问题的操作就是 取一个包含中文字符的字符串的长度： [1] –&gt; Python 2 1234567891011121314# 字节串，长度为字节个数 = len('Hello,')+len('中国') = 6+2*2 = 10&gt;&gt;&gt; str1 = 'Hello,中国'# 字符串，长度为字符个数 = len('Hello,') + len('中国') = 6+2 = 8&gt;&gt;&gt; str2 = u'Hello,中国'# 其实 str2 的定义方式是 str3 定义方式的简写，都是将一个 GBK 编码的字节串解码（decode）为一个 Uniocde 字符串&gt;&gt;&gt; str3 = unicode(str1, 'gbk')&gt;&gt;&gt; &gt;&gt;&gt; print(type(str1), len(str1))(&lt;type 'str'&gt;, 10)&gt;&gt;&gt; print(type(str2), len(str2))(&lt;type 'unicode'&gt;, 8)&gt;&gt;&gt; print(type(str3), len(str3))(&lt;type 'unicode'&gt;, 8)&gt;&gt;&gt; 可以发现，str类型指代的是字节串，而经过 unicode 编码之后的才是字符串。所以要想 Python2 &amp;&amp; Python3 兼容必须指定其编码方式为 # -*- coding:utf-8 -*-。 [12] –&gt; Python 3 1234567891011&gt;&gt;&gt; str1 = 'Hello,中国'&gt;&gt;&gt; str2 = u'Hello,中国'&gt;&gt;&gt; str3 = str1.encode('gbk')&gt;&gt;&gt; &gt;&gt;&gt; print(type(str1), len(str1))&lt;class 'str'&gt; 8&gt;&gt;&gt; print(type(str2), len(str2))&lt;class 'str'&gt; 8&gt;&gt;&gt; print(type(str3), len(str3))&lt;class 'bytes'&gt; 10&gt;&gt;&gt; 可以发现，已经可以明确字符串和字节串了。 字符串编码转换结合上面我们提到过的解码编码，这一模块我们来看 Python 中的各种编码转换。 unicode 字符串可以与任意字符编码的字节进行相互转换，如图： [1] –&gt; Python2 首先，我们来简单看一下 Python2 中的字符串进行字符编码转换过程是： [字节串] –&gt; [decode(‘原来的字符编码’)] –&gt; [Unicode 字符串] –&gt; [encode(‘新的字符编码’)] –&gt; [字节串] 12345678# -*- coding:utf-8 -*- utf_8_str = '我要学中文'gbk_str = utf_8_str.decode('utf-8').encode('gbk')print(gbk_str.decode('gbk')) # 输出结果：我要学中文 [2] –&gt; Python3 而 Python3 中定义的字符串默认就是 unicode，因此不需要先解码，可以直接编码成新的字符编码： 1234567891011121314151617&gt;&gt;&gt; # -*- coding:utf-8 -*-&gt;&gt;&gt; utf_8_str = '我要学中文'&gt;&gt;&gt; gbk_str = utf_8_str.encode('gbk')&gt;&gt;&gt; print(gbk_str.decode('gbk'))# 输出结果：&gt;&gt;&gt; 我要学中文&gt;&gt;&gt; 'ABC'.encode('ascii')b'ABC'&gt;&gt;&gt; '中文'.encode('utf-8')b'\\xe4\\xb8\\xad\\xe6\\x96\\x87'# 中文编码的范围超过了 ASCII 编码的范围，报错&gt;&gt;&gt; '中文'.encode('ascii')Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;UnicodeEncodeError: 'ascii' codec can't encode characters in position 0-1: ordinal not in range(128) 深入解析一下字节串对于单个字符的编码，Python 提供了ord()函数获取字符的十进制整数表示，chr()函数把编码转换为对应的字符： 12345678&gt;&gt;&gt; ord('A')65&gt;&gt;&gt; ord('中')20013&gt;&gt;&gt; chr(66)'B'&gt;&gt;&gt; chr(25991)'文' 获取字符串的字符 unicode 形式的表示 &gt;&gt;&gt;&gt; encode(‘unicode-escape’)：可将此 str 编码为 bytes 类型, 内容则是 unicode 形式 decode(‘unicode-escape’)：可将内容为 unicode 形式的 bytes 类型转换为 str 12345&gt;&gt;&gt; str = &quot;中国&quot;&gt;&gt;&gt; str.encode(&quot;unicode_escape&quot;)b'\\\\u4e2d\\\\u56fd'&gt;&gt;&gt; b'\\\\u4e2d\\\\u56fd'.decode(&quot;unicode_escape&quot;)'中国' 知道了字符串中字符的 unicode 编码，这里我们给出一个等价写法： 123456&gt;&gt;&gt; str1 = &quot;中文&quot;&gt;&gt;&gt; str2 = &quot;\\u4e2d\\u6587&quot;&gt;&gt;&gt; print(str1 == str2)True&gt;&gt;&gt; print(type(str1), type(str2))&lt;class 'str'&gt; &lt;class 'str'&gt; 再来看一下解码 &gt;&gt;&gt;&gt; 123456&gt;&gt;&gt; b'ABC'.decode('ascii')'ABC'&gt;&gt;&gt; &quot;中文&quot;.encode('utf-8')b'\\xe4\\xb8\\xad\\xe6\\x96\\x87'&gt;&gt;&gt; b'\\xe4\\xb8\\xad\\xe6\\x96\\x87'.decode('utf-8')'中文' 如果bytes（字节串）中包含无法解码的字节，decode()方法会报错： 1234&gt;&gt;&gt; b'\\xe4\\xb8\\xad\\xff'.decode('utf-8')Traceback (most recent call last): ...UnicodeDecodeError: 'utf-8' codec can't decode byte 0xff in position 3: invalid start byte 如果bytes（字节串）中只有一小部分无效的字节，可以传入errors='ignore'忽略错误的字节： 12&gt;&gt;&gt; b'\\xe4\\xb8\\xad\\xff'.decode('utf-8', errors='ignore')'中' 可以看到，此时不再报错 UnicodeDecodeError，而是采用了忽略错误的做法。","link":"/2018/01/05/python-zi-fu-chuan-zhi-unicode-bian-ma/"},{"title":"Python 字符串之格式化输出","text":"Python 的字符串格式化传统有两种方式：％-formatting 方式以及 format 方式。除此之外，从 Python 3.6 开始映入了一种新的格式化方法：f-string，与传统格式化方法相比，f-string 不仅更易读，更简洁，不易出错，而且速度更快！本文将详解三种字符串格式化方法的用法。 % 格式符方法% 格式符 语法规则如下： %[(var-name)][flags][width][.precision]typecode 参数详解[1] &gt;&gt;&gt;&gt; (var-name) (var-name) 为命名参数，可选。用于指定 key，即用于变量映射(参数为字典) 。 [2] &gt;&gt;&gt;&gt; flags flags 为对齐方式以及数值符号设置参数，可选。可供选择的值有：+，-，空格或 0。 + ：右对齐；正数前加正好，负数前加负号； 空格：右对齐；正数前加空格，负数前加负号； 0：右对齐；正数前无符号，负数前加负号，用 0 填充空白处; -：左对齐；正数前无符号，负数前加负号。 [3] &gt;&gt;&gt;&gt; width width 为显示宽度设置参数，可选。 [4] &gt;&gt;&gt;&gt; .precision .precision 为小数点后精度设置参数，可选。 [5] &gt;&gt;&gt;&gt; typecode typecode 为类型码参数，必选。常用类型码如下： s：字符串 类型码 (采用 str() 的显示 )； r：字符串 类型码 (采用 repr() 的显示 )； d：十进制整数 类型码，将整数、浮点数转换成 十 进制表示； i：十进制整数 类型码，将整数、浮点数转换成 十 进制表示； o：八进制整数 类型码，将整数转换成 八 进制表示; x：十六进制整数 类型码，将整数转换成 十六 进制表示; e：指数 类型码(基底写为 e)，将整数、浮点数转换成 科学计数法； E：指数 类型码(基底写为 E)，将整数、浮点数转换成 科学计数法； f：浮点数 类型码，将整数、浮点数转换成 浮点数表示； F：浮点数 类型码，将整数、浮点数转换成 浮点数表示； g：指数或浮点数类型码，自动调整将整数、浮点数转换成 浮点型或科学计数法 表示，超过 6 位数用基底为 e 科学计数法；智能选择使用 %f 或 %e 格式； %%：字符 “%” 类型码。 测试样例[1] &gt;&gt;&gt;&gt; var-name 1234&gt;&gt;&gt; name = &quot;python&quot;&gt;&gt;&gt; age = 20&gt;&gt;&gt; print(&quot;%(name)s:%(age)d&quot; % {'name':name, 'age':age})python:20 [2] &gt;&gt;&gt;&gt; flags &amp;&amp; width 12345678910&gt;&gt;&gt; name = 'python'&gt;&gt;&gt; test = 1000&gt;&gt;&gt; print(&quot;%(name)s:%(number)+10d&quot; % {'name':name, 'number':test})python: +1000&gt;&gt;&gt; print(&quot;%(name)s:%(number)-10d&quot; % {'name':name, 'number':test})python:1000&gt;&gt;&gt; print(&quot;%(name)s:%(number) 10d&quot; % {'name':name, 'number':test})python: 1000&gt;&gt;&gt; print(&quot;%(name)s:%(number)010d&quot; % {'name':name, 'number':test})python:0000001000 [3] &gt;&gt;&gt;&gt; .precision 12345&gt;&gt;&gt; f = 123.321&gt;&gt;&gt; print(&quot;precision test: %(p)f&quot; % {'p':f})precision test: 123.321000&gt;&gt;&gt; print(&quot;precision test: %(p).2f&quot; % {'p':f})precision test: 123.32 [4] &gt;&gt;&gt;&gt; typecode 12345678910&gt;&gt;&gt; a,b,c = 'TheMusicIsLoud', 20, 12.3&gt;&gt;&gt; print(&quot;my name is: %s; age: %d; level: %+10.4f&quot; % (a,b,c))my name is: TheMusicIsLoud; age: 20; level: +12.3000&gt;&gt;&gt; print(&quot;my name is: %s; age: %d; level: %-10.4f&quot; % (a,b,c))my name is: TheMusicIsLoud; age: 20; level: 12.3000&gt;&gt;&gt; print(&quot;%05x&quot; % -12)-000c&gt;&gt;&gt; print(&quot;%05o&quot; % -12)-0014 缺点我们可以发现，一旦我们开始使用多个参数和更长的字符串，代码将很快变得不太容易阅读。事情已经开始显得有点凌乱： 1234567first_name = &quot;Eric&quot;last_name = &quot;Idle&quot;age = 27profession = &quot;Developer&quot;affiliation = &quot;Easy Python&quot;print((&quot;Hello, %s %s. You are %s. You are a %s. You are a member of %s.&quot; %(first_name, last_name, age, profession, affiliation))) 冗长，不能正确显示元组或字典都是它的缺点。 Format 方法Python 中除了上述我们介绍过的 % 格式化方法，还可以通过 {} 和 : 来代替以前的 % 完成格式化输出，增强了字符串格式化的功能。 format 格式符语法规则如下： [fill][align][sign][#][width][,][.precision][typecode] 参数详解[1] &gt;&gt;&gt;&gt; fill fill 为空白处可填充字符设置参数，可选。 [2] &gt;&gt;&gt;&gt; align align 为对齐方式设置参数，可选，需要配和 width 参数使用。 &lt;：内容左对齐； &gt;：内容右对齐(默认)； =：内容右对齐，将符号放置在填充字符的左侧，且只对数字类型有效。即，符号+填充物+数字。 ^：内容居中。 [3] &gt;&gt;&gt;&gt; sign sign 为有无符号数字设置参数，可选。 +：正号加正，负号加负； -：正号不变，负号加负； 空格：正号空格，负号加负。 [4] &gt;&gt;&gt;&gt; # # 为是否显示进制前缀设置参数，可选。对于二进制、八进制、十六进制，如果加上 #，会显示 0b/0o/0x，否则不显示。 [5] &gt;&gt;&gt;&gt; , , 为数字分割符设置参数，可选。如：1,000,000。 [6] &gt;&gt;&gt;&gt; width width 为显示宽度设置参数，可选。 [7] &gt;&gt;&gt;&gt; .precision .precision 为小数点后精度设置参数，可选。 8）typecode typecode 为类型码参数，可选（注意这里变为可选参数）。常用类型码如下： 空白：未指定类型，则默认是None，同 s； s：字符串 类型码 (采用 str() 的显示 )； r：字符串 类型码 (采用 repr() 的显示 )； d：十进制整数 类型码，将整数、浮点数转换成 十 进制表示； i：十进制整数 类型码，将整数、浮点数转换成 十 进制表示； o：八进制整数 类型码，将整数转换成 八 进制表示; x：十六进制整数 类型码，将整数转换成 十六 进制表示; e：指数 类型码(基底写为 e)，将整数、浮点数转换成 科学计数法； E：指数 类型码(基底写为 E)，将整数、浮点数转换成 科学计数法； f：浮点数 类型码，将整数、浮点数转换成 浮点数表示； F：浮点数 类型码，将整数、浮点数转换成 浮点数表示； g：指数或浮点数类型码，自动调整将整数、浮点数转换成 浮点型或科学计数法 表示，超过 6 位数用基底为 e 科学计数法；智能选择使用 %f 或 %e 格式； %：显示百分比（默认显示小数点后 6 位） 类型码。 测试样例 [1] &gt;&gt;&gt;&gt; fill &amp;&amp; align &amp;&amp; width 123456789&gt;&gt;&gt; s1 = &quot;{:*^20}&quot;.format('welcome')&gt;&gt;&gt; print(s1)******welcome*******&gt;&gt;&gt; s2 = &quot;{:*&gt;20s}&quot;.format('welcome')&gt;&gt;&gt; print(s2)*************welcome&gt;&gt;&gt; s3 = &quot;{:*&lt;20s}&quot;.format('welcome')&gt;&gt;&gt; print(s3)welcome************* [2] &gt;&gt;&gt;&gt; # 我们还可以通过引用其索引（或变量名称）来以任何顺序引用变量： 123456789&gt;&gt;&gt; a1 = &quot;numbers: {:b},{:o},{:d},{:x},{:X}, {:%},{:c}&quot;.format(16, 15, 14, 13, 12, 0.87623,99)&gt;&gt;&gt; a2 = &quot;numbers: {0:#b},{0:#o},{0:#d},{0:#x},{0:#X}, {0:%},{1:c}&quot;.format(15,99)&gt;&gt;&gt; a3 = &quot;numbers: {num:b},{num:o},{num:d},{num:x},{num:X}, {num:%},{cc:c}&quot;.format(num=15,cc=99)&gt;&gt;&gt; print(a1)numbers: 10000,17,14,d,C, 87.623000%,c&gt;&gt;&gt; print(a2)numbers: 0b1111,0o17,15,0xf,0XF, 1500.000000%,c&gt;&gt;&gt; print(a3)numbers: 1111,17,15,f,F, 1500.000000%,c [3] &gt;&gt;&gt;&gt; , &amp;&amp; .precision 123456&gt;&gt;&gt; s1 = '{:,d}'.format(100000000)&gt;&gt;&gt; s2 = '{:.2f}'.format(123.321)&gt;&gt;&gt; print(s1)100,000,000&gt;&gt;&gt; print(s2)123.32 [4] &gt;&gt;&gt;&gt; 常用格式化 123456789101112131415161718192021222324252627282930313233&gt;&gt;&gt; tp1 = &quot;i am {}, age {}, {}&quot;.format(&quot;seven&quot;, 18, 'alex')&gt;&gt;&gt; tp2 = &quot;i am {}, age {}, {}&quot;.format(*[&quot;seven&quot;, 18, 'alex'])&gt;&gt;&gt; tp3 = &quot;i am {0}, age {1}, really {0}&quot;.format(&quot;seven&quot;, 18)&gt;&gt;&gt; tp4 = &quot;i am {0}, age {1}, really {0}&quot;.format(*[&quot;seven&quot;, 18])&gt;&gt;&gt; tp5 = &quot;i am {name}, age {age}, really {name}&quot;.format(name=&quot;seven&quot;, age=18)&gt;&gt;&gt; tp6 = &quot;i am {name}, age {age}, really {name}&quot;.format(**{&quot;name&quot;: &quot;seven&quot;, &quot;age&quot;: 18})&gt;&gt;&gt; tp7 = &quot;i am {0[0]}, age {0[1]}, really {0[2]}&quot;.format([1, 2, 3], [11, 22, 33])&gt;&gt;&gt; tp8 = &quot;i am {:s}, age {:d}, money {:f}&quot;.format(&quot;seven&quot;, 18, 88888.1)&gt;&gt;&gt; tp9 = &quot;i am {:s}, age {:d}&quot;.format(*[&quot;seven&quot;, 18])&gt;&gt;&gt; tp10 = &quot;i am {name:s}, age {age:d}&quot;.format(name=&quot;seven&quot;, age=18)&gt;&gt;&gt; tp11 = &quot;i am {name:s}, age {age:d}&quot;.format(**{&quot;name&quot;: &quot;seven&quot;, &quot;age&quot;: 18})&gt;&gt;&gt; print(tp1)i am seven, age 18, alex&gt;&gt;&gt; print(tp2)i am seven, age 18, alex&gt;&gt;&gt; print(tp3)i am seven, age 18, really seven&gt;&gt;&gt; print(tp4)i am seven, age 18, really seven&gt;&gt;&gt; print(tp5)i am seven, age 18, really seven&gt;&gt;&gt; print(tp6)i am seven, age 18, really seven&gt;&gt;&gt; print(tp7)i am 1, age 2, really 3&gt;&gt;&gt; print(tp8)i am seven, age 18, money 88888.100000&gt;&gt;&gt; print(tp9)i am seven, age 18&gt;&gt;&gt; print(tp10)i am seven, age 18&gt;&gt;&gt; print(tp11)i am seven, age 18 缺点尽管一定程度上增强了 %-formatting 功能，但当我们开始使用多个参数和更长的字符串，还是具有冗长问题： 1234567first_name = &quot;Eric&quot;last_name = &quot;Idle&quot;age = 27profession = &quot;Developer&quot;affiliation = &quot;Easy Python&quot;print(&quot;Hello, {first_name}{last_name}. You are {age}. You are a {profession}. \\You were a member of {affiliation}.&quot;.format(first_name = first_name, last_name=last_name, age=age, profession=profession, affiliation=affiliation)) f-stringPython 自 Python 3.6 开始在标准库加入一种改进 Python 格式字符串的新方法：f-string。 f-string 在功能方面不逊于传统的：%-formating 和 format 方法，同时性能又优于二者，且使用起来也更加简洁明了。故，Python3.6 及以后的版本，推荐使用 f-string 进行字符串格式化 &lt;– 如何使用？。","link":"/2018/01/06/python-zi-fu-chuan-zhi-ge-shi-hua-shu-chu/"},{"title":"一文了解什么是 Java","text":"Java 是一门经典的面向对象编程语言，是基于 C++ 发展起来的，你可以将其看作是 C++ 的 “纯净” 版，它不仅吸收了 C++ 语言的各种优点，还摒弃了 C++ 中难以理解的指针等部分。再加上刚好赶上互联网的“顺风车”，随着 Internet 和 WWW 的迅速发展，Java 成为了越来越受欢迎的语言。尽管经历了近 30 年的技术变革，但 Java 仍然是当前开发基于 Web 的应用程序的最佳选择。 Java 起源及发展–&gt; Java 前身 起初（90 年代初），Sun Microsystems 公司为了开发一种用于编写 “家用电器的小型交互式系统” 的编程语言，如手机、机顶盒、面包机等。由于当时设备平台（硬件和操作系统）多样化，即需要该编程语言具有良好的跨平台能力，而且这些家用设备不足以运行大型程序（小内存），故开发了基于 C++ 的 Oak（橡树）语言。 –&gt; Java 的正式诞生 Oak 语言的诞生，就像 C/C++ 语言的诞生一样，开发者都寄予了很大的期望。但事实上，基于 Oak 语言所开发的智能化家电的市场需求远没有没有预期的那么高，不得以 Sun 公司放弃了该项计划。 绝境中往往孕育着机遇！90 年代随着互联网的迅猛发展，Sun 公司发现 Oak 在互联网上的应用前景，于是再一次做出尝试，改造了 Oak。 1995 年，Sun 公司正式发布了第一个 Java 版本，Java 正式诞生！！！ 2010 年 Oracle（甲骨文）公司收购 Sun Microsystems 公司，之后由 Oracle 公司负责 Java 的维护和版本升级。 随着互联网的迅速发展，定位于网络运算的 Java 语言，特别适合于开发网络应用程序，于是 Java “热” 迅速席卷全球。 Java 开篇Java 不仅仅是一门编程语言，还是一个平台。Java 平台由 Java 虚拟机（Java Virtual Machine，JVM）和 Java 应用编程接口（Application Programming Interface，API）构成。Java 应用编程接口提供了一套独立于操作系统的标准接口，可分为基本部分和扩展部分。 在硬件或操作系统平台上安装一个 Java 平台之后，Java 应用程序就可运行。Java 平台已经嵌入了几乎所有的操作系统，这样 Java 程序只编译一次，就可以在各种系统中运行。 JDK &amp; JRE为了编程人员开发和运行 Java 程序，Sun 公司免费推出了 Java 的开发、运行工具 —— JDK（Java Development Kit，Java 开发工具包）。 有时候，你可能会遇到如下说法： 1 –&gt; Java SDK 我们先来认识一下 SDK： SDK 说法：全称 Software Development Kit，即软件开发工具包，覆盖面很广泛的一个说法。可以这么说：辅助某一类软件开发的相关文档、范例和工具的集合都可以叫做 “SDK”，它为软件的开发提供一个平台。 JDK 是 Java 开发工具包，专为开发、运行 Java 设计而生，是 SDK 的一个子集。 所以，你可以说：JDK 是 Java SDK（Java Software Development Kit），这也没问题。 2 –&gt; Java 2 Java 1.2 版本之后发布的 Java 版本都可以称为：Java 2。 Java 5（Java 7/8/9）：Java 1.5（Java 1.7/1.8/1.9）版本。 所以，现在我们说的 Java，更多的是指 Java 2 平台。 3 –&gt; J2 SDK J2 SDK，全称 Java2 Software Development Kit，包含 JDK、JRE（Java Runtime Environment）等。 JRE：Java Runtime Environment，Java 运行环境，是运行 JAVA 程序所必须的环境的集合。 但要注意的是，JDK 中也包含一套单独的 JRE。 J2 SDK 一般特指 Java 2 平台的 JDK，开发人员必装，可进行 Java 程序的开发、运行。 J2 JRE 就是 Java 2 平台的 JRE，Java 客户端运行必装。如果你只需要运行 Java 程序，只需要安装 JRE 即可。 J2SE &amp; J2EE &amp; J2ME为了推广 Java，根据应用领域的不同，Java 可以分为 3 个体系： 1 –&gt; J2SE J2SE，也称为 Java SE（Java Platform Standard Edition，Java 平台标准版），它允许开发和部署在桌面、服务器、嵌入式环境和实时环境中使用的 Java 应用程序，是 Java 系统的标准与核心平台。 Java SE 包含了 Java 语言基础、JDBC 操作、I/O 操作、JavaSwing 以及多线程等技术，还提供了支持 Java Web 服务开发的类库。 Java SE 平台体系示意图如下： 2 –&gt; J2EE J2EE，也称为 Java EE（Java Platform Enterprise Edition，Java 平台企业版），帮助企业开发和部署可移植、健壮、可伸缩且安全的服务器端 B/S架构的 Java 应用程序。 Java EE 是在 Java SE 基础上构建的，个人理解就是在 J2SE 平台的基础上，添砖加瓦后出现的。它提供 Web 服务、组件模型、管理和通信 API等： servlet jsp spring mybatis … 3 –&gt; J2ME J2ME，也称为 （Java Platform Micro Edition，Java 平台微型版）， Java ME 为在移动设备和嵌入式设备（比如手机、PDA、电视机顶盒和打印机）上运行的应用程序提供一个健壮且灵活的环境。 ============================================== 关系图示： Java 特点Java 语言是一种分布式的面向对象语言，具有面向对象、平台无关性、简单性、解释执行、多线程、安全性等很多特点，下面针对这些特点进行逐一介绍。 面向对象Java 是一种纯面向对象的语言。使用 Java 语言开发程序，需要采用面向对象的思想设计程序和编写代码。 和 C++ 相比，Java 更加纯粹，所有内容都被封装到类中。 1 –&gt; 面向对象的核心： 以更接近人的思维去建立计算机逻辑，利用类和对象对数据和操作的分装到一起，并通过定义统一的接口去和 “外界” 交互，使反映实体的类在程序中能够独立、自治和继承 2 –&gt; 面向对象的程序设计： 从实际问题中抽象出封装了数据和操作的对象，定义其属性和操作，以及接口实现交互，形成一个接近于实际问题的动态对象模式。 简单易学Java 语言是基于 C++ 创建的，所以 Java 语言的风格很像 C/C++ 语言，但要比 C++ 更纯粹。 继承了 C++ 语言面向对象的技术核心，但是拋弃了 C++ 的一些缺点，比如说容易引起错误的指针、操作符重载以及多继承等，同时也增加了垃圾回收机制，释放掉不被使用的内存空间，解决了管理内存空间的烦恼。 基础语法同 C 语言几乎一模一样，便于学习。 平台无关性Java 提出 “Write Once，Run any Where”，即 “一次编写，到处运行”。 Java 编译后产生一种 二进制字节码文件，任何操作系统平台，只要安装有 Java 虚拟机都可以解释执行。并且 Java 中的原始数据存储都是固定的，如任何机器，int 都是 32 位。理所当然，使整数类型平台无关后性能必然下降，但这带来的跨平台特性是值得的。 Java 语言使用 Java 虚拟机机制屏蔽了具体平台的相关信息，使得 Java 语言编译的程序只需生成虚拟机上的目标代码，就可以在多种平台上不加修改地运行。 解释型语言Java 程序在 Java 平台运行时会被编译成字节码文件，在运行文件时，Java 的解释器对这些字节码进行解释执行。 看起来，逐条解释执行，导致单机运行很慢。但事实上，JVM 中采用了即时编译机制（JIT）可以很大程度上的优化，Java 的运行速度也越来越高。 多线程Java 语言是多线程的，但它必须由 Thread 类和它的子类来创建。Java 支持多个线程同时执行，并提供多线程之间的同步机制。 分布式Java 语言支持 Internet 应用的开发，在 Java 的基本应用编程接口中就有一个网络应用编程接口，它提供了网络应用编程的类库，包括 URL、URLConnection、Socket 等。Java 的 RIM 机制也是开发分布式应用的重要手段。 健壮性Java 的强类型机制、异常处理、垃圾回收机制等都是 Java 健壮性的重要保证。对指针的丢弃是 Java 的一大进步。另外，Java 的异常机制也是健壮性的一大体现。 安全性Java 通常被用在网络环境中，为此，Java 提供了一个安全机制以防止恶意代码的攻击。 除了 Java 语言具有许多的安全特性以外，Java 还对通过网络下载的类增加一个安全防范机制，分配不同的名字空间以防替代本地的同名类，并包含安全管理机制。 丰富的类库支持Java 中提供了丰富的类库支持，这些类库存放于 Java 系统的各种包（Package）中，有接口、类、异常处理等等 1 –&gt; java.lang Java 语言包，提供了包括字符串处理，多线程处理，数学函数处理等各种基础类。 2 –&gt; java.io Java 输入输出包，用统一的 “流” 模型来实现所有格式的输入、输出。通过数据流，序列化，文件系统提供系统输入输出。 3 –&gt; java.awt/javax.swing Java 图形用户接口包，提供实现不同平台的计算机图形用户接口部件，包括窗口，菜单，滚动条等等组件。 4 –&gt; java.sql Java 数据库包，提供了用户进行数据库操作的驱动程序和应用程序接口。 5 –&gt; java.util Java 应用程序工具包，支持哈希表，堆栈，可变数组，时间和日期，集合框架，事件模型和各种实用工具类（随机数生成器、位数组等等）。 6 –&gt; java.net Java 网络包，提供了实现网络编程的 URL，Socket 编程，还支持 Internet 的 ICP/IP 协议，提供了与 Internet 的接口。","link":"/2017/10/08/yi-wen-liao-jie-shi-me-shi-java/"},{"title":"Hello Hexo World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start如果你使用的是 Hexo Matery 主题的话，你可以参考系列博文： Hello, Hexo Matery World Create a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files12$ hexo clean$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment Begin To Edit Article博文编写分为两步： 设置博文的 Front-Matter 创作博文内容 Doc Front-Matter PolicyFront-matter is a block of YAML or JSON at the beginning of the file that is used to configure settings for your writings. Front-matter is terminated by three dashes when written in YAML or three semicolons when written in JSON. YAML 1234---title: Hello Worlddate: 2013/7/13 20:46:25--- JSON 123&quot;title&quot;: &quot;Hello World&quot;,&quot;date&quot;: &quot;2013/7/13 20:46:25&quot;;;; Front-matter 选项中的所有内容均为 非必填 的。推荐至少填写 title 和 date 的值。 Setting Description Default title Title Filename (posts only) date Published date File created date updated Updated date File updated date tags Tags (Not available for pages) categories Categories (Not available for pages) toc Article Contents false 以下为文章的 Front-matter 示例。 The Simple Demo1234---title: Hello Hexodate: 2017-12-18 00:55:00--- The Most Complete Demo1234567---title: Hello, Hexo Worlddate: 2017-12-18 00:55:00categories: [Markdown, Hexo]tags: [Markdown, Hexo]toc: true--- 学会 Front-Matter Policy 之后，你就可以开始正式的创作了~~~","link":"/2017/09/20/hello-world/"},{"title":"为什么 0.1 + 0.2 不等于 0.3 ?","text":"十进制小数在高级程序设计语言中属于浮点类型数据，既然十进制小数存储到内存中有误差，所以计算机中的浮点型数值的计算是不精确的，这种问题 对于所有支持浮点数运算的编程语言都是存在的。 先看两个简单但诡异的代码： 120.1 + 0.2 &gt; 0.3 // true0.1 * 0.1 = 0.010000000000000002 0.1 加 0.2 为什么就不等于 0.3 昵？要回答这个问题，得先了解计算机内部是如何表示数的。 内存中数的存储我们知道，计算机中任何类型的数据，其本质是以二进制的形式存储的。 [1] –&gt; 计算机内部如何表示整数 这里以十进制数 13 来展示 “按位计数法” 如何表示整数： 十进制值 进制 按位格式 描述 13 10 13 1x10^1 + 3x10^0 = 10 + 3 13 2 1101 1x2^3 + 1x2^2 + 0x2^1 + 1x2^0 = 8 + 4 + 0 + 1 [2] –&gt; 计算机内部如何表示小数 再来看，十进制小数 0.625 怎么用 “按位计数法” 表示： 十进制值 进制 按位格式 描述 0.625 10 0.65 6x10^-1 + 2x10^-2 + 5x10^-3 = 0.6 + 0.02 + 0.005 0.65 2 0.101 1x2^-1 + 0 x2^-2 + 1x2^-3 = 1/2 + 0 + 1/8 [3] –&gt; 如何用二进制表示 0.1 最终回归到本篇开头的样例，先来看如何用二进制表示 0.1 ？？？ 我们知道，十进制整数转二进制方法：除 2 取余，逆序排列；十进制小数转二进制方法：乘 2 取整，顺序排列。 十进制 0.1 转换成二进制，乘 2 取整过程： 123456780.1 * 2 = 0.2 # 00.2 * 2 = 0.4 # 00.4 * 2 = 0.8 # 00.8 * 2 = 1.6 # 10.6 * 2 = 1.2 # 10.2 * 2 = 0.4 # 0..... 从上面可以看出，0.1 的二进制格式是：0.000110011.... 。这是一个二进制无限循环小数，但计算机内存有限，我们不能用储存所有的小数位数。 也就是说 &gt;&gt;&gt;&gt; 将十进制小数转化为其它进制小数时，存在无限问题。 &gt;&gt;&gt;&gt; 那么在精度与内存间如何取舍呢？ 答案是：在某个精度点直接舍弃。 当然，代价就是，0.1 在计算机内部根本就不是精确的 0.1，而是一个有舍入误差的 0.1。当代码被编译或解释后，0.1 已经被四舍五入成一个与之很接近的计算机内部数字，以至于 计算还没开始，一个很小的舍入错误就已经产生了，并且这种误差会在后续的计算过程中不断累计。 这也就是 0.1 + 0.2 不等于 0.3 的根本原因。 有误差的两个数，其计算的结果，很可能 与我们期望的不一样了。 注意前面的这句话中的 “很可能” 这三个字？为啥是很可能昵？ 0.1 + 0.1 为什么等于 0.2 ?答案是：两个有舍入误差的值在求和时，相互抵消了，但这种“负负得正，相互抵消”不一定是可靠的，当这两个数字是用不同长度数位来表示的浮点数时，舍入误差可能不会相互抵消。 又如，对于 0.1 + 0.3 ，结果其实并不是 0.4，但 0.4 是最接近真实结果的数，比其它任何浮点数都更接近。许多语言也就直接显示结果为 0.4 了，而不展示一个浮点数的真实结果了。 另外要注意，二进制能精确地表示位数有限且分母是 2 的倍数的小数。比如 0.5（0.25、0.625…），0.5 在计算机内部就没有舍入误差。所以 0.5 + 0.5 === 1。 胡乱舍入，能满足所有的计算需求吗我们看两个现实的场景： 对于一个修建铁路的工程师而言，10 米宽，还是 10.0001 米宽并没有什么不同。铁路工程师就不需要这么高 0.x 这样的精度； 对于芯片设计师，0.0001 米就会是一个巨大不同，他也永远不用处理超过 0.1 米距离。 不同行业，要求的精度不是线性的，我们允许（对结果无关紧要的）误差存在。 10.0001 与 10.001 在铁路工程师看来都是合格的。 虽然允许误差存在，但在使用浮点数进行计算或逻辑处理时，不注意，就可能出问题。记住，永远不要直接比较两个浮点的大小。","link":"/2016/07/29/wei-shi-me-0-1-0-2-bu-deng-yu-0-3/"},{"title":"打造沉浸式写作体验，你需要试试 Markdown + Editor","text":"Markdown，一款轻量级的，可以使用普通文本编辑器编写的标记语言，打造沉浸式写作新体验。 Markdown + Editor「Action &gt;&gt;&gt; 夜深人静，房间的门紧闭着，灯也关着。 屏幕发出的亮光隐约勾勒出坐在电脑前码字的你的轮廓。 你脑海中的思绪畅游，无数想法在飞舞，但输出过程却不像脑中的思考那么流畅。 为了打磨用词和造句，你的手不断的从键盘移到鼠标上，只为把光标移到合适的位置。为了快速的调整样式，你虽然记住一些快捷键，但发现依然要先用鼠标选中。 不要小瞧了这看似短暂频繁的切换，稍纵即逝的想法可不会因为你的输出的节奏的中断而停留。 沉浸式写作 的前提，可 不是只要有个安静不受打扰的环境就够了，你还需要让输出的速度跟上你思考的速度。 如果你刻意练习过盲打，那么你会知道提高打字速度的首要条件就是保证打字姿势的稳定，手要保持在键盘上，尽量减少手的移动范围。 可问题是，在写作过程中，如何才能在保持手在键盘上，却依旧能准确的移动光标、调整样式呢？ 答：忘记鼠标，只用键盘就好。 …… 哎哎哎，千万别走，不是在逗你。 相信我，你只需要一个简单的文本编辑器（YOU WANT），再熟练掌握一把“利刃”——Markdown Syntax，就可以开启新世界的大门。 Markdown 初识Markdown 是一种轻量级的，可以使用 普通文本编辑器编写 的标记语言。它允许所有的写作爱好者（Sharer）可以专注于内容而不是纠结于字体字号行间距等等排版问题（沉浸式写作），使用易读易写的纯文本格式编写文档，然后就可以转化成格式丰富优美的 HTML 页面或 PDF（所思即所得）。你唯一要付出的代价就是掌握极其 简单的标记语法。 眼尖尖的同学已经发现：普通文本编辑器编写！？对，你看的没错，只要你手头有 任意一款文本编辑器，参照后文中 「Markdown Function Demo」标记语法，就可以开始使用 Markdown “随心所欲”了。 敲黑板！！！是不有“急躁”的看官已经默默打开 Windows 自带的记事本准备开始尝试了…？ 初学者警告！！！ 初学 MarkDown 的人，最开始可能会用 Windows 自带的记事本进行编辑，然后baidu，balabala….在线转成 HTML 或 PDF，用自带的浏览器打开查看效果。这种方式是最绿色的不依靠任何其他软件，就可以完成一份高质量的排版，但…实在是太累了。 Windows 自带的记事本没有 MD 语法提醒功能，也没有语法高亮功能，还无法 实时预览 效果，对初学者很不友好。往往边写作的同时还要百度语法，这就失去了用 MarkDown 快速办公的意义了（相信看客老爷们愤怒了，你不是说任何普通编辑器就可以编写了！！！前提是你得使用灰常熟练啊~人艰不拆…）。 事实上，更多使用的文本编辑器是： –&gt; 1 Markdown 在线编辑器，推荐一种：MdEditor； –&gt; 2 专门支持用来写 Markdown 的编辑器：MarkdownPad、Typora 等等。 对于新手，选择一款顺手的 Markdown 编辑器是刚需啊… MarkDown 编辑器推荐MarkdownPad2很多初学者的第一选择，支持多操作系统平台，UI 简洁，使用流畅，功能全面，但需要升级到 Pro 版本后（付费升级，可破解）才可解锁所有功能。主要特点：左右分屏实时预览（F5），可自定义添加各种 CSS 样式渲染。 关于 MarkdownPad2 安装以及常见问题解决见: 传送门 –&gt; MarkdownPad2 安装以及常见问题解决教程 。 缺点也很明显，软件 UI 一般般，更重要的是，安装后可能存在一些 Bug，如公式不能正常显示…，需要自行 baidu 解决。 Typora推荐，同样支持多平台（OS X， Windows 和 Linux），UI 界面美观，官网的首页如下： Typora 抛弃了传统的交互模式，它只使用一个窗口，却能优雅地实现同时将代码编辑与预览结合起来！从而为用户带来更加流畅直观的，所见即所得的 Markdown 写作体验。毕竟，对于刚接触 MarkDown 的新手来说，实时预览的功能真的太重要了。 Typora 安装过程很简单，一路 「Next」 即可。 Atom开源世界的巨人，全世界最大的，开源平台，GitHub 出品的编辑器 Atom，也是很多人选择使用的。 和 Typora 不同的是，Atom 并不只是用来写 MarkDown，通过丰富的插件机制支持 CSS，HTML，JavaScript 等各种网页编程语言，常用于 WEB 开发, 也可用于 PHP 等后端开发。 个人建议，可以和 Typora 二选其一（博主没有使用过 Atom，捂脸~）。 事实上，光日常学习和使用有上面几款编辑器已经可以满足你的需要了。 VS Code真正的编辑器神器，强烈安利！ 本人最常用的一款开源的文本编辑器编辑器（Atom 表示很悲伤），不仅用它写 MarkDown 文档，还可以通过丰富的插件机制用它写 Python、C/C++、Java 等等，几乎支持所有的语言。 你只需要下载它，安上 Markdown Preview Enhanced 插件就可以薅微软爸爸的羊毛了。界面效果图如下： 对于使用，篇幅原因，这里不进行详细的赘述。如果你想要详细了解 VS Code 的更多使用方法，可以关注我的相关系列博文。 Markdown 编辑器选择好之后，你就可以开始学习 Markdown 标记语法了： Markdown Function Demo标题演示一级标题：H1 语法规则： # 标题H1 MarkdownPad 中快捷键：Ctrl + 1 二级标题：H2 语法规则： ## 标题H2 MarkdownPad 中快捷键：Ctrl + 2 三级标题：H3 语法规则： ### 标题H3 MarkdownPad 中快捷键：Ctrl + 3 四级标题：H4 语法规则： #### 标题H4 MarkdownPad 中快捷键：Ctrl + 4 五级标题：H5 语法规则： ##### 标题H5 六级标题：H6 语法规则： ##### 标题H6 字符效果和横线演示删除线语法规则： &lt;s&gt;删除内容&lt;/s&gt; 显示效果： 删除内容 斜体字语法规则：*斜体字* &amp;&amp; _斜体字_ 显示效果： 斜体字 &amp;&amp; 斜体字 粗体法规则： **粗体** &amp;&amp; __粗体__ 显示效果： 粗体 &amp;&amp; 粗体 斜粗体语法规则： ***粗斜体*** &amp;&amp; ___粗斜体___ 显示效果： 粗斜体 &amp;&amp; 粗斜体 上下标语法规则：X&lt;sub&gt;2&lt;/sub&gt;, O&lt;sup&gt;2&lt;/sup&gt; 下标：X2，上标：O2 缩写缩写功能，同 HTML 的 &lt;abbr&gt; 标签 即更长的单词或短语的缩写形式，前提是开启识别 HTML 标签，默认已开启。 语法规则： The &lt;abbr title=&quot;Hyper Text Markup Language&quot;&gt;HTML&lt;/abbr&gt; specification is maintained by the &lt;abbr title=&quot;World Wide Web Consortium&quot;&gt;W3C&lt;/abbr&gt;. 显示效果如下： The HTML specification is maintained by the W3C. 分割线 语法规则： --- 字体颜色 语法规则: &lt;font color=blue/red/yellow...&gt; Text &lt;/font&gt; 显示效果： 此处文本为蓝色 此处文本为红色 引用 Blockquotes 文本引用 Blockquotes 引用的行内混合 Blockquotes 规则: &gt; 引用内换行使用&lt;br /&gt;标签，此处换行–&gt;这里为下一行引用文本。 锚点与链接 Links这是一个普通链接 语法规则： [这是一个普通链接](https://www.baidu.com/) 语法规则： [这是一个带标题的普通链接（光标移到此处显示标题）](https://www.baidu.com/ &quot;百度一下&quot;) 这是一个直接链接：https://www.baidu.com 语法规则： 这是一个直接链接：&lt;https://www.baidu.com&gt; 多语言代码高亮 Codes行内代码1Ctrl + k 或者 Tab 或者 ``` ``` 预格式化文本缩进后可用于格式化文本，正常以下内容会显示一个表格（可见下文绘制表格部分：3.8）： 1234| First Header | Second Header || ------------- | ------------- || Content Cell | Content Cell || Content Cell | Content Cell | JS 代码12345​```javascriptfunction test() { console.log(&quot;Hello world!&quot;);}​``` 显示效果如下： 123function test() { console.log(&quot;Hello world!&quot;);} HTML 代码12345678910111213141516171819​```html&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;mate charest=&quot;utf-8&quot; /&gt; &lt;meta name=&quot;keywords&quot; content=&quot;Editor.md, Markdown, Editor&quot; /&gt; &lt;title&gt;Hello world!&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; body{font-size:14px;color:#444;font-family: &quot;Microsoft Yahei&quot;, Tahoma, &quot;Hiragino Sans GB&quot;, Arial;background:#fff;} ul{list-style: none;} img{border:none;vertical-align: middle;} &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1 class=&quot;text-xxl&quot;&gt;Hello world!&lt;/h1&gt; &lt;p class=&quot;text-green&quot;&gt;Plain text&lt;/p&gt; &lt;/body&gt;&lt;/html&gt;​``` 显示效果如下： 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;mate charest=&quot;utf-8&quot; /&gt; &lt;meta name=&quot;keywords&quot; content=&quot;Editor.md, Markdown, Editor&quot; /&gt; &lt;title&gt;Hello world!&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; body{font-size:14px;color:#444;font-family: &quot;Microsoft Yahei&quot;, Tahoma, &quot;Hiragino Sans GB&quot;, Arial;background:#fff;} ul{list-style: none;} img{border:none;vertical-align: middle;} &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1 class=&quot;text-xxl&quot;&gt;Hello world!&lt;/h1&gt; &lt;p class=&quot;text-green&quot;&gt;Plain text&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 图片链接 语法规则： ![](https://www.mdeditor.com/images/logos/markdown.png)](https://markdownpad.com &quot;markdown&quot;) 可以发现，我们只是把链接中的文本替换为图片，就创建了一个图片链接。 如何 插入图片： 语法规则： ![](https://www.mdeditor.com/images/logos/markdown.png) 插入图片效果如下： Follow your heart. 如何实现 图像居中 呢？！！ 语法规则： &lt;div align=center&gt; &lt;img src='url'&gt; &lt;/div&gt; 图片居中效果如下： 列表 Lists无序列表（减号）Unordered Lists (-)- 列表一 - 列表二 - 列表三 显示效果如下： 列表一 列表二 列表三 无序列表（星号）Unordered Lists (*)* 列表一 * 列表二 * 列表三 显示效果如下： 列表一 列表二 列表三 无序列表（加号和嵌套）Unordered Lists (+)多级列表注意缩进（2 空格），显示效果如下： 列表一 列表二 列表二-1 列表二-2 列表三 列表三-1 列表三-2 有序列表 Ordered Lists 第一行 第二行 第三行 绘制表格 Tables语法规则： 默认标题栏居中对齐，内容居左对齐。 -: 表示内容和标题栏居右对齐，:- 表示内容和标题栏居左对齐，:-: 表示内容和标题栏居中对齐。 内容和 | 之间的多余空格会被忽略，每行第一个 | 和最后一个 | 可以省略，- 的数量至少有一个。 | First Header | Second Header | | ------------ | ------------- | | Content Cell | Content Cell | | Content Cell | Content Cell | 显示效果如下： First Header Second Header Content Cell Content Cell Content Cell Content Cell 去练习如下样式： 表一 –&gt; Function name Description help() Display the help window. destroy() Destroy your computer! 表二 –&gt; Left-Aligned Center Aligned Right Aligned col 3 is some wordy text $1600 col 2 is centered $12 zebra stripes are neat $1 表三 –&gt; Item Value Computer $1600 Phone $12 Pipe $1 特殊符号 HTML Entities Codes &amp;copy; &amp; &amp;trade; &amp;iexcl; &amp;pound; &amp; &trade; &iexcl; &pound; &amp;amp; &amp;lt; &amp;gt; &amp;yen; &amp;euro; &amp;reg; &amp;plusmn; &amp;para; &amp;sect; &amp;brvbar; &amp;macr; &amp;laquo; &amp;middot; &amp; &lt; &gt; &yen; &euro; &reg; &plusmn; &para; &sect; &brvbar; &macr; &laquo; &middot; X&amp;sup2; Y&amp;sup3; &amp;frac34; &amp;frac14; &amp;times; &amp;divide; &amp;raquo; X&sup2; Y&sup3; &frac34; &frac14; &times; &divide; &raquo; 18&amp;ordm;C &amp;quot; &amp;apos; 18&ordm;C &quot; &apos; 科学公式 MathJaxMarkdown 文档中引入 MathJax 标签就可以正常显示了，标签内容如下： &lt;script type=&quot;text/javascript&quot; src=&quot;http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&quot;&gt;&lt;/script&gt; 然后你会发现，博文中插入的公式已可以正常显示了： $$ x = {-b \\pm \\sqrt{b^2-4ac} \\over 2a} $$","link":"/2017/09/20/da-zao-chen-jin-shi-xie-zuo-ti-yan-ni-xu-yao-shi-shi-markdown-editor/"},{"title":"基于图床的博客图片存储解决方案","text":"一个优秀的博客图片存储解决方案—图床。 更多 Hexo 博客框架内容，请关注博主 Hexo 博文系列： 一文学会 Hexo 轻量级框架的博客搭建【持续更新】 Hexo 预安装环境部署之 Node.js Git 使用指南之初识 打造沉浸式写作体验，你需要试试-Markdown-Editor 基于图床的博客图片存储解决方案 稳定快速、高效免费的图床方案-Github-jsDelivr-PicGo Hexo 博客多设备协同管理问题【持续更新】 Pictures use in hexo当你看到这里的时候，应该已经有一个自己的 Hexo 博客了。如果还没有的话，不妨使用 Hexo 和 Markdown 来写博客和文章。 在 Hexo 使用初期，你可能也遇到过和我相似的问题： 一篇添加了本地图片的博文在你的个人博客站点无法预览显示出来。 考虑一下：为什么博客站点中的本地图片无法正常加载显示？ 事实上，这个很好理解，图片是无法直接作为 MD 文本源码的一部分插入的，只能插入图片的地址，这个地址可以是相对 MD 文件的相对路径，也可以是网络图片地址（网络图片事实上也是不可靠的，毕竟来源是第三方的，当网络图片来源被删除时也会丢失，所以很多使用网络图片的博客一段时间后就会发生图像无法显示、缺失）。 这里我们来考虑插入电脑本地图片的场景，Markdown 文档中指定的图片路径就是自己本地的路径，博客站点当然链接不到自己本地的图片了。 这里，我们先来分享一种基本的解决此问题的方法。使用 hexo-asset-image 插件来为博客插入图片： 插件下载在 Git Bash 中，进入 Hexo 站点目录下执行如下命令： 1$ npm install https://github.com/CodeFalling/hexo-asset-image --save Hexo 配置在 Hexo 站点配置文件中，搜索 post_asset_folder 关键字，并将其值设为：true： 1post_asset_folder: true 下载以及设置完成后，当你通过 hexo new “Blog Name” 新建博客后，会在 &lt;Hexo 站点目录&gt;\\source_posts 文件夹下产生一个和博文同名的文件夹（这个和博文同名文件夹可以作为当前博文的图集，远程推送时会被一起推送到远程库中）。 Demo设置后如何进行图像的插入呢？ 当博文需要添加图片时，将需要添加的图片放入和博文同名的文件夹中，同时通过【相对路径】索引到该图片即可。 例如，你想要在博文 post_name.md 中想要插入了一张图片（test.jpg）。首先你需要将图片资源放在同名文件夹 post_name 中，然后使用相对路径就可以引用到图片资源： 1![](test.jpg) 添加后你可以使用 hexo s 开启本地 Hexo 服务预览一下，发现已经可以正常显示图片了~ ========================================== 事实上，这样的使用是存在问题的： 当添加的图片比较多、比较大时，除了自己本地的博客源文件比较臃肿外，还会占用大量本地空间。再加上 Github 仓库的使用，会使得网站部署时非常的慢（推送图集）； 博客中所有的图片都是要部署到仓库的，而仓库容量是受限的，你懂得； 博文中存在大量图片时，会大大降低网页的加载速度，加载的难受啊； 哪里都有玄学….咳咳，之前的博客采用这种方法，不知道什么时候竟然丢失了一部分图片。 ┓( ´∀` )┏ 怎么办？幸好有度娘啊… 一个广泛使用的，优秀的博客图片存储解决方案 —— 图床。 Image HostImage Host（Picture Host），也称为图床。图床？！！ 何为图床？图床是指 用于储存图片，并且可以对外提供图片访问链接 的服务器。 服务器？！！难道博主又要骗我花钱买服务器拉？┓( ´∀` )┏ 事实上，有很多免费的图床可供你选择。国内和国外都有，国外的图床可能由于有空间距离等因素决定访问速度很慢影响图片显示速度（但可以通过 CDN 技术实现加速）。国内很多大中小型公司都提供免费的图床服务，注册后就可以使用（真香）。 事实上，图床的本质就是： 将图片保存在网络上，并且可以获得图片的直链地址。 爱思考的看客老爷可能已经反应过来了： 这不就是博主前面说的网络图片链接么？你不是说不可靠么？！不要担心，前面我们使用的网络图片其实是其他人提供的图床。这当然是不可靠的，毕竟你不知道什么时候这些图床就不再提供了！之后我们使用的都是自己的图床，这是可控的。 了解了图床的基本概念之后，我们再来看一下图床都有哪些优点： 图床的优点1 –&gt; 图床访问速度快 图床，一般会把图片存储到第三方的 CDN，除了加快图片访问速速，还可以降低你服务器的存储压力，后续网站迁移扩容就不受影响了。 2 –&gt; 博客前瞻性 目前，你可能只是在部署一个个人博客小网站，但是以后无论是自己的博客还是实际的项目，都可以用图片来提供外链，方便管理。 并且如果你的网站访问量很高啊，一天几十万几百万啊，这时候你考虑的就不是服务器空间够不够大，而是惊人的并发数啊，光是请求 HTML 文件（或其他）的链接就处理不过来了，哪还有多余的资源去读取图片啊，索性就把图片存另一个服务器，为主服务器缓解压力。 大致了解了图床的基本概念以及其优点，这里我们来看当前个人博客有哪些具体的图床实施方案？ 图床实施方案说到这里，图床原来就是图片网络链接啊。可能一些爱动手的看客老爷可能已经开始思绪乱飞~ 下面我们来看如何将图片保存在网络上且获得图片的链接地址方案，看客老爷可以根据个人实际情况进行选择： 网盘很多看客老爷可能想到，如果直接把图片放到各类网盘（百度、腾讯、坚果、OneDrive…）是否可行？ 事实上，虽然网盘上传图片方便快捷，免费存储空间又足够，但是网盘中的图片无法获取到链接，或者获取到链接后很快就无法使用了。 直接 Pass…. 自建图床服务器关于自建图床服务器，如果你有一台可供使用的个人服务器，可以尝试使用FTP、Nginx、PHP、MySQL、Chevereto等工具搭建个人图床服务器。 缺点就是，你需要支出必要的服务器等费用，还需要去进行相对繁琐的安装过程才可以使用。 关于自建图床服务器方法，网络上的教程很多。当然你也可关注博主相关系列博客 –&gt; 传送门（未完成，待续…）。 云存储对象腾讯云、阿里云、等云平台都提供有云储存对象支持，可以用作图床使用，配置过程也非常简单快捷。 但是缺点是，虽有免费额度，但使用量较大时，可能产生相关存储流量费用。但贵在对于访问量较少的个人博客使用很便宜甚至免费，具体收费情况可见各云平台。 特别说明，云存储对象的使用可能涉及到实名认证，域名备案等过程。 关于使用云存储对象配置图床，请参见博主相关系列博客 –&gt; 传送门（未完成，待续…）。 第三方免费图床(推荐)上面我们说过，国内外有很多免费的图床可供使用。 在选择一款免费图床平台时，你需要关注的是，图床平台服务商是否可靠，图床的流量限制、储存限制以及访问速度等。 例如：免费存储容量为10G，每月访问流量10G，每小时限制上传 20 张，每张大小小于 10M 之类的，但这对于写MD 远远够了。当然这些第三方服务商也是提供相关的收费服务的，你可以消费提升使用权限。 特别说明，一定要选择相对大平台的服务商，主要是怕图床服务商经营惨淡，挂掉以后图片就丢失了。并且有些第三方免费图床会要求进行实名认证，域名备案等。 网络上各路 主流图床推荐： 1 –&gt; 微博图床 你在查找时，很有可能查到使用微博做为博客图床的教程。 这里特别说明一下，微博图床之前使用人较多，但从2019年开始开启了防盗链，直接凉凉了…. 2 –&gt;七牛云 官网地址：https://portal.qiniu.com 简介：注册认证后有 10G 永久免费空间，每月 10G 国内和 10G 国外流量，速度相当快，七牛云是国内专业 CDN 服务商，插件支持比较多，有免费 SSL 证书，但 HTTPS 流量收费。 图片上传限制：暂无 七牛云 30 天后会回收测试域名，因此你必须要实名认证以及绑定自己的已经备案的域名。 3 –&gt;又拍云 官网地址：https://www.upyun.com 简介：注册认证后有10G永久免费空间，每月 15G 的 HTTP 和 HTTPS 流量，提供两款可以免费续期的 SSL 证书，不过用户需要加入又拍云联盟（即在网站底部添加又拍云 LOGO 及官网链接）。 图片上传限制：暂无 需要实名认证以及绑定自己的已备案域名，又拍云认证比较麻烦，建议使用七牛云。 4 –&gt;路过图床 官网地址：https://imgchr.com 简介：支持免注册上传图片，永久存储，支持 HTTPS 加密访问和调用图片，提供多种图片链接格式。 图片上传限制：最大10M 5 –&gt;SM.MS 官网地址：https://sm.ms 简介：永久存储免注册，图片链接支持 HTTPS，可以删除上传的图片，提供多种图片链接格式，有时速度可能较慢。 图片上传限制：每个图片最大 5M，每次最多上传 10 张 ================================================== 墙裂推荐： 如果想要长期稳定使用，请优先选择七牛云或者又拍云（需要实名认证以及已备案域名），再下来就是路过图床和 SM.MS 图床。 图床配套工具选择好图床之后，你可以选择搭配以下图床工具一起使用以便更高效地使用图床： 图片压缩工具上传图片之前建议压缩一下，一方面可以降低存储，又可以有效加快图片载入速度： TinyPNG –&gt; 传送门 Tiomg –&gt; 传送门 图床工具使用图床工具可以方便我们快速将本地图片转换成图床链接，以方便各位博主使用： PicGo（Molunerfinn/PicGo），是一款比较优秀的图床工具，可以支持微博，七牛云，腾讯云 COS，又拍云，GitHub，阿里云 OSS，SM.MS，imgur 等八种常用图床。且功能强大，简单易用。 关于 PicGo 的安装以及配置方法，请参见博主相关系列博客 –&gt; 传送门。 这里，由于篇幅原因，不做赘述。关于博客中图床方案的具体应用参加博文系列：稳定快速、高效免费的图床解决方案-Github-jsDelivr-PicGo","link":"/2017/09/21/ji-yu-tu-chuang-de-bo-ke-tu-pian-cun-chu-jie-jue-fang-an/"},{"title":"稳定快速、高效免费的图床解决方案-Github-jsDelivr-PicGo","text":"一种稳定快速、高效免费的图床解决方案 —— Github + jsDelivr + PicGo。 更多 Hexo 博客框架内容，请关注博主 Hexo 博文系列： 一文学会 Hexo 轻量级框架的博客搭建【持续更新】 Hexo 预安装环境部署之 Node.js Git 使用指南之初识 打造沉浸式写作体验，你需要试试-Markdown-Editor 基于图床的博客图片存储解决方案 稳定快速、高效免费的图床方案-Github-jsDelivr-PicGo Hexo 博客多设备协同管理问题【持续更新】 Introduction先来对比一下之前博文我们给出的图床解决方案: 自建图床服务器：需要支出必要的服务器等费用，还需要去进行相对繁琐的安装过程才可以使用； 云存储对象：有免费额度，但使用量较大时，可能产生相关存储流量费用，并且需要进行实名认证，域名备案等； 第三方免费图床：流量、储存、图片上传受限，国内大平台图床服务商需要进行实名认证，域名备案等； 其它小众图床：不可靠，随时有挂掉的风险。 使用过 Github 的看官肯定知道，Github 的 Repo 也可以储存东西，最直接的就是程序的版本控制，当然也可以用来当作备份储存。关于存储，Github 官方回复是：该行为不构成 Abuse（滥用）。 因此，GitHub 作为图床是个不错的选择，利用 jsDelivr CDN 加速访问（jsDelivr 是一个免费开源的 CDN 解决方案），PicGo 工具一键上传，操作简单高效。 并且 GitHub 和 jsDelivr 都是大厂，不用担心跑路问题，速度和容量问题都得以解决，而且完全免费，可以说是目前免费图床的较佳的一种解决方案！ 下面我们来看解决方案的具体实施： New Github Repo登录/注册 GitHub，新建一个仓库。填写好仓库名（HexoImageBed0），仓库描述(Hexo Image Host Repo)，仓库必须设为：public 的，根据需求选择是否为仓库初始化一个 README.md 描述文件: 填好仓库信息后，点击【Create Repository】即可完成 Repo 的创建。 生成一个 Token在主页选择【Settings】： Next –&gt; 点击【Developer settings】: Next –&gt; 依此点击【Personal access tokens】–&gt;【Generate new token】: 进入如下界面： 填写好描述，勾选【repo】，然后点击【Generate token】生成一个如图所示的 Token： 注意：请勿关闭当前页面，这个 Token 只会显示一次，自己先截图保存下来。或者等后面配置好 PicGo 后再关闭此网页。 PicGoPicGo，一款比较优秀的图床工具。 所谓图床工具，就是自动把本地图片转换成链接，以精简用户繁杂的图床上传、下载过程的一款工具，网络上有很多免费图床工具可供使用。 PicGo 可以支持微博，七牛云，腾讯云 COS，又拍云，GitHub，阿里云 OSS，SM.MS，Imgur 等八种常用图床，功能强大，简单易用。 PicGo Setup首先，你可以从这里提供的 PicGo 下载链接地址 下载 PicGo下载到最新的 PicGo。下载好后界面如下所示： PicGo 配置安装好后就可以开始配置 Github 图床了: 具体步骤为：【图床设置】–&gt; 【GitHub图床】，配置界面如下： ============================================== 配置内容详解： 设定仓库名：按照【用户名 / 图床仓库名】的格式填写； 设定分支名：【master】； 设定 Token：粘贴之前生成的【Token】； 指定存储路径：填写想要储存的路径，如【Img/】，这样就会在仓库下创建一个名为 Img 的文件夹，图片将会储存在此文件夹中； 设定自定义域名：在图片上传后，PicGo会按照【自定义域名+储存路径+上传的图片名】的方式生成访问链接。这里由于我们要使用 jsDelivr 加速访问，所以可以设置为【https://cdn.jsdelivr.net/gh/用户名/图床仓库名 】。使用时，我们就可以通过【https://cdn.jsdelivr.net/gh/用户名/图床仓库名/图片路径】加速访问我们的图片了。 About CDN百度百科：CDN 的全称是 Content Delivery Network，即内容分发网络。 CDN 是构建在网络之上的内容分发网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN 的关键技术主要有内容存储和分发技术。 我们知道，放在 Github 的资源在国内加载速度比较慢，因此需要使用 CDN 加速来优化网站打开以及资源访问速度，“jsDelivr + Github” 是免费，好用的 CDN 加速方案，非常适合博客网站使用。 jsDelivr 引用资源方法： https://cdn.jsdelivr.net/gh/ {your usrname name}/{your repositry name}@{release version}/{resource file path} 例如： 12# https://cdn.jsdelivr.net/gh/TheNightIsYoung/HexoImageBed0@1.0/images/test.png# https://cdn.jsdelivr.net/gh/TheNightIsYoung/HexoImageBed0@2.0/css/style.css 注意：版本号不是必需的，是为了区分新旧资源，如果不使用版本号，将会直接引用最新资源，除此之外还可以使用某个范围内的版本，查看所有资源等，具体使用方法如下： 123456789101112131415161718# 加载任何Github发布、提交或分支https://cdn.jsdelivr.net/gh/user/repo@version/file# 加载 jQuery v3.2.1https://cdn.jsdelivr.net/gh/jquery/jquery@3.2.1/dist/jquery.min.js# 使用版本范围而不是特定版本https://cdn.jsdelivr.net/gh/jquery/jquery@3.2/dist/jquery.min.jshttps://cdn.jsdelivr.net/gh/jquery/jquery@3/dist/jquery.min.js# 完全省略该版本以获取最新版本https://cdn.jsdelivr.net/gh/jquery/jquery/dist/jquery.min.js# 将“.min”添加到任何JS/CSS文件中以获取缩小版本，如果不存在，将为会自动生成https://cdn.jsdelivr.net/gh/jquery/jquery@3.2.1/src/core.min.js# 在末尾添加 / 以获取资源目录列表https://cdn.jsdelivr.net/gh/jquery/jquery/ Quick Start安装配置好 Github + jsDelivr+PicGo 之后，我们就可以进行高效创作了 点击 PicGo【上传区】，将图片拖拽到上传区域，即可自动上传到 Github 仓库（支持多图片上传），注意上传区域下方可设置图床链接格式，默认为 Markdown 格式（可以直接复制到 MD 文档中使用）。 PicGo 还有相册功能，可以快速查看以及复制上传的图片链接。并且可以对已上传的图片进行删除，修改链接等快捷操作。 例如，我们选择默认的链接格式（Markdown），上传完毕后，点击相册，然后复制相应图片链接，示例： 1![](https://cdn.jsdelivr.net/gh/TheNightIsYoung/HexoImageBed0/Img/hexo-picgo-setting.png) 这样的 Markdown 链接格式，可以直接插入到 MD 中使用了。 ======================== PicGo Use Error ======================== PicGo 用了一段时间，可能突然发现偶尔上传图片时报如下错误： 12# 上传失败：服务端出错，请重试# 上传失败：请检查配置和上传文件是否符合要求 解决方法（迷之方法~）： 更改文件名（任何形式的改动）即可成功上传。向服务器上传已存在图片也会上报上诉错误。 ================================================================ 自此，我们就成功搭建起了基于 “Hexo + Github·Pages + Gitee·Pages + Domain + VSCode + TinyPNG + PicGo + Image Host ” 的个人博客。 You need to know more当然了，人无完人。Gihub+jsDelivr+PicGo 图床解决方案也是有缺陷的，你应该了解当前方案的局限： Github Page 容量受限正如 Github 官方给出的说明： Github 没有设置磁盘配额。我们试图为所有 Git 仓库提供充足的存储空间。保持存储库的大小可以确保我们的服务器快速且下载速度快。 如果您经常向 GitHub 推送大型文件，可以考虑将 Git 大型文件存储（Git LFS）作为你的工作流的一部分。Git LFS 可以很好地使用 GitHub 流，并且可以与任何大文件一起使用，不管它的类型是什么。 如果您的存储库超过 1 GB，则可能会收到来自 GitHub 支持的礼貌电子邮件，要求您减少存储库的大小以使其恢复。 也就是说，对于 Github Repo 是没有磁盘配额限制的，但单个仓库存储要低于 1G。 这也就意味着，一旦仓库满额，就得需要重新配置一个新的图床仓库了… Public RepoGithub 中创建的图床仓库必须是 Public，如果是 Pravite，那么图片地址会带有一个随时刷新 Token，这样虽然 Repo 他人不可见，但是也没法作为图床用。 Github Contribution Activity图床每添加一张，就会进行一次 commit，这样会导致你的 Github 动向表部分一片绿……虽然这样显得你很活跃，但是真正点进去会发现你的代码更新并没有你真正提交 commit 的频率高。 小结: Gihub 是一个稳定快速，高效免费的图床解决方案，但绝对不适用于大流量场景，只限于个人小流量博客站点适用。 并且，我们要注意：禁止滥用！！！把 Github 当图床算滥用，那么和把微博当图床使用最终导致被锁理所应当。","link":"/2017/09/21/wen-ding-kuai-su-gao-xiao-mian-fei-de-tu-chuang-jie-jue-fang-an-github-jsdelivr-picgo/"},{"title":"编程基础之机器数和算术溢出","text":"一文深入理解计算机底层数据存储的形式，以及数据存储中的机器数（原码，反码，补码）和算术溢出等概念。 我们知道，计算机要处理的信息是多种多样的，如数字、文字、符号、图形、音频、视频等，这些信息在人们的眼里是不同的，那么计算机是如何存储以及管理这些丰富多样的数据呢？ 数据在内存中的存储事实上，由于计算机的硬件决定，任何存储于计算机中的数据，其本质都是以二进制码存储。 对于计算机来说，数据在内存中都是一样的，都是以二进制的形式来表示，它是计算机处理数据的基础。 以内存条为例，它是一个非常精密的部件，包含了上亿个微小的（纳米级别）电子元器件。这些元器件，实际上就是电路，电路的电压会变化，要么是 0V，要么是 5V，只有这两种电压（门电路）。5V 是通电，用 1 来表示，0V 是断电，用 0 来表示。所以，一个元器件有 2 种状态，0 或者 1。 这也就说明，对于计算机中底层存储—&gt;只能识别 0 &amp;&amp; 1 两种数据。 [0 &amp;&amp; 1] 组合表示丰富的数据信息 &gt;&gt;&gt;&gt; 但是，我们可以通过电路来控制这些元器件的通断电，会得到很多 0、1 的组合。 例如，8 个元器件有 2^8=256 种不同的组合，16 个元器件有 2^16=65536 种不同的组合。虽然一个元器件只能表示 2 个数值，但是多个结合起来就可以表示很多数值了。 同时，我们可以给每一种组合赋予特定的含义（编码），例如，可以分别用 1101000、00011100、11111111、00000000 来表示 我、爱、中、国 这几个字，那么结合起来 1101000 00011100 11111111 00000000 就表示：“我爱中国”。这样不就可以存储文本了么？ 实际上，也确实是这样用的，详情请参考：编程基础之字符编码。 比特（bit）&amp;&amp; 字节（Byte） &gt;&gt;&gt;&gt; 一般情况下，我们不一个一个的使用元器件，而是将 8 个元器件看做一个单位。这样，即使表示一个很小的数，例如 1，也需要 8 个，也就是 00000001。 1 个元器件称为 1 Bit（比特），8 个元器件统称为 1 Byte（字节）。那么 16 个元器件就是 2 Byte，32 个就是 4 Byte，以此类推： 8 × 1024 个元器件就是 1024 Byte，简写为 1KB； 8 × 1024 × 1024 个元器件就是 1024 KB，简写为 1MB； 8 × 1024 × 1024 × 1024 个元器件就是 1024 MB，简写为 1GB。 现在，你知道 1GB 的内存有多少个元器件了吧？！！ B、KB、MB、GB、TB、PB、EB &gt;&gt;&gt;&gt; 我们通常所说的文件大小是多少多少 KB，多少多少 MB，就是指占用了多少字节。 单位换算 &gt;&gt;&gt;&gt; 1Byte = 8 Bit 1KB = 1024Byte = 2^10Byte 1MB = 1024KB = 2^20Byte 1GB = 1024MB = 2^30Byte 1TB = 1024GB = 2^40Byte 1PB = 1024TB = 2^50Byte 1EB = 1024PB = 2^60Byte 平时使用计算机时，通常只会设计到 KB、MB、GB、TB 这几个单位，PB 和 EB 这两个高级单位一般在大数据处理过程中才会用到。 500 GB 硬盘的实际容量 当你购买了一块 500 GB 的硬盘，回来接到 Windows 下却显示没有 500 GB，买到假的了？？ 实际硬盘空间之所以跟标准计算有差距是因为换算的问题。只是由于硬件厂商在生产时是按照 1MB=1000KB 来算的，而 Windows 系统是按照 1MB=1024KB 来进行计算显示的。所以： N GB 硬盘的实际容量 ≈ (N × 1000 × 1000 × 1000)/(1024 × 1024 × 1024) ≈ 0.93N 故，500 GB ≈ 465 GB ============================================================ 总结一下： 你看，在内存中没有 abc 这样的字符，也没有 gif、jpg 这样的图片，只有 0 和 1 两个数字，计算机也只认识 0 和 1。所以，计算机使用二进制，写入内存中的数据都会被转换成 0 和 1 的组合。 预备知识我们知道，由于计算机的硬件决定，任何存储于计算机中的数据，计算机底层存储数据时都使用的是二进制形式。 [1] –&gt; 计算机只有加法运算器 根据冯·诺依曼提出的经典计算机体系结构框架，一台计算机由运算器、控制器、存储器、输入和输出设备组成。 目前，计算机中运算器只有加法运算器，没有减法运算器（据说一开始是有的，后来由于减法运算器硬件开销太大，被废了）。那如何进行减法运算？？？ 我们知道，减去一个数可以看作加上这个数的相反数，计算机中没办法直接做减法的，但是可以通过加法运算来实现减法功能。 有个前提 &gt;&gt;&gt;&gt; 必须要有负数的概念，这就得向二进制数中引入符号位了。 [2] –&gt; 机器数 &amp;&amp; 真值 机器数 &gt;&gt;&gt; 一个数在计算机的存储形式是二进制数，我们称这些二进制数为机器数。机器数是有符号，在计算机中用机器数的最高位存放符号位，0 表示正数，1 表示负数。 由于存在符号位，以机器数 1000 0111 为例，机器数的形式值（135，无符号数）不等于其真正的值（-7，有符号数）。 机器数的真值 &gt;&gt;&gt; 将带符号的机器数的真正表示的值称为机器数的真值（有符号数值）。 [3] –&gt; 内存存储的是二进制补码 计算机在存储一个数字时，并不是直接存储该数字对应的二进制数字（原码），而是存储该数字对应二进制数字的补码。 原码、反码、补码的产生过程就是为了解决计算机做减法和引入符号位的问题（后续会告诉你为什么）。 原码 &amp;&amp; 反码 &amp;&amp; 补码这一小节来看原码、反码和补码到底是个啥？ 为了方便说明问题，这里我们假定用 4 位二进制数表示一个整数。 原码原码的表示与机器数真值表示的一样，即用第一位表示符号，其余位表示数值。 例如，十进制的的正负 1，用 4 位二进制的原码表示如下： 【+1】= 原：[ 0001 ] 【-1】= 原：[ 1001 ] 所有机器数的原码表示如下：","link":"/2016/07/29/bian-cheng-ji-chu-zhi-ji-qi-shu-he-suan-zhu-yi-chu/"},{"title":"编程基础之特殊注释标记 TODO &amp;&amp; FIXME &amp;&amp; XXX","text":"在编写代码的时候，我们可以利用一些公认的特殊注释标记（TODO &amp;&amp; FIXME &amp;&amp; XXX）快速简洁地表达自己的目地。并且大多数的 IDE 都可以根据这些注释标记检测到相应的代码块以进行后续的编码工作，防止遗漏。 TODO: &lt;说明&gt;通常写在函数的上方或者内部，当然，实际上你可想写哪儿就写哪儿。 TODO 注释标记表示 &gt;&gt;&gt;&gt; 该注释标识处代码块，有一些代码功能还未实现，当前不实现，未来会实现。&lt;说明&gt; 中应简要描述该功能。 FIXME: &lt;说明&gt;FIXME 注释标记表示 &gt;&gt;&gt;&gt; 该注释标记处的代码块有问题或者是错误的，有可能无法正常工作，是需要进行修复的（BUG）。&lt;说明&gt; 中应简要描述下问题的修复思路。 XXX: &lt;说明&gt;XXX 注释标记表示 &gt;&gt;&gt;&gt; 该注释标记处的代码块功能虽然实现了，但是实现的方式可能并不那么的好，可以进行一些改进优化。&lt;说明&gt; 中应简要描述下后续改进优化的策略。 DemoJava1234567891011// TODO: 未来将实现的功能。// FIXME: 该部分代码问题的修复思路。// XXX: 该部分代码后续改进优化的策略。或者/* TODO: 未来将实现的功能。 FIXME: 该部分代码问题的修复思路。 XXX: 该部分代码后续改进优化的策略。*/ Python1234567891011# TODO: 未来将实现的功能。# FIXME: 该部分代码问题的修复思路。# XXX: 该部分代码后续改进优化的策略。或者''' TODO: 未来将实现的功能。 FIXME: 该部分代码问题的修复思路。 XXX: 该部分代码后续改进优化的策略。'''","link":"/2016/08/02/bian-cheng-ji-chu-zhi-te-shu-zhu-shi-biao-ji-todo-fixme-xxx/"},{"title":"编程基础之编码详解","text":"很多程序设计语言初学者都遇到过“文件显示乱码”的情况，其多数都是由于在打开文件时，没有选对编码格式导致的，即 文件编码格式问题。 而文件是由字符或字符串构成的，故，了解 字符或字符串底层的编码格式（字符编码） 是非常有必要的。 字符编码学习字符编码之前，先来认识一下计算机中的字符与字节： 字符与字节字符（chars）是人类能够识别的符号，而这些符号要能被计算机识别，处理和存储，就需要用计算机能够识别和处理的字节（byte）来表示。 例如：计算机要处理文本，就必须先把文本转换为字节才能处理。 计算机在设计时采用 8 个比特（bit）位作为一个字节（byte），也就是 8 位二进制数（也称为 字节码）。所以，一个字节能表示的最大的整数就是 255（\\b11111111 = \\d255 = 2^8 - 1，代表最多可映射 255 个字符）。 如果要表示更大的整数（更多的字符），就必须用更多的字节。比如两个字节可以表示的最大整数是 65535 = 2^16 - 1，4 个字节可以表示的最大整数是 4294967295 = 2^32 - 1 等等。 可想而知，计算机中特定的字符必然对应着固定的二进制字节码，否则在转换时将发生混乱。 何为字符编码就是 &gt;&gt;&gt;&gt; 必然存在着一套能将人类可识别的字符转换为机器可识别、处理的字节码的映射（规范），称为字符集（Character Set）或者字符编码（Character Encoding）。 严格来说，字符集和字符编码不是一个概念，字符集定义了字符和二进制码的对应关系，为字符分配了唯一的编号，而字符编码还规定了如何将文字的编号存储到计算机中。我们暂时先不讨论这些细节，姑且认为它们是一个概念。 换言之，字符编码事实上就是 &gt;&gt;&gt;&gt; 一套字符和字节码的映射规则，这里的字节码一般采用十六进制来表示，并且它定义了映射规则在计算机中的存储。 你可以将字符集理解成 &gt;&gt;&gt;&gt; 一个很大的表格，它列出了所有字符和二进制字节码的对应关系，计算机显示文字或者存储文字，就是一个查表的过程。并且计算机会采用相应的字符集编码将其存储到计算机进行处理。 而根据 字符集以及字符编码所使用字节数 的不同，产生很多不同的字符编码： 最早的 ASCII 编码计算机是美国人发明的，他们最先要考虑的问题是，如何将大小写英文字母、数字和一些特定符号与二进制字节码对应起来，故收录制定了标准的 ASCII 编码（American Standard Code for Information Interchange，美国信息互换标准代码）。 比如，数字 0 的编码是 48（~57），大写字母 A 的编码是 65（~90），小写字母 a 的编码是 97（-122）。 迄今为止 ASCII 码表 中 共收录了 128 个字符，用一个字节中较低的 7 个比特位（Bit）足以表示（2^7 = 128），所以还会空闲下一个比特位，它就被浪费了…… ASCII 码是美国人给自己设计的，他们并没有考虑欧洲那些扩展的拉丁字母，也没有考虑韩语和日语，我大中华几万个汉字更是不可能被重视，这也是合理的，先解决自己的问题。 随着计算机技术的发展，其它国家/地区编码也开始陆续出现…… 兼容 ASCII 编码 其它国家或地区的字符编码都要兼容 ASCII 编码。 由于 ASCII 先入为主，已经使用了十来年了，现有的很多软件和文档都是基于 ASCII 的，所以后来的字符编码都是在 ASCII 基础上进行的扩展，它们都兼容 ASCII，以支持既有的软件和文档。 兼容 ASCII 的含义是 &gt;&gt;&gt;&gt; 原来 ASCII 中已经包含的字符，在其它国家/地区编码中的位置不变（也就是编码值不变），只是在这些字符的后面继续收录增添了新的字符。 GBK 编码再转到我们大中华，为了把中文编码进去，可以想到要处理中文字符显然一个字节是不够的，至少需要两个字节，而且还要考虑兼容 ASCII 编码。 中文编码的三套方案：GB2312 –&gt; GBK –&gt; GB18030 出现的时间从早到晚，收录的字符数目依次增加，并且向下兼容。 GBK 编码最牛掰，后来的 中文版 Windows 都将 GBK 作为默认的中文编码方案。可以说，GBK 编码在中文版的 Windows 中大行其道。你可以选择使用 GB2312 或者 GB18030，不过一般没有这个必要。 —&gt; 这里产生一个问题： 你可以想得到的是，全世界有上百种语言，日本把日文编到 Shift_JIS 里，韩国把韩文编到 Euc-kr 里，各国有各国的标准，就会不可避免地出现冲突，结果就是，在多语言混合的文本中，显示出来会有乱码。 Unicode 字符集人们迫切希望有一种字符编码可以统一世界各地的字符，计算机只要安装了这一种字编码，就能支持使用世界上所有的文字，再也不会出现乱码，再也不需要转码了，这对计算机的数据传递来说是多么的方便！！！ Unicode（Unity Code）字符集应运而生~~~ Unicode 也称为统一码、万国码。看名字就知道，Unicode 希望统一所有国家的字符集。 Windows、Linux、Mac OS 等常见操作系统都已经从底层（内核层面）开始支持 Unicode，大部分的网页和软件也使用 Unicode，Unicode 是大势所趋。 不过由于历史原因，目前的计算机仍然安装了 ASCII 编码以及 GB2312、GBK、Big5、Shift-JIS 等地区编码，以支持不使用 Unicode 的软件或者文档。实际上，内核在处理字符时，一般会将地区编码先转换为 Unicode，再进行下一步处理。 我们一直在说，Unicode 是一套字符集，而不是说是一套字符编码。借鉴 【何为字符编码】 中关于字符集和字符编码的说明： 字符集定义了字符和二进制的对应关系，为每个字符分配了唯一的编号。可以将字符集理解成一个很大的表格，它列出了所有字符和二进制的对应关系，计算机显示文字或者存储文字，就是一个查表的过程； 而字符编码还规定了如何将字符的编号存储到计算机中。不同的字符占用的字节数可能是不一样，那么为了区分一个字符到底使用了几个字节，就不能将字符的编号直接存储到计算机中，字符编号在存储之前必须要经过转换，在读取时还要再逆向转换一次，这套转换方案就叫做字符编码。 有的字符集在制定时就考虑到了编码的问题，是和编码结合在一起的，例如 ASCII、GB2312、GBK 等，所以无论称作字符集还是字符编码都无所谓，也不好区分两者的概念。 而有的字符集只管制定字符的编号，至于怎么存储，那是字符编码的事情，Unicode 就是一个典型的例子，它只是定义了全球文字的唯一编号，因此我们还需要 UTF-8、UTF-16、UTF-32 这几种编码方案将 Unicode 存储到计算机中。 UTF-8 统一字符编码UTF 是 Unicode Transformation Format 的缩写，意思是“Unicode 转换格式”，后面的数字表明至少使用多少个比特位（Bit）来存储字符。 Unicode 可以使用的编码方案有三种，分别是： UTF-8：一种变长的编码方案，使用 1~6 个字节来存储； UTF-32：一种固定长度的编码方案，不管字符编号大小，始终使用 4 个字节来存储； UTF-16：介于 UTF-8 和 UTF-32 之间，使用 2 个或者 4 个字节来存储，长度既固定又可变。 日常中，UTF-8 字符编码使用的最多，下面来简单认识一下。UTF-8 的编码规则很简单： 如果只有一个字节，那么最高的比特位为 0，这样可以兼容 ASCII； 如果有多个字节，那么第一个字节从最高位开始，连续有几个比特位的值为 1，就使用几个字节编码，剩下的字节均以 10 开头。 具体的表现形式为： 0xxxxxxx：单字节编码形式，这和 ASCII 编码完全一样，因此 UTF-8 是兼容 ASCII 的； 110xxxxx 10xxxxxx：双字节编码形式（第一个字节有两个连续的 1）； 1110xxxx 10xxxxxx 10xxxxxx：三字节编码形式（第一个字节有三个连续的 1）； 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx：四字节编码形式（第一个字节有四个连续的 1）。 xxx 就是用来存储 Unicode 中的字符编号的。 对于常用的字符，它的 Unicode 编号范围是 0 ~ FFFF（65535），用 1~3 个字节足以存储，只有及其罕见，或者只有少数地区使用的字符才需要 4~6 个字节存储。 字符编码工作模式当然有编码就有 解码，即编码反向过程。 搞清楚了ASCII、Unicode 和 UTF-8 的关系，我们就可以总结一下现在计算机系统通用的字符编码以及解码工作方式： 用记事本编辑的时候，从文件读取的 UTF-8 字符被转换为 Unicode 字符到内存里，编辑完成后，保存的时候再把 Unicode 转换为 UTF-8 保存到文件： 浏览网页的时候，服务器会把动态生成的 Unicode 内容转换为 UTF-8 再传输到浏览器： 所以你看到很多网页的源码上会有类似 &lt;meta charset=&quot;UTF-8&quot; /&gt; 的信息，表示该网页正是用的 UTF-8 编码。 编码和解码编码(encode)：将 Unicode 字符串（中的代码点）转换特定字符编码规则对应的字节串的过程。 解码(decode)：将特定字符编码规则的字节串转换为对应的 Unicode 字符串的过程。","link":"/2016/09/01/bian-cheng-ji-chu-zhi-bian-ma-xiang-jie/"},{"title":"编程基础之进制详解","text":"计算机组成原理中的二进制、八进制、十进制、十六进制以及进制转换。 什么是进制？在生活中，我们通常都是使用阿拉伯数字计数的，也就是 10 进制，以 10 为单位，逢十进一（满十进一），借一当十，也因为只有 0，1，2、3、4、5、6、7、8、9 十个数字组成的，所以叫做十进制（Decimal）。十进制是在人类社会发展过程中自然形成的，它符合人们的思维习惯，例如人类有十根手指，也有十根脚趾。 那么什么是进制呢？进制也就是 进位制 &gt;&gt;&gt;&gt; 对于任何一种进制（X 进制），进行加法运算时都表示某一位置上的数运算时是逢 X 进一位，进行减法运算时都表示某一位置上的数运算时借一当 X，这就是 X 进制。这种进位制，包含 X 个数字（0 ~ X-1），基数为 X。 例如：十进制有 0~9 共 10 个数字，基数为 10，在加减法运算中，逢十进一，借一当十；二进制就是逢二进一（借一当二，0~1），八进制就是逢八进一（借一当八，0~7）， 十六进制是逢十六进一（借一当十六，0~F），以此类推…… 常用进制计算机常用进制有：二进制、八进制、十六进制。 二进制二进制（Binary）有 0~1 共 2 个数字，基数为 2，在加减法运算中，逢二进一，借一当二。 例如，数字 0、1、10、111、100、1000001` 都是有效的二进制。 了解计算机组成原理的看客老爷应该知道，在计算机内部，数据都是以二进制的形式存储的，计算机硬件无法识别除了 0/1 以外的任何数（参见：[&gt;&gt;&gt; 编程基础之机器数和算术溢出 &lt;&lt;&lt;]），所以二进制是学习编程必须掌握的基础。 二进制加减法 &gt;&gt;&gt;&gt; 二进制加减法和十进制加减法的思想是类似的： 对于十进制，进行加法运算时逢十进一，进行减法运算时借一当十； 对于二进制，进行加法运算时逢二进一，进行减法运算时借一当二。 下面来演示二进制加减法运算的全过程： [1] –&gt; 二进制加法：1+0=1、1+1=10、11+10=101、111+111=1110 [2] –&gt; 二进制减法：1-0=1、10-1=1、101-11=10、1100-111=101 八进制除了二进制，计算机程序设计语言中还会使用到八进制。 八进制（Octonary）有 0~7 共 8 个数字，基数为 8，在加减法运算中，逢八进一，借一当八。 数字 0、1、5、7、14、733、67001、25430 都是有效的八进制。 下面来演示八进制加减法运算的全过程： [1] –&gt; 八进制加法：3+4=7、5+6=13、75+42=137、2427+567=3216 [2] –&gt; 八进制减法：6-4=2、52-27=23、307-141=146、7430-1451=5757 十六进制除了二进制和八进制，计算机程序设计语言中十六进制也经常使用，甚至比八进制还要频繁。 十六进制（Hexadecimal）中，用 A 来表示 10，B 表示 11，C 表示 12，D 表示 13，E 表示 14，F 表示 15，因此有 0~F 共 16 个数字，基数为 16，在加减法运算中，逢十六进一，借一当十六。 注意，十六进制中的字母不区分大小写，ABCDEF 也可以写作 abcdef。 下面来演示十六进制加减法运算的全过程： [1] –&gt; 十六进制加法：6+7=D、18+BA=D2、595+792=D27、2F87+F8A=3F11 [2] –&gt; 十六进制减法：D-3=A、52-2F=23、E07-141=CC6、7CA0-1CB1=5FEF 进制转换上节我们对二进制、八进制和十六进制进行了说明，这里讲解不同进制之间的转换，这在编程中经常会用到： 将二进制、八进制、十六进制转换为十进制二进制、八进制和十六进制向十进制转换都非常容易，就是 “按权相加”。所谓 “权”，也即“位权（权重）”。 假设当前数字是 N 进制，那么： 对于整数部分，从右往左看，第 i 位的权重等于 Ni-1； 对于小数部分，从左往右看，第 i 位的权重为 N-i（0 包含在整数部分）。 更加通俗的理解是，假设一个多位数（由多个数字组成的数）某位上的数字是 Y，那么它所表示的数值大小等于 Y × 权重。 怎么理解？？？看下面实例： [1] –&gt; 整数部分 例如，将八进制数字 53627（Oct） 转换成十进制： （八进制）53627 = 5×8^4 + 3×8^3 + 6×8^2 + 2×8^1 + 7×8^0 = 22423（十进制） 从右往左看，第 1 位的位权为 8^0=1，第 2 位的位权为 8^1=8，第 3 位的位权为 8^2=64，第 4 位的位权为 8^3=512，第 5 位的位权为 8^4=4096 …… 第 n 位的位权就为 8^(n-1)。将各个位的数字乘以位权，然后再相加，就得到了十进制形式。 再如，将十六进制数字 9FA8C（Hex） 转换成十进制： （十六进制）9FA8C = 9×16^4 + 15×16^3 + 10×16^2 + 8×16^1 + 12×16^0 = 653964（十进制） 从右往左看，第 1 位的位权为 16^0=1，第 2 位的位权为 16^1=16，第 3 位的位权为 16^2=256，第 4 位的位权为 16^3=4096，第 5 位的位权为 16^4=65536 …… 第 n 位的位权就为 16^(n-1)。将各个位的数字乘以位权，然后再相加，就得到了十进制形式。 将二进制数字 11010（B） 转换成十进制也是类似的道理： （二进制）11010 = 1×2^4 + 1×2^3 + 0×2^2 + 1×2^1 + 0×2^0 = 26（十进制） 从右往左看，第 1 位的位权为 2^0=1，第 2 位的位权为 2^1=2，第 3 位的位权为 2^2=4，第 4 位的位权为 2^3=8，第 5 位的位权为 2^4=16 …… 第 n 位的位权就为 2^(n-1)。将各个位的数字乘以位权，然后再相加，就得到了十进制形式。 [2] –&gt; 小数部分 例如，将八进制数字 423.5176 转换成十进制： （八进制）423.5176 = 4×8^2 + 2×8^1 + 3×8^0 + 5×8^(-1) + 1×8^(-2) + 7×8^(-3) + 6×8^(-4) = 275.65576171875（十进制） 小数部分和整数部分相反，要从左往右看，第 1 位的位权为 8^(-1)=1/8，第 2 位的位权为 8^(-2)=1/64，第 3 位的位权为 8^(-3)=1/512，第 4 位的位权为 8^(-4)=1/4096 …… 第 m 位的位权就为 `8^(-m)。 再如，将二进制数字 1010.1101 转换成十进制： （二进制）1010.1101 = 1×2^3 + 0×2^2 + 1×2^1 + 0×2^0 + 1×2^(-1) + 1×2^(-2) + 0×2^(-3) + 1×2^(-4) = 10.8125（十进制） 小数部分和整数部分相反，要从左往右看，第 1 位的位权为 2^(-1)=1/2，第 2 位的位权为 2^(-2)=1/4，第 3 位的位权为 2^(-3)=1/8，第 4 位的位权为 2^(-4)=1/16 …… 第 m 位的位权就为 2^(-m)。 将十进制转换为二进制、八进制、十六进制将十进制转换为其它进制时比较复杂，整数部分和小数部分的算法不一样，分别讲解: [1] –&gt; 整数部分 十进制整数转换为 N 进制 整数采用 “除 N 取余，逆序排列”法。具体做法是： 将 N 作为除数，用十进制整数除以 N，可以得到一个商和余数； 保留余数，用商继续除以 N，又得到一个新的商和余数； 仍然保留余数，用商继续除以 N，还会得到一个新的商和余数； …… 如此反复进行，每次都保留余数，用商接着除以 N，直到商为 0 时为止。 演示将十进制数字 36926 转换成八进制的过程 &gt;&gt;&gt;&gt; 从图中得知，十进制数字 36926 转换成八进制的结果为 110076。 演示将十进制数字 42 转换成二进制的过程 &gt;&gt;&gt;&gt; 从图中得知，十进制数字 42 转换成二进制的结果为 101010。 [2] –&gt; 小数部分 十进制小数转换成 N 进制 小数采用“乘 N 取整，顺序排列”法。具体做法是： 用 N 乘以十进制小数，可以得到一个积，这个积包含了整数部分和小数部分； 将积的整数部分取出，再用 N 乘以余下的小数部分，又得到一个新的积； 再将积的整数部分取出，继续用 N 乘以余下的小数部分； …… 如此反复进行，每次都取出整数部分，用 N 接着乘以小数部分，直到积中的小数部分为 0，或者达到所要求的精度为止。 演示将十进制小数 0.930908203125 转换成八进制小数的过程 &gt;&gt;&gt;&gt; 从图中得知，十进制小数 0.930908203125 转换成八进制小数的结果为 0.7345。 演示将十进制小数 0.6875 转换成二进制小数的过程 &gt;&gt;&gt;&gt; 从图中得知，十进制小数 0.6875 转换成二进制小数的结果为 0.1011。 [3] –&gt; 整数部分 &amp;&amp; 小数部分 如果一个数字既包含了整数部分又包含了小数部分，那么将整数部分和小数部分开，分别按照上面的方法完成转换，然后再合并在一起即可。例如： 十进制数字 36926.930908203125 转换成八进制的结果为 110076.7345； 十进制数字 42.6875 转换成二进制的结果为 101010.1011。 将十进制数转化为其它进制数无限问题十进制小数转换成其他进制小数时，结果有可能是一个无限位的小数。 请看下面的例子： 十进制 0.51 对应的二进制为 0.100000101000111101011100001010001111010111...，是一个循环小数； 十进制 0.72 对应的二进制为 0.1011100001010001111010111000010100011110...，是一个循环小数； 十进制 0.625 对应的二进制为 0.101，是一个有限小数。 但我们知道，计算机内存有限，我们不能用储存所有的小数位数。那么在精度与内存间如何取舍呢？？？ 答案是：在某个精度点直接舍弃，代价就是，计算机内部相应数值不是精准的。 十进制小数在高级程序设计语言中属于浮点类型数据，既然十进制小数存储到内存中有误差，所以计算机中的浮点型数值的计算是不精确的，这种问题 对于所有支持浮点数运算的编程语言都是存在的。 导致什么问题？？？ &gt;&gt;&gt;&gt; 永远不要直接比较两个浮点的大小！！！ &gt;&gt;&gt;&gt; 0.1 + 0.2 不等于 0.3（传送门 –&gt; 为什么 0.1 + 0.2 不等于 0.3？）。 但我们知道： 实际应用中，不同行业，要求的精度不是线性的，我们允许（对结果无关紧要的）误差存在。 10.0001 与 10.001 在铁路工程师看来都是合格的。 二进制和八进制、十六进制的转换将二进制转换为八进制和十六进制时非常简洁，反之亦然。 [1] –&gt; 二进制整数和八进制整数之间的转换 1）二进制 &gt;&gt;&gt;&gt; 八进制 二进制整数转换为八进制整数时，每三位二进制数字转换为一位八进制数字，高位不足三位用零补齐，注意从低位向高位依次进行。 下图演示如何将二进制整数 1 110 111 100 转换为八进制： 从图中可以看出，二进制整数 1 110 111 100 转换为八进制的结果为 1674。 2）八进制 &gt;&gt;&gt;&gt; 二进制 八进制整数转换为二进制整数时，思路是相反的，每一位八进制数字转换为三位二进制数字，注意从低位向高位依次进行。 下图演示了如何将八进制整数 2743 转换为二进制： 从图中可以看出，八进制整数 2743 转换为二进制的结果为 10 111 100 011。 [2] –&gt; 二进制整数和十六进制整数之间的转换 1）二进制 &gt;&gt;&gt;&gt; 十六进制 二进制整数转换为十六进制整数时，每四位二进制数字转换为一位十六进制数字，高位不足四位用零补齐，注意从低位向高位依次进行。 下图演示了如何将二进制整数 10 1101 0101 1100 转换为十六进制： 从图中可以看出，二进制整数 10 1101 0101 1100 转换为十六进制的结果为 2D5C。 2）十六进制 &gt;&gt;&gt;&gt; 二进制 十六进制整数转换为二进制整数时，思路是相反的，每一位十六进制数字转换为四位二进制数字，注意从低位向高位依次进行。 下图演示了如何将十六进制整数 A5D6 转换为二进制： 从图中可以看出，十六进制整数 A5D6 转换为二进制的结果为 1010 0101 1101 0110。 八进制和十六进制的转换八进制和十六进制之间也极少直接转换。 而且，八进制和十六进制之间转换: 可先其转换为十进制数，再由在十进制数转换为十六进制或者八进制。","link":"/2016/08/01/bian-cheng-ji-chu-zhi-jin-zhi-xiang-jie/"},{"title":"面向对象的编程概述","text":"相信很多程序猿，特别是新手，对面向对象都用过而且可能用的还很熟，却没有去深入理解过，别人一问才发现，入门便是不熟。 说起 面向对象，不得不提的就是面向过程。大家应该都清楚，面向过程是具体化的，流程化的，解决一个问题，你需要一步一步的分析（变量），一步一步的实现（方法），这就是面向过程的设计。那什么是面向对象？其实，面向对象是模型化的，你只需抽象出一个类，这是一个封闭的盒子，在这里你拥有数据也拥有解决问题的方法。 话不多说，本文让我们来看看究竟什么是面向对象？？？ 什么是面向对象的语言面向对象语言（Object-Oriented Language）是一类以对象作为程序结构基本单位的程序设计语言，用于描述的设计是以对象为核心，并且对象是程序运行时刻的基本成分。 而面向对象的程序设计把计算机程序视为一组对象的集合，而每个对象都可以接收其他对象发过来的消息，并处理这些消息，计算机程序的执行就是一系列消息在各个对象之间传递。 面向对象语言很多，如一直高居世界编程语言排行榜的 Java、Python、C++、C#、PHP 等等。 面向对象的理解什么是对象？记住！一切皆是类，一切皆是对象。 实体、类以及对象先来认识一下面向对象中的基本概念： –&gt; 什么是对象？ 对象是现实世界中某一具体实体在计算机逻辑中的抽象，具有一组属性（也称为状态及行为）。 –&gt; 什么是类？ 具有相同特征的对象的集合，是一种抽象数据类型。属于某类的某一个对象，称为类的一次实例化的结果。 –&gt; 对象属性（状态及行为）的理解 1）对象的状态： 对象的状态也称为对象的静态属性，是指对象内部包含的各种信息，也就是变量。 2）对象的行为： 对象的行为也称为对象的动态属性，也指方法，用来设置或改变对象的状态（完成一定的功能）。 给一个实例一切都是对象 ~~~~ 一切都是对象。 举一个例子： 我们用于设计的描述（实际问题）是房子，可以抽象出一个房子类 【House：Class】，故可以将一栋房子看作是房子类 【House：Class】的一次实例化结果：【HouseA：Object】。 后面我们将基于这个实例描述面向对象的四大特性：抽象、封装、继承以及多态性。 不要疑惑，就是四大特性，其实抽象性是面向对象的基本特性，也应该被包含在内。 面向对象的特性这一部分我们来看面向对象的四大特性抽象、封装、继承以及多态性的理解： 抽象性从对象定义来看面向对象的抽象性，对象就是现实某一具体实体在计算机逻辑中的抽象 。 在上面的实例中，我们从实际问题中抽象出了房子类 【House：Class】 以及具体的房子对象 【HouseA：Object】。 封装性封装就是将各个独立功能设计成一个个独立的单元，尽可能的隐藏内部细节，只保留必要的对外接口，与外部联系。 高内聚，低耦合。通过封装可以减小耦合，提高内聚，避免牵一发而动全身，方便对程序的修改。 –&gt; 实例说明 对于【HouseA：Object】，房子空间很大，但如果男男女女有十几人住，而且就一间屋子的话，很不方便，并且吃喝拉撒都一个屋，那就成难民营。 –&gt; 这样，就要想法解决: 工人们出动了，把房子折腾折腾给分成楼上楼下两层，并说明了，一楼吃喝玩乐、二楼休息； 楼上楼下工人们又分别给隔离出几个房间，分别规划修建厨房、卫生间、卧室、娱乐室等等，这样就把房子这样改造好了。然后男男女女们过来了，大家就可以各自的房间，做爱做的事，而且不会影响到其他了。 –&gt; 这样一个简单的封装就完成 【House：Class】 是对部分类 【房子两层：Partialclass】 的封装；而 【房子两层：Partialclass】 是对 【房间：函数/方法-function】 的封装。 继承性继承发生在两个对象之间，是特殊类对象具有一般类对象全部的属性和行为。可以提高软件的开发效率，对软件复用有很大的意义。 –&gt; 继续来看房子 工人们已经给分好楼层、并且根据不同的功能做好了房间。这时屋主觉得，不行啊，得有个地下室来放杂物啊。工人一听，好尼玛房子都折腾的差不多了，又要搞一个地下室，不好搞啊。 屋主发话了，要搞必须搞，不好搞也要搞，而且狠狠的搞。工人们就为难了，难道再去给盖一栋有避难所的房子？ 大家集思广益最终，房子其他都还用着，再给挖个地下室就行了，于是新房子诞生了。 –&gt; 一个简单的继承就出现了 【房子：基类-baseclass】 被 【新房子：扩展类-ExtensionClass】 继承。 多态性多态是同一消息可以根据发送对象的不同产生多种不同的行为方式，可以说是封装的一个实现。实现多态的方法有：方法重写（覆盖）、方法重载以及接口等。 –&gt; 仍然是房子 房子已经成型，要对房间进行装修了。工人想法很简单，都按照一种样式来，简单方便快捷。屋主不乐意了，有要在承重墙上开扇窗户的，有要在卫生间装摄像头的、要在厨房里装空调的….工人们安装要求对能实现的就开始开工了，对房子的窗户、地板、墙、楼梯等进行装修。 –&gt; “一种多态的展现” 就出来了 【房子：类-class】 通过 【窗户、地板、墙、楼梯等：属性-Property】 体现多态。 面向对象和面向过程的比较事实上，面向对象更符合人类的思维，面向过程则是机器的思想。 –&gt; 面向过程： 优点：性能比面向对象好，因为类调用时需要实例化，开销比较大，比较消耗资源。 缺点：不易维护、不易复用、不易扩展。 –&gt; 面向对象： 优点：易维护、易复用、易扩展。由于面向对象有封装、继承、多态性的特性，可以设计出高内聚，低耦合的系统，使系统更加灵活、更加易于维护 。 缺点：性能比面向过程差 面向对象的软件开发过程 面向对象分析（Object Oriented Analysis）：OOA； 面向对象设计（Object Oriented Design）：OOD； 面向对象实现（Object Oriented Programming）：OOP，也就是面向对象的编程。","link":"/2017/10/07/mian-xiang-dui-xiang-de-bian-cheng-gai-shu/"},{"title":"网站基础之 URL 结构解析","text":"我们知道，URL 是浏览器寻找信息（资源）时所需的地址（位置），通过 URL，浏览器才能找到并使用共享因特网上大量的数据资源。那么，了解 URL 的结构对于网站建设来说是极其重要的。 URL 是互联网的基础，最常见的形式就是网页通过链接（指向其它网页的 URL）相连，用户通过点击链接（URL），从当前 URL 跳转到另一个 URL，也实现了从一个网页跳转到另一个网页，错综复杂的链接使用最终构成了万维网。 何为 URL？在互联网（万维网）中，任何一个可访问的文件或文档都具有一个唯一的地址，这种地址称为统一资源定位符（Uniform Resource Locator，URL），也被称为网址（URL）。 简言之，URL 是用来 唯一 标识和定位 万维网上的 WEB 资源的，每个 URL 都有其对应的文件（文档、图片、视频等），例如 URL: https://www.baidu.com/index.html 对应的则是百度的官网首页等。 当你点击 HTML 页面中的某个链接时，WEB 浏览器会通过其 URL 从相应的 Web 服务器请求资源（网页、图片、视频、下载文件等等）。 下面我们看一下 URL 的组成： URL 标准语法URL 组成遵守一种标准的语法，它由：协议、主机名、域名、端口、路径、以及文件名这六个部分构成（端口可以省略）。具体格式如下： 1scheme://host.domain[:port]/path/filename 其中，scheme 表示互联网服务类型（协议），host 表示域主机名，domain 表示域名，port 表示端口（可以省略），path 表示文件（资源）的路径，filename 表示文件（资源）名称。 接下来我们详细看一下这几部分到底是如何使用的： Scheme协议用来指明客户端和服务器之间通信的类型。我们经常用到的协议有四种：http、https、ftp、file。这四种协议的使用场景如下表所示： Scheme 全称 访问 用于… http HyperText Transfer Protocol 超文本传输协议 Http 协议可以将编码为超文本的数据从一台计算机传送到另一台计算机，不进行加密 https HyperText Transfer Protocol Over SecureSocket Layer 安全超文本传输协议 以安全为目标的 Http 通道，安全网页，加密所有信息交换 ftp File Transfer Protocol 文件传输协议 用于将文件下载或上传至网站 file file 本地 本地计算机文件 需要注意的是：通信协议需要与 URL 的其它部分用 :// 隔开。 Host域主机名可以向浏览器提供，访问文件站点的名称。 www 是我们常见的域主机名 &gt;&gt;&gt; 例如百度的网址 https://www.baidu.com/ &amp;&amp; 淘宝的网址 https://www.taobao.com/ 使用的都是 www 的主机名。 除此之外，还有很多网站使用的是其它主机名： 例如网易云音乐的网址 https://music.163.com/ 的主机名是 music。 Domain域名和域主机名一起使用，被用来定义服务器的地址。前面提到过，浏览器会向 URL 指向的 WEB 服务器请求相应资源，这里的 Domain 就是用来定义 WEB 服务器地址的。 Web 服务器需要遵守数字网际协议（Internet Protocol，IP），即每一台连接到因特网的计算机都有一个固定的 IP 地址。 而，因为一般的 IP 地址都是长串的数字，为了方便记忆所以使用域名进行替代。简单来说，没有域名（IP）我们就不能上网。 [1] &gt;&gt;&gt; 域名后缀 域名后会有域名后缀，一般是由网站组织机构性质决定： com : Commercial organizations，国际商业组织或公司，如 sohu.com edu : Educational institutions，教研机构, 如 PKU.edu.cn gov : Governmental entities，政府部门, 如 beijing.gov.cn net : Network operations and service centers，互联网络信息中心和运行中心, 如 263.net org : Other organizations，非盈利组织 另外，还有标识不同国家或地区的最高层域名后缀，如：CN（中国）、JP（日本）、UK（英国）、US（美国）、HK（香港）、TW（台湾）等等。 [2] &gt;&gt;&gt; 一、二级域名 以百度搜索为例： 其一级域名一般是这样的：baidu.com；二级域名一般是这样的：zhidao.baidu.com。 也即是说，一级域名可以设置很多个二级域名，比如 baidu.com 可以设置 bbs.baidu.com；zhidao.baidu.com；post.baidu.com；mp3.baidu.com 等，相反则不可能！！！ [3] &gt;&gt;&gt; 域名解析 前面提到过，域名即服务器 IP 地址的别名，实际上使用域名（Domain）访问网站时，浏览器会先通过 DNS 域名解析服务器（DNS 服务器） 拿到域名对应的 IP 地址（域名解析），然后再通过 IP 地址请求服务器上的文件。 Port端口用来定义访问 WEB 服务器的端口号，以提供可以访问到目标的 Web 服务。 如果不写（浏览器会根据所用的协议来为你指定一个缺省端口），Http 的默认端口号是 80，Https 的默认端口号是 443，Ftp 的默认端口号是 21。 还是拿 BAIDU 举例说明，不论用户输入 &gt;&gt;&gt; https://www.baidu.com/ 还是 &gt;&gt;&gt; https://www.baidu.com:443/，浏览器都会解析为 BAIDU 的链接。 Path路径用于指定请求的服务器上文件（资源）的所在位置。 就像我们自己在计算机上保存文件时所指定的文件夹一样，Web 服务器上的文件也有可能是存放在子目录（就是文件夹中的子文件夹）中的。如果是这样，路径中的相邻文件夹需要使用斜线（/）隔开。例如 http://www.test.net/view/views/demo.html 这个网址，它的路径就是 /view/views。 Filename文件名用来定义请求的文档或资源的名称。 和路径类似，路径指的是文件夹，而它指的是文件夹中的文件了，例如 .html 、.php、 .jsp、.asp 等。 URL 通用语法URL 除了上述的标准格式外，更为通用的语法格式为： 1scheme://username:passwd@host.domain[:port]/path/filename[para -&gt; ;参数?查询#片段] 其中，多出了 username:passwd@ &amp;&amp; [para -&gt; ;参数?查询#片段] 两部分： username:passwd很多服务器都要求输入用户名和密码才会允许用户访问数据，如 FTP 服务器（User: joe &amp;&amp; Passwd: joe-passwd）: 1ftp://joe:joepasswd@ftp.prep.edu/pub/name [para -&gt; ;参数?查询#片段]URL 末尾添加 &gt;&gt;&gt; [1] &gt;&gt;&gt; 参数 为了向应用程序提供它们所需要的输入参数，以便正确地与服务器进行交互，URL 中有个参数组件。由字符 ; 将其与 URL 的其余部分分隔开来。 例如：type=7 &amp;&amp; num=30 就是两个参数： 1ftp://prep.mit.edu/pub;type=7;num=30 注意，查询条件为 参数=参数值 的表达式。 [2] &gt;&gt;&gt; 查询 搜索引擎中访问资源，都可以通过提问题或设置查询条件来缩小请求资源的范围。由字符 ? 表示查询，并使用 &amp; 分割多个查询条件。如下： 1http://www.cheng.cn/si.html?name=csh&amp;age=24 注意，查询条件为 参数=参数值 的表达式。 [3] &gt;&gt;&gt; 书签 页面书签，使用字符 # 来代表要定位的网页中的一个书签位置。 # 后面跟随的字符就是该位置的标识符(一般情况下，锚链接会用到)。 浏览器读取这个 URL 后，会自动将 第一章 位置滚动至可视区域。 1http://www.cheng.cn/si.html#第一章 了解了 URL 标准语法和通用语法格式之后，这一小节为我们来看 URL 编码： URL 编码我们知道，WEB 浏览器会通过 URL 发送一个请求，实现从相应的 Web 服务器请求特定的资源。 如果 URL 路径或者 [para -&gt; ;参数?查询#片段] 中带有中文或者特殊字符的时候，浏览器在发送请求前会对 URL 进行 URL 编码，这是 URL 编码协议 规定的。 URL 编码协议URL 编码协议（RFC3986 协议）中规定：URL 只允许使用 ASCII 字符集中可以显示的字符来通过因特网进行发送。 针对 URL 中可能出现的字符分为三种情况： ASCII 码表中不支持的可显示字符； ASCII 码表中可显示的不安全字符； ASCII 码表中可显示的 URL 保留字符。 [1] &gt;&gt;&gt; ASCII 码表中不支持的可显示字符 “ASCII 码表中不支持的可显示字符” 好理解， 比如你的 URL 中包含有中文或其它非英文国家字符时，均不属于 ASCII 码表。 [2] &gt;&gt;&gt; ASCII 码表中可显示的 URL 保留字符 所谓保留字符，就是那些在 URL 中具有特定意义的字符。 你可以返回上文中查看 URL 标准语法和通用语法中，用来分隔不同 URL 组件时使用的字符，它们属于 URL 结构的一部分，被称为保留（Reserved）字符。 例如： 1: / . ... @ ; = ? &amp; 等 [3] &gt;&gt;&gt; ASCII 码表中可显示的不安全字符 “ASCII 码表中可显示的不安全字符（Unsafe）” 指的是，在 URL 中没有特殊含义，但在 URL 所在的上下文中具有特殊用途或者特殊意义的字符。 例如： 1&lt; &gt; “ # % | \\ 等 通常情况下，如果对某个字符能否在 URL 中使用有疑问，那么你应该始终使用该字符的编码。除字母、数字和字符 $ - _ . + ! * ’ ( ) 外的其它所有字符都应该使用编码，将其编码为有效的 ASCII 格式。 如何编码？众所周知，单字节字符是可由八位字节数（Octet）来表示的，八位字节数可用十六进制来表示它的值。例如字符 &lt; 的八位字节数十六进制值是 3C。 在 URL 中，单字节字符的编码方式为：% 加上字符的两个十六进制数值，即 %XX。如下： 部分保留字符和不安全字符及其 URL 编码 &gt;&gt;&gt; 字符 描述 用法 编码 ; 分号 保留 %3B / 斜线 保留 %2F ? 问号 保留 %3F : 冒号 保留 %3A @ “at”符号 保留 %4O = 等号 保留 %3D &amp; “和”符号 保留 %26 &lt; 小于号 不安全 %3C &gt; 大于号 不安全 %3E “ 双引号 不安全 %22 # 井号 不安全 %23 % 百分号 不安全 %25 { 左大括号 不安全 %7B } 右大括号 不安全 %7D | 竖线 不安全 %7C \\ 反斜线 不安全 %5C ^ 加字号 不安全 %5E ~ 波浪 不安全 %7E [ 左中括号 不安全 %5B ] 右中括号 不安全 %5D ` 反单引号 不安全 %60 空格 不安全 + 或 %20 有些同学可能会想到中文字符的编码，由于 URL 编码协议没有规定汉字的编码方式，而是让浏览器自己去决定，因此会造成了不同浏览器对 URL 汉字编码的不统一（UTF-8/GBK-2312）。 经过浏览器编码处理之后的 URL 才是最终请求中的 URL，故通过编码后的 URL 必然也是可以访问相应的 Web 服务器的。你可以认为我们浏览器中通常可见的未编码处理的 URL 是给用户看的，而编码之后的 URL 是给设备使用的。 学会使用编码工具 通过上面的课程你可以看到，采用人工查表的方式去为 URL 进行编码是不现实的，而且很容易出现问题，导致无法访问目标服务器。 事实上，网络上提供了很多 URL 在线编码（格式化）公式，你只需要 Copy &gt;&gt;&gt; Encode 即可快速获得编码好的 URL。 如果你学过一些高级编程语言（Python &amp;&amp; Java …），你可以通过其提供的网络扩展包中 URL 编码和解码接口轻松实现上述功能。","link":"/2019/01/01/wang-zhan-ji-chu-zhi-url-jie-gou-jie-xi/"},{"title":"Git 使用指南之 WorkFlow (工作流)","text":"Git 多人协作必须有一个规范的工作流程，让大家有效地合作，使得项目井井有条地发展下去，这个流程叫做 WorkFlow（工作流），也称为 Git 分支管理策略。工作流不涉及任何命令，因为它就是一个规则，完全由开发者自定义，并且自我遵守。 版权说明： 本文思路以及内容主要来自廖雪峰老师的 Git 教程 （强烈推荐膜拜原文），并结合个人使用所作，只作为学习记录使用。如内容有侵权请联系删除，禁止转载！ 更多 Git 相关内容，请关注博主 Git 博文系列： 之一 &gt;&gt;&gt; Git 使用指南之初识 之二 &gt;&gt;&gt; Git 使用指南之时光穿梭机 之三 &gt;&gt;&gt; Git 使用指南之远程仓库 之四 &gt;&gt;&gt; Git 使用指南之分支管理 之五 &gt;&gt;&gt; Git 使用指南之 WorkFlow (工作流) 之六 &gt;&gt;&gt; Git 使用指南之 Git 自定义 之七 &gt;&gt;&gt; Git 使用指南之 HEAD 指针 之八 &gt;&gt;&gt; Git 使用指南之 Git 中的黑魔法 何为 Git 工作流？WorkFlow 的字面意思，工作流，即工作流程。Git 中因为有分支的存在，才构成了多工作流的特色。 事实的确如此，因为项目开发中，多人协作，分支很多，虽然各自在分支上互不干扰，但是我们总归需要把分支合并到一起，而且真实项目中涉及到很多问题，例如版本迭代，版本发布，bug 修复等，为了更好的管理代码，需要制定一个约束的工作流程。 简言之，Git 工作流指的是多人协作过程中的 git 的使用流程，不涉及技术细节，是一种项目管理、开发约定的方式。 工作流最受欢迎榜 目前使用度最高的工作流前三名（排名不分先后）分别是以下三种： Git Flow GitHub Flow GitLab Flow 其中 Git Flow 出现的最早；GitHub Flow 是在 Git Flow 的基础上，做了一些优化，适用于持续版本的发布；而 GitLab Flow 是综合前面两种工作流的优点，制定而成的一个工作流。 PopCharts Introduction你可以根据这里关于上述三种工作流的特性描述，为自己的项目构筑适配的工作流，毕竟适合自己的才是最好的~~~ Git FlowGit Flow 工作流，是 Vincent Driessen 2010 年发布出来的他自己的分支管理策略，一经发布就广为留下，目前位置使用度非常高，也是我们日常项目的常用工作流。 Git Flow 的分支结构很特别，按功能来说，可以分支为 5 种分支。从分支生命周期来看，可以分别归类为:长期分支 &amp;&amp; 短期分支，或者更贴切描述为，主要分支 &amp;&amp; 协助分支。 主要分支Git Flow 分支管理策略项目中，代码的中央仓库会一直存在以下两个 长期分支： master develop 其中，origin/master 分支上的最新提交永远是提供给用户使用的正式发布版本（任何时候 master 分支上拿到的，都是稳定的分布版）。origin/develop 分支用于日常开发，存放最新的开发进度。 当 develop 上的代码达到一个稳定的状态，可以发布版本的时候，develop 上的修改可以以某种特别方式（–no-ff，有时也需要借助后面将要提到的协助分支 {非必须} 等）被合并到 master 分支上，然后标记上对应的版本标签（tag），为以后项目排查定位提供便利。 事实上，常设分支只需要这两条主要分支就够了，不需要其他了~~~ 协助分支然而，除了常设分支以外，Git Flow 的开发模式还需要一系列的协助分支，来帮助更好的功能的并行开发，简化功能开发和问题修复。 协助分支是暂时分支，它们非常无私奉献，在需要它们的时候，迫切地创建，用完它们的时候，又挥挥衣袖地彻底消失。 协助分支分为以下三类： Feature Branch（功能分支） Release Branch（预发布分支） Hotfix Branch（热修复分支） 1 –&gt; Feature Branch Feature 功能分支，是为了开发某种特定功能，从 develop 分支上面分出来的。Feature Branch 命名可以采用：feature-xxx 的方式。 待功能模块开发完成之后，会将其重新合并到 develop 分支上，然后删除 Feature Branch。 如图，有两个功能模块在开发，其中一个已经完成，重新合并到 develop 分支；另一个仍处于开发状态。 2 –&gt; Hotfix Branch Hotfix 热修复分支，是用来做线上的紧急 Bug 修复的，建议命名为 hotfix-xxx。 当线上（master）某个版本出现了问题，将检出对应版本的代码，创建 Hotfix 分支，问题修复后，合并回 master 和 develop ，然后删除 Hotfix Branch。 这里注意，合并到 master 的时候，也要打上修复后的版本标签。 3 –&gt; Release Branch Release 预发布分支，是指发布正式版本之前（即 develop 分支合并到 Master 分支之前），我们可能需要从 develop 分支上分出来一个预发布的版本分支进行测试，预发布（测试）结束以后，必须将其合并进 develop 和 master 分支，然后删除 Release Branch。Release Branch 命名可以采用：reature-xxx 的方式。 例如，在软件 1.0.0 版本的功能全部开发完成提交后，从 develop 检出 release-1.0.0 进行测试，测试中出现的小问题，在 release 分支进行修改提交，测试完毕准备发布的时候，代码会合并到 master 和 develop，master 分支合并后会打上对应版本标签 v1.0.0, 合并完成后删除 release-1.0.0。 这样做的好处是：在 测试的时候，不影响下一个版本功能并行开发。 最后我们来看发布之后的目前的日志记录情况，这里将没有用的分支 hotfix、release、feature 均删除了，可以看出常驻分支只有 master/dev，最下面的 feature 表示仍在开发中。 No Fast Forward需要说明的是，Git Flow 的作者 Vincent Driessen 非常建议，合并分支的时候，加上 no-ff 参数，采取禁用快速合并模式，使用递归策略合并模式。 好处：保证一个非常清晰的提交历史，防止丢失分支信息。 Git Flow Diagram这里给出 Git Flow 整体工作流程的图解，可以看出，Git Flow 的五种分支，master，develop，feature branchs ,release branchs , hoxfixes。 其中，master 和 develop 字体被加粗代表主要分支。master 分支每合并一个分支，无论是 hotfix 还是 release ,都会打一个版本标签。通过箭头可以清楚的看到分支的开始和结束走向，例如 feature 分支从 develop 开始，最终合并回 develop ，hoxfixes 从 master 检出创建，最后合并回 develop 和 master，master 也打上了标签。 Git Flow EvaluationGit Flow 综合考虑了开发、测试、新功能开发、临时需求、热修复，理想很丰满，现实很骨干，这一套运行起来实在是太复杂了/(ㄒoㄒ)/~~ Git Flow 的优点是清晰可控，缺点除了：1.频繁在两个长期分支（master &amp;&amp; develop）之间切换；2.没有 GUI 图形页面，只能命令行操作； 更大的问题在于 &gt;&gt;&gt;&gt;&gt; Git Flow 是基于 “版本发布” 的，目标是一段时间以后产出一个新版本。但很多网站项目是”持续发布”（快速迭代），代码一有变动，就部署一次。这时，master 分支和 develop 分支的差别不大，没必要维护两个长期分支。 GitHub FlowGithub flow 是 Git flow 的简化版，专门配合 ”持续发布”，它是 Github.com 使用的工作流程。 Github flow 只有一个长期分支，就是 master，因此用起来非常简单。 Introduction官方推荐的流程如下： GitHub Flow 模型简单说明: 第一步：根据需求，只有一个长期分支 master ,而且 master 分支上的代码，永远是可发布状态。并且 master 分支会设置 protected 分支保护，只有有权限的人才能推送代码到 master 分支。 第二步：根据需求，从 master 拉出新分支，不区分功能分支或热修复分支等。 第三步：新分支开发完成后，或者需要讨论的时候，就向 master 发起一个 pull request（简称 PR）。 第四步：Pull Request 既是一个通知，让别人注意到你的请求;又是一种对话机制，大家一起评审和讨论你的代码。对话过程中，你还可以不断提交代码。 第四步：你的 Pull Request 被接受，合并进 master，重新部署后，原来你拉出来的那个分支就被删除。 特色之 Pull RequestGitHub Flow 最大的特色就是 Pull Request 的提出，这是一个伟大的发明，它的用处并不仅仅是合并分支，还有以下功能： 可以很好控制分支合并权限：分支不是你想合并就合并，需要对方同意 问题讨论 或者 寻求其他小伙伴们的帮助:和拉个讨论组差不多，可以选择相关的人参与，而且参与的人还可以向你的分支提交代码，非常适合代码交流 代码 Review：如果代码写的很烂，有了 pull request 提供的评论功能支持，准备好接受来自 review 的实时吐槽吧。 Github Flow 这种方式，要保证高质量，对于贡献者的素质要求很高，换句话说，如果代码贡献者素质不那么高，安安心心小板凳做好膜拜大佬就好了~~~ 特色之 issue tracking日常开发中，会用到很多第三方库，然后使用过程中，出现了问题，是不是第一个反应是去这个第三方库的 GitHub 仓库去搜索一下 issue ，看没有人遇到过，项目维护者修复了没有？？？一般未解决的 issue 是 open 状态，已解决的会被标记为 closed，这就是 issue tracking（问题追踪）。 如果你是一个项目维护者，除了标记 issue 的开启和关闭，还可以给它标记上不同的标签，来优化项目。当提交的时候，如果提交信息中有 fix #1 等字段，可以自动关闭对应编号的 issue。 issue tracking 非常适合开源项目。 GitLab FlowGitlab Flow 集百家之长，补百家之短。 Gitlab Flow 是 Git Flow 与 Github Flow 的综合。它吸取了两者的优点，既有适应不同开发环境的弹性，又有单一主分支的简单和便利。它是 Gitlab.com 推荐的做法。 GitLab 既支持 Git Flow 的分支策略，也有 GitHub Flow 的 Pull Request（ Merge Request ） 和 issue tracking。 Git &amp; GitHub Flow 的瑕疵当 Git Flow 出现后，它解决了之前项目管理的很让人头疼的分支管理，但是实际使用过程中，也暴露了很多问题： 默认工作分支是 develop，但是大部分版本管理工具默认分支都是 master，开始的时候总是需要切换很麻烦。 Hotfix 和 Release 分支在需要版本快速迭代的项目中，几乎用不到，因为刚开发完就直接合并到 master 发版，出现问题 develop 就直接修复发布下个版本了。 Hotfix 和 Release 分支，一个从 master 创建，一个从 develop 创建，使用完毕，需要合并回 develop 和 master。而且在实际项目管理中，很多开发者会忘记合并回 develop 或者 master。 随着，GitHub Flow 的出现，极大程度上简化了 Git Flow ，因为只有一个长期分支 master，并且提供 GUI 操作工具，一定程度上避免了上述的几个问题，然而在一些实际问题面前，仅仅使用 master 分支显然有点力不从心，例如： 版本的延迟发布（例如开发 iOS 应用审核过程中（等待审核上架），可能也要在 master 上推送代码，导致线上版本落后 master 分支） 不同环境的部署 （例如：测试环境，预发环境，正式环境） 不同版本发布与修复 （只有一个 master 分支真心不够用） GitLab Flow 解决方案在给出解决方案之前，需要明确 GitLab Flow 中的一个最大原则：”上游优先”（upsteam first）。 ”上游优先”原则：即只存在一个主分支master，它是所有其他分支的”上游”。只有上游分支采纳的代码变化，才能应用到其他分支。只有紧急情况，才允许跳过上游，直接合并到下游分支。 关于”上游优先”原则的具体应用，请参看下文 &gt;&gt;&gt;&gt; 为了解决 Git Flow &amp; GitHub Flow 中那些毛茸茸的小问题，GitLab Flow 给出了以下的解决方案： 1 –&gt; 版本的延迟发布 解决思路：Prodution Branch &amp; Upsteam First master 分支不够，于是添加了一个 prodution 分支，专门用来发布版本。 但要注意需要遵循 ”上游优先”（upsteam first），代码的变化，必须由”上游”向”下游”发展。比如，生产环境出现了 bug，这时就要新建一个功能分支，先把它合并到 master，确认没有问题，再 cherry-pick 到 production。 2 –&gt; 不同环境的部署 应对”持续发布”的项目，解决思路：Environment Branches &amp; Upstream First 每个环境，都对应一个分支，例如下图中的 pre-production 和 prodution 分支都对应不同的环境，GitLab Flow 模型比较适用服务端，测试环境、预发环境、正式环境，一个环境建一个分支。 比如，”开发环境”的分支是 master，”预发环境”的分支是 pre-production，”生产环境”的分支是 production。 开发分支是预发分支的”上游”，预发分支又是生产分支的”上游”。代码的变化，必须由”上游”向”下游”发展。比如，生产环境出现了 bug，这时就要新建一个功能分支，先把它合并到master，确认没有问题，再 cherry-pick 到 pre-production，这一步也没有问题，才进入 production。 只有紧急情况，才允许跳过上游，直接合并到下游分支。 3 –&gt; 版本发布分支 应对”版本发布”的项目，解决思路：Release Branches &amp; Upstream First 只有当对外发布软件的时候，才需要创建 release 分支。作为一个移动端开发来说，对外发布版本的记录是非常重要的，如果线上出现了一个问题，需要拿到问题出现对应版本的代码，才能准确定位问题。 GitLab Flow 中建议的做法是：每一个稳定版本，都要从 master 分支拉出一个分支，比如 2-3-stable、 2-4-stable 等等。发现问题，就从对应版本分支创建修复分支，完成之后，先合并到 master，才能再合并到 release 分支，遵循 “上游优先” 原则，并且记得要更新小版本号。 Useful TipsPull RequestGitHub Flow 中的 Pull Request 见上文相关部分，GitLab Flow 中也支持 Pull Request，只是叫法改为 Merge Request！！！ Protected branchmaster 分支应该受到保护，不是每个人都可以修改这个分支，以及拥有审批 Pull Request 的权限。 Github 和 Gitlab 都提供”保护分支”（Protected branch）这个功能。 Issue trackingIssue 用于 Bug追踪和需求管理。建议先新建 Issue，再新建对应的功能分支。功能分支总是为了解决一个或多个 Issue。 功能分支的名称，可以与issue的名字保持一致，并且以 issue 的编号起首，比如：”15-require-a-password-to-change-it”。 开发完成后，在提交说明里面，可以写上 “fixes #14” 或者 “closes #67”。Github 规定，只要 commit message 里面有下面这些 “动词 + 编号”，就会关闭对应的 issue。 123456789closeclosesclosedfixfixesfixedresolveresolvesresolved Merge With NO-FF需要说明的是，合并分支的时候，加上 no-ff 参数，采取禁用快速合并模式，使用递归策略合并模式。 这样可以保证一个非常清晰的提交历史，防止丢失分支信息。 Squash commits为了便于他人阅读你的提交，也便于 cherry-pick 或撤销代码变化，在发起 Pull Request 之前，应该把多个 commit 合并成一个（前提是，该分支只有你一个人开发，且没有跟 master 合并过）。 这可以采用 rebase 命令附带的 squash 操作 ===================================================== 至此，Git 中的分支管理策略就也就介绍完了。事实上，Git 的使用真的很灵活自由，你完全可以采取搭配式的工作流模式，比如：GitLab + Git Flow，一定要把思路打开。 这里再扩展一种工作流：Forking Flow Forking Flow开源项目常用的工作流 ——Forking 工作流，介绍之前首先需要了解什么是 fork 操作，见下图： fork 操作是在个人远程仓库新建一份目标远程仓库的拷贝，操作很简单，比如 github 上在项目的主页点击 fork 按钮即可。 明白了 fork 操作之后，我们来看下 forking 工作流的流程，如下： 首先开发者 A 拥有一个远端仓库 &gt;&gt;&gt; 这时候有一个开发者 C 也想参与 A 的这个项目的开发工作，那他就可以 fork 一份 A 的这个仓库，之后在 C 的个人仓库里就有了这份代码库，后续开发者 C 就可以在自己的这个项目里进行开发工作，C 在完成了某个功能的实现之后，可以给 A 的仓库发一个 PR 请求，这时候会通知到开发者 A 有新的 PR，A 如果有问题可以直接在这个 PR 里提，开发者 C 可以进行进一步的修改，最后 A 通过了 C 的这份 PR 请求，就会将 C 的代码合并进 A 的仓库，这样就完成了 A / 代码库新特性的开发。同时如果有其他开发者对 A 的项目有兴趣也会进行相同的操作。 这里注意到 开发者 B/C 并不是 A 代码库的开发人员，而是第三方开发者，所以这种工作流主要用于开源项目！ Tag Management在开发过程中, Git 支持使用 标签（Tag） 给仓库历史中的某一个提交打上标签，以示重要。 例如版本发布, 有重大修改, 升级的时候，开发人员会使用标签来标记发布（修改、升级）结点：v1.0 、 v2.0 等等，这可以为以后项目排查、定位提供极大便利。 将来无论什么时候，可以通过之前打好的标签（v1.0 、 v2.0），拿到那个时刻的历史快照，相当于版本库某个特殊时刻的快照。Git 标签虽然是 版本库的快照，但本质上它是 指向某个 commit 的指针（是不是跟分支很像？？？），所以创建和删除标签也都是瞬间完成的。 注意和分支指针不同的是：标签是指向 commit 的死指针，分支是指向 commit 的活指针！！！事实上，你可以将标签简单理解为 某个 Commit 的别名。 为何引入 Git Tag思考一下：为什么 Git 有 commit，为什么还要引入 tag ？？？ 你：“请把上周一的那个版本打包发布，commit 号是 6a5819e..” 同事：“一串乱七八糟的数字不好找！” 如果换一个办法： 你：“请把上周一的那个版本打包发布，版本号是v1.2” 同事：“好的，按照 tag v1.2 查找 commit id 就行！” 所以，tag 就是一个让人 容易记住的有意义的名字，它跟某个 commit 绑在一起（别名）。 查看标签在开始标签操作说明之前，需要先介绍一下 Git 中的标签查看命令，后续标签操作需要查看命令的配合。 1 –-&gt; git tag：列出标签 在 Git 中列出已有的标签非常简单，只需要输入 git tag: 1234# 如果仓库中已创建了标签：v1.0，v2.0，可以使用命令进行查看$ git tagv1.0v2.0 git tag 列出的标签，会以字母顺序列出，但是它们显示的顺序并不重要。 这时会有一个问题：当项目经过长时间维护，仓库中包含的标签数量较多时，以上命令会全部进行显示，不方便精确查找到目标。 这时，你可以通过通配符的方式，使用 git tag -l &quot;tag version*&quot;进行精确查找，例如只对 1.8.5 系列感兴趣，可以运行： 1234567891011$ git tag -l &quot;v1.8.5*&quot;v1.8.5v1.8.5-rc0v1.8.5-rc1v1.8.5-rc2v1.8.5-rc3v1.8.5.1v1.8.5.2v1.8.5.3v1.8.5.4v1.8.5.5 2 –&gt; git show：查看标签信息 git show 命令可以用来查看某个标签对应的提交的信息： 1234567 $ git show v0.8commit fb508357fe0e488ac6720874941ecd6bbd3aacf2 (HEAD -&gt; master, tag: v0.8, origin/master)Merge: 7d23fef c07648eAuthor: TheNightIsYoung &lt;guojie0213_iit@163.com&gt;Date: Mon Feb 28 19:52:38 2022 +0800 Dealing Merge Conflict Git WorkFlow 学习之后，你应该知道标签（Tag）正式情况下更多运用在 master 分支上（生产线上）。 创建标签Git 中支持两种类型的标签： 轻量标签（Lightweight） 附注标签（Annotated） 轻量标签，轻量级的标签，它只是某个特定提交的引用。 而附注标签见名知义，除了引用作用之外，还包含了丰富的信息：打标签者的名字、电子邮件地址、日期时间等。 通常，推荐创建附注标签，这样你可以拥有以上所有信息。但是如果你只是想用一个临时的标签， 或者因为某些原因不想要保存这些信息，那么也可以用轻量标签。 轻量标签创建轻量标签非常简单，没有保存任何其他信息，故创建时只需要提供标签名字即可： 命令格式 –&gt;&gt;&gt; git tag &lt;name&gt; 1234567891011121314# 1.首先，切换到需要打标签的分支上(master)：$ git branch* dev master$ git checkout masterSwitched to branch 'master'# 2.创建 v0.8 版本标签：$ git tag v0.8# 3. 查看当前版本库已有标签$ git tagv0.8# 可以看到，已经成功创建标签 附注标签在 Git 中创建附注标签也十分简单，可以配合 -a &amp;&amp; -m 参数一起使用，例如创建名为 v1.0 的附注标签： 1234$ git tag -a v1.0 -m &quot;Version 1.4: User Authorization&quot;(master) GitTestProject $ git tagv0.8v1.0 参数 -m，你可以理解为提交时的提交信息。如果没有为附注标签指定一条信息，Git 会启动编辑器要求你输入信息。 通过使用 git show 命令查看标签信息和与之对应的提交信息： 123456789101112$ git show v1.0tag v1.0Tagger: TheNightIsYoung &lt;guojie0213_iit@163.com&gt;Date: Sat Mar 5 11:19:29 2022 +0800Version 1.4: User Authorizationcommit 6a9789d4f788a797aa75283c15b521dd6b028be4 (HEAD -&gt; master, tag: v1.0)Author: TheNightIsYoung &lt;guojie0213_iit@163.com&gt;Date: Sat Mar 5 11:18:58 2022 +0800 Tag Test 可以看到，输出显示了打标签者的信息、打标签的日期时间、附注信息，然后显示具体的提交信息。 后期打标签默认标签是打在最新提交的 commit 上的。有时候，如果忘了打标签，比如，现在已经是周五了，但应该在周一打的标签没有打，怎么办？ 方法是你可以对历史提交的 commit id 打标签。 语法规则：git tag -a &lt;tag name&gt; &lt;commit id&gt; 假设当前提交历史是这样的： 12345678910111213141516171819 $ git log --pretty=oneline --abbrev-commit 6a9789d (HEAD -&gt; master, tag: v1.0) Tag Testfb50835 (tag: v0.8, origin/master) Dealing Merge Conflictc07648e (FeatureA) Merge conflic test in FeatureA7d23fef Merge conflic test in master28157d9 Merge with no-ff02636d0 Func-Add Permission(no-ff)b324182 Func-Add User(no-ff)8a39810 Func-Add Permission3d6d64d Func-Add User5f264b1 Merge branch 'featureB'4528426 (featureB) Add BTest File For featureBfc2702b Add ATest File For79c3a2c Add git_rm_test.txtfe3235b git tracks changesd6ddc31 Git local data management test0f5a696 understand how stage worksebba382 Add test codeda1fadc Add help info65586b3 ADD Project Base 现在，假设在 v1.2 时你忘记给项目打标签，也就是在 “Merge branch ‘featureB’” 提交。你可以在之后补上标签: 1$ git tag -a v1.2 5f264b1 这时，Git 会启动编辑器要求你输入标签信息（类似于 git commit）。 可以看到你已经在那次提交上打上标签了： 123456789101112131415161718$ git tagv0.8v1.0v1.2(master) GitTestProject $ git show v1.2tag v1.2Tagger: TheNightIsYoung &lt;guojie0213_iit@163.com&gt;Date: Sat Mar 5 11:41:30 2022 +0800Version 1.2: Add Function-Bcommit 5f264b1aecadb5082627d33d431ee52ce37dcd23 (tag: v1.2)Merge: fc2702b 4528426Author: TheNightIsYoung &lt;guojie0213_iit@163.com&gt;Date: Mon Feb 28 13:17:29 2022 +0800 Merge branch 'featureB' 注意：标签总是和某个 commit 挂钩。如果这个 commit 既出现在 master 分支，又出现在 dev 分支，那么在这两个分支上都可以看到这个标签。 共享标签默认情况下，创建的标签都只存储在本地，git push 命令并不会自动推送标签到远程仓库服务器上。 想要将本地创建的标签同步到远程仓库中，在创建完标签后你必须显式地推送标签到远程仓库上。这个过程就像共享远程分支一样——你可以通过 git push origin &lt;tagname&gt; 实现： 1234567$ git push origin v1.2Enumerating objects: 1, done.Counting objects: 100% (1/1), done.Writing objects: 100% (1/1), 186 bytes | 186.00 KiB/s, done.Total 1 (delta 0), reused 0 (delta 0), pack-reused 0To github.com:TheNightIsYoung/GitTestProject.git* [new tag] v1.2 -&gt; v1.2 如果想要一次性推送很多标签，也可以使用带有 --tags 选项的 git push 命令。 这将会把所有不在远程仓库上的标签全部传送到那里: 12345678$ git push origin --tagsEnumerating objects: 1, done.Counting objects: 100% (1/1), done.Writing objects: 100% (1/1), 187 bytes | 187.00 KiB/s, done.Total 1 (delta 0), reused 0 (delta 0), pack-reused 0To github.com:TheNightIsYoung/GitTestProject.git* [new tag] v0.8 -&gt; v0.8* [new tag] v1.0 -&gt; v1.0 从远程仓库已经可以看到推送上来的所有标签了： 删除标签1 –&gt; 本地标签删除 要删除掉你本地仓库上的标签，可以使用命令: git tag -d &lt;tagname&gt;。 例如，可以使用以下命令删除一个标签： 12345678910$ git tagv0.8v1.0v1.2(master) GitTestProject $ git tag -d v0.8Deleted tag 'v0.8' (was fb50835)$ git tagv1.0v1.2 注意上述命令并不会从任何远程仓库中移除这个标签，你必须用下面命令更新你的远程仓库： 1$ git push &lt;remote&gt; :refs/tags/&lt;tagname&gt; 实测如下： 123$ git push origin :refs/tags/v0.8To github.com:TheNightIsYoung/GitTestProject.git- [deleted] v0.8 登陆 GitHub 查看，发现远程仓库标签已经被删除： 检出标签如果你想查看某个标签所指向的文件版本，可以使用分支介绍中我们提到过的 git checkout 命令，但这会使我们仓库处于 “头指针游离（detached HEAD）” 的状态： 12345678910111213141516171819202122$ git checkout v1.2Note: switching to 'v1.2'.You are in 'detached HEAD' state. You can look around, make experimentalchanges and commit them, and you can discard any commits you make in thisstate without impacting any branches by switching back to a branch.If you want to create a new branch to retain commits you create, you maydo so (now or later) by using -c with the switch command. Example:git switch -c &lt;new-branch-name&gt;Or undo this operation with:git switch -Turn off this advice by setting config variable advice.detachedHead to falseHEAD is now at 5f264b1 Merge branch 'featureB'# 可以看到，HEAD 指针已经切换到 v1.2 了：((v1.2)) GitTestProject $ 为什么会进入游离态？前面介绍 HEAD 指针时说过：HEAD 不指向 branch，而是指向分支上的某一个 commit 时就会进入游离态，再结合命令 git checkout 移动 HEAD 指针来实现切换分支，这里移动 HEAD 指针指向被打了标签的某一个特定提交，所以游离是显而易见的。 HEAD 处于 “游离态” 会产生不好的副作用，如果你做了某些更改然后提交它们，标签不会发生变化， 但你的新提交将不属于任何分支，并且将无法访问。如果你需要进行更改，比如你要修复旧版本中的错误（修复 Bug），那么通常需要创建一个新分支，然后在新分支上进行提交，这时新分支上的内容和 v1.2 就不一样了。 更多关于 HEAD 游离态的说明可以参看博文：Git 使用指南之 HEAD 指针。","link":"/2017/07/05/git-shi-yong-zhi-nan-zhi-workflow-gong-zuo-liu/"},{"title":"Git 使用指南之远程仓库","text":"上一篇博文我们已经掌握了 Git 版本库管理日常操作指令，已经初步达成了简单管理日常项目的目标，再也不用担心文件备份或者丢失的问题了。有用过集中式版本控制系统 SVN 的童鞋会说，这些功能在 SVN 里早就有了，没看出 Git 有什么特别的地方。 确实没错，如果只是作为仓库管理文件历史，Git 和 SVN 还真没啥区别，但项目开发不仅仅是管理文件历史。为了体现 Git 作为分布式版本控制系统较于 SVN 的优势（不做“杠精”哈~），本篇我们将介绍 Git 的杀手锏功能之一：Git 远程仓库，这也是 Git 迅速流行的主要原因。 版权说明： 本文思路以及内容主要来自廖雪峰老师的 Git 教程 （强烈推荐膜拜原文），并结合个人使用所作，只作为学习记录使用。如内容有侵权请联系删除，禁止转载！ 更多 Git 相关内容，请关注博主 Git 博文系列： 之一 &gt;&gt;&gt; Git 使用指南之初识 之二 &gt;&gt;&gt; Git 使用指南之时光穿梭机 之三 &gt;&gt;&gt; Git 使用指南之远程仓库 之四 &gt;&gt;&gt; Git 使用指南之分支管理 之五 &gt;&gt;&gt; Git 使用指南之 WorkFlow (工作流) 之六 &gt;&gt;&gt; Git 使用指南之 Git 自定义 之七 &gt;&gt;&gt; Git 使用指南之 HEAD 指针 之八 &gt;&gt;&gt; Git 使用指南之 Git 中的黑魔法 Git 分布式版本控制策略Git 是分布式版本控制系统，意味着同一个 Git 仓库，可以分布到不同的机器上。 怎么分布呢？ 起初肯定只有一台机器有一个原始版本库，此后别的机器可以 克隆 这个原始版本库，而且每台机器的版本库其实都是一样的，并且没有主次之分。 那么 如何保证所有分布式节点版本库数据同步呢？ 考虑以下场景： 某个项目由多人负责开发，想要实现所有人项目版本库数据同步 多地点不同机器进行项目开发（公司，家等），难道每天需要将项目拷贝过来拷贝过去？ 我们在介绍版本控制系统的集中式和分布式区别时，我们提到过：分布式不像集中式一样有中央服务器，但它会选用一台服务器充当“中央服务器”的角色。 实际使用情况确实如此，找一台电脑充当服务器的角色，每天24小时开机，分布式系统中其它每个用户都从这个 “中央服务器” 仓库克隆一份到自己的电脑上，并且各自把各自的最新提交推送到服务器仓库里，也从服务器仓库中拉取别人的提交。 在公司局域网内进行项目开发时，完全可以搭建一台运行 Git 的 “中央服务器” 进行项目开发。不过为了学习 Git，先搭个服务器绝对是小题大作（看官老爷也要骂街了~）。不知道你还记不记得之前我们提过的 GitHub —&gt; 提供了远程 Git 仓库托管服务的，只要注册一个 GitHub 账号，就可以免费获得 Git 远程仓库，然后就可以将其作为 “中央服务器” 使用了。 P.S. 如果你想要尝试一下个人搭建 Git 服务器，可以了解一下 GitLab。 后续我们将以 GitHub 作为远程仓库（中央仓库）进行继续学习，阅读后续内容前，请自行注册 GitHub 账号。 Github首先我们给出 GitHub 登陆界面： SSH Reff我们需要知道：本地 Git 仓库和远程 GitHub 仓库之间的传输是通过 SSH 加密的，所以首先我们需要设置 Git 和 GitHub 之间的 SSH，只有配置了 SSH，Git 才可以和 GitHub 远程仓库进行同步通信（SSH 保证了 Git 与 Github 之间的通信安全，防止其它人恶意操作你的 Github 仓库）。 SSH 是一种通讯协议，是用于实现 远程安全登录 的。有使用过在 Windows 下远程登录 Linux 服务器进行文件互传的看官，相信会对 SSH 有初步的了解，你可以直接跳过下面关于 SSH 安全机制的说明。 |—————————— SSH 安全机制 ——————————| SSH 之所以能够保证安全，原因在于它采用了非对称加密技术(RSA)的安全机制，提供两种级别的验证方法： 第一种级别（基于口令的安全验证）：只要你知道自己帐号和口令，就可以登录到远程主机。所有传输的数据都会被加密，但是不能保证你正在连接的服务器就是你想连接的服务器。可能会有别的服务器在冒充真正的服务器，这是危险的。 第二种级别（基于密钥的安全验证）：必须为自己创建一对密钥，并把公钥放在需要访问的服务器上。如果你要连接到 SSH 服务器上，客户端软件就会向服务器发出请求，请求用你的密钥进行安全验证。服务器收到请求之后，先在该服务器上你的主目录下寻找你的公钥，然后把它和你发送过来的公钥进行比较。如果两个密钥一致，服务器就用公钥加密 “质询”（challenge）并把它发送给客户端软件。客户端软件收到 “质询” 之后就可以用你的私钥在本地解密再把它发送给服务器完成登录。 Config SSH Key For Git下面来看如如何为 GiHub 配置本地 Git 仓库机器的 SSH： 1 –&gt; 本地 Git 创建 SSH Key 检查用户主目录（~）下是否有 .ssh 目录，以及 .ssh 目录下是否有 id_rsa 和 id_rsa.pub 这两个文件。如果都存在，可以跳过当前步骤，否则通过 Shell（ Windows 下打开 Git Bash），使用邮箱创建 SSH Key： 1$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot; 将 youremail@example.com 换成可用的邮件地址，然后一路回车，使用默认值即可。 如果创建成功的话，可以在用户目录下找到 .ssh 目录，并且 .ssh 目录中还有 id_rsa 和 id_rsa.pub 两个文件（SSH Key 的秘钥对）。其中 id_rsa 是私钥，id_rsa.pub 是公钥。 2 –&gt; GitHub Settings 登陆 GitHub，打开 “Settings” –&gt; “SSH and GPG keys” 页面： 然后点击 “Add SSH Key”，填任意 Title，在 Key 文本框里粘贴本地 Git 节点中 id_rsa.pub 文件的内容，点击下方 “Add SSH Key” 即可查看到添加好的 SSH Key 了： |—————————————————————– 内容补充： 为什么 GitHub 需要 SSH Key 呢？因为 GitHub 需要识别出推送的提交确实是你推送的，而不是别人冒充的，而 Git 支持 SSH 协议，所以 GitHub 只要知道了你的公钥，就可以确认只有你自己才能推送。 当然，GitHub 允许用户添加多个 SSH Key。假定你有若干台设备时，只要把每台设备的 Key 都添加到 GitHub，就可以在每台设备上往 GitHub 进行推送了（是不实现了版本库的数据同步了）。 注意：GitHub 上免费托管的 Git 仓库，任何人都可以看到（但只有你自己才能改）。所以，不要把敏感信息放进去。当然你可以使用 GitHub 创建私有仓库。 —————————————————————–| SSH Key 添加成功之后，我们可以在 Git bash 中进行测试： 123$ ssh -T git@github.comWarning: Permanently added the RSA host key for IP address 'X.X.X.X' to the list of known hosts.Hi TheNightIsYoung! You've successfully authenticated, but GitHub does not provide shell access. 返回 “Hi username ！You’ve successfully ……” 说明你已经成功啦！ Add Repo For Local Git当前的场景是：我们的本地机器已经拥有了一个本地 Git 仓库，想将 GitHub 作为本地 Git 某个仓库（GitTestProject）的远程仓库（“中央仓库”）。这样 GitHub 上的仓库既可以作为备份，又可以让其他人通过该仓库来协作，真是一举多得。 1 –&gt; GitHub 上创建一个新仓库，作为中央仓库（备份、同步仓库） 这里我们还是以 GitTestProject 作为项目名称。创建好后，GitHub 上的这个 GitTestProject 仓库还是空的。 可以看到，GitHub 告诉我们：可以从这个仓库克隆出新的仓库；也可以把一个已有的本地仓库与之关联，然后把本地仓库的内容推送到 GitHub 仓库；还可以从其它仓库导入代码。 这里我们只关注本地 Git 仓库与其进行关联。 2 –&gt; 本地 Git 仓库关联 GitHub 远程仓库 根据你自己的 …or push an existing repository from the command line 中关联命令在 GitTestProject 目录下进行关联操作： CMD 9 –&gt;&gt;&gt; git remote add &lt;repo name&gt; &lt;repo addr&gt; 12# 将地址为：git@github.com:TheNightIsYoung/GitTestProject.git 的远程仓库 origin（别名）链接到当前本地 Git 仓库$ git remote add origin git@github.com:TheNightIsYoung/GitTestProject.git 注意：TheNightIsYoung 应该是你 GitHub 的用户名。如果使用成我的，关联没问题，但你无法推送（未添加你设备的 SSH Key）。 添加后，远程库的名字就是 origin，这是 Git 默认的叫法（比较形象），当然也可以改成别的。 修改本地映射的远程库的名字：git remote rename 3 –&gt; 推送本地 Git 所有内容到 GitHub 把本地库的内容推送到远程，用 git push 命令，实际上是把当前分支 master 推送到远程。 CMD 10 –&gt;&gt;&gt; git push &amp;&amp; git pull 123456789101112131415$ git push -u origin masterThe authenticity of host 'github.com (127.8.0.1)' can't be established.RSA key fingerprint is SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8.Are you sure you want to continue connecting (yes/no)? yesWarning: Permanently added 'github.com' (RSA) to the list of known hosts.Enumerating objects: 29, done.Counting objects: 100% (29/29), done.Delta compression using up to 8 threadsCompressing objects: 100% (19/19), done.Writing objects: 100% (29/29), 2.32 KiB | 395.00 KiB/s, done.Total 29 (delta 5), reused 0 (delta 0)remote: Resolving deltas: 100% (5/5), done.To github.com:TheNightIsYoung/GitTestProject.git * [new branch] master -&gt; masterBranch 'master' set up to track remote branch 'master' from 'origin'. |—————————————————————– SSH 连接警告 当你第一次使用 Git 的 clone 或者 push 命令连接 GitHub 时，会得到一个警告： 123The authenticity of host 'github.com (xx.xx.xx.xx)' can't be established.RSA key fingerprint is xx.xx.xx.xx.xx.Are you sure you want to continue connecting (yes/no)? 这是因为 Git 首次使用 SSH 连接，而 SSH 连接在第一次验证 GitHub 服务器的 Key 时，需要你确认 GitHub 的 Key 的指纹信息是否真的来自 GitHub 的服务器，输入 yes 回车即可。 后续，Git 会输出一个警告，告诉你已经把 GitHub 的 Key 添加到本机的一个信任列表里了： 1Warning: Permanently added 'github.com' (RSA) to the list of known hosts. 这个警告只会出现一次，后面的操作就不会有任何警告了。 如果你实在担心有人冒充 GitHub 服务器，输入 yes 前可以对照 GitHub 的 RSA Key 的指纹信息 是否与 SSH 连接给出的一致。 参数说明 由于远程库是空的，我们第一次推送 master 分支时，加上了 -u 参数，Git 不但会把本地的 master 分支内容推送的远程新的 master 分支，还会把本地的 master 分支和远程的 master 分支关联起来，在以后的推送或者拉取时就可以简化命令（直接使用 git pull or git push）。 —————————————————————–| 4 –&gt; 查看 GitHub GitTestProject 仓库 推送成功后，可以立刻在 GitHub 页面中看到远程库的内容已经和本地一模一样： 从现在起，只要本地作了提交，就可以通过命令： 1$ git push origin master 把本地 master 分支的最新修改推送至 GitHub（origin）。到这里你就拥有了真正的分布式版本库！ Remove Repo For Local Git如果添加的时候地址写错了，或者就是想删除远程库，可以用如下命令删除远程仓库的关联： CMD 11 –&gt;&gt;&gt; git remote rm &lt;repo name&gt; 建议先用 git remote -v 查看远程库信息： 123$ git remote -vorigin git@github.com:TheNightIsYoung/GitTestProject.git (fetch)origin git@github.com:TheNightIsYoung/GitTestProject.git (push) 然后，根据名字删除，比如删除 origin： 1$ git remote rm origin 注意：此处的 “删除” 其实是 解除了本地和远程的绑定关系，并不是物理上删除了远程库。远程库本身并没有任何改动。要真正删除远程库，需要登录到 GitHub，在后台页面找到删除按钮再删除。 Clone Repo From Github之前我已经创建好了一个 GitTestProject 远程库，并且关联到了我自己的本地测试项目仓库。 多个人协作开发时，其他人要想获取我的版本库的话，可以直接使用 git clone 从我的 GitHub 克隆一个 GitTestProject 本地库： CMD 12 –&gt;&gt;&gt; git clone &lt;repo addr&gt; 12345$ git clone git@github.com:TheNightIsYoung/GitTestProject.gitCloning into 'gitskills'...remote: Counting objects: 3, done.remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 3Receiving objects: 100% (3/3), done. GitHub 给出的地址不止一个，还可以用 https://github.com/TheNightIsYoung/GitTestProject.git 这样的地址。实际上 Git 支持多种协议，默认使用 SSH 协议，即 git://xxxxx ，但也可以使用 https 等其他协议。 使用 https 除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令，但是在某些只开放 http 端口的公司内部就无法使用 ssh 协议而只能用 https。 Git Clone 仓库中的单个目录 很多时候，由于项目较大，我们只想 git clone 仓库的某单个或多个文件夹，而不是全部的仓库内容。 Git1.7.0 以前，这无法实现。但是幸运的是，在 Git1.7.0 以后加入了 Sparse Checkout 模式，这使得 CheckOut 指定文件或者文件夹成为可能。 假设我们有一个 Github 仓库：https://github.com/yourgithub/Demo，我们想要 git clone Demo 里面的 childDir 子目录： 1234567891011121314151617181920212223###注意： 'childDir' 需要替换为自己想要下载的目录名称：# 初始化本地仓库：$ git init Demo &amp;&amp; cd Demo# 设置允许进行子目录克隆：$ git config core.sparsecheckout true$ 设置目标子目录名称（假设我的 childDir 位于 https://github.com/yourgithub/Demo/code 下）：echo 'code/childDir*' &gt;&gt; .git/info/sparse-checkout$ 映射：git remote add origin https://github.com/yourgithub/Demo.git# 拉取：$ git pull origin masterremote: Enumerating objects: 2750, done.remote: Total 2750 (delta 0), reused 0 (delta 0)Receiving objects: 100% (2750/2750), 36.41 MiB | 10.38 MiB/s, done.Resolving deltas: 100% (542/542), done.From e.coding.net:xdzsoft/mashangwuyou * branch master -&gt; FETCH_HEAD * [new branch] master -&gt; origin/master OK!!! 配置多个 SSH Key事实上，除了 Github 提供远程 Git 仓库托管服务，国内也有一些优秀的远程 Git 仓库托管服务平台（Gitee、Coding …），只要注册相关平台账号，就可以免费使用 Git 远程仓库，而且由于这些平台在国内，所以可以为我们提供更快的访问速度。 随着工作与学习的不断深入，你会拥有多个 Git 账户。比如公司 Gitlab 一个工作账号，Github 和 Gitee 一个个人学习账号，Coding 一个个人项目账号。而平时我们又会通过配置 SSH 公私钥认证的方式省去繁琐的登录远程仓库的操作，不同的 Git 账户一般都是不同的邮箱，而 SSH Key 又通过邮箱生成，那么就会涉及到为不同 Git Host 配置多对 ssh key 的问题。 详细步骤如下（以 Gitlab &amp;&amp; Gitee 为例）： 1 –&gt; 为公司账号生成一对密钥（Gitlab） 通过 -f 参数指定生成的密钥文件的名称 1$ ssh-keygen -t rsa -C &quot;yourEmail1@xx.com&quot; -f ~/.ssh/gitlab_id_rsa 执行后，生成公私钥文件如下： 12your identification has been saved in /home/xx_usr/.ssh/gitlab_id_rsa. ==&gt; 私钥your public key has been saved in /home/xx_usr/.ssh/gitlab_id_rsa_pub. ==&gt; 公钥 2 –&gt; 为个人账号生成一对密钥（Gitee） 通过 -f 参数指定生成的密钥文件的名称 1$ ssh-keygen -t rsa -C &quot;yourEmail2@xx.com&quot; -f ~/.ssh/gitee_id_rsa 执行后，生成公私钥文件如下： 12your identification has been saved in /home/xx_usr/.ssh/gitee_id_rsa. ==&gt; 私钥your public key has been saved in /home/xx_usr/.ssh/gitee_id_rsa_pub. ==&gt; 公钥 3 –&gt; 配置不同 SSH Key 使用规则 在 ~/.ssh 目录下新建名为 config 的文件（无后缀），config 文件用于配置多个不同的 Git Host 使用不同的 ssh key ： 1234567891011# giteeHost gitee.com HostName gitee.com PreferredAuthentications publickey IdentityFile ~/.ssh/gitee_id_rsa# gitlabHost gitlab.com HostName gitlab.com PreferredAuthentications publickey IdentityFile ~/.ssh/gitlab_id_rsa 配置文件参数说明： Host：用于区别不同平台的识别模式，名字随意； HostName：登录服务器的域名地址或者 ip 地址； PreferredAuthentications：配置登录时用什么权限认证 –&gt; 可设置 publickey，password publickey； IdentityFile：私钥路径。 4 –&gt; 配置平台的 SSH 将上面生成的公钥文件 gitlab_id_rsa_pub &amp;&amp; gitee_id_rsa_pub 中的内容，分别添加到 Gitlab 和 Gitee 平台的 SSH 中，添加过程类似于 Github。 5 –&gt; 连接测试 配置完成之后测试一下，成功显示如下： 1234$ ssh -T git@gitee.comHi TheNightIsYoung! You've successfully authenticated, but GITEE.COM does not provide shell access.Jie Guo Desktop $ ssh -T git@github.comHi TheNightIsYoung! You've successfully authenticated, but GitHub does not provide shell access. ================================== Permission denied (publickey) ================================== 这里有可能产生异常：git@gitee.com: Permission denied (publickey).，可以尝试如下操作： 删除掉 config 配置文件中相关条目的 PreferredAuthentications 项目。 ============================================================================================== 至此，你可以像使用 Github 平台一样使用其它平台提供的 Git 仓库托管服务了~~~","link":"/2017/07/03/git-shi-yong-zhi-nan-zhi-yuan-cheng-cang-ku/"},{"title":"HTML 教程之 HTML 基础语法","text":"HTML 英文全称是 Hyper Text Markup Language，中文译为 “超文本标记语言”，专门用来设计和编辑网页。 深入了解 HTML前面提到过，HTML 是一种超文本标记语言，不是编程语言，没有逻辑处理能力，没有计算能力，不能动态地生成内容，而只能静态地描述网页信息。 1 &gt;&gt;&gt; 超文本特性 尽管 HTML 文档是一个纯文本文档（HTML 标签 &amp;&amp; 纯文本），但其通过标记标签，可以描述超越纯文本的信息，图片、音视频、表格、列表、链接、按钮、输入框等高级内容。 而其中的超链接又是互联网的纽带，它能将众多网页连接起来，让它们交织在一起，形成一张“网”。没有超链接，就没有互联网。 2 &gt;&gt;&gt; 标记语言特性 HTML 尽管也是一种计算机语言，但它不能编程，只能使用标签来描述网页中的内容。通过不同的标签来描述不同的页面内容、格式、布局等。 也就是说 &gt;&gt;&gt; HTML 是一种用来设计和编写网页的计算机语言。它通过标签（HTML Tag）将文本、音视频、图片、表格、按钮、输入框等页面需要显示的内容描述出来，同时，对网页内容进行排版和布局。 HTML 版本说明自万维网 诞生之后随即就出现了非标准化的 HTML 语言，经过后续不断的发展，HTML 已经更新了多个版本： 发布时间 版本说明 HTML 版本 1989 Tim Berners-Lee 发明万维网 WWW 1991 Tim Berners-Lee 制定 HTML 规范 HTML 1.0 1995 HTML 工作组定义 HTML 2.0 HTML 2.0 1997 W3C 推荐标准: HTML 3.2 HTML 3.2 1999 W3C 推荐稳定标准: html 4.01，该版本之后增加了对样式表（CSS）的支持，是当前的官方标准 HTML 4.01 2000 W3C 推荐标准: XHTML 1.0 XHTML 1.0 2008 WhatWG 首次公开 HTML5 HTML5 HTML 4 &amp;&amp; HTML 5（简称 H5）是两个最重要版本，HTML 4 适应了 PC 互联网时代，HTML 5 适应了移动互联网时代。 HTML 5 在 HTML 4 的基础上增加了很多语义化的标签，功能更加强大，除了较低版本的 IE 浏览器，几乎所有其它浏览器都能很好地支持 HTML 5。如果您的用户很少使用 IE 浏览器，那么请放心地使用 HTML 5。 HTML 基本概念这里，首先给出一个 HTML 文档 Demo（如下）用于进行后续 HTML 相关语法的说明： 1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;title&gt;页面标题&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;这是一个标题&lt;/h1&gt; &lt;p&gt;这是一个段落。&lt;/p&gt; &lt;p&gt;这是另一个段落。&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; HTML 文档是由 HTML 标签组成的网页描述性文档，HTML 标签可以描述文本、图形 、动画、声音 、表格、链接等。 HTML 的结构包括头部 （Head）、主体（Body）两大部分。头部描述浏览器所需的信息，主体包含所要说明的具体内容。 需要注意的是，本章节中提及到的各种 HTML 标签、属性等，你可以不用深究。这里只是为了认知 HTML 标签 &amp;&amp; 元素 &amp;&amp; 属性 等概念给出的样例，后续博文会有专门的章节进行说明。 HTML 标签HTML 使用标记标签来设计和编写网页，通常也被称之为 HTML 标签（HTML Tag）。其特性如下： HTML 标签是由 尖括号 包围的关键词，如 &lt;html&gt;； HTML 标签 大多数是成对出现 的，比如 &lt;html&gt; ... &lt;/html&gt; &amp;&amp; &lt;b&gt; ... &lt;/b&gt;；也有一些单标签：&lt;br/&gt;； HTML 标签对中，第一个是 开始标签（开放标签），第二个是 结束标签（闭合标签）；单标签（自闭合标签）开始和结束标签合并表示； HTML 标签使用要遵循语法规范，有开始标签，就要有对应的结束标签。 参考 Demo 中 HTML 代码 &gt;&gt;&gt;&gt; 标签 &lt;h1&gt;&lt;/h1&gt;：用于标记当前为一级标题 h1; 标签 &lt;p&gt;&lt;/p&gt;：用于标记当前为一个段落; &amp;&amp; …. 实际上，学习 HTML 其实就是学习各个标签的含义，根据实际场景的需要，选择合适的标签，从而制作出精美的网页。 标签内容开放标签和闭合标签之间的部分，为相应标签的内容。 例如，&lt;h1&gt;这是一个标题&lt;/h1&gt; &gt;&gt;&gt; 其内容为：这是一个标题；&lt;p&gt;这是一个段落。&lt;/p&gt; &gt;&gt;&gt; 其内容为：这是一个段落。。 自闭合标签少部分的 HTML 标签为单标签，其开始和结束标签合并表示（直接在开始标签中添加 / 来进行闭合），也称为 自闭合标签。 例如：&lt;br/&gt; &gt;&gt;&gt; 表示文本换行 &amp;&amp; &lt;hr/&gt; &gt;&gt;&gt; 表示分割线 &amp;&amp; &lt;img src=&quot;...&quot; alt=&quot;...&quot; /&gt; &gt;&gt;&gt; 表示图像 等等。 需要注意的是：自闭合标签不需要单独的结束标签，不用包围内容！！！ 标签嵌套HTML 标签是支持嵌套使用的，也就是说一个 HTML 标签中可以包含其他的 HTML 标签。来看一个实例： 1&lt;p&gt;这是一个段落。&lt;font color=&quot;red&quot;&gt;该部分文字为红色&lt;/font&gt; &lt;/p&gt; HTML 5 标准中，&lt;font&gt; 标签已经成为一种不被建议使用的标签了，请尽量使用 CSS 来设置文本样式。 可以看到，我们在 &lt;p&gt; 标签内容中嵌套了一个 &lt;font&gt; 标签，这是符合语法规范的。 需要注意的是 &gt;&gt;&gt; 尽管标签嵌套层次没有限制的，但是我们应尽量保持 HTML 文档的简洁。并且存在多层次标签嵌套时，一定要注意该闭合的标签一定要闭合，否则可能会引发一些意外。 HTML 元素HTML 文档（Web Page）由 HTML 元素定义，HTML 元素指的是从开始标签（Start Tag）到结束标签（End Tag）的所有代码。 元素的内容是开始标签与结束标签之间的内容； 某些 HTML 元素具有空内容，如自闭合元素 &lt;br/&gt;，也称为空元素； 大多数 HTML 元素可拥有属性。 例如：&lt;p&gt; 元素 == &lt;p&gt;这是一个段落。&lt;/p&gt; | &gt;&gt;&gt; ==================================== Split Line ================================== &lt;&lt;&lt; | 更一般 HTML 元素格式 &gt;&gt;&gt; 【开始标签 &amp;&amp; 属性 &amp;&amp; 内容 &amp;&amp; 结束标签】，以字体标签为例： 1&lt;font color=&quot;red&quot;&gt;字体颜色为红色&lt;/font&gt; 关于元素属性这里不用深究，见下一小节中属性的相关说明。 其中，&lt;font&gt; 为开始标签；color=&quot;red&quot; 为标签属性；字体颜色为红色 为内容；&lt;/font&gt; 为结束标签。 HTML 属性属性是用来修饰 HTML 标签（元素）的，以提供一些额外的内容描述信息。 属性需要以 “键值对（key=”value”）” 的形式添加在开始标签中（Start Tag），语法格式为： 1attr=&quot;value&quot; attr 表示属性名，value 表示属性值。属性值必须使用双引号 &quot; &quot;（语法规范推荐） 或者单引号 ' ' 包围，当属性值本身就含有双引号，那么必须使用单引号。 来看一个属性使用实例： 1&lt;h1 align=&quot;center&quot;&gt;居中标题&lt;/h1&gt; 其中，align 为属性名，center 为属性值。 HTML 中支持的标签属性有很多，大体可以分为三类： 通用属性：有些属性适用于 &gt;&gt;&gt; 大部分或者所有 HTML 标签； 专用属性：有些属性只适用于 &gt;&gt;&gt; 一个或者几个特定的 HTML 标签； 自定义属性：HTML 中也允许我们自定义属性，以提供标签的更多描述。 标签可以没有属性，也可以有一个或者多个属性（≥0 个）。当标签使用多个属性修饰时，使用空格隔开即可。 专用属性例如，HTML 中的 &lt;img&gt; 标签就有 src 和 alt 两个专用属性，&lt;a&gt; 标签也有 href 和 target 两个专用属性，如下例所示： 12&lt;img src=&quot;./logo.png&quot; alt=&quot;Markdown Icon Font&quot; width=&quot;100&quot; height=&quot;50&quot;&gt;&lt;a href=&quot;https://www.baidu.com/&quot; target=&quot;_blank&quot;&gt;百度一下，你就知道&lt;/a&gt; 属性说明 &gt;&gt;&gt; &lt;img&gt; 标签中的 src 属性用来定义图像的路径，alt 属性用来定义图像的描述信息，当图像出现异常无法正常显示时就会显示 alt 中的信息； &lt;a&gt; 标签的 href 属性用来定义链接的地址，target 属性用来定义新页面在浏览器中的打开方式。 通用属性HTML 标签中有一些常见的通用属性，如 id &amp;&amp; title &amp;&amp; class &amp;&amp; style 等，这些通用属性可以在大多数 HTML 标签中都支持。 [1] &gt;&gt;&gt; id id 属性用来赋予某个标签唯一的名称（标识符），可用于 标签定位。当我们使用 CSS 或者 JavaScript 来访问和操作这个标签时，就可以通过 id 属性来找到这个标签。 注意：在一个 HTML 文档中 id 属性的值必须是唯一的，即不能存在多个有相同 id 的标签或元素。 为标签定义 id 属性可以给我们提供很多便利： 如果标签中带有 id 属性作为唯一标识符，通过 id 属性可以很方便的定位到该标签； 如果 HTML 文档中包含多个同名的标签，利用 id 属性的唯一性，可以很方便的区分它们。 示例代码如下： 12&lt;input type=&quot;text&quot; id=&quot;username&quot; /&gt;&lt;p id=&quot;url&quot;&gt;https://www.baidu.com/&lt;/p&gt; [2] &gt;&gt;&gt; class 与 id 属性类似，class 属性也可以为标签定义名称（标识符）。 但不同的是 class 属性在整个 HTML 文档中不必是唯一的，我们可以为多个标签定义相同的 class 属性值，还可以为一个标签定义多个不同的 class 属性值。 示例代码如下： 123&lt;div class=&quot;className1 className2 className3&quot;&gt;&lt;/div&gt;&lt;p class=&quot;content&quot;&gt;https://www.baidu.com/&lt;/p&gt;&lt;div class=&quot;content&quot;&gt;https://www.baidu.com/&lt;/div&gt; 为标签定义 class 属性后，当使用 CSS 或者 JavaScript 来操作 HTML 标签时，同样可以使用 class 属性来找到对应的 HTML 标签。 需要注意的 &gt;&gt;&gt; 不同于 id 属性，由于 class 属性不是唯一的，所以通过 CSS 或 JavaScript 对 HTML 标签的操作会应用于所有具有同名 class 属性的标签中。 你可以将 具有相同 class 属性的标签看作一个标签族，对其操作会应用于所有具有同名 class 属性的标签中。 [3] &gt;&gt;&gt; title title 属性用来对标签内容进行描述说明，当鼠标移动到该标签上方时会显示出 title 属性的值。 示例代码如下： 1&lt;p title=&quot;这是一个链接&quot;&gt;https://www.baidu.com/&lt;/p&gt; 注意：将鼠标在链接处悬停片刻才能看到提示框。 [4] &gt;&gt;&gt; style style 属性规定了元素的行内样式（inline style），用来为标签内容定义 CSS 样式，例如设置文本颜色、标题居中等。 其属性值是一个或多个由分号分隔的 CSS 属性:值 对，例如 color:blue; text-align:center。 示例代码如下： 12&lt;h1 style=&quot;color:blue;text-align:center&quot;&gt;这是一个标题&lt;/h1&gt;&lt;p style=&quot;color:green&quot;&gt;这是一个段落。&lt;/p&gt; 需要注意的是，style 属性将覆盖任何全局的样式设定，例如在 &lt;style&gt; 标签或在外部样式表中规定的样式。 HTML 4.01 中, style 属性不能用于: &lt;base&gt; &amp;&amp; &lt;head&gt; &amp;&amp; &lt;html&gt; &amp;&amp; &lt;meta&gt; &amp;&amp; &lt;param&gt; &amp;&amp; &lt;script&gt; &amp;&amp; &lt;style&gt; &amp;&amp; &lt;title&gt;。而 HTML5 中, style 属性可用于任何的 HTML 元素 (它会验证任何 HTML 元素。但不一定是有用)。 自定义属性除了自带的属性，HTML 也允许我们自定义属性。 这些属性虽然可以被浏览器识别，但是并不会添加什么特殊效果，你可以尝试随别添加一个属性尝试一下。 但此时，我们可以借助 CSS 和 JavaScript 处理自定义属性，为 HTML 标签添加指定样式或者行为。 对于自定义属性的使用，后续学习 CSS 和 JavaScript 时你会有更深入的了解。 HTML 注释HTML 注释主要用来对文档中的代码进行解释说明，注释也是代码的一部分，但浏览器会自动忽略注释的内容，所以用户在网页中是看不到注释的。 注释的功能[1] &gt;&gt;&gt; 代码说明 通常，一个完整的 HTML 文档往往由成百上千行代码组成，当我们想要修改其中的某个部分时，可能需要花费很长的时间才能找到想要修改的地方。可以根据功能或者其它条件将程序划分为若干个部分并通过注释进行标记，这样可以帮助您和他人阅读您的代码，提高代码的可读性。 [2] &gt;&gt;&gt; 代码注释 除了可以对代码进行说明外，还可以用来注释程序中的代码。 例如当不希望某段代码执行时，就可以先将它们注释掉，这样浏览器就不会执行这段代码了。 注释语法格式HTML 文档中，使用注释标签 &lt;!-- &amp;&amp; --&gt; 来插入注释，支持行注释和块注释。语法格式如下： 1234567&lt;!-- 这是一个行注释 --&gt;&lt;br/&gt;&lt;!--这是一个多行注释--&gt; 条件注释HTML 中你偶尔还会发现一种条件注释，条件注释仅对 Windows 系统上的 Internet Explorer（IE）浏览器中有效，其他的浏览器会忽略它们。 需要注意的是 &gt;&gt;&gt;&gt; Internet Explorer 从 IE5 开始支持条件注释，您可以使用条件注释为使用 IE 浏览器的用户提供一些说明。自 IE10 起，标准模式不再支持条件注释。 [1] &gt;&gt;&gt; 语法格式 1&lt;!--[if expression]&gt; HTML Code &lt;![endif]--&gt; 比较 IE 版本将会用到如下关键字： lt：less than &gt;&gt;&gt; 小于； lte：less than or equal to &gt;&gt;&gt; 小于或等于； gt：greater than &gt;&gt;&gt; 大于； gte：greater than or equal to &gt;&gt;&gt; 大于或等于； ! &gt;&gt;&gt; 不等于； () &gt;&gt;&gt; 子表达式运算符； &amp; ：AND &gt;&gt;&gt; AND 运算符； | ：OR &gt;&gt;&gt; OR 运算符； 示例代码如下（你可以在不同浏览器下尝试一下）： 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;IE Explorer Conditional Annotation&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;根据不同的 IE 版本显示不同的内容&lt;/h1&gt; &lt;!-- 如果使用 IE Explorer，则显示 --&gt; &lt;!--[if IE]&gt; &lt;p&gt;您正在使用 IE 浏览器&lt;/p&gt; &lt;![endif]--&gt; &lt;!-- 如果使用 IE8 Explorer，则显示 --&gt; &lt;!--[if IE 8]&gt; &lt;p&gt;您正在使用 IE8 浏览器&lt;/p&gt; &lt;![endif]--&gt; &lt;!-- 如果不是使用 IE7 Explorer，则显示 --&gt; &lt;!--[if !IE 7]&gt; &lt;p&gt;您正在使用不是 IE7 浏览器&lt;/p&gt; &lt;![endif]--&gt; &lt;!-- 如果 Explorer 版本小于 IE10，则显示 --&gt; &lt;!--[if lt IE 10]&gt; &lt;p&gt;您正在使用 IE10 以下的版本&lt;/p&gt; &lt;![endif]--&gt; &lt;!-- 如果 Explorer 版本大于 IE6，则显示 --&gt; &lt;!--[if gt IE 6]&gt; &lt;p&gt;您正在使用 IE6 以上的版本&lt;/p&gt; &lt;![endif]--&gt; &lt;/body&gt;&lt;/html&gt; [2] &gt;&gt;&gt; 使用场景 条件注释可以检测当前浏览器是否是 IE，以及 IE 版本。于是，开发人员可以根据不同的 IE 浏览器加载不同的 CSS 或者 JS 脚本。 示例代码如下： 12345678910&lt;!DOCTYPE html&gt;&lt;!--[if lt IE 7 ]&gt;&lt;html class=&quot;ie6&quot; lang=&quot;zh-cn&quot;&gt;&lt;![endif]--&gt;&lt;!--[if IE 7 ]&gt;&lt;html class=&quot;ie7&quot; lang=&quot;zh-cn&quot;&gt;&lt;![endif]--&gt;&lt;!--[if IE 8 ]&gt;&lt;html class=&quot;ie8&quot; lang=&quot;zh-cn&quot;&gt;&lt;![endif]--&gt;&lt;!--[if IE 9 ]&gt;&lt;html class=&quot;ie9&quot; lang=&quot;zh-cn&quot;&gt;&lt;![endif]--&gt;&lt;!--[if (gt IE 9)|!(IE)]&gt;&lt;!--&gt;&lt;html class=&quot;&quot; lang=&quot;zh-cn&quot;&gt;&lt;!--&lt;![endif]--&gt;......&lt;/html&gt; IE 浏览器对 HTML5 支持不太友好，并且 IE 已经逐渐退出市场，各大互联网巨头也不再兼容 IE，开发过程中如果没有特殊情况也不用重点考虑 IE。 第三方软件程序注释各种 HTML 相关的软件程序也能够生成 HTML 注释。 例如 标签会被包围在由 FrontPage 和 Expression Web 创建的 HTML 注释中。 作为一项规则，这些标签的存在，有助于对创建这些标签的软件进行支持。 HTML 编码问题有时在浏览器中预览 HTML 页面时会出现 中文乱码 的问题。 这是由于 HTML 文档是一种纯文本文件，因此会涉及到文件编码格式的问题。也就是说， Web 浏览器必须知道要使用哪种编码来进行显示。 [1] &gt;&gt;&gt; HTML 字符集 从 ASCII 到 UTF-8 ↓↓↓↓↓↓↓↓↓↓ ASCII 是第一个字符编码标准。ASCII 定义了 128 种可以在互联网上使用的字符：数字（0-9）、英文字母（a-z &amp;&amp; A-Z）和一些特殊字符，比如：! $ + - ( ) @ &lt; &gt;。 ISO-8859-1 是 HTML 4 的默认字符集。此字符集支持 256 个不同的字符代码。HTML 4 同时支持 UTF-8。 ANSI（Windows-1252） 是原始的 Windows 字符集。 ANSI 与 ISO-8859-1 相同，不同之处在于 ANSI 具有 32 个额外的字符。 [2] &gt;&gt;&gt; Solution HTML5 规范鼓励 Web 开发人员使用 UTF-8 字符编码，该字符集涵盖了世界上几乎所有的字符和符号！可用于解决页面显示乱码问题。 你可以在 &lt;head&gt; 元素中添加如下： 123&lt;head&gt;&lt;meta charset=&quot;UTF-8&quot;&gt;&lt;/head&gt; 如果你对编码格式不了解的话，请猛击链接学习 &gt;&gt;&gt; 编程基础之编码详解。 HTML 语法规范类似于其它计算机语言，在编写 HTML 代码时通常会有以下两种主要类型的错误： 语法错误：由于拼写错误或者语法错误使用导致程序无法运行 &gt;&gt;&gt; 通常熟悉语法并理解错误信息后很容易修复； 逻辑错误：不存在语法错误，但代码无法运行出预期结果 &gt;&gt;&gt; 逻辑错误比语法错误更难修复，由于无法得到指向错误源头的信息，需要通过调试等手段进行修复。 和其它计算机语言不同的是，HTML 本身不容易出现语法错误，因为浏览器是以宽松模式解析 HTML 的。这就意味着，即使出现语法错误浏览器依然会继续运行，浏览器通常都有内建规则来解析书写错误的 HTML 标记，所以即使与预期不符，页面仍可显示出来。 HTML 之所以以宽松的方式进行解析，是因为 Web 创建的初心就是：人人可发布内容，不去纠结代码语法。 你可以尝试一下仅在 HTML 文档中写一行如下内容，浏览器也可以正常解析显示页面： 12&lt;!-- HTML 文档中没有：!DOCTYPE 声明 &amp;&amp; &lt;head&gt; &amp;&amp; &lt;body&gt; 等，仅一个标题元素--&gt;&lt;h1&gt;这是一个标题&lt;/h1&gt; [1] 浏览器宽泛解析引发的问题 &gt;&gt;&gt;&gt; 不要觉得很庆幸，寄希望浏览器可以理解你的预期是存在隐患的，极大可能会带来与预期不符的结果！！！ 尝试预览如下页面： 123456789101112&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;页面标题&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;这是一个标题&lt;/h1&gt; &lt;p&gt;这是一个段落。&lt;/p&gt; &lt;p&gt;这是一个浏览器宽泛解析测试段落，&lt;font color=&quot;red&quot;&gt;[仅当前文字为红色]，[这里正常显示默认黑色颜色文字]&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 这里缺省了 &lt;font 标签的结束标签，我们期望的是仅将 [仅当前文字为红色] 设置为红色，然后浏览器宽泛解析后，[这里正常显示默认黑色颜色文字] 也被设置为红色。 可见，遵循基本的 HTML 语法规范，对于设计和编写符合预期的网页是比较重要的！！！ [2] 基本的 HTML 语法规范 &gt;&gt;&gt;&gt; HTML 文档中应包含基本的：!DOCTYPE（文档类型声明）&amp;&amp; &lt;html&gt;&lt;/html&gt;（HTML 页面根标签）&amp;&amp; &lt;head&gt;&lt;/head&gt;（头标签）&amp;&amp; &lt;title&gt;&lt;/title&gt;（网页标题标签）&amp;&amp; &lt;body&gt;&lt;/body&gt;（页面主体标签）以及其它必要的元素标签； HTML 标签使用 &lt;&gt; 包围：其中，自闭合标签使用 / 进行闭合，其它标签有开始标签，就需要使用闭合标签进行闭合； 标签 &amp;&amp; 属性 &amp;&amp; 属性值对大小写不敏感，HTML 4（推荐）&amp;&amp; XHTML（强制）统一使用小写。 关于标签大小写不敏感，是由于 HTML4 标准之前规范较混乱，HTML 代码与 XML 的代码更加相似，而 XML 代码的一大特点就是标签喜欢使用大写，由此沿袭。 对上述基本概念有了一定的认知之后，这一小节我们来看一个简单的 HTML 文档（网页）的基本结构： HTML 文档 &amp;&amp; 网页基本结构正如上面【HTML 语法规范】中提到的，一个 HTML 文档中应包含基本的： !DOCTYPE（文档类型声明）&amp;&amp; &lt;html&gt;&lt;/html&gt;（HTML 页面根标签）&amp;&amp; &lt;head&gt;&lt;/head&gt;（头标签）&amp;&amp; &lt;title&gt;&lt;/title&gt;（网页标题标签）&amp;&amp; &lt;body&gt;&lt;/body&gt;（页面主体标签）以及其它必要的元素标签，它们 共同构成了 HTML 文档（网页）的基本结构。 HTML 文档 &amp;&amp; 网页基本结构示例如下： 12345678910111213&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;页面标题&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 其它必要的元素 --&gt; &lt;h1&gt;这是一个标题&lt;/h1&gt; &lt;p&gt;这是一个段落。&lt;/p&gt; &lt;p&gt;这是另一个段落。&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 语法说明如下（更详细的说明请参见博文系列） &gt;&gt;&gt;&gt; &lt;!DOCTYPE html&gt;：标准通用标记语言的文档类型声明（技术层面不属于标签，不区分大小写，不需要闭合），用于声明当前文档类型（HTML），以及 HMTL 使用版本（HTML5 &amp;&amp; HTML 4.0.1 &amp;&amp; XHTML 1.0）； &lt;html&gt; &lt;/html&gt;：HTML 页面的根标签（root tag），其他所有的标签都需要在 &lt;html&gt; 和 &lt;/html&gt; 标签之间定义； &lt;head&gt; &lt;/head&gt;：页面头部标签，用来定义 HTML 页面的元数据以及资源引用信息，例如标题、meta 元数据、CSS 样式或 JavaScript 脚本引用等； &lt;title&gt; &lt;/title&gt;：用来定义网页的标题（网页标题会显示在浏览器的标签栏）； &lt;body&gt; &lt;/body&gt;：页面主体标签，用来定义网页中能通过浏览器看到的所有内容，例如段落、标题、图片、链接等等； &lt;h1&gt; &lt;/h1&gt; &amp;&amp; &lt;p&gt; &lt;/p&gt;：构成页面的其它必要的元素标签，这里页面中使用了 &lt;h1&gt; &amp;&amp; &lt;p&gt; 元素标签。 可视化上述的 HTML 文档（页面）结构 &gt;&gt;&gt;&gt; 需要注意的是，只有 &lt;body&gt; 标签中的内容才会显示在浏览器。 HTML 中的空格和换行不知道你有没有发现，无论你在 HTML 元素中用了多少空格或换行（包括空格字符，换行字符），当浏览器渲染这些代码时，会将连续出现的空格字符（或换行）截短为一个单独的空格符。 也就是说，下面的代码片段都是等价的： 1234567&lt;p&gt;这是 一个段落。&lt;/p&gt;&lt;p&gt;这是 一个段落。&lt;/p&gt;&lt;p&gt;这是 一个段落。&lt;/p&gt;&lt;p&gt;这是 一个段落。&lt;/p&gt; 如果就是想使用连续空格，你可以使用 HTML 中表示空格的字符实体（&amp;nbsp）来插入多个空格。更多关于 HTML 字符实体的内容可参考博文系列中相关内容。 如果就是想换行，你可以使用 HTML 中的换行标签 &lt;br/&gt;，其属于一个自闭合标签。 &lt;!DOCTYPE&gt; 声明&lt;!DOCTYPE&gt; 是标准通用标记语言的文档类型声明，有助于在浏览器中正确地显示网页。 这是由于网络上文件的类型不一，因此需要正确声明文档类型以及使用的 HTML 版本，以使得浏览器能够正确解析并显示网页内容。 并且，所有主流浏览器（IE &amp;&amp; Firefox &amp;&amp; Opera &amp;&amp; Safari &amp;&amp; Edge &amp;&amp; Chrome）都支持 &lt;!DOCTYPE&gt; 声明。 HTML4 VS HTML5开始之前，你需要了解什么是 DTD ？？？ 所谓 DTD，全称 Document Type Defination，即文档类型定义。它是 一套标记符的语法规则，通过定义 DTD，使浏览器使用相应的渲染模式对页面进行渲染，从而正确显示页面。 HTML5 之前，HTML 实际上是基于 SGML （Standard Generalized Markup Language 标准通用标记语言）中规定的一种标记格式，而 SGML 是通过 DTD 来定义文档类型的。 所以，不出意外地在 HTML4.01 &lt;!DOCTYPE&gt; 声明中需引用 DTD，以帮助浏览器能够使用相应 DTD 的渲染模式去渲染显示页面。而 HTML5 不是基于 SGML 的，因此不要求引用 DTD。 并且，HTML 4.01 中采用了三种不同的 DTD 定义，因此规定了三种不同的 &lt;!DOCTYPE&gt; 声明，分别是：Strict（严格模式）、Transitional（过度模式） 和 Frameset（框架集模式）。 HTML5 中仅规定了一种： 1&lt;!DOCTYPE html&gt; 常见的 DOCTYPE 声明使用 &gt;&gt;&gt; W3C Validation Tool &lt;&lt;&lt; 可以检查你是否编写了一个符合特定 DTD 规则的合法 HTML/XHTML 文档！！！ HTML 5 1&lt;!DOCTYPE html&gt; HTML 4.01 Strict 这个 DTD 包含所有 HTML 元素和属性，但不包括展示性的或过时的元素（如 font ），且不允许框架集。 1&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01//EN&quot; &quot;http://www.w3.org/TR/html4/strict.dtd&quot;&gt; HTML 4.01 Transitional 这个 DTD 包含所有 HTML 元素和属性，包括展示性的或过时的元素（如 font ），但不允许框架集。 1&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot; &quot;http://www.w3.org/TR/html4/loose.dtd&quot;&gt; HTML 4.01 Frameset 这个 DTD 包含所有 HTML 元素和属性，包括展示性的或过时的元素（如 font ），且允许框架集。 1&lt;!DOCTYPE HTML PUBLIC &quot;-//W3C//DTD HTML 4.01 Frameset//EN&quot; &quot;http://www.w3.org/TR/html4/frameset.dtd&quot;&gt; XHTML 1.0 Strict 这个 DTD 包含所有 HTML 元素和属性，但不包括展示性的或过时的元素（如 font ），且不允许框架集。结构必须按标准格式的 XML 进行书写。 1&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Strict//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;&gt; XHTML 1.0 Transitional 这个 DTD 包含所有 HTML 元素和属性，包括展示性的或过时的元素（如 font ），但不允许框架集。结构必须按标准格式的 XML 进行书写。 1&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;&gt; XHTML 1.0 Frameset 这个 DTD 包含所有 HTML 元素和属性，包括展示性的或过时的元素（如 font ），且允许框架集。结构必须按标准格式的 XML 进行书写。 1&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Frameset//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd&quot;&gt; XHTML 1.1 这个 DTD 与 XHTML 1.0 Strict 相同，但是允许你添加模块（例如为东亚语言提供 ruby 支持）。 1&lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.1//EN&quot; &quot;http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd&quot;&gt;","link":"/2019/01/01/html-jiao-cheng-zhi-html-ji-chu-yu-fa/"},{"title":"Hexo 博客多设备协同管理问题【持续更新】","text":"优秀的 Hexo 博客多环境、多设备协同管理方案。 前面我们已经成功搭建了基于 Hexo + Github·Page + Coding·Page + Domain + VSCode + TinyPNG + PicGo + Image Host 的个人博客环境。系列博文中给出了 Hexo 新手小白如何快速搭建基于 Hexo 的个人博客进行产出。 更多 Hexo 博客框架内容，请关注博主 Hexo 博文系列： 一文学会 Hexo 轻量级框架的博客搭建【持续更新】 Hexo 预安装环境部署之 Node.js Git 使用指南之初识 打造沉浸式写作体验，你需要试试-Markdown-Editor 基于图床的博客图片存储解决方案 稳定快速、高效免费的图床方案-Github-jsDelivr-PicGo Hexo 博客多设备协同管理问题【持续更新】 前面我们提到过，hexo d 仅仅是将 Hexo 博文静态页面（public）推送到了远程仓库（Github·Page 或 Coding·Page）上以实现公共访问，而 Hexo 个人博客框架相关配置信息都存放在本地终端。如果未进行其它备份或同步处理，一旦存放 Hexo 配置信息的本地终端出现问题（如系统崩溃），那么我们便无法再维护我们的的博客了，Game Over… 所有当我们更换工作环境（公司、个人）或者原来用于搭建 Hexo 博客环境的设备需要重新更换系统，出于安全性以及灵活性考虑，我们不得不面对的一个问题就是： 如何将本地终端中的 Hexo 博客相关配置信息完美移植到新环境或保持不同创作环境同步是至关重要的。 使用 Git 解决 Hexo 个人博客多平台同步管理关于 Hexo 博客多平台（多设备）协同管理以及更新教程网络上有很多，但对于刚刚接触 Hexo 、Git 的小白们不太友好，配置过程中容易出现各种问题，本文提到的所有配置方案均通过实际测试给出。 本文所作的主要目的：一方面作为学习记录回顾使用；另一方面适用于类似我这样的 Hexo 新手以供参考分享，可以快速对应以及解决问题。所以文中有些地方可能表达有误，欢迎各位大佬指正。 模拟场景公司和家里两台 PC： 公司 PC_A：最初用于搭建 Hexo 个人博客的终端； 个人 PC_B：移植 Hexo 个人博客项目的终端。 为了可以随时随地创作更新个人 Blog，两台 PC 中都必须搭建有相同的 Hexo 博客环境，并这必然要求我们的 Hexo 博客本地配置项目要保持同步（即实现版本控制）。 对于 同步 问题： 由于除了静态页面 以外，其它全部文件都在本地生成，所以如果在公司终端上推送了 articleA 文章后回家又写了篇 articleB 文章，在家里推送后我们会发现只有 articleB 文章而 articleA 文章没了（因为家里的 PC 上没有 articleA 文章的 md 文件），故及时同步两台 PC 终端中的 Hexo 博客项目相当重要。 也就是说，对我们的 Hexo 个人博客本地项目实现版本控制是必要的。 — important split line — 这里，我们首先给出新设备环境，解决 Hexo 个人博客多平台同步管理的通用步骤： 搭建 Hexo 个人博客环境，包括： Node.js、Git 以及 hexo 的安装，具体安装方式可见前面提到的搭建教程。 对 Hexo 个人博客本地配置信息项目实现同步，也就是版本控制。 实施方案分析介于模拟场景提到的解决方法，搭建 Hexo 个人博客环境本文不在做细致说明，参考前面教程即可。针对同步（备份），这里我们给出三种具体的版本控制（同步、备份）的实施方案分析： 存储设备备份使用存储设备备份，是指我们使用存储设备对 Hexo 个人博客项目本地文档进行备份。例如，我们可以直接对 PC_A 中最新的本地 Hexo 博客站点目录进行打包存储到硬盘、U盘或者云盘（大多数使用）中，然后将其移植 PC_B 中进行直接使用。 下面我们来分析其优略： 1）优点： 免费且操作简单快捷。 在某些场景下可以很快完成移植，而不需要进行额外的同步设置。例如，当我们的电脑需要重装系统时，我们可以直接将最新的 Hexo 博客项目进行打包，新系统中搭建好 Hexo 个人博客环境后，直接解压几乎就可以使用了。 2）缺点： 对于硬盘、U盘等设备，备份后的同步十分麻烦，每次其它终端都需要手动下载备份最新的 Hexo 博客文件夹，进行手动覆盖。 目前大多数云盘，可以开启云端自动备份功能，写完 Blog 后可以自动备份（同步）到云端。但是很容易产生一些云盘内部文件，影响 Hexo 解析产生一些不可预期的错误。 因此，使用存储设备备份使用的很少。 第三方代码仓库备份鉴于之前我们将 Hexo 个人博客产生的静态页面托管到了一些第三方 Git 服务平台，以实现远程访问。同样，类似于代码托管，我们可以将我们的 Hexo 个人博客项目本地配置信息文档托管到远程仓库进行版本控制，以实现多设备的同步管理。这是 目前最合理，并且使用最多 的解决方案。 使用第三方代码仓库进行备份是目前普遍使用的对 Hexo 个人博客进行备份同步的方法。 国内外现在知名的 Git 服务提供商主要有： Github、Coding 以及 Gitee（码云）等等，使用上没有比较大的差异，但国内站点访问较快。 下面我们来分析其优略： 1）优点： 部署完成后同步非常方便，Hexo 更新完后只需要再更新（push）全站到 Git 远程仓库即可。 2）缺点： 部署过程相对比较麻烦，对 Git 新手不友好，但这仅仅是 Git 使用上的问题，不是难点。 对于使用第三方代码仓库（以 Github 为例）进行备份的方法，目前主流的有两种方法： 分支备份法：我们知道，Hexo生成的静态博客文件都是上传到 GitHub 上的, 且默认放在 master 分支上。分支备份法是将本地的 Hexo 相关环境配置文件都推送到对应仓库新创建的分支上（如 hexo 分支），以实现备份。 将本地整个 Hexo Blog 项目进行备份：创建一个新的仓库用来对本地环境配置文件进行版本管理以及备份。 实施方案细则下面我们将以前面提到的实施方案给出其具体的操作指南，你可以根据需要选择不同的实施方案： 方案一：Hexo Envs + Cloud Service–&gt; 步骤一：Hexo envsPC_A 中我们已经成功搭建和使用 Hexo 博客了，所以不需要重复安装。而关于 PC_B 中 Hexo 个人博客环境的搭建，参考：一文学会 Hexo 轻量级框架的博客搭建【持续更新】 。步骤如下： 安装 Node.js 安装 Git 安装 Hexo –&gt; 步骤二：yunpan1）将 PC_A 终端中 Hexo 个人博客项目目录进行打包（打包格式任选，在 PC_B 中可以实现快速解压即可），备份到云盘。 2）然后在 PC_B 中从云盘下载已经上传好的 Hexo 个人博客项目压缩文件，然后进行解压。 3）PC_B 中开启 Hexo 服务，然后打开浏览器，通过访问 localhost:4000 进行 Hexo 博客本地测试，发现已经可以成功访问到我们的 Hexo 本地博客页面。 4）Hexo 个人博客本地测试通过后，由于更换设备，我们需要为Hexo Github·Page（Coding·Page）仓库配置新设备的 SSH Key。此时只需要将新设备（PC_B ）的 SSH Key 添加到 Github（Coding）中即可。如果不进行设置，当使用 hexo d 进行推送时无法成功，原因在于 Hexo 无法连接到 Github·Page（Coding·Page）。 关于新设备创建 SSH Key 方法以及为 Github 配置 SSH Key 可参加：Git 使用指南之远程仓库。 除了上述添加方式外，还有一种更简单的方式，我们可以将 PC_A 生成的 .ssh 文件直接放到 PC_B 设备当前用户目录下即可。 自此，设置完成。这种方法缺点很明显，操作太繁琐，对于同步很不友好！！！ 方案二：Hexo envs + hexo 备份（Recommended）这一小节，我们来看如何将本地整个 Hexo Blog 项目进行备份。即创建一个新的仓库用来对本地环境配置文件进行版本管理以及备份。 关于 Git 远程仓库的选择，Github or Coding or Gitee 三选其一即可，这里以 Github 为例，推荐使用 Coding or Gitee。这也就意味着： Hexo 博客静态页面托管到一个仓库，Hexo 博客配置托管到另一个远程仓库。 –&gt; 步骤一：Hexo envsPC_A 中我们已经成功搭建和使用 Hexo 博客了，所以不需要重复安装。而关于 PC_B 中 Hexo 个人博客环境的搭建，参考：一文学会 Hexo 轻量级框架的博客搭建【持续更新】 。步骤如下： 安装 Node.js 安装 Git 安装 Hexo 步骤一和方案一种中完全一样，实现 PC_B 上 Hexo 环境的部署。 –&gt; 步骤二：hexo 项目备份注意，这一部分操作全部在 PC_A（保存了 Hexo Blog 最新进度）上进行，用于将本地整个 Hexo Blog 项目托管到 Github 上的一个全新仓库（以创建 HexoBackups 为例）。 首先，添加设备 SSH Key 到 Github 以提供访问权限（在搭建 Hexo 环境时已经添加过），并且在 Github 中创建 HexoBackups 仓库（操作方法可见：Git 使用指南之远程仓库）。 1）删除 Hexo 站点目录主题路径（Hexo站点目录\\themes）下原有的 .git* 缓存文件夹，并编辑站点目录中的 .gitignore 文件。 有些插件或者主题是从 Github 上 clone 过来安装的，每个文件夹下都会有对应的 .git 文件夹，记得先删掉，否则会和 Blog 仓库冲突。（.git 默认是隐藏文件夹，需要先开启显示隐藏文件夹。.git 文件夹被删除后整个文件对应的 Git 仓库状态也会被清空，避免冲突） 编辑 .gitignore 文件的作用是声明不被 Git 记录的非必要文件（我们希望将必要的 Hexo 配置文件进行版本控制，而不是所有文件）。Blog 站点目录下的 .gitignore 是 Hexo 初始化时生成的，可以先删除或者直接编辑，对 Hexo 不会有影响。我的 Hexo 默认 .gitignore 文件内容如下： 1234567.DS_StoreThumbs.dbdb.json*.lognode_modules/public/.deploy*/ .deploy_git 是 Hexo 默认的 .git 配置文件夹，不需要同步； public 内文件是根据 source 文件夹内容自动生成，不需要备份，不然版本仓库每次修改内容太多； node_modules 目录中存放了 Hexo 个人博客所需的所有插件，太大，使用时通过 npm install 安装即可。 .DS_Store、Thumbs.db、*.log 、db.json 等均属于非必要文件。 2）初始化本地仓库 Hexo Blog 站点目录下执行以下代码： 123# &lt;server&gt; 是指远程备份仓库的地址（HexoBackups）；origin 是本地分支；remote add 操作会将本地仓库映射到云端 git initgit remote add origin &quot;Repository Addr&quot; “Repository Addr” 即上面创建的用于备份的仓库：HexoBackups 的仓库地址。 3）添加本地文件到本地仓库并同步到远程 Github 上 123456# 添加 Hexo Blog 站点目录下所有文件（.gitignore 声明过的文件不包含在内)git add .# 添加更新操作说明git commit -m &quot;Hexo Blog Backups&quot;# 推送更新到云端服务器git push -u origin master 在执行这步之前一定要注意检查下 .gitignore 文件的内容，看看是否正确的把一些文件夹忽略掉了。如果加错了的话可以用： 1git rm -r --cached . 自此，我们已经成功将本地 Hexo 博客配置文件推送到了 Github 远程仓库 HexoBackups 中实现版本控制。 –&gt; 步骤三：其它设备终端克隆测试1）添加 SSH Key 到 GitHub 首先，我们需要将设备 PC_B 的 SSH Key 添加到 GitHub 以提供访问权限。 2）将 Hexo Github 仓库内容同步到本地 之前我们已经成功将 PC_A 电脑里的 Hexo 配置信息备份到 Github HexoBackups 仓库了。 现在在 PC_B 电脑准备通过为本地仓库配远程 Hexo Github 版本仓库以实现 Hexo 配置信息同步。 123456789# 创建本地博客目录mkdir HexoBlogProjectcd HexoBlogProjectgit init# 将本地文件和云端仓库映射起来。这步不可以跳过git remote add origin &quot;Repository Addr&quot;git fetch --allgit reset --hard origin/master 当然我们还可以直接 git clone 将 HexoBackups 仓库中的 Hexo 博客配置文件拉取下来： 1git clone &quot;Repository Addr&quot; 3）安装依赖插件 同步后需要安装相应的 Hexo 插件（这是由于我们之前备份时未备份 node_modules 插件目录），否则无法正常使用 Hexo： 1npm install 4）localhost 测试 PC_B 中打开浏览器，通过访问 localhost:4000 进行 Hexo 博客本地测试，发现已经可以成功访问到我们的 Hexo 本地博客页面。 方案三：Hexo envs + hexo 分支备份和方案二中备份整个 Hexo 本地配置信息文件到一个新仓库不同的是，分支备份是在原 Hexo 静态页面托管仓库（username.github.io）重新创建一个分支（以 hexo 分支为例）来备份 Hexo 本地配置信息文件。 最终，username.github.io 仓库的 master 分支和 hexo 分支各自保存着一个版本： master 分支用于保存 Hexo 博客静态资源，提供博客页面以供人访问；hexo 分支用于备份博客部署文件，供自己维护更新，两者在一个 username.github.io 仓库内也不会有任何冲突。 -&gt; 步骤一：Hexo envsPC_A 中我们已经成功搭建和使用 Hexo 博客了，所以不需要重复安装。而关于 PC_B 中 Hexo 个人博客环境的搭建，参考：基于 Hexo 轻量级框架的博客搭建 。步骤如下： 安装 Node.js 安装 Git 安装 Hexo 步骤一和方案一种中完全一样，实现 PC_B 上 Hexo 环境的部署。 –&gt; 步骤二：hexo 分支备份注意，这一部分操作全部在 PC_A（保存了 Hexo Blog 最新进度）上进行。 和 方案二 中备份过程类似，这一部分给出 Hexo 分支备份通用流程，关于操作解读可对应 方案二 中的步骤二。 12345678910111213141516171819# 消除 Git 仓库冲突rm -rf Hexo站点目录\\themes\\主题目录、.git*# 即 Hexo 博客根目录cd Hexo站点目录# 初始化本地仓库git init# 将本地与 Github 远程仓库进行对接git remote add origin git@github.com:user/user.github.io.git# 添加 Hexo Blog 站点目录下所有文件（.gitignore 声明过的文件不包含在内)git add .# 添加更新操作说明git commit -m &quot;Hexo Blog Backups&quot;# 创建名为 hexo 的分支git checkout -b hexo# 推送分支到 GitHubgit push origin hexo –&gt; 步骤三：其它终端克隆测试1）添加 SSH Key 到 GitHub 首先，我们需要将设备 PC_B 的 SSH Key 添加到 GitHub 以提供访问权限。 2）克隆 Hexo 博客环境 123# 将 Github 中 hexo 分支 clone 到本地git clone -b hexo git@github.com:username/username.github.io.gitcd user.github.io 3）安装依赖插件 12# 安装 Hexo 博客中使用到的插件npm install 4）localhost 测试 PC_B 中打开浏览器，通过访问 localhost:4000 进行 Hexo 博客本地测试，发现已经可以成功访问到我们的 Hexo 本地博客页面。 Git + Hexo 管理博文这一部分我们来看加入版本控制后，如何进行 Hexo Blog 的多平台协同创作 （Git + Hexo）？ –&gt; 步骤一：发布静态页面 假设在 PC_B 电脑上写完了文章，然后进行发布： 1$ hexo d -g –&gt; 步骤一：同步 Hexo 最新配置 接下来，我们还需要将新文章的 .md 文件推送到备份仓库。（其实就是提交更新给 Hexo Github 备份仓库）： 1$ git add . 这时候可以用 git status 查看状态，一般会显示刚刚更改过的文件状态。如： 123456On branch masterChanges to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) modified: db.json new file: source/_posts/test.md 上面的输出状态即说明 db.json 文件做了更改，source/_posts 目录下新增了 test.md 文件。 然后对更改添加说明并推送到远程仓库： 123456git commit -m '更新信息'# 推送git push# 或者（取决于整体备份还是分支备份）git push origin hexo 当显示类似如下提示的时候，即表示备份成功： 12To git@git.oschina.net:xxxx/HexoBackups.git + 2c77e1e...5616bc6 master -&gt; master (forced update) 再回到到 PC_A 电脑上的时候，我们需要拉取最新的 Hexo 配置信息到本地以实现本地仓库和远程仓库一致： 1234# 拉取最新版本git pull# 或者（取决于整体备份还是分支备份）git pull origin hexo 即可实现 Hexo 博客同步更新以及协同管理。 自此，基于 Hexo + Github·Page + Coding·Page + Domain + VSCode + MarkDown + TinyPNG + PicGo + Image Host + Git 框架的 Hexo 个人博客创作生态已经建立。 常见问题Hexo 博客使用过程中的 真·疑难杂症： hexo init 卡死Hexo 搭建个人博客时，调用 hexo init 命令一直卡住不动： 12$ hexo initINFO Cloning hexo-starter https://github.com/hexojs/hexo-starter.git 这就很困惑了，npm 已经使用了淘宝源，node.js &amp;&amp; npm 版本也比较新，就是 hexo init 不成功…. 此时查看 Hexo 站点路径，发现目录中已经出现 clone 的文件目录结构： 12345678.gitscaffoldssourcethemes.gitignore_config.ymldb.jsonpackage.json 网上查找原因，应该是 Hexo 主题未能成功下载（子模块未能成功下载），可以在 .gitmodules 查看相关信息： 123submodule &quot;themes/landscape&quot; path = themes/landscape url = https://github.com/hexojs/hexo-starter.git 通过查看站点目录下的 themes 目录，发现确实没有相应主题。 –&gt; 解决方法： 为 Git 配置代理： git config –global http.proxy http://proxyuser:proxypwd@proxy.server.com:port 当然，你也可以等待网络流畅时重新进行 hexo init，说不定下一次执行就成功了。 npm install 很慢很慢安装 Hexo 博客相关依赖插件时，我们需要使用 npm install 下载进行安装。但是执行指令后一直没反应，这是由于 npm 官方资源被墙，我们可以为其更换一个国内源： 1npm config set registry https://registry.npm.taobao.org 当然，当我们的 Hexo 个人博客使用较多的插件时，npm install 可能看起来很慢（好像卡在某一个安装语句不再执行），此时我们可以通过 Hexo 站点目录下的 node_modules 目录更新时间来判断。 如果 node_modules 目录下各种插件文件更新时间长时间不发生变化，就意外着安装已停止，Ctrl + c 即可。 Git 监测不到空文件夹Git 无法监测到空文件夹，也就意外着无法将空文件夹 git add、git commit -m &quot;&quot;、git push 推送到远程仓库，这会导致 Hexo 博客项目中丢失一些空的功能文件夹。这应该算是 Git 的设计失误。 解决方法： 需要在空文件夹中添加一个占位文件。主流做法是在空文件夹里放置一个 .gitkeep 文件。或者加个 .gitconfig 文件在里面比较实用，也不会觉得突兀，虽然绝大多数时候这个文件不起作用。 Hexo 推送错误距离上次写博文已经有一段时间了，今天想将最近写好的博文推送到远程仓库，却发现推送不上去了，WTF？？！ 错误信息提示如下： ssh: connect to host github.com port 22: Connection timed outfatal: Could not read from remote repository.Please make sure you have the correct access rights and the repository exists. 然后进行了连接测试，果然发现连接有问题： 123$ ssh -T git@github.com# 和$ ssh -T git@gitee.com 从报错信息可以看出 GitHub 连接超时，去 ping github.com 也是正常的，浏览器也可以正常访问 Github，于是认为应该不是网络的问题。 第一反应是 SSH 配置出问题了，于是删除掉 .ssh 文件，重新生成并配置 Github SSH 公钥。配置完成之后再次推送，还是上述问题！！！ 于是开始 Google 解决问题了。网络上主流思路是“上述问题是由于 22 端口被占用了，修改一下访问端口就好使了！”，这种方法想要同时解决 Github &amp; Gitee 推送是有问题的，不要尝试了！！！ 当时采用切换端口的思路，使用 ssh -T -p 443 git@ssh.github.com 进行网络测试，确实是可以连接到的。于是从端口占用角度还去查了环境中 22 端口占用情况，发现也没问题，人方了 走投无路的时候，宿舍同学电脑这时候联不上校园网了，抱怨说学校的网络太辣鸡了~，这时候才想到可能真的是网络问题（有些网络环境下被 q 了），于是尝试使用手机热点进行推送，成功了！！！自此问题解决。","link":"/2017/09/22/hexo-bo-ke-duo-she-bei-xie-tong-guan-li-wen-ti-chi-xu-geng-xin/"},{"title":"Java JDK 下载与安装教程","text":"开始正式的 JAVA 语言学习之前，首要的就是完成 Java 程序所需的开发、运行环境搭建——JDK（Java Development Kit：Java 开发工具包）的安装，以及配置。 本篇博文所作目的主要是记录一下 Java 开发环境的搭建过程，即 JDK 的安装以及配置过程 安装以及配置 JDK这里，首先给出 JDK 各版本下载地址供安装选择： Download –&gt; JDK 官方最新版 Download –&gt; JDK 1.8 官方最新版 [Download –&gt; JDK 官方各历史版本 本文将以 JDK1.8 的安装配置为 Demo，其它 JDK 版本安装过程一样。 JDK Package Download根据个人的使用需要，从上面选择要访问的 JDK 下载页，选择就可以下载相应的安装包了： 注意：目前从官网下载相应版本 JDK 之前，你需要注册一个 Oracle 账号，并完成登录，才会被授权下载使用。 可以发现，JDK 官网提供了不同平台下（Linux、Mac 以及 Windows）JDK 的安装包。后文我们会给出 Linux &amp; Windows 平台下 JDK 的安装配置方法： 根据需要下载相应平台安装包 1.1 –&gt; For Windows: 对于 Windows 下的安装包，提供了 i586（32 bit） 和 x64（64 bit） 供我们下载使用。 这里我们选择安装包：jdk-8u261-windows-x64.exe 用于后续的安装。 1.2 –&gt; For Linux: 对于 Linux下的安装包，提供了 i586（32 bit） 和 x64（64 bit） 的 RPM 包以及 .tar.gz 包供下载使用。 这里我们选择安装包：jdk-8u261-linux-x64.tar.gz 用于后续的安装。 JDK Setup上面我们已经下载好了 JDK 的安装包，接下来我们来看如何在不同的平台下安装下载好的 JDK 安装包： For Windows1）检查当前系统中是否安装有 JDK Windows 命令行（Terminal ）下执行如下指令： 1$ java -version 如果原始系统中已安装有 JDK ，则会输出如下 JDK 版本等信息： 123java version &quot;1.8.0_131&quot;Java(TM) SE Runtime Environment (build 1.8.0_131-b11)Java HotSpot(TM) 64-Bit Server VM (build 25.131-b11, mixed mode) 否则的话，开始安装 JDK（当然，如果系统中已存在某个版本的 JDK 了，我们还可以再同时安装一个其它目标版本的 JDK），接下文。 2）安装 JDK 双击 jdk-8u261-windows-x64.exe 安装包开始进行安装…… 安装过程中没有什么难的，Next 即可。需要注意的是，我们可以自定义 JDK 安装路径，不要什么东西都往系统盘安装，这里假设我们安装在：E:\\JAVA 目录下。 等待安装完成关闭安装界面即可。 可以发现，JDK 以及被安装到了 E:\\JAVA 目录下，包含两个文件： 12jdk1.8.0_261jre1.8.0_261 自此 Windows 下 JDK 的安装就完成了，但此时仍不能使用，我们还需要为 JDK 配置环境变量，接 【1.3.1 Windows 下 JDK 环境变量配置】。 For Linux1）检查当前系统中是否安装有 JDK 1[root@localhost test]# java -version 有些 Linux 系统默认会安装有 openjdk（一种 Linux 开源 JDK），例如会输出如下信息： 123openjdk version &quot;1.8.0_102&quot;OpenJDK Runtime Environment (build 1.8.0_102-b14)OpenJDK 64-Bit Server VM (build 25.102-b14, mixed mode) 我们可以选择先将其卸载掉（当然，不用管也可以）： 1234# Centos 下可以使用 yum 进行卸载：[root@localhost test]# yum remove *openjdk*# Ubuntu 下[root@localhost test]# apt-get remove openjdk* 当然系统中还有可能装有其它版本（区别于 openjdk，例如：oracle）的 JDK，例如： 123java version &quot;1.8.0_131&quot;Java(TM) SE Runtime Environment (build 1.8.0_131-b11)Java HotSpot(TM) 64-Bit Server VM (build 25.131-b11, mixed mode) 否则的话，开始安装 JDK（当然，如果系统中已存在某个版本的 JDK 了，我们还可以再安装一个其它目标版本的 JDK），接下文。 2）安装 JDK 进入到 jdk-8u261-linux-x64.tar.gz` 安装包存放目录（例如：~/Downloads），并且对安装包进行解压： 12345678910# 查找安装包：[root@localhost test]$ cd Downloads[root@localhost Downloads]$ ls |grep jdk*jdk-8u131-linux-x64.tar.gz# 解压至 /usr/java 目录下：[root@localhost Downloads]$ tar -zxvf jdk-8u131-linux-x64.tar.gz -C /usr/java# 等待解压完成即可。# 解压后，我们可以在 /usr/java 目录下可以查看到解压好的 JDK 目录：jdk1.8.0_131 自此 Linux下 JDK 的安装就完成了，但此时仍不能使用，我们还需要为 JDK 配置环境变量，接 【3. 环境变量配置】。 Config EvnsFor WindowsWindows 下为 JDK 配置环境变量: 首先打开环境变量配置界面：右键我的电脑 ---&gt; 属性 ---&gt; 高级系统设置 ---&gt; 环境变量。界面如下： –&gt; 开始设置环境变量: 这里注意，我们既可以设置普通用户变量，也可以设置系统变量。区别在于设置普通用户变量的话，只有该用户下可用，其他用户想要使用的话需要重新配置环境变量。而设置系统变量后，我们可以在所有用户下都可以使用。 –&gt; 故，这里我们选择设置系统变量： 1）点击系统变量下面的新建按钮，变量名设置为：JAVA_HOME（代表 JDK 安装路径），变量值：E:\\JAVA\\jdk1.8.0_261（具体的 JDK 的安装路径）。如下： 2）继续在系统变量里面新建一个 CLASSPATH 变量， 其变量值为：.;%JAVA_HOME%\\lib\\tools.jar;%JAVA_HOME%\\lib\\dt.jar;。如下： 这里注意变量前面还有一个 .;，表示当前路径，不要漏加！！！ 3）在系统变量里面找一个变量名是 Path 的变量，找到后进行编辑，在它的变量值最后面追加一段如下的代码： 1%JAVA_HOME%\\bin; 最后点击确定，此时 Windows 下 JDK 的环境变量配置就完成了，还不圆满，需要测试一下。 4）测试 WIndows Terminal 下分别执行如下指令： –&gt; java -version 1234$ C:\\Users\\guoji&gt;java -versionjava version &quot;1.8.0_211&quot;Java(TM) SE Runtime Environment (build 1.8.0_211-b12)Java HotSpot(TM) 64-Bit Server VM (build 25.211-b12, mixed mode) –&gt; java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051C:\\Users\\guoji&gt;java用法: java [-options] class [args...] (执行类) 或 java [-options] -jar jarfile [args...] (执行 jar 文件)其中选项包括: -d32 使用 32 位数据模型 (如果可用) -d64 使用 64 位数据模型 (如果可用) -server 选择 &quot;server&quot; VM 默认 VM 是 server. -cp &lt;目录和 zip/jar 文件的类搜索路径&gt; -classpath &lt;目录和 zip/jar 文件的类搜索路径&gt; 用 ; 分隔的目录, JAR 档案 和 ZIP 档案列表, 用于搜索类文件。 -D&lt;名称&gt;=&lt;值&gt; 设置系统属性 -verbose:[class|gc|jni] 启用详细输出 -version 输出产品版本并退出 -version:&lt;值&gt; 警告: 此功能已过时, 将在 未来发行版中删除。 需要指定的版本才能运行 -showversion 输出产品版本并继续 -jre-restrict-search | -no-jre-restrict-search 警告: 此功能已过时, 将在 未来发行版中删除。 在版本搜索中包括/排除用户专用 JRE -? -help 输出此帮助消息 -X 输出非标准选项的帮助 -ea[:&lt;packagename&gt;...|:&lt;classname&gt;] -enableassertions[:&lt;packagename&gt;...|:&lt;classname&gt;] 按指定的粒度启用断言 -da[:&lt;packagename&gt;...|:&lt;classname&gt;] -disableassertions[:&lt;packagename&gt;...|:&lt;classname&gt;] 禁用具有指定粒度的断言 -esa | -enablesystemassertions 启用系统断言 -dsa | -disablesystemassertions 禁用系统断言 -agentlib:&lt;libname&gt;[=&lt;选项&gt;] 加载本机代理库 &lt;libname&gt;, 例如 -agentlib:hprof 另请参阅 -agentlib:jdwp=help 和 -agentlib:hprof=help -agentpath:&lt;pathname&gt;[=&lt;选项&gt;] 按完整路径名加载本机代理库 -javaagent:&lt;jarpath&gt;[=&lt;选项&gt;] 加载 Java 编程语言代理, 请参阅 java.lang.instrument -splash:&lt;imagepath&gt; 使用指定的图像显示启动屏幕有关详细信息, 请参阅 http://www.oracle.com/technetwork/java/javase/documentation/index.html。 —&gt; javac 12345678910111213141516171819202122232425262728293031323334C:\\Users\\guoji&gt;javac用法: javac &lt;options&gt; &lt;source files&gt;其中, 可能的选项包括: -g 生成所有调试信息 -g:none 不生成任何调试信息 -g:{lines,vars,source} 只生成某些调试信息 -nowarn 不生成任何警告 -verbose 输出有关编译器正在执行的操作的消息 -deprecation 输出使用已过时的 API 的源位置 -classpath &lt;路径&gt; 指定查找用户类文件和注释处理程序的位置 -cp &lt;路径&gt; 指定查找用户类文件和注释处理程序的位置 -sourcepath &lt;路径&gt; 指定查找输入源文件的位置 -bootclasspath &lt;路径&gt; 覆盖引导类文件的位置 -extdirs &lt;目录&gt; 覆盖所安装扩展的位置 -endorseddirs &lt;目录&gt; 覆盖签名的标准路径的位置 -proc:{none,only} 控制是否执行注释处理和/或编译。 -processor &lt;class1&gt;[,&lt;class2&gt;,&lt;class3&gt;...] 要运行的注释处理程序的名称; 绕过默认的搜索进程 -processorpath &lt;路径&gt; 指定查找注释处理程序的位置 -parameters 生成元数据以用于方法参数的反射 -d &lt;目录&gt; 指定放置生成的类文件的位置 -s &lt;目录&gt; 指定放置生成的源文件的位置 -h &lt;目录&gt; 指定放置生成的本机标头文件的位置 -implicit:{none,class} 指定是否为隐式引用文件生成类文件 -encoding &lt;编码&gt; 指定源文件使用的字符编码 -source &lt;发行版&gt; 提供与指定发行版的源兼容性 -target &lt;发行版&gt; 生成特定 VM 版本的类文件 -profile &lt;配置文件&gt; 请确保使用的 API 在指定的配置文件中可用 -version 版本信息 -help 输出标准选项的提要 -A关键字[=值] 传递给注释处理程序的选项 -X 输出非标准选项的提要 -J&lt;标记&gt; 直接将 &lt;标记&gt; 传递给运行时系统 -Werror 出现警告时终止编译 @&lt;文件名&gt; 从文件读取选项和文件名 For Linux开始设置环境变量: 这里注意，我们既可以设置普通用户变量（局部变量），也可以设置系统变量（全局变量）。区别在于设置普通用户变量的话，只有该用户下可用，其他用户想要使用的话需要重新配置环境变量。而设置系统变量后，我们可以在所有用户下都可以使用。 –&gt; 故，这里我们选择设置系统变量： 123456789# 打开系统变量配置文件：[root@localhost test]# vim /etc/profile# 追加如下内容：JAVA_HOME=/usr/local/java/jdk1.8.0_131JRE_HOME=$JAVA_HOME/jreCLASSPATH=.:$JAVA_HOME/lib/tools.jar:$JAVA_HOME/lib/dt.jar:$JRE_HOME/libPATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/binexport JAVA_HOME JRE_HOME CLASSPATH PATH –&gt; 生效 /etc/profile 配置文件： 1[root@localhost test]# source /etc/profile ============================================= 再来看一下普通用户变量如何设置： 12345# 在 ~/.bashrc 用户配置文件中添加上述内容即可。[root@localhost test]$ vim ~/.bashrc# 追加完配置内容后，需要使配置生效：[root@localhost test]$ source ~/.bashrc 此时 Linux下 JDK 的环境变量配置就完成了，还不圆满，需要测试一下。 –&gt; 测试 12345$ java -version$ java$ javac 篇幅原因，输出信息释义见 Windows 中测试部分。 You Need Know MorePath 和 CLASSPATH 详解1 –&gt; Path Path，是系统用来搜索可执行文件路径的环境变量。如果所执行的文件不在当前目录下，就会依次搜索 Path 中设置的路径。 而 Java 中的可执行文件路径是存放于 bin 目录下的，所以在 Path 中设置了 JDK 的 bin 路径后，DOS/Shell 中即使不把 jdk 可执行文件的完整路径给出，系统会自动去 Path 中设置的路径查找，然后执行。 这也是很多应用配置系统环境变量（Path）后，就可以直接在 DOS/Shell 中快速调用或启动的原因！ 2 –&gt; CLASSPATH CLASSPATH，是 Java 专用的查找类的路径，用来指定 Java 程序中所用类文件所在的位置。 如 Java 程序中，“import javax.swing.JTable” 就是告诉编译器引入 “javax.swing” 这个包下面的 “JTable”，而 CLASSPATH 就是告诉编译器要去哪里找到这个包。 两套 JRE？？？Windows 下 Java 安装完成之后，你会发现有两套 JRE：一套位于 &lt;JDK安装目录&gt;\\jre 下，一套位于 C:\\Program Files\\Java\\jre1.8.0_xxx 或和 &lt;JDK安装目录&gt; 同目录下。 并且安装 JDK 可以选择是否只安装 JRE，而不是 JDK，那么只会在安装目录下安装唯一的一套 JRE。 1 –&gt; 两套 JRE 的作用？ 两套 JRE 主要体现在工作的职责上，也就是不同的JRE负责不同的工作范围： JDK 里的工具有些是用 Java 所编写，因此要使用 JDK 所附的工具来开发 Java 程序，也必须要附一套 JRE 才行（如javac.exe、jar.exe…） 例如： javac.exe 与输入 java -cp c:/jdk/lib/tools.jar com.sun.tools.javac.Main 是一样的，可以认为 javac.exe 只是一个包装器（Wrapper），目的是简写指令。 而，另外一套 JRE 就是专门用来运行开发好的 Java 程序用的。 2 –&gt; 执行谁？ 例如 Java.exe 依照顺序来查找 JRE： 自己的目录下有没有 JRE ? 父目录有没有 JRE ? 查询注册表（环境变量）：[HKEY_LOCAL_MACHINE/SOFTWARE/JavaSoft/Java Runtime Environment] ? JDK 安装目录详解JDK安装目录如下（JDK 8）： 下面来详细介绍： 1 –&gt; bin bin(binary) 目录下存放了 JDK 的各种工具的可执行文件： 12345678# 主要工具可执行文件：Javac：Java编译器，将 Java 源代码编译为字节码文件；Java：Java解释器，解释执行 Java 字节码文件；appletviewer：Java Applet小程序查看器，可以执行 HTML 文件上 Java Applet 程序；Javadoc：java文档生成器，提取 Java 源码中的注释生成 HTML 说明文档；Jdb：Java调试器，可以逐行执行程序，设置断点和检查变量；Javap：Java反编译器，显示编译成的类文件中的可访问功能和数据，同时显示字节代码含义。jar：java打包器，可将 Java 包结构压缩成以 .jar 为后缀的 JAR 文件 2 –&gt; db db 目录是从 Java 6 开始新增的一个目录，这是一个纯 Java 实现、开源的数据库管理系统（DBMS），源于 Apache 软件基金会（ASF）名下的项目 Derby。 3 –&gt; include 由于 JDK 是通过 C 和 C++ 实现的，因此在启动时需要引入一些 C 语言的头文件，所以 include目录里面是一些供 C语言使用的标题文件。 支持 Java 本地接口和 Java 虚拟机调试程序接口的本地编程技术。 4 –&gt; jre jre 目录路径下安装的就是 Java 运行时环境。 5 –&gt; lib lib(libarary)，见名知义，存放类库，存放的是开发工具使用的归档包文件。 6 –&gt; src.zip 该压缩文件里面存放的就是 Java 所有核心类库的源代码。通过该文件可以查看 Java 基础类的源代码。 7 –&gt; javafx-src.zip 存放 JavaFX 脚本，JavaFX 它是一种声明式、静态类型编程语言。(是 JDK 1.8 以上新加的)。","link":"/2017/10/09/java-jdk-xia-zai-yu-an-zhuang-jiao-cheng/"},{"title":"Java 程序设计基础之操作符","text":"关于 Java 程序设计语言的 基础语法 部分，前面我们已经详细了解过了 Java 中的字面值，变(常)量，数据类型，本文我们来看 Java 基础语法的另一个重要组成部分——操作符，Java 中提供了丰富的操作符支持。 Java 中的操作符1 –&gt; 特殊概念 –&gt; 优先级 &amp; 结合性 Java 中的操作符，等价于数学中的运算符，也是有优先级，和结合性的概念的。 这也就是说，当一个表达式中出现多种操作符时，执行的先后顺序不仅要遵守操作符优先级规定，还要受操作符结合性的约束，以便确定是自左向右进行运算？还是自右向左进行运算？ –&gt; 操作数 操作符进行运算时，所操作（依赖）的数据 –&gt; 操作符按照【操作数的数量】可以分为：单目运算符、双目运算符和三目运算符。 2 –&gt; 操作符类别 Java 中最基本的操作符可归纳为以下 6 大类： 算术操作符 赋值操作符 关系操作符 逻辑操作符 条件操作符 位操作符 详细解读上面提到的 6 种 Java 基本操作符用法： 算术操作符Java 语言中，算术操作符的功能是对数据进行算术运算。这里为了方便记忆，特将算术运算分为三类： 基本算术操作符：+（加） -（减） *（乘） /（除）％（取模/余） 基本算术赋值操作符：+=（加赋值）-=（减赋值）*=（乘赋值）/=（除赋值）%=（取模赋值） 算术单目运算符：-（负） ++（自增） –（自减） 基本算术操作符Java 算术操作符中，最基本的算术运算就是： 1+（加） -（减） *（乘） /（除）％（取模/余） 上述运算符，和我们平常接触的数学运算具有相同的含义。 隐藏运算规则： 如果表达式中有任何运算单元的长度超过 int，那么运算结果就按照最长的长度计算 如果表达式中有任何运算单元的长度都不超过 int，那么运算结果就按照 int 来计算 123456789101112public class HelloWorld { public static void main(String[] args) { int a = 5; long b = 6; int c = (int) (a+b); // a+b 的运算结果是 long 型，所以要进行强制转换 byte d = 1; byte e= 2; byte f = (byte) (d+e); //虽然 a b 都是 byte 类型，但是运算结果是 int 类型，需要进行强制转换 }} 基本算术赋值操作符算术赋值运算符只是一种简写（算术操作符 &amp;&amp; 赋值运算符的一种应用），一般用于变量自身的变化： 运 算 符 名 称 例 子 等价于 += 加赋值 a += b + 3 a = a + b + 3 -= 减赋值 a -= b a = a - b *= 乘赋值 a *= b a = a*b /= 除赋值 a /= b a = a/b %= 取余赋值 a %= b a = a%b 算术单目操作符算术操作符中的，单目运算符有 3 个，分别表示：-（负） ++（自增） –（自减）。 其中，-（负）最为简单，就是数学上的含义，不做过多说明，下面重点来看自增、自减的使用。 使用原则： 自增/自减只能作用于变量，不允许对常量、表达式等进行操作； 自增/自减运算可以用于整数类型 byte、short、int、long；浮点类型 float、double；字符串类型 char 自增/自减运算（Java V1.5 以上）可以用于基本类型对应的包装器类 Byte、Short、Integer、Long、Float、Double 和 Character 自增/自减运算作用于变量自身加/减 1，放在操作数的前面或后面都是允许的。 1 –&gt; 自增 &amp; 自减 i++（自增）i –（自减）：在变量 i 原来的基础上，增加 1 或者减少 1。 123456789public class HelloWorld { public static void main(String[] args) { int i = 4; i++; System.out.println(5); // 输出为6 }} 2 –&gt; 前后置区别 以 ++ 为例，– 同理。 123int i = 4;i++; // 先取值，再运算++i; // 先运算，再取值 具体测试例： 1234567891011public class HelloWorld { public static void main(String[] args) { int i = 5; System.out.println(i++); // 输出5 System.out.println(i); // 输出6 int j = 5; System.out.println(++j); // 输出6 System.out.println(j); // 输出6 }} 思考：下面的 j 是 多少？ 12int i = 1;int j = ++i + i++ + ++i + ++i + i++; // 2 + 2(3) + 4 + 5 + 5 = 18 赋值操作符赋值运算符是指为 变量或常量 指定数值的符号。使用很简单，其语法格式如下所示： 1变量名称 = 表达式内容 它是双目运算符，左边的操作数必须是变量，不能是常量值或表达式；右侧可以为字面值，表达式。 注意：不要将赋值运算符与相等运算符 “==” 混淆。 示例： 123456public class HelloWorld { public static void main(String[] args) { /* 首先进行 5+5 的运算，得到结果 10，然后把 10 这个值，赋给变量 i */ int i = 5+5; }} 关系操作符关系操作符（relational operators）也可以称为：“比较操作符”，用来比较判断两个变量或常量的大小。 运算结果是 boolean 型。当操作符对应的大小关系成立时，运算结果是 true，否则是 false。 比较操作符的含义及其实例应用： 1 –&gt; 大于操作符（&gt;） 只支持左右两边操作数是数值类型。如果前面变量的值大于后面变量的值， 则返回 true。 12# false2 &gt; 3 2 –&gt; 大于等于操作符（&gt;=） 只支持左右两边操作数是数值类型。如果前面变量的值大于等于后面变量的值， 则返回 true。 12# true4 &gt;= 2 3 –&gt; 小于操作符（&lt;） 只支持左右两边操作数是数值类型。如果前面变量的值小于后面变量的值，则返回 true。 12# true2 &lt; 3 4 –&gt; 小于等于操作符（&lt;=） 只支持左右两边操作数是数值类型。如果前面变量的值小于等于后面变量的值， 则返回 true。 12# false4 &lt;= 2 5 –&gt; 相等运算符（==） 5.1 数值类型比较： 无论它们的数据类型是否相同，只要它们的值相等，也都将返回 true。 12345678# true4 == 4# true97 == 'a'# true5.0 == 5# falsetrue == false 等于操作符支持，两个 boolean 类型的值进行比较。但注意：boolean 类型的变量、值不能与其他任意类型的变量、值使用 == 进行比较。 5.2 引用类型比较： 只有当两个引用变量的类型具有父子关系时才可以比较，只要两个引用指向的不是同一个对象就会返回 true。 6 –&gt; 不相等运算符（!=） 6.1 数值类型比较： 如果进行比较的两个操作数都是数值类型，无论它们的数据类型是否相同，只要它们的值不相等，也都将返回 true。 12# true4 != 2 6.2 引用类型比较： 如果两个操作数都是引用类型，只有当两个引用变量的类型具有父子关系时才可以比较，只要两个引用指向的不是同一个对象就会返回 true。 ============================================= You Know More： == 和 != 可以应用于基本数据类型和引用类型。当用于引用类型比较时，比较的是两个引用是否指向同一个对象，但实际开发过程多数情况下，只是比较对象的内容是否相当，不需要比较是否为同一个对象。 基本类型的变量、值不能和引用类型的变量、值使用 == 进行比较；boolean 类型的变量、值不能与其他任意类型的变量、值使用 == 进行比较；如果两个引用类型之间没有父子继承关系，那么它们的变量也不能使用 == 进行比较。 逻辑操作符逻辑运算符把各个关系表达式连接起来组成一个复杂的逻辑表达式，以判断程序中的表达式是否成立，判断的结果是 true 或 false。 逻辑运算符的用法、含义及实例： 1 –&gt; 逻辑与（&amp;） 和 短路与（&amp;&amp;） 两边的运算单元都是布尔值，运算规则： 都为真时，才为真 有假即假 区别： 逻辑与 两侧，都会被运算 短路与 只要第一个是false，第二个就不进行运算了 1234567891011121314public class HelloWorld { public static void main(String[] args) { //长路与 无论第一个表达式的值是true或者false,第二个的值，都会被运算 int i = 2; System.out.println( i== 1 &amp; i++ ==2 ); //无论如何i++都会被执行，所以i的值变成了3 System.out.println(i); //短路与 只要第一个表达式的值是false的，第二个表达式的值，就不需要进行运算了 int j = 2; System.out.println( j== 1 &amp;&amp; j++ ==2 ); //因为j==1返回false,所以右边的j++就没有执行了，所以j的值，还是2 System.out.println(j); }} 2 –&gt; 逻辑或（|） 和 短路或（||） 两边的运算单元都是布尔值，运算规则： 有真即真 都为假时，才为假 区别： 逻辑或（|）两侧都会被运算 短路或（||） 只要第一个是 true 的，第二个就不进行运算了 1234567891011121314public class HelloWorld { public static void main(String[] args) { //长路或 无论第一个表达式的值是true或者false,第二个的值，都会被运算 int i = 2; System.out.println( i== 1 | i++ ==2 ); //无论如何i++都会被执行，所以i的值变成了3 System.out.println(i); //短路或 只要第一个表达式的值是true的，第二个表达式的值，就不需要进行运算了 int j = 2; System.out.println( j== 2 || j++ ==2 ); //因为j==2返回true,所以右边的j++就没有执行了，所以j的值，还是2 System.out.println(j); }} 3 –&gt; 取反（!） 真变为假，假变为真。 123456789public class HelloWorld { public static void main(String[] args) { boolean b = true; System.out.println(b); //输出true System.out.println(!b);//输出false }} 4 –&gt; 异或（^） 不同，返回真；相同，返回假。 12345678910public class HelloWorld { public static void main(String[] args) { boolean a = true; boolean b = false; System.out.println(a^b); //不同返回真 System.out.println(a^!b); //相同返回假 }} 注意：短路与（&amp;&amp;）和短路或（||）能够采用最优化的计算方式，从而提高效率。在实际编程时，应该优先 考虑使用短路与和短路或。 条件操作符Java 中提供了一个特别的三目运算符，经常用于取代某个类型的 if-then-else 语句。 使用条件操作符的一般语法结构为： result = &lt;expression&gt; ? &lt;statement_1&gt; : &lt;statement_3&gt;; 其中，expression 是一个布尔表达式。当 expression 为真时，执行 statement_1， 否则就执行 statement_3。 12345678910111213141516171819public class HelloWorld { public static void main(String[] args) { int i = 5; int j = 6; int k = i &lt; j ? 99 : 88; // 相当于 if (i &lt; j) { k = 99; } else { k = 88; } System.out.println(k); }} 位操作符Java 中定义的位运算（bitwise operators），按位运算表示按每个二进制位（bit）进行计算。 可以直接对 整数类型 的二进制位进行操作，这些整数类型包括 long，int，short，char 和 byte。其操作数和运算结果都是整型值。 Java 语言中的位运算符分为 位逻辑操作符 、 位移操作符 以及位赋值操作符： 位逻辑操作符：&amp;（与）、|（或）、~（非）和 ^（异或） 位移操作符：将操作数向左（&lt;&lt;）或者右（&gt;&gt;），移动指定的二进制位数 这里注意，位逻辑操作符和逻辑操作符的区别。 1 –&gt; 整数的二进制 位操作，都是对整型操作数二进制而言的。 Java 中可以通过 Integer.toBinaryString() 方法，将一个十进制整数转换为一个二进制字符串 12345678910public class HelloJava { public static void main(String[] args) { // TODO Auto-generated method stub int i = 5; String string = Integer.toBinaryString(i); System.out.println(string); } } 2 –&gt; 位逻辑操作符 2.1 –&gt; 位与（&amp;） 运算规则： 参与运算的操作数，低位对齐，高位不足的补零；如果对应的二进制位同时为 1，那么计算结果才为 1，否则为 0。 例如：100&amp;0 2.2 –&gt; 位或（|） 运算规则： 参与运算的操作数，低位对齐，高位不足的补零；如果对应的二进制位只要有一个为 1，那么结果就为 1；如果对应的二进制位都为 0，结果才为 0。 例如：11|7 2.3 –&gt; 位异或（^） 运算规则： 其运算规则是：参与运算的数字，低位对齐，高位不足的补零，如果对应的二进制位相同（同时为 0 或同时为 1）时，结果为 0；如果对应的二进制位不相同，结果则为 1。 例如：11^7 2.4 –&gt; 位取反（~） 运算规则： 只对一个操作数进行运算，将操作数二进制中的 1 改为 0，0 改为 1。 例如：~10 注意：位操作符的操作数只能是整型或者字符型数据以及它们的变体，不用于 float、double 或者 long 等复杂的数据类型。 3 –&gt; 位移操作符 位移运算符用来将操作数向某个方向（向左或者右）移动指定的二进制位数。 位移操作符说明： 运算符 含义 实例 结果 » 右移位运算符 8»1 4 « 左移位运算符 9«2 36 3.1 –&gt; 左位移（&lt;&lt;） 运算规则： 按二进制形式把所有的数字向左移动对应的位数，高位移出（舍弃），低位的空位补零。 例如：11 –&gt; 22 3.2 –&gt; 右位移（&gt;&gt;） 运算规则： 按二进制形式把所有的数字向右移动对应的位数，低位移出（舍弃），高位的空位补零。 例如：11 –&gt; 5 ======================================================= 带符号右移与无符号右移： 1 –&gt; 带符号右移：&gt;&gt; 对于正数， 带符号右移 &gt;&gt; 会把所有的位右移，并在最前面补0对于负数， 带符号右移 &gt;&gt; 会把所有的位右移，并在最前面补1 2 –&gt; 无符号右移：&gt;&gt;&gt; 如果是一个负数，那么对应的二进制的第一位是1。无符号右移&gt;&gt;&gt;会把第一位的1也向右移动，导致移动后，第一位变成0，这样就会使得负数在无符号右移后，得到一个正数。 4 –&gt; 位赋值操作符 所有的二进制位运算符都有一种将赋值与位运算组合在一起的简写形式： 运算符 含义 实例 结果 &amp;= 按位与赋值 num1 &amp;= num2 等价于 num 1=num 1 &amp; num2 |= 按位或赋值 num1 |= num2 等价于 num 1=num 1 ^= 按位异或赋值 num1 ^= num2 等价于 num 1=num 1 ^ num2 «= 按位左移赋值 num1 «= num2 等价于 num 1=num 1 « num2 »= 按位右移赋值 num1 »= num2 等价于 num 1=num 1 » num2 ============================================ 位赋值实例： 1234567891011121314151617181920212223public class HelloJava { public static void main(String[] args) { // TODO Auto-generated method stub int a = 1; int b = 2; int c = 3; a &amp;= 4; System.out.println(a); a |= 4; System.out.println(a); a ^= c; System.out.println(a); a -= 6; System.out.println(a); b &gt;&gt;= 1; System.out.println(b); c &lt;&lt;= 1; System.out.println(c); } } 输出： 123456047116 操作符优先级Java 中操作符优先级助记口诀： 单目乘除为关系，逻辑三目后赋值 口诀解释： 单目：单目操作符 –&gt; !（取反）+（正） –（负数） ++/ –（自增自减） ~ 乘除：算数操作符中的 *（乘） /（除） %（取模）–&gt; 后 +（加）-（减） 为：位移操作符 &lt;&lt; （左移）&gt;&gt;（右移） 关系：关系运算符&gt; （大于）&lt;（小于） &gt;=（大于等于） &lt;=（小于等于）==（等于） !=（不等于） 逻辑：逻辑操作符 &amp;&amp;（短路与） ||（短路或） &amp;（逻辑与） |（逻辑或） ^ （异或） 三目：三目操作符 A &gt; B ? X : Y 后：无意义，仅仅为了凑字数 赋值：=（赋值）+=/-+/*=//=/%=（算术赋值）&amp;=/|=/^=/~=（位逻辑赋值）&lt;&lt;=/&gt;&gt;=（位移赋值） 操作符优先级： 优先级 运算符 结合性 1 ()、[]、{} 从左向右 2 !、+、-、~、++、– 从右向左 3 *、/、% 从左向右 4 +、- 从左向右 5 «、»、&gt;&gt;&gt; 从左向右 6 &lt;、&lt;=、&gt;、&gt;=、instanceof 从左向右 7 ==、!= 从左向右 8 &amp; 从左向右 9 ^ 从左向右 10 | 从左向右 11 &amp;&amp; 从左向右 12 || 从左向右 13 ?: 从右向左 14 =、+=、-=、*=、/=、&amp;=、|=、^=、~=、«=、»=、&gt;&gt;&gt;= 从右向左 实际的开发中，不需要去记忆运算符的优先级别，也不要刻意的使用运算符的优先级别，对于不清楚优先级的地方使用小括号去进行替代。 Scanner截至目前为止，学习了使用 System.out.println(“”) 向控制台输出数据。 那么，如何从控制台输入数据？ 使用Scanner类，需要在最前面加上 import java.util.Scanner; 表示导入这个类，才能够正常使用。 Scanner 读取整数1234567891011import java.util.Scanner; public class HelloWorld { public static void main(String[] args) { Scanner s = new Scanner(System.in); int a = s.nextInt(); System.out.println(&quot;第一个整数：&quot;+a); int b = s.nextInt(); System.out.println(&quot;第二个整数：&quot;+b); }} Scanner 读取浮点数12345678910import java.util.Scanner; public class HelloWorld { public static void main(String[] args) { Scanner s = new Scanner(System.in); float a = s.nextFloat(); System.out.println(&quot;读取的浮点数的值是：&quot;+a); }} Scanner 读取字符串123456789import java.util.Scanner; public class HelloWorld { public static void main(String[] args) { Scanner s = new Scanner(System.in); String a = s.nextLine(); System.out.println(&quot;读取的字符串是：&quot;+a); }} 读取了整数后，接着读取字符串: 如果在通过nextInt()读取了整数后，再接着读取字符串，读出来的是回车换行:”\\r\\n”,因为nextInt仅仅读取数字信息，而不会读取回车换行”\\r\\n”。 所以，如果在业务上需要读取了整数后，接着读取字符串，那么就应该连续执行两次nextLine()，第一次是取走回车换行，第二次才是读取真正的字符串。 123456789101112import java.util.Scanner; public class HelloWorld { public static void main(String[] args) { Scanner s = new Scanner(System.in); int i = s.nextInt(); System.out.println(&quot;读取的整数是&quot;+ i); String rn = s.nextLine(); String a = s.nextLine(); System.out.println(&quot;读取的字符串是：&quot;+a); }} Scanner Close使用之后记得关闭 Scanner，防止消耗资源 scan.close();","link":"/2017/10/14/java-cheng-xu-she-ji-ji-chu-zhi-cao-zuo-fu/"},{"title":"Java 程序设计基础之流程控制","text":"关于 Java 程序设计语言的 基础语法 部分，前面我们已经详细了解过了 Java 中的字面值，变(常)量，数据类型以及操作符，这里我们来看 Java 基础语法的另一个重要组成部分——Java 中的流程控制语句，它决定程序要进入什么流程，即“做什么”以及“怎么做等。 流程控制结构从结构化程序设计角度出发，编程语言一般会有 3 种结构： 顺序结构 分支结构 循环结构 若是在程序中没有给出特别的执行流程控制，系统则默认自上而下一行一行地执行该程序，这类程序的结构就称为顺序结构。 但事实上，现实事物的发展往往不会遵循早就设想好的轨迹进行，此时需要引入：分支结构，循环结构。 分支结构Java 支持两种选择语句： if 语句：使用 布尔表达式或布尔值 作为分支条件，来进行程序执行分支控制 switch 语句：用于对多个 整型值、字符串值 进行匹配，从而实现程序执行分支控制。 下面会分别对上述的两种选择（分支）语句进行解读： if 语句1 –&gt; if 结构 if 语句的最简语法格式如下，表示：“如果条件表达式为 true，就执行语句块”。 123if (条件表达式) { 语句块;} if 条件语句的运行流程如下： 实例： 12345678910public class HelloWorld { public static void main(String[] args) { boolean b = true; if(b){ // 如果成立就打印：yes System.out.println(&quot;yes&quot;); } }} –&gt; 多表达式与一个表达式 123456789101112131415161718192021222324252627public class HelloWorld { public static void main(String[] args) { boolean b = false; // 如果有多个表达式，必须用大括弧包括起来 if(b){ System.out.println(&quot;yes1&quot;); System.out.println(&quot;yes2&quot;); System.out.println(&quot;yes3&quot;); } // 否则表达式2 3, 无论 b 是否为 true 都会执行 if(b) System.out.println(&quot;yes1&quot;); System.out.println(&quot;yes2&quot;); System.out.println(&quot;yes3&quot;); // 如果只有一个表达式可以不用写括弧，看上去会简约一些（但语法规范不推荐） if(b){ System.out.println(&quot;yes1&quot;); } if(b) System.out.println(&quot;yes1&quot;); }} 2 –&gt; if-else 结构 if-else 结构语法格式如下，表示：“如果条件（表达式）正确则执行 –&gt; 语句块1，否则执行 –&gt; 语句块2”。 12345if (表达式) { 语句块1;} else { 语句块2;} if-else 结构的运行流程如下： 实例： 12345678910111213public class HelloWorld { public static void main(String[] args) { boolean b = false; if (b){ System.out.println(&quot;yes&quot;); } else{ System.out.println(&quot;no&quot;); } }} 3 –&gt; 多条件 if-else-if 结构 if-else-if 结构是多条件判断，语法格式如下： 12345678910if(表达式1) { 语句块1;} else if(表达式2) { 语句块2;...} else if(表达式n) { 语句块n;} else { 语句块n+1;} 表现为：依次判断表达式的值，当某个分支的条件表达式的值为 true 时，则执行该分支对应的语句块，然后跳到整个 if 语句之外继续执行程序。如果所有的表达式均为 false，则执行语句块 n+1，然后继续执行后续程序。 if-else-if 结构的运行流程如下： 实例： 1234567891011121314151617181920212223242526public class HelloWorld { public static void main(String[] args) { // 如果只使用 if,会执行 4 次判断 int i = 2; if (i==1) System.out.println(1); if (i==2) System.out.println(2); if (i==3) System.out.println(3); if (i==4) System.out.println(4); // 如果 i == 2 时成立，则后续判断均不再执行 if (i==1) System.out.println(1); else if (i==2) System.out.println(2); else if (i==3) System.out.println(3); else if (i==4) System.out.println(4); }} 4 –&gt; if 嵌套结构 if 条件结构里嵌套另一个 if 结构。同样，if…else 结构语句和 if…else if 结构语句中也可以嵌套另一个 if 结构的语句，以完成更深层次的判断（一般不要超过 3 层）。 嵌套 if 的语法格式如下： 12345678910111213141516171819if(表达式1) { if(表达式2) { 语句块1; } else { 语句块2; }} else { if(表达式3) { 语句块3; } else if(表达式4) { 语句块4; } else { if(表达式n) { 语句块n; } else { 语句块n+1; } }} switch 语句switch 语句是 Java 中的多路分支语句，提供了一种基于一个表达式的值来使程序执行不同部分的简单方法。 switch 提供了一个比一系列 if-else-if 语句更好的选择。 switch 语句的基本语法形式如下所示： 123456789101112131415switch(表达式) { case 值1: 语句块1; break; case 值2: 语句块2; break; … case 值n: 语句块n; break; default: 语句块n+1; break;} switch 语句的执行过程如下：表达式的值与每个 case 语句中的常量作比较。如果发现了一个与之相匹配的，则执行该 case 语句后的代码。如果没有一个 case 常量与表达式的值相匹配，则执行 default 语句。 default 语句是可选的。 如果没有相匹配的 case 语句，也没有 default 语句，则什么也不执行。 注意：重复的 case 值是不允许的。 ================================================= 使用注意： switch 关键字后面小括号里的值：要放一个整型变量或字符型变量；表达式必须为 byte，short，int，char类型； case 关键字后的值，可以是：类型为 char、byte、 short 或 int 的常量表达式；enum 常量；或字符串字面量； break：一般语句块后均需要加 break；如果在 case 分支语句的末尾没有 break 语句，那么就会接着执行下一个 case 分支语句。这种情况相当危险，常常会引发错误。 default：表示“默认”，即其他情况都不满足；default 块和 case 块的先后顺序可以变动，不会影响程序执行结果。通常，default 块放在末尾，也可以省略不写。 switch 语句中也支持嵌套，但一般不这么用 if 语句可计算任何类型的布尔表达式。也就是 switch 语句只能寻找 case 常量间某个值与表达式的值相匹配。 循环结构所有流行的编程语言中都有循环语句。Java 中采用的循环语句与C语言中的循环语句相似，主要有： while do-while for Java 5 之后，还推出了 for-each 循环语句。它是专门为数组、集合遍历而设计的。但 for-each 并不是一个关键字。 while 语句while 语句是 Java 最基本的循环语句，是一种先判断的循环结构。while 循环语句的语法结构如下： 123while(条件表达式) { 语句块;} 其中语句块中的代码可以是一条或者多条语句，而条件表达式是一个有效的 boolean 表达式，它决定了是否执行循环体。当条件表达式的值为 true 时，就执行大括号中的语句块。 循环语句的执行流程如下: 实例： 1234567891011public class HelloWorld { public static void main(String[] args) { // 打印 0~4 int i = 0; while(i&lt;5){ System.out.println(i); i++; // 控制循环结束 } }} do…while语句如果 while 循环一开始条件表达式就是假的，那么循环体就根本不被执行。然而，有时需要在开始时条件表达式即使是假的情况下，while 循环至少也要执行一次。 do-while 循环语句的特点是先执行循环体（循环至少也要执行一次），然后判断循环条件是否成立，成立后继续执行。 do-while 语句的语法格式如下： 123do { 语句块;}while(条件表达式); do-while 循环语句执行流程如下： 实例（图书列表中保存了 50 条信息，现在需要让它每行显示 10 条，分 5 行进行显示）： 12345678910public static void main(String[] args) { int bookIndex = 1; do { System.out.print(bookIndex+&quot;\\t&quot;); if(bookIndex%10 == 0) { System.out.println(); } bookIndex++; }while(bookIndex&lt;51);} for 语句for 循环，和 while 循环一样，只是表达方式不一样。 for 语句语法格式如下所示： 123for(条件表达式1;条件表达式2;条件表达式3) { 语句块;} for 关键字后面括号中的 3 个条件表达式必须用 “;” 隔开。 for 循环中 3 个表达式的含义: 表达式 形式 功能 举例 条件表达式 1 赋值语句 循环结构的初始部分，为循环变量赋初值 int i=1 条件表达式 2 条件语句 循环结构的循环条件 i&gt;40 条件表达式 3 迭代语句，通常使用 ++ 或 – 运算符 循环结构的迭代部分，通常用来修改循环 变量的值 i++ 123456789public static void main(String[] args) { for (int bookIndex = 1;bookIndex&lt;51;bookIndex++){ System.out.print(bookIndex+&quot;\\t&quot;); if(bookIndex%10 == 0) { System.out.println(); } }} ================================================== 特别： for 语句中初始化、循环条件以及迭代部分都可以为空语句（但分号不能省略），三者均为空的时候，相当于一个无限循环。但无论缺少哪部分条件表达式，都可以在程序的其他位置补充，从而保持 for 循环语句的完整性，使循环正常进行。 1 –&gt; 条件表达式 1 为空 例如，使用 for 语句的这种形式计算 1~100 所有奇数的和。 123456789public static void main(String[] args) { int result = 0; int number = 1; // 相当于for语句的第1个表达式 for (; number &lt; 101; number++) { if (number % 2 != 0) // 如果不能整除2，说明是奇数，则进行累加 result += number; } System.out.print(&quot;100 以内所有奇数和为：&quot; + result);} 2 –&gt; 条件表达式 2 为空 当 for 语句中条件表达式 2 为空时，将没有循环的终止条件。为了使循环达到某种条件时退出，需要在语句块中进行逻辑判断，并使用 break 语句来跳出循环，否则将产生死循环。 同样是计算 1~100 所有奇数的和，使用这种方式的代码如下。 12345678910public static void main(String[] args) { int result = 0; for (int number = 1;; number++) { if (number &gt; 100) break; // 相当于for语句的表达式2，满足时就退出for循环 if (number % 2 != 0) // 如果不能整除2，说明是奇数，则进行累加 result += number; } System.out.print(&quot;100 以内所有奇数和为：&quot; + result);} 3 –&gt; 条件表达式 3 为空 当 for 语言中条件表达式 3 为空时，也就没有设置控制变量的表达式，即每次循环之后无法改变变量的值，此时也无法保证循环正常结束。 同样是计算1~100 所有奇数的和，使用这种方式的代码如下： 123456789public static void main(String[] args) { int result = 0; for (int number = 1; number &lt; 101;) { if (number % 2 != 0) // 如果不能整除2，说明是奇数，则进行累加 result += number; number++; // 相当于for语句的条件表达式3，每次递增1 } System.out.print(&quot;100 以内所有奇数和为：&quot; + result);} 4 –&gt; 3 个条件表达式都为空 事实上，在 for 循环语句中，无论缺少哪部分条件表达式，都可以在程序的其他位置补充，从而保持 for 循环语句的完整性，使循环正常进行。 但是，对于这种情况，读者在使用时应该尽量避免。 例如，计算 1~100 所有奇数的和，使用这种方式的代码如下： 123456789101112public static void main(String[] args) { int result = 0; int number = 1; // 相当于for语句的条件表达式1 for (;;) { if (number &gt; 100) break; // 相当于for语句的条件表达式2 if (number % 2 != 0) // 如果不能整除2，说明是奇数，则进行累加 result += number; number++; // 相当于for语句的条件表达式3 } System.out.print(&quot;100 以内所有奇数和为： &quot; + result);} 循环嵌套和其他编程语言一样，Java 允许循环嵌套。如果把一个循环放在另一个循环体内，那么就可以形成嵌套循环。 嵌套循环既可以是 for循环嵌套 while 循环，也可以是 while 循环嵌套 do-while 循环 …… 即各种类型的循环都可以作为外层循环，也可以作为内层循环。 假设外层循环的循环次数为 n 次，内层循环的循环次数为 m 次，那么内层循环的循环体实际上需要执行 n×m 次。 for、do-while 和 while 的区别： 名称 概念 适用场景 for 根据循环次数限制做多少次重复操作 适合循环次数是已知的操作 while 当满足什么条件的时候，才做某种操作 适合循环次数是未知的操作 do-while 先执行一次，在判断是否满足条件 适合至少执行一次的循环操作 foreach 语句foreach 循环语句是 Java 1.5 的新特征之一，在 遍历数组、集合 方面，foreach 为开发者提供了极大的方便。 foreach 循环语句的语法格式如下： 123for(类型 变量名:集合) { 语句块;} 其中，“类型”为集合或数组中 元素的类型，“变量名”表示集合或数组中的每一个元素，“集合”是被遍历的集合对象或数组。 样例，假设有一个数组，采用 for 语句遍历数组的方式如下： 1234567// 声明并初始化数组int[] numbers = { 43, 32, 53, 54, 75, 7, 10 };System.out.println(&quot;----for----&quot;);// for语句for (int i = 0; i &lt; numbers.length; i++) { System.out.println(&quot;Count is:&quot; + numbers[i]);} 关于数组集合会在教程后面详细介绍，这里我们只需要大概了解就可以。numbers.length 是获得数组的长度，length 是数组的属性，numbers[i] 是通过数组下标访问数组元素。 那么采用 for-each 循环语句遍历数组的方式如下： 1234567// 声明并初始化int数组int[] numbers = { 43, 32, 53, 54, 75, 7, 10 };System.out.println(&quot;----for each----&quot;);// for-each语句for (int item : numbers) { System.out.println(&quot;Count is:&quot; + item);} 从示例中可以发现，item 不是循环变量，它保存了集合中的元素，for-each 语句将集合中的元素一一取出来，并保存到 item 中，这个过程中不需要使用循环变量，通过数组下标访问数组中的元素。可见 for-each 语句在遍历集合的时候要简单方便得多。 –&gt; 注意：foreach 循环迭代数组（集合）元素时，并不能改变数组（集合）元素的值 当使用 foreach 循环来迭代输出数组元素或集合元素时，通常不要对循环变量进行赋值，虽然这种赋值在语法上是允许的，但没有太大的实际意义，而且极容易引起错误。例如下面程序。 1234567891011public static void main(String[] args) { String[] languages={&quot;Java&quot;,&quot;ASP.NET&quot;,&quot;Python&quot;,&quot;C#&quot;,&quot;PHP&quot;}; System.out.println(&quot;时下流行的编程语言：&quot;); // 使用 foreach 循环语句遍历数组 for(String lang:languages) { lang = &quot;Google&quot;; System.out.println(lang); } System.out.println(languages[0]);} 运行上边程序，将看到如下结果： 1234567时下流行的编程语言：GoogleGoogleGoogleGoogleGoogleJava 可以发现，由于在 foreach 循环中对数组元素进行赋值，结果导致不能正确遍历数组元素，不能正确地取出每个数组元素的值。而且当再次访问第一个数组元素时，发现数组元素的值依然没有改变。 =================================================== 原理解析： 当使用 foreach 来迭代访问数组元素时，foreach 中的循环变量相当于一个临时变量，系统会把数组元素依次赋给这个临时变量，而这个临时变量并不是数组元素，它只是保存了数组元素的值。因此，如果希望改变数组元素的值，则不能使用这种 foreach 循环。 break 语句某些时候需要在某种条件出现时强行终止循环，而不是等到循环条件为 false 时才退出循环。此时，可以使用 break 来完成这个功能。 Java 中，break 语句有 3 种作用： break，可用于直接结束当前循环 在 switch 语句中终止一个语句序列 实现 goto 的功能 直接结束当前循环使用 break 语句直接强行退出循环的示例如下： 123456789101112public class HelloWorld { public static void main(String[] args) { // 打印单数 for (int j = 1; j &lt; 10; j++) { if(0==j%2) break; // 如果是双数，直接结束循环 System.out.println(j); } }} 输出如下： 11 break 语句能用于任何 Java 循环中，包括人们有意设置的无限循环。 在一系列嵌套循环中使用 break 语句时，它将仅仅终止最里面的循环 123456789101112131415public static void main(String[] args) { // 外循环，循环5次 for (int i = 0; i &lt; 5; i++) { System.out.print(&quot;第&quot; + (i + 1) + &quot;次循环：&quot;); // 内循环，设计为循环10次 for (int j = 0; j &lt; 10; j++) { // 判断j是否等于3，如果是，则终止循环 if (j == 3) { break; } System.out.print(&quot;内循环的第&quot; + (j + 1) + &quot;次循环\\t&quot;); } System.out.println(); }} break 带标签实现 goto 功能Java 提供了一种带标签的 break 语句，用于跳出多重嵌套的循环语句，可以实现 goto 的功能。 通过使用扩展的 break 语句，可以终止执行一个或者几个任意代码块，这些代码块不必是一个循环或一个 switch 语句的一部分。同时这种扩展的 break 语句带有标签，可以明确指定从何处重新开始执行。 标签 break 语句的通用格式如下： break label; label 是标识代码块的标签。被加标签的代码块必须包围 break 语句，但是它不需要直接包围 break 的块。也就是说，可以使用一个加标签的 break 语句来退出一系列的嵌套块，但是不能使用 break 语句将控制权传递到不包含 break 语句的代码块。 用标签（label）可以指定一个代码块，标签可以是任何合法有效的 Java 标识符，后跟一个冒号。 下面是使用带标签的break 语句的示例。 123456789101112public class GotoDemo { public static void main(String[] args) { label: for (int i = 0; i &lt; 10; i++) { for (int j = 0; j &lt; 8; j++) { System.out.println(j); if (j % 2 != 0) { break label; } } } }} 程序执行结果： 1201 可以发现，加上标签的代码块可以作为 break 语句的对象，使程序在加标签的块的结尾继续执行。 标签语句必须和循环匹配使用，使用时书写在对应的循环语句的上面，标签语句以冒号结束。如果需要中断标签语句对应的循环，可以采用 break 后面跟标签名的方式。 但注意，标签语句可以独立使用， Java 不会报错 switch 语句中终止一个语句序列break 在 switch 语句中可终止一个语句序列，就是在每个 case 子句块的最后添加语句 “break;”，具体使用可见分支结构中的 switch 语句。 continue 语句与 break 语句一样， 它将中断正常的控制流程。与 break 语句的区别在于：continue 并不是中断循环语句，而是中止当前迭代的循环，进入下一次的迭代。 简单来讲，continue 是忽略循环语句的当次迭代。 123456789101112public class HelloWorld { public static void main(String[] args) { //打印单数 for (int j = 0; j &lt; 10; j++) { if(0==j%2) continue; //如果是双数，后面的代码不执行，直接进行下一次循环 System.out.println(j); } }} 程序输出： 1234513579 –&gt; continue label 同 break 语句一样，continue 语句同样可以配合 label 使用。 带标签的 continue 语句示例代码如下： 123456789101112public class GotoDemo { public static void main(String[] args) { label: for (int i = 0; i &lt; 10; i++) { for (int j = 0; j &lt; 8; j++) { System.out.println(j); if (j % 2 != 0) { continue label; } } } }} 注意，与 break label 使用时的区别。 输出如下: 12345678910110101010101...","link":"/2017/10/16/java-cheng-xu-she-ji-ji-chu-zhi-liu-cheng-kong-zhi/"},{"title":"Jupyter Tutorial","text":"我们应该知道，Python 之所有“崛起”，得益于机器学习和数学统计应用的兴起。至于 Python 适合数学统计和机器学习的原因，很多读者可能并不会想到，Jupyter Notebook 功不可没。可以好不夸张地说，作为一名 Python 数据工程师，如果不会使用 Jupyter Notebook（Jupyter Lab），你真是太 Out 了。 更多 Python 版本管理以及运行环境相关内容，请关注博主 Git 博文系列： 之一 &gt;&gt;&gt; Python-Vers Management 之二 &gt;&gt;&gt; Pythoner 神器之 virtualenv 之三 &gt;&gt;&gt; 一文了解数据科学神器 Anaconda 之四 &gt;&gt;&gt; Jupyter Tutorial What Is Jupyter Notebook？说了这么多，到底什么是 Jupyter Notebook 呢？按照 Jupyter 创始人的说法，起初他是想做一个综合 Ju（Julia）、Py（Python）和 R 三种科学运行语言的计算工具平台，所以将其命名为 Jupyter。 Jupyter 发展到现在，已经成为了一个几乎支持所有语言，能够把软件代码开发、运行输出、解释文档、多媒体资源整合在一起的 基于网页的多功能科学运行平台。Jupyter Notebook 的工作界面如图： 简言之，Jupyter Notebook 是以网页的形式打开，可以在页面中直接编写和运行代码，代码的运行结果也会直接在代码块下显示。假如在编程过程中需要编写说明文档，可在同一个页面中直接编写，便于作及时的说明和解释。 System Composition1 –&gt; 网页应用 Jupyter Notebook 是基于网页形式的，并且结合了代码开发运行、说明文档编写、交互计算和其他富媒体形式的网页应用工具。 简言之，Jupyter Notebook 是可以实现特定功能的网页工具。 2 –&gt; 文档 Jupyter Notebook 中所有代码开发运行、说明文档编写、交互计算和其他富媒体形式的输入和输出，都是 以文档的形式体现 的。 这些文档都以后缀名为 .ipynb 的 JSON 格式文件 进行保存。此外，Jupyter Notebook 中的文档换支持导出为：HTML、MD、PDF、LaTeX、python 等多种格式。 Features introduction主要特点说明： 编程时具有语法高亮、缩进、Tab 补全的功能； 可直接通过浏览器运行代码，同时在代码块下方展示运行结果； 以富媒体格式展示计算结果，包括：HTML，LaTeX，PNG，SVG 等； 对代码编写说明文档或语句时，支持 Markdown 语法； 支持使用 LaTeX 编写数学性说明。 jupyter Setup预安装准备 &gt;&gt;&gt;&gt; 安装 Jupyter Notebook 的前提是：你需要安装了 Python（3.3 版本及以上，或 2.7 版本）。 准备好 Python 环境之后，就可以开始 Jupyter Notebook 的安装了，这里我们提供两种不同的安装方式： 使用 Anaconda 方式安装； 使用 Pip 方式 安装； Anaconda For Jupyter Setup对于初学者，建议你通过安装 Anaconda 来解决 Jupyter Notebook 的安装问题，Anaconda 中已自动为你安装了 Jupyter Notebook，并且还为你提供了其它丰富的 Python 学习支持。 关于 Anaconda 的安装配置和学习可参见系列博文：一文了解数据科学神器 Anaconda。 Anaconda 安装完成后，可以在终端中使用查看 Jupyter Notebook 版本信息命令测试一下，验证 Jupyter Notebook 是否安装成功： 12$ &gt;jupyter notebook --version6.4.5 Pip For Jupyter Setup这里尝试用 Pip 命令来单独安装 Jupyter Notebook，请看以下步骤： 1 –&gt; 升级 Pip 工具至最新版本 12# Python 3.x（Python 2.x）$ pip3(pip) install --upgrade pip 提示：老版本的 Pip 在安装 Jupyter Notebook 过程中可能会面临依赖项无法同步安装的问题。因此，强烈建议先把 Pip 升级至最新版本。 2 –&gt; Setup Jupyter 12# Python 3.x（Python 2.x）$ pip3(pip) install jupyter 3 –&gt; Setup Test 123# 使用查看 Jupyter Notebook 版本信息命令测试一下，验证安装是否成功$ &gt;jupyter notebook --version6.4.5 安装完成之后，你就可以尝试启动 Jupyter Notebook，一睹芳容了~~~ How To Run?如果你有任何 Jupyter Notebook 命令的疑问，可以考虑查看官方帮助文档，命令如下： 123$ jupyter notebook --help# 或者$ jupyter notebook -h 默认端口启动在终端中输入以下命令： 1$ jupyter notebook 执行命令之后，在终端中将会输出显示一系列启动 Jupyter notebook 本地服务器的信息： 12345$[I 20:31:48.891 NotebookApp] Serving notebooks from local directory: E:/jupyterWorkS[I 20:31:48.892 NotebookApp] Jupyter Notebook 6.4.5 is running at:[I 20:31:48.892 NotebookApp] http://localhost:8888/?token=4179d7ebd004065c9bb751e25539e9c605ead31e1c1cc5b7[I 20:31:48.892 NotebookApp] or http://127.0.0.1:8888/?token=4179d7ebd004065c9bb751e25539e9c605ead31e1c1cc5b7[I 20:31:48.892 NotebookApp] Use Control-C to stop this server and shut down all kernels (twice to skip confirmation). 注意：之后想要在 Jupyter Notebook 页面正常工作，请保持终端不要关闭，因为一旦关闭终端，就会立刻断开与本地服务器的链接，你将无法继续在 Jupyter Notebook 中工作了（404）。 同时浏览器将会自动启动 Jupyter Notebook 页面，浏览器地址栏中默认地将会显示：http://localhost:8888: 如果你同时启动了多个 Jupyter Notebook，由于默认端口 “8888” 被占用，因此地址栏中的数字将从 “8888” 起，每多启动一个 Jupyter Notebook 数字就加 1，如 “8889”、“8890”…… 指定端口启动如果你想使用自定义的端口号来启动 Jupyter Notebook，可以在终端中输入以下命令： 1$ jupyter notebook --port &lt;port_number&gt; 命令说明 –&gt; “port_number” 是自定义端口号，直接以数字的形式写在命令当中。例如：jupyter notebook --port 9999，即在端口号为 9999 的服务器启动 Jupyter Notebook。 启动 Jupyter 但不打开浏览器默认情况下不出异常的话，启动 Jupyter Notebook 服务器就会自动打开浏览器页面。 如果你只是想启动 Jupyter Notebook 的服务器但不打算立刻进入到主页面，那么就无需立刻启动浏览器。在终端中输入： 1$ jupyter notebook --no-browser 此时，将会在终端显示启动的服务器信息，并在服务器启动之后，显示出打开浏览器页面的链接。当你需要启动浏览器页面时，只需要复制链接，并粘贴在浏览器的地址栏中，轻按回车就转到了你的 Jupyter Notebook 页面。 异常情况 &gt;&gt;&gt; 默认情况下，使用 jupyter notebook 命令运行时观察到已启动 Jupyter Notebook 服务器，但无法自动打开浏览器，手动使用链接可以？！！可使用以下方式解决： 1）查找配置文件 首先查找 Jupyter Notebook 配置文件，我们在命令行终端输入： 1$ jupyter notebook --generate-config 该命令执行后，如果发现没有配置文件则会新建，如有则会询问是否重载。 Jupyter Notebook 默认配置文件存放路径：~/.jupyter/jupyter_notebook_config.py，即当前用户目录下的 .jupyter 目录下的文件：jupyter_notebook_config.py。 2）定位设置项语句 找到该文件后，打开，定位到如下语句： 1#c.NotebookApp.browser = '' 3）配置默认打开浏览器 在上述语句下方添加内容： 1234import webbrowserwebbrowser.register(&quot;Microsoft Edge&quot;,None,webbrowser.GenericBrowser(u&quot;C:\\Program Files (x86)\\Microsoft\\Edge\\Application\\msedge.exe&quot;))c.NotebookApp.browser = 'Microsoft Edge' 如果想将默认浏览器调成 Chrome，可以将上述 Microsoft Edge 换成 Chrome，并且找到 Chrome 的运行文件，替换即可。 OK，重新尝试启动 jupyter notebook，观察一下~~~ 关闭 Jupyter Notebook如果你想退出 Jupyter Notebook 程序，仅仅通过关闭网页是无法退出的，因为当你打开 Jupyter Notebook 时，其实是启动了它的本地服务器。 你可以尝试关闭页面，并打开新的浏览器页面，把之前的地址输进地址栏，然后跳转页面，你会发现再次进入了刚才 “关闭” 的 Jupyter Notebook 页面。 要彻底退出 Jupyter Notebook，需要关闭它的服务器。只需要在它启动的终端上按：Ctrl + c，关闭信息如下： 123[I 00:18:06.765 NotebookApp] Interrupted...[I 00:18:06.768 NotebookApp] Shutting down 0 kernels[I 00:18:06.772 NotebookApp] Shutting down 0 terminals Jupyter Notebook Page这一小节来从 Jupyter Notebook 网页页面来了解 Jupyter Notebook 的使用。 File PageFiles 页面是用于管理和创建文件相关的类目： 当前，我们的界面当中应该还没有 “Conda” 和 “Nbextensions” 类目，这需要后续单独安装配置，不要着急~~~ 当前页面就不详细说明了，结合上面的图示说明，上手尝试一下，很快就了解使用了。 Running PageRunning 页面展示的是当前正在运行当中的终端（Terminal）和 “ipynb” 格式笔记本（Notebook）。 若想要关闭已经打开的终端 和 “ipynb” 格式的笔记本，仅仅关闭其页面是无法彻底退出程序的，需要在 Running 页面点击其对应的 【Shutdown】。 Clusters Page Clusters tab is now provided by IPython parallel. See ‘IPython parallel’ for installation details. Clusters 类目现在已由 IPython parallel 对接，且由于现阶段使用频率较低，因此在此不做详细说明，想要了解更多可以访问 IPython parallel。 Nbextensions Page默认情况下，Jupyter Notebook Page 中是不含 Nbextensions 页面的。你可以通过如下方法进行安装： 12345# Step 1 &gt;&gt;&gt; 安装 Nbextensions 插件库：$ pip install jupyter_contrib_nbextensions# Step 2 &gt;&gt;&gt; 安装关联的 JavaScript 和 CSS 文件$ jupyter contrib nbextension install --user 完成上述操作后，就可以看到如下 Nbextensions 选项卡了： Nbextensions页面提供了多个 Jupyter Notebook 的插件，使其功能更加强大。该页面中主要使用的插件有：nb_conda、nb_present、Table of Contents(2)。 例如，Table of Contents(2) 插件可为 Markdown 文档提供目录导航，便于我们编写文档。nb_conda 插件可方便 Jupyter Notebook 中 Python 多版本环境的自由切换。 需要注意的是：初始情况下 Nbextensions 的功能是没有开启的，需要 去掉 disable 的勾选！！！ Conda Page默认情况下，Jupyter Notebook Page 中是不含 Conda 页面的，安装 nb_conda 插件后出现。可用于管理 Anaconda 中所有的虚拟环境以及依赖包。 安装过程如下 ↓↓↓↓↓↓↓↓ [1] –&gt; 关联 Jupyter Notebook 和已创建的 conda 虚拟环境 执行如下命令： 1$ conda install nb_conda 执行上述命令能够将你 conda 创建的虚拟环境与 Jupyter Notebook 相关联，便于你在 Jupyter Notebook 的使用中，在不同的环境下创建笔记本进行工作。 [2] –&gt; Using nb_conda 你可以在 Conda 类目下对 conda 环境和包进行一系列操作： [3] –&gt; 卸载 nb_conda 1$ conda remove nb_conda Common OperationsJupyter 笔记本（Notebook）中常用操作： Run Python想在 Jupyter Notebook 中加载本地的 Python 文件并执行文件代码，单元格（Cell）中执行以下命令： 1%load Python文件的绝对路径 首次执行时，会将本地的 Python 文件内容加载到单元格（Cell）内。此时，Jupyter Notebook 会自动将 “%load” 命令注释掉（即在前边加井号 “#”），以便在执行已加载的文件代码时不重复执行该命令；之后再次执行时，则是执行已加载文件的代码。 如果，不想在 Jupyter Notebook 的单元格中加载本地 Python 文件，想要直接运行，单元格（Cell）中执行以下命令： 1%run Python文件的绝对路径 或者： 12# 调用 Python3(Python2) 解释器执行（Cell 可直接执行 Shell 命令）!python3（!python） Python文件的绝对路径 Get Current PATH想要在 Jupyter Notebook 中获取当前所在位置的绝对路径： 1%pwd 或者： 12# Cell 可直接执行 Shell 命令!pwd Run Shell CMD在 Jupyter Notebook 中的笔记本单元格中，用英文感叹号 ! + Shell命令 即可执行 shell 命令： 1!shell命令 例如： 1!ls Show Line Numbers默认情况下，Notebook Cell 中是不显示行号的，你可以通过【View】 &gt;&gt;&gt;&gt; 【Toggle/Show Line Numbers】开启行号。 Notebook ModeJupyter Notebook笔记本有两种工作模式： 命令模式 编辑模式 命令模式选定某一单元格，按 【Esc】 键进入命令模式，此时单元格边框为灰色，且左侧边框线为蓝色粗线条。 命令模式下，可以通过键盘不同键的组合运行笔记本的操作。 例如，常用的切换单元格文本类型的：Y（Code）、M（Markdown）、R（Raw）。 此时，使用快捷键 dd 可以快速删除当前单元格。 编辑模式选定某一单元格，按 【enter】 键进入编辑模式，此时单元格边框和左侧边框线均为绿色。 编辑模式使用户可以在单元格内编辑代码或文档。 Jupyter Lab怎么又跑出来个 Jupyter Lab？！！ Jupyter Lab 是包含 Jupyter Notebook 在内的下一代用户界面，它具有模块化的结构，您可以在同一窗口中打开多个笔记本或文件（例如：HTML、Text、Markdowns等）作为选项卡，提供了更多类似于 IDE 的体验。 你可以将其视为一个究极进化版本的 Jupyter Notebook。 你可以设置一个 .ipynb 文件（TheDifference.ipynb），一个 文件浏览器 和一个 TheDifference.ipynb 文件所对应的 Python 控制台，这可以帮助你高效的使用 Jupyter Lab，如下： 现在，你可以使用以下工具： 查看文件，正在运行的内核，命令，笔记本工具，打开选项卡或扩展管理器； 使用快捷键来运行单元格， Ctrl + Enter； 使用菜单选项或键盘快捷键运行单个表达式，行或突出显示的文本； 使用以下命令直接在控制台中运行代码 Shift + Enter； 在控制台中快速轻松地检查变量，数据框或绘图，而不会使笔记本的输出混乱； 使用快捷键 Ctrl + B 可以实现快速开启和关闭文件浏览器。 你可以通过右键 .ipynb 文件（TheDifference.ipynb），点击 【New Console For Notebook】 为 TheDifference.ipynb 创建一个同时运行于当前内核的 Python 控制台，用于监控 TheDifference.ipynb 运行时变量以及数据流的变化。 此时，你可以通过复制 TheDifference.ipynb 文件中的单行内容在 Python 控制台中进行单独执行。 同内核中运行单行代码更简介的方法 &gt;&gt;&gt;&gt; 较新版本的 Jupyter Lab，你可以将标记放在一行上，或突出显示一个选择（标记选择一个区域），然后使用菜单选项：【Run】 &gt;&gt;&gt; 【Run Selected Text or Current Line in Console】，即可打开 .ipynb 文件所对应的 Python 控制台。 为了方便使用，还分配快捷键使运行变得更加轻松： 【Settings】 –&gt; 【Advanced Settings editor】 –&gt; 【Keyboard shortcuts tab】 –&gt; 在 System Defaults 区域 【ctrl + F】 进行搜索关键字：run-in-console，找到如下部分： 1234567{ &quot;command&quot;: &quot;notebook:run-in-console&quot;, &quot;keys&quot;: [ &quot;&quot; ], &quot;selector&quot;: &quot;.jp-Notebook.jp-mod-editMode&quot;} 将其粘贴在 User Preferences 区域，然后在 keys 下键入所需的快捷方式（F9），如下所示: 1234567891011{ &quot;shortcuts&quot;: [ { &quot;command&quot;: &quot;notebook:run-in-console&quot;, &quot;keys&quot;: [ &quot;F9&quot; ], &quot;selector&quot;: &quot;.jp-Notebook.jp-mod-editMode&quot; } ]} 完美~~~~ Jupyter Lab（Notebook）Home我们知道，JupyterLab（Jupyter Notebook） 这一数据分析神器，它能帮助我们有效地组织输入输出，将我们探索数据的过程记录下来，后续稍加整理便可以生成一篇数据分析报告。 但是在使用 Jupyter （Windows、Linux）过程中，你会发现，通过 Anaconda Navigator launch 后其默认目录是用户目录，而通过命令行终端启动的 Jupyter 默认目录是当前执行启动 Jupyter 命令所在目录。 通常对于我个人来说，我一般习惯将项目存放于固定目录（盘符），我希望启动 Jupyter 后可以固定到我的项目所在目录，而不是人为先去 Location 项目目录。于是产生一个小需求：如何自定义 Jupyter 启动之后的默认目录到一个固定目录？ 下面我们提供两种方法来实现： 注意：只要以下 JupyterLab 或者 Jupyter Notebook 配置一个，另外一个不用配置也可生效。 JupyterLab[1] –&gt; 确认 Anaconda 安装路径，我的是安装 Anaconda 的用户目录：~ [2] –&gt; 确定配置文件：jupyter_notebook_config.json 是否存在？ 查看 ~/Anaconda/etc/jupyter 路径下是否存在文件：jupyter_notebook_config.json ??? 如果你想配置的 JupyterLab 位于某个 Conda 虚拟环境中，你可以在 ~/Anaconda/envs/myenv-xxx/etc/jupyter 下查找，其中 myenv-xxx 为虚拟环境名称。 默认 jupyter_notebook_config.json 文件内容格式： 1234567{ &quot;NotebookApp&quot;: { &quot;nbserver_extensions&quot;: { &quot;jupyterlab&quot;: true } }} 如果不存在，则根据上述内容手动创建。 [3] –&gt; 添加配置项 notebook_dir 在其中添加：notebook_dir –&gt; “自定义目录” 项，用于指定自定义 Home 目录。例如我们自定义 Home 目录为：&quot;E:/&quot;。 修改 jupyter_notebook_config.json 文件后变为： 12345678{ &quot;NotebookApp&quot;: { &quot;nbserver_extensions&quot;: { &quot;jupyterlab&quot;: true }, &quot;notebook_dir&quot;:&quot;E:/&quot; }} [4] –&gt; 重新启动 JupyterLab 后，你会发现更改已经成功~~~ Jupyter Notebook[1] –&gt; 查找配置文件 首先查找 Jupyter Notebook 配置文件，我们在命令行终端输入： 1$ jupyter notebook --generate-config 该命令执行后，如果没有配置文件则新建，如有则会询问是否重载。 Jupyter Notebook 默认配置文件存放路径：~/.jupyter/jupyter_notebook_config.py，即当前用户目录下的 .jupyter 目录下的文件：jupyter_notebook_config.py。 [2] –&gt; 定位设置项语句 找到该文件后，打开，定位到如下语句： &quot; c.NotebookApp.notebook_dir = '' &quot;，该配置项用于自定义 Jupyter Notebook Home 目录。 [3] –&gt; 配置 Jupyter Notebook Home 目录 我们将其修改为：c.NotebookApp.notebook_dir = 'E:/'，并将其注释消掉。 [4] –&gt; 重新启动 Jupyter Notebook 后，你会发现更改已经成功~~~ 应该还存在一个问题，你可以尝试下： 如果你直接通过 Jupyter Notebook 的快捷方式进入，默认目录还是原来那个。如果需要修改，还需要进行如下步骤： 找到快捷方式，右键打开属性，将“目标”最后面的 &quot;%USERPROFILE%&quot; 删除就可以了。 Jupyter Lab（Notebook）Remote Server考虑以下场景： 通常我们更加专注于本地机器开发，实际运行环境是远程服务器。我们会苦恼于本地机器 [Local_Server] 和远程服务器 [Remote_Server] 上都要配置相同的机器学习环境（Anaconda），这既消耗时间又占用计算机资源； 想要在某一台本地机器上访问远程服务器上的 Jupyter Notebook 文档。一方面我们需要在本地机器重新搭建 Jupyter Notebook 环境；另一方面我们需要将目标 Jupyter Notebook 文档 Download 到本地机器？ 当你也面临这些场景时，你就有必要考虑搭建一个可以远程访问的 Jupyter Notebook 或者 JupyterLab 服务器了。 所以今天花了点时间研究了下 Jupyter notebook（JupyterLab） 远程访问服务器：在 Remote_Server 安装 Jupyter ，然后在本地 Local_Server 浏览器访问 Remote_Server 的 Jupyter，使用其内部搭建好的机器学习环境，所以记录一下。 Jupyter &amp;&amp; Anaconda前面提到过，JupyterLab &amp;&amp; Jupyter Notebook 可以作为单独的数据分析工具使用，可以单独（Pip 方式）安装使用。为什么强调单独安装使用呢？我们也知道，Anaconda 中已经将其作为内部的插件，可以极其方便的使用 Anaconda 的虚拟隔离环境。 故，一般我们推荐在 Anaconda 环境下使用 Jupyter notebook（JupyterLab），并且 Anaconda 安装包中自带了 Jupyter 。安装 Anaconda 时会默认将 Jupyter notebook（JupyterLab） 安装到 Anaconda 的 base 环境（免安装）。 当然，你也可以在 Anaconda 其它虚拟环境中再次安装，这是显而易见的（环境隔离）。 Go Start这里，我们先给出在服务器安装配置 Jupyter 服务以提供远程访问的通用步骤： 通常，首先需要根据我们已创建的虚拟开发环境，选择 【Jupyter】 服务安装的虚拟环境（例如： DeepLearning(python2.7) 或者 DeepLearning(python3.5） ？），然后激活相应虚拟环境，在其中安装 Jupyter ，然后完成后续的远程访问配置后，我们就可以在相应的虚拟环境中启动 Jupyter 进行远程使用了。 注意：JupyterLab 与 Jupyter Notebook 师出同源，配置过程完全一样（除了安装）。下面我将会以 Jupyter notebook 安装以及配置为主（JupyterLab 与之有差异的地方会另外标注出）介绍如何搭建远程访问。 先给出 Jupyter 服务的两种访问方式： 本地访问：部署 Jupyter 服务的服务器本地浏览器中访问； 远程访问：远程浏览器中访问部署在服务器上的 Jupyter 服务（常用访问模式）。 下面我们来看如何安装和部署 Server Jupyter 服务的本地访问和远程访问： 本地访问这里的本地访问是指在远程服务器（Remote_Server）本地实现访问，首先需要登录远程服务器，然后： [1] –&gt; 明确虚拟环境 首先我们需要明确我们是使用 Anaconda base 环境中自带的 Jupyter Notebook（JupyterLab）？？？ 还是 ↓↓↓↓↓↓↓ 在其它的虚拟环境（conda env）中安装新的 Jupyter Notebook（JupyterLab）？？？ –&gt; Anaconda base envs（推荐） 如果我们使用 Anaconda base 环境中自带的 Jupyter notebook（JupyterLab）可以直接跳过 [2] 安装步骤 开始[3] 本地使用。 注意，如果安装的是 Anaconda 2 的话，base 环境是不支持 JupyterLab 的（无法安装）。但此时可以在其创建的 conda envs python3.x 中安装 JupyterLab 。 –&gt; Other conda envs (Create) 如果在其它新创建的虚拟环境中安装配置的话，我们需要先切换到相应环境中： 1source activate envsname [2] –&gt; 安装步骤 检查 Remote_Server 当前环境是否有安装 jupyter notebook（JupyterLab）服务，如果没有则安装。 1234567891011### --&gt; jupyter Notebook 检测与安装：# 终端输入 jupyter notebook,如果报错就是没有安装，那么就要用下面命令安装。(安装完成后可重新检查：$ jupyter notebook)$ pip install jupyter notebook### --&gt; jupyter jupyterlab 检测与安装：# 检测：$ jupyter lab# 安装（注意，Python2.7 中不支持 jupyterlab）$ pip install jupyter jupyterlab [3] –&gt; 本地使用 12345678910# 1. Terminal 下先使用下面的命令开启 notebook service：（之后便可以在浏览器中使用，默认下只能在远程服务器本地进行访问）$ jupyter notebook# 开启 jupyterlab service：$ jupyter lab# 2. 在 [`Remote_Server`] 浏览其中输入 url：（就可以实现本地访问了）$ http://localhost:8888# 访问：jupyterLab$ http://localhost:8888/lab 补充如何查看当前已启动的 Jupyter 服务： 12345$ jupyter notebook list# 或：$ jupyter lab list 远程访问Jupyter notebook（JupyterLab）默认只能在本地访问，如果想把它安装在服务器上，然后在本地远程访问 Jupyter 服务器，则需要进行如下配置： [1] –&gt; 相关配置： 123456789101112131415161718192021222324# 1. 生成配置文件$ jupyter notebook --generate-config# Log：Write default config to : ~/.jupyter/jupyter_notebook_config.py# 2. 打开ipython，创建一个密文的密码：$ ipythonIn [1]: from notebook.auth import passwdIn [2]: passwd()Enter password: Verify password: Out[2]: 'sha1:ce23d945972f:34769685a7ccd3d08c84a1......'# 3. 复制密文，并 `exit` ipython# 4. 修改默认配置文件$ vim ~/.jupyter/jupyter_notebook_config.py# 添加如下内容：c.NotebookApp.ip='*'c.NotebookApp.password = u'sha:ce...刚才复制的那个密文'c.NotebookApp.open_browser = Falsec.NotebookApp.port =8888 #随便指定一个端口c.IPKernelApp.pylab = 'inline'# 5. 至此，配置完成。接下来，看如何使用 [2] –&gt; 远程访问 123456789# 1. 在 [`Remote_Server`] 上启动 Jupyter notebook(root 用户下安装需要加参数： --allow-root)，从 Log 可以获取到开放的端口号，该远程连接切勿关闭！！！$ jupyter notebook# 开启 jupyter jupyterlab service：$ jupyter lab# 2. 远程访问：在本地[`Local_Server`]中浏览器直接访问[`Remote_Server`]$ https://address_of_remote:8888# 远程访问：jupyter jupyterlab$ https://address_of_remote:8888/lab 补充启动方式，可以指定启动时的端口以及限制远程登录客户端的 IP： 12345# --ip：Limit Remote_Server_ip , --port:开放端口$ jupyter notebook --ip 0.0.0.0 --port 9999# 远程访问：$ https://address_of_remote:9999 配置问题配置远程访问后，在启动时报错：KeyError：'allow_remote_access'。解决方法如下： 1234$ vim ~/.jupyter/jupyter_notebook_config.py# 补充添加如下语句：c.NotebookApp.allow_remote_access = True JupyterLab Debugger细心的同学肯定已经发现，Jupyter Lab 界面右侧导航栏有一个 Bug 标识，点击之后会向左侧弹出一个类似于 IDE 的 Debug 工作区，如下： 实际上，它就是 JupyterLab 的可视化调试功能支持（JupyterLab Debugger）： 变量浏览器（VARIABLES） &amp;&amp; 断点列表（BREAKPOINTS） &amp;&amp; 源代码预览（SOURCE） 调用堆栈（CALLSTACK），提供下一行（Next）、进入（Step in）、退出（Step out）等功能 JupyterLab Debugger 的发布，弥补了 JupyterLab 无法通过可视化的方式进行 Debug 的限制，降低了大型代码库对 IDE Debug 的依赖。 Xeus-PythonJupyterLab Debugger 的实现，构建在 xeus-python 内核的基础上。 类似于 ipykernel，Xeus-Python 是 Python 编程语言在 Jupyter Kernel 的轻量级实现。它也 支持类似于 Ipykernel 的 Magic Command（魔法指令）以及 Matplotlib 图形。 我们知道，之前写的 Notebook 都是基于 IPython 内核的，而 Xeus-Python Kernel 为 Jupyter 提供了另一种选择，甚至有人说 “Jupyter：正准备抛弃IPython内核 ！！！“ 有消息宣传：xeus-python 正在接近与 ipykernel 进行功能奇偶校验（不知道真假~~~）。 How To Use？Jupyter 官方宣传，未来 Debugger 会作为 Jupyter 的默认模式。 目前，要想使用 JupyterLab Debugger，需要单独安装支持 Jupyter 调试的 Xeus-Python Kernel： ↓↓↓↓↓↓ JupyterLab 3.x ↓↓↓↓↓↓ 123456# 谨慎（目前 Xeus-Python Kernel 安装问题较多，防止破坏 Base Env） &gt;&gt;&gt; 当前环境安装: xeus-pythonpip install xeus-python# 推荐 &gt;&gt;&gt; 新 Conda 环境安装: xeus-pythonconda create -n jupyterlab-debugger -c conda-forge jupyterlab=3 xeus-pythonconda activate jupyterlab-debugger ↓↓↓↓↓↓ JupyterLab 2.0+ ↓↓↓↓↓↓ 目前，由于 Anaconda 官方提供的都是基于 Python3.X 的安装包，故 Base JupyterLab 2.X 已经很少见了。 1234$ conda create -n jupyterlab-debugger -c conda-forge xeus-python=0.8.6 notebook=6 jupyterlab=2 ptvsd nodejs$ conda activate jupyterlab-debugger$ jupyter labextension install @jupyterlab/debugger # 安装前端插件 | =============================================== Split Line ================================================= | 👇👇👇 使用说明 👇👇👇 安装完成之后，启动 Jupyter Lab &gt;&gt;&gt; 1$ jupyter lab 安装 Xeus-Python Kernel 后，启动 JupyterLab 时可能产生 No module named 'jupyter_nbextensions_configurator' 错误，请参见章节【Relevant Issues】。 然后就可以在打开的 Notebook 中切换内核至 Python3.XX（XPython） &lt;&lt;&lt; Xeus-Python Kernel，然后就通过环境名称前的 🐞（Debug Switch） 开启或关闭调试模式了： Python 脚本调试实操： Conda Envs(Kernels) Switch在 Jupyter 中进行深度学习实验时，肯定会涉及到不同的环境配置，看如下场景： Python3 和 Python2 的不同虚拟环境。 不同版本的 tensorflow 的虚拟环境。 这就要求我们 需要随时切换虚拟环境。 conda 环境中运行 Jupyter 服务器和内核方法推荐指数：⭐️⭐️ 从上面 Jupyter notebook（JupyterLab）安装配置中知道，我们可以在不同的虚拟环境中分别安装 Jupyter notebook（JupyterLab），然后通过在不同的 conda 环境中启动 Jupyter notebook（JupyterLab）实现切换不同的 Jupyter 环境。 这种方法就是：为每一个 Conda 虚拟环境都按照 Jupyter。这是 最简单的方法，绝对没问题。 –&gt; 引发一个问题：这不是有点（da）病么？既浪费系统资源又浪费时间！ 那么，有么有一种办法我只在一个虚拟环境下启动 Jupyter notebook（JupyterLab）却可以在 Jupyter 中切换不同的虚拟运行环境？？？ 答案肯定是有的。 内核插件 ipykernel虚拟环境的内核是运行代码的封装 Python 的组件。 方法推荐指数：⭐️⭐⭐ Install ipykernel需要用到一个 ipykernel 插件，首先，我们选择在 Anaconda base 环境安装： 1$ conda install ipykernel 此时，我们可以在 Anaconda base 中启动 Jupyter notebook（JupyterLab），发现启动后只有一个原生的 base 环境。 添加虚拟环境到 Jupyter事实上，这一部分就是将各种创建好的 conda 虚拟环境（也称为不同的 Kernel）添加 Jupyter Kernel（Base）中。 [1] –&gt; 激活虚拟环境 1$ source activate myenv [2] –&gt; 将环境写入 notebook 的 kernel 中 1python -m ipykernel install --user --name myenv --display-name &quot;Python (myenv)&quot; 推荐将 --name（将用于 Jupyter 内部，会覆盖具有相同名称的 Kernel）和 --display-name（指定 Jupyter Notebook/Lab 中显示的名称）设置为当前虚拟环境的名称。其中 --user 非服务器环境可缺省。 如果显示 “No module named ipykernel”，说明当前虚拟环境没有安装 ipykernel 插件： 1$ conda install ipykernel 其它环境添加也一样： 12source activate other-envpython -m ipykernel install --user --name other-env --display-name &quot;Python (other-env)&quot; [3] –&gt; 测试 重新在 Anaconda base 环境中启动 Jupyter notebook（JupyterLab），可以看到 Jupyter 中已经可以切换其它虚拟环境了。 注意：切换 Jupyter notebook（JupyterLab）虚拟环境其实相当于切换其 Kernel（内核）。 |&gt;&gt;&gt;&gt; 引发一个问题： 方法挺不错的，但有个缺点是：你新建一个环境，就要重复一次上述操作。 Kernel 移除有时，由于添加了错误的内核或者不想要该内核，我们需要移除 Jupyter notebook（JupyterLab）虚拟环境内核（Kernel）。 首先，我们来看如何查看当前系统中安装的内核以及其位置： 1$ jupyter kernelspec list –&gt; 如何移除？ 1$ jupyter kernelspec remove myenv myenv 表示 Kernel 所对应的虚拟环境的名称。 移除后，重新启动 Jupyter notebook（JupyterLab）即可发现内核已经被移除。 nb_conda_kernels 插件添加所有环境内核方法推荐指数： ⭐️⭐️⭐️⭐️⭐️ 一键添加所有 conda 环境，妙不可言（Anaconda Base）： 123$ source activate base$ conda install nb_conda_kernels |&gt;&gt;&gt;&gt; 可能出现的问题： 安装 nb_conda_kernels 之后，系统原有 Conda 环境已经可以切换。但新建虚拟环境后，Jupyter Notebook（Lab）中没有相应内核。 此时，你可以通过为新创建的虚拟环境安装 ipykernel 插件来解决，具体方法见上一小节【内核插件 ipykernel】。 需要注意的是，如果你的 Anaconda 环境中同时 ipykernel &amp;&amp; nb_conda_kernels，这会导致 Jupyter Page 切换内核界面出现同一虚拟环境的两个内核，请不要困惑！！！ Relevant Issues最后给出 Jupyter 使用过程中遇到的问题以及其解决方案，方便之后进行排查。 EnvironmentLocationNotFound在启动 Jupyter Notebook 时，可能会出现环境错误 &gt;&gt;&gt; EnvironmentLocationNotFound: Not a conda environment: /home/xxx/.conda/envs/anaconda3 官方说明 Conda 版本 4.4 以后会出现上述问题，原文如下： This is a confirmed bug in nb_conda for conda version &gt;=4.4:The reason is the change of conda info –json output. Fresh installation of version 4.3.33 gives envs=[], version &gt;=4.4 gives envs=[root_env_dir] (always non empty). 这是由于 &gt;&gt;&gt; 之前版本 Conda 是 envs=[]，而 4.4 版本之后 envs=[root_env_dir]，然而这个目录通常并不是空的，官方可能在后续的更新中解决这个问题。 Solution &gt;&gt;&gt; 查找目录 ..\\Anaconda3\\pkgs\\nb_conda-2.2.0-py38_0\\Lib\\site-packages\\nb_conda（py38.0 根据 Anaconda 版本可能会有不同） 修改 envmanager.py 文件 查找这一句: 1234return { &quot;environments&quot;: [root_env] + [get_info(env) for env in info['envs']]} 将： 1for env in info['envs']] 替换为: 1for env in info['envs'] if env != info['root_prefix']] 重启 jupyter Notebook Local-Server，会发现错误提示已经消失~~~ NbExtConfiguratorNotFound在启动 Jupyter Lab 时，可能会出现如下错误 &gt;&gt;&gt; 1The module 'jupyter_nbextensions_configurator' could not be found (No module named 'jupyter_nbextensions_configurator'). Are you sure the extension is installed? ↓↓↓↓↓↓ 问题描述 ↓↓↓↓↓↓ 查看报错说明，是 Jupyter 加载的 jupyter_contrib_nbextensions 插件失败！！！但安装插件后仍然报错，继续分析原因： 此插件需要与某些插件组合使用； 此插件未配置环境，导致不能正确加载。 以后出现此类问题，上述的第二个原因是更容易出现的！！！ ↓↓↓↓↓↓ 解决方案 ↓↓↓↓↓↓ 1234567891011# Step 1 &gt;&gt;&gt; 安装 Nbextensions 插件库：$ pip install jupyter_contrib_nbextensions# Step 2 &gt;&gt;&gt; 安装关联的 JavaScript 和 CSS 文件$ jupyter contrib nbextension install --user# Step 3 &gt;&gt;&gt; 安装 Jupyter Nbextensions Configurator$ pip install jupyter_nbextensions_configurator# Step 4 &gt;&gt;&gt; 启用 Jupyter Nbextensions Configurator$ jupyter nbextensions_configurator enable --user 重新启动 Jupyter Lab 即可~~~","link":"/2018/01/03/jupyter-tutorial/"},{"title":"Python 中的函数升阶","text":"我们知道函数是 Python 内建支持的一种封装，通过一层一层的函数封装，就可以把复杂任务分解成简单的任务，这种分解可以称之为面向过程的程序设计。函数就是面向过程的程序设计的基本单元。本文作为 Python 中 函数使用的升阶内容。 前面已经介绍了 Python 函数的所有基本用法和使用注意事项，但是，Python 函数的用法还远不止此。 除了我们已经了解的函数赋值（别名）、局部函数、函数调用、函数间相互调用，甚至作为其他函数的返回值以外，Python 中还支持很多高级的用法：闭包函数、lambda 匿名函数、函数式编程等等。 lambda 匿名函数Python 中支持一种快速定义简单函数的方法 –&gt; Lambda 表达式，也称为匿名函数。 lambda 表达式，常用来表示内部仅包含 1 行表达式的简单函数。如果一个函数的函数体仅有 1 行表达式，则该函数就可以用 lambda 表达式来代替。 lambda 表达式的语法格式如下： 1name = lambda [list] : 表达式 其中，定义 lambda 表达式，必须使用 lambda 关键字；[list] 作为可选参数，等同于函数定义时指定的形参列表，name 为该 lambda 表达式（匿名含数）的名称。 明白为什么叫匿名函数了吗？ &gt;&gt;&gt;&gt; 简单到不需要使用专门的函数名称，而是采用函数别名的方式直接赋值给变量就行了，就像一个表达式一样简单（lambda 表达式）。能猜到如何调用吗?： 1name() 既然是等同于一个简单函数，故可以转换成普通函数的形式： 1234def name(list): return 表达式name(list) 来一个实例（求 2 个数之和）： 123# 求 2 个数之和的匿名函数add = lambda x,y:x+yprint(add(3,4)) 可以这样理解 lambda 表达式，其就是简单函数（函数体仅是单行的表达式）的简写版本。这可以帮助我们省去定义函数的过程，对于不需要多次复用的函数，使用 lambda 表达式可以在用完之后立即释放，提高程序执行的性能。 重新认识闭包函数和前面讲的嵌套函数（局部函数）类似，不同之处在于，闭包中外部函数返回的不是一个具体的值，而是一个函数。 构成闭包的条件： 必须有一个内嵌函数（局部函数）； 内嵌函数必须引用其外部函数中的变量； 外部函数的返回值必须是内嵌函数。 先来看一个例子(不定长参数的求和)： 12345678910111213141516def lazy_sum(*args): sum = 0 def calc_sum(): nonlocal sum for arg in args: sum += arg return sum return calc_sumf1 = lazy_sum(1, 3, 5, 7, 9)print(f1())# 25f2 = lazy_sum(1, 2, 3, 4, 5)print(f2())# 15 程序中，我们在函数 lazy_sum 中又定义了局部函数（内嵌函数） calc_sum，并且，内嵌函数 calc_sum 引用了外部函数 lazy_sum 的参数和局部变量。 当调用外部函数 lazy_sum 时返回 calc_sum 嵌入函数的引用，相关参数和变量都保存在返回的嵌入函数中，这就是一个典型的 “闭包（Closure）” 结构。 看到这里，读者可能会问，为什么要使用闭包呢？完全可以写成下面的形式（多简洁）： 123456def lazy_sum(*args): sum = 0 for arg in args: sum += arg return sum 事实上，我们知道使用闭包结构，当外部函数结束后，其局部函数中使用到的外部函数相关联变量会被绑定到内部函数，这样你就可以使得这些变量始终保存在内存中，不会随外部函数的结束而清除，起到变量状态保存的作用。 基于此，你可以想到 &gt;&gt;&gt;&gt; 一般函数开头需要做一些额外工作，当需要多次调用该函数时，如果将那些额外工作的代码放在外部函数，就可以减少多次调用导致的不必要开销，提高程序的运行效率。 [1] &gt;&gt;&gt;&gt; 外部函数的每次调用返回都的是一个新的函数引用 这也就意味着，即使传入完全相同的参数： 1234567891011121314def lazy_sum(*args): sum = 0 def calc_sum(): nonlocal sum for arg in args: sum += arg return sum return calc_sumf1 = lazy_sum(1, 3, 5, 7, 9)f2 = lazy_sum(1, 2, 3, 4, 5)print(f1 == f2)# False f1() 和 f2() 的调用结果互不影响，可以看作每次执行内嵌函数调用都会新开辟一块内存空间。 [2] &gt;&gt;&gt;&gt; 内嵌函数被调用时才执行 使用闭包结构时，需要注意的是，外部函数调用时内嵌函数并没有立刻执行（用来返回来一个内嵌函数引用），而是直到显式调用内嵌函数 f1()/f2() 时才执行。 我们来看一个例子： 123456789101112131415def count(): fs = [] for i in range(1, 4): def f(): return i*i fs.append(f) # print(fs) # [.f at 0x7fc3e786d510&gt;, .f at 0x7fc3e786d598&gt;, .f at 0x7fc3e786d620&gt;] return fsf1, f2, f3 = count()print(&quot;f1, f2, f3 :&quot;, f1(),f2(),f3()) 上面程序中，每次循环都会向列表中添加一次内嵌函数引用（引用都不相同），然后最终把包含 3 个函数引用的列表返回。猜猜上面的代码结果是什么 –&gt; 1, 4, 9 ？ 但实际结果是： 1&gt;&gt;&gt; f1, f2, f3 : 9 9 9 f1, f2, f3 全部都是 9！！！ 原因就在于（变量状态保存）：尽管内嵌函数引用了外部函数的变量 i，但在调用外部函数时并非立刻执行，外部函数结束后返回了循环构建的 3 个函数引用列表，此时它们所引用的变量 i 已经变成了 3。之后使用 f1(), f2(), f3() 调用内嵌函数时，按照 i==3 计算，因此最终结果为 9。 牢记一点：返回函数不要引用任何循环变量，或者后续会发生变化的变量。 [3] &gt;&gt;&gt;&gt;闭包中循环变量的使用 如果一定要引用循环变量怎么办？ 方法就是再内嵌函数外再外嵌套一个函数，用该函数的参数绑定循环变量当前的值，然后该参数的值会被绑定给内嵌函数，之后无论该循环变量后续如何更改，已绑定给内嵌函数参数的值不变： 1234567891011121314def count(): def f(j): def g(): return j*j return g fs = [] for i in range(1, 4): fs.append(f(i)) # f(i) 立刻被执行，因此 i 的当前值被传入 f(j) return fs f1, f2, f3 = count()print(&quot;f1, f2, f3 :&quot;, f1(),f2(),f3())# f1, f2, f3 : 1 4 9 [4] &gt;&gt;&gt;&gt;闭包中的 closure 属性 闭包比普通的函数多了一个 __closure__ 属性，该属性记录着外部函数绑定给内嵌函数变量（自由变量）的地址。当闭包被调用时，系统就会根据该地址找到对应的变量，完成整体的函数调用。 以 outer() 为例，当其被调用时，可以通过 __closure__ 属性获取变量 b 存储的地址，例如： 1234567891011121314def outer(): b = 10 # 自由变量 def inner(x): return 5 * x + b return inner b = 2fun = outer()print(fun(b))# 20print(fun.__closure__)# (&lt;cell at 0x000002503F36ED60: int object at 0x00007FFCC8AC1F00&gt;,) 可以看到，显示的内容是一个 int 整数类型，这就是 fun 中自由变量 b 的初始值。还可以看到，__closure__ 属性的类型是一个元组，这表明闭包可以支持多个自由变量的形式。 说是这么说的，得眼见为实（补充如下内容）： 12print(fun.__closure__[0].cell_contents)# 10 Python 解释器 eval &amp;&amp; execeval() 和 exec() 函数都属于 Python 的内置函数，功能相当于一个 Python 的解释器。 eval() 和 exec() 函数的功能都是可以 &gt;&gt;&gt;&gt; 执行一个字符串形式的 Python 代码（代码以字符串的形式提供）。 不同之处在于 &gt;&gt;&gt;&gt; eval() 执行完要返回结果，而 exec() 执行完不返回结果。 eval() &amp;&amp; exec() 函数的语法格式为： 1234# eval()eval(expression, globals=None, locals=None, /)# exec()exec(expression, globals=None, locals=None, /) 可以看到，二者的语法格式除了函数名，其他都相同，其中各个参数的具体含义如下： expression：这个参数是一个字符串，代表要执行的语句 。该语句受后面两个字典类型参数 globals 和 locals 的限制，只有在 globals 字典和 locals 字典作用域内的函数和变量才能被执行。 globals：这个参数管控的是一个全局的命名空间，即 expression 可以使用全局命名空间中的函数。如果只是提供了 globals 参数，而没有提供自定义的 __builtins__，则系统会将当前环境中的 __builtins__ 复制到自己提供的 globals 中，然后才会进行计算；如果连 globals 这个参数都没有被提供，则使用 Python 的全局命名空间。 locals：这个参数管控的是一个局部的命名空间，和 globals 类似，当它和 globals 中有重复或冲突时，以 locals 的为准。如果 locals 没有被提供，则默认为 globals。 __builtins__ 是 Python 的内建模块，平时使用的 int、str、abs 都在这个模块中。通过 print(dic[&quot;__builtins__&quot;]) 语句可以查看 __builtins__ 所对应的 value。 [1] &gt;&gt;&gt;&gt; globals 作用域 首先，通过如下的例子来演示参数 globals 作用域的作用，注意观察它是何时将 builtins 复制 globals 字典中去的： 12345dic={} # 定义一个字典dic['b'] = 3 # 在 dic 中加一条元素:&quot;b=3&quot;print (dic.keys()) # 先将 dic 的 key 打印出来，有一个元素 bexec(&quot;a = 4&quot;, dic) # 在 exec 执行的语句后面跟一个作用域 dicprint(dic.keys()) # exec 后，dic 的 key 多了一个 运行结果为： 12dict_keys(['b'])dict_keys(['b', '__builtins__', 'a']) 上面的代码是在作用域 dic 下执行了一句 a = 4 的代码。可以看出，exec() 之前 dic 中的 key 只有一个 b。执行完 exec() 之后，系统在 dic 中生成了两个新的 key，分别是 a 和 __builtins__。其中，a 为执行语句生成的变量，系统将其放到指定的作用域字典里；__builtins__ 是系统加入的内置 key。 [2] &gt;&gt;&gt;&gt; locals 作用域 使用如下： 12345678a=10b=20c=30g={'a':6, 'b':8} #定义一个字典t={'b':100, 'c':10} #定义一个字典print(eval('a+b+c', g, t)) # 定义一个字典# Output: 116 [3] &gt;&gt;&gt;&gt; exec() &amp;&amp; eval() 的区别 exec() &amp;&amp; eval() 的区别在于：eval() 执行完会返回结果，而 exec() 执行完不返回结果。 实例演示： 1234567a = 1exec(&quot;a = 2&quot;) #相当于直接执行 a=2print(a)a = exec(&quot;2+3&quot;) #相当于直接执行 2+3，但是并没有返回值，a 应为 Noneprint(a)a = eval('2+3') #执行 2+3，并把结果返回给 aprint(a) 运行结果为： 1232None5 也就是说，exec() 中最适合放置运行后没有结果的语句，而 eval() 中适合放置有结果返回的语句。 [4] &gt;&gt;&gt;&gt; 应用场景 在使用 Python 开发服务端程序时，这两个函数应用得非常广泛。例如，客户端向服务端发送一段字符串代码，服务端无需关心具体的内容，直接跳过 eval() 或 exec() 来执行，这样的设计会使服务端与客户端的耦合度更低，系统更易扩展。 另外，如果读者以后接触 TensorFlow 框架，就会发现该框架中的静态图就是类似这个原理实现的： TensorFlow 中先将张量定义在一个静态图里，这就相当将键值对添加到字典里一样； TensorFlow 中通过 session 和张量的 eval() 函数来进行具体值的运算，就当于使用 eval() 函数进行具体值的运算一样。 需要注意的是，在使用 eval() 或是 exec() 来处理请求代码时，函数 eval() 和 exec() 常常会被黑客利用，成为可以执行系统级命令的入口点，进而来攻击网站。解决方法是：通过设置其命名空间里的可执行函数，来限制 eval() 和 exec() 的执行范围。 函数式编程所谓函数式编程，是指代码中每一块都是不可变的，都由纯函数的形式组成。 认识函数式编程思想纯函数构成？ &gt;&gt;&gt;&gt; 是指函数本身相互独立、互不影响，对于 相同的输入，总会有相同的输出。 前面我们知道，既然变量可以指向函数，而函数的参数能接收变量，那么一个函数就可以接收另一个函数作为参数。函数式编程的一大特点 &gt;&gt;&gt;&gt; 即 允许把函数本身作为参数传入另一个函数，还允许返回一个函数（高阶函数）。 怎么理解呢？？？ 先来看一个让列表中的元素值都变为原来的两倍的函数实现： 1234def multiply_2(list): for index in range(0, len(list)): list[index] *= 2 return list 需要注意的是，这段代码不是一个纯函数的形式，因为列表中元素的值被改变了（“引用传递”），如果多次调用 multiply_2() 函数，那么每次得到的结果都不一样。 如何修改为纯函数的形式的实现呢？ &gt;&gt;&gt;&gt; 12345def multiply_2_pure(list): new_list = [] for item in list: new_list.append(item * 2) return new_list 纯粹的函数式编程 &gt;&gt;&gt;&gt; 事实上，纯粹的函数式编程语言（比如 Scala），其编写的函数中是没有变量的，因此可以保证，只要输入是确定的，输出就是确定的；而允许使用变量的程序设计语言，由于函数内部的变量状态不确定，同样的输入，可能得到不同的输出。 对于 Python 而言，是允许使用变量的，所以它 并不是一门纯函数式编程语言。 Python 仅对函数式编程提供了部分支持，主要包括 map()、filter() 和 reduce() 这 3 个函数，它们通常都结合 lambda 匿名函数一起使用。接下来逐一介绍: map()map() 函数的功能是依次对可迭代对象中的每个元素，都调用指定的函数进行处理，并返回一个可迭代的（Iterable） map 对象。 map() 函数的基本语法格式如下： 1map(function, iterable) 其中，function 参数表示要传入一个函数，其可以是内置函数、自定义函数或者 lambda 匿名函数；iterable 表示一个或多个可迭代对象，可以是列表、字符串、字典、集合、元组等。 需要注意的是，该函数返回的是一个 map 对象，不能直接输出，可以通过 for 循环或者 list()/tuple() 等函数来显示。 实例演示一下 &gt;&gt;&gt;&gt; 比如我们有一个函数 f(x)=x*x，要把这个函数作用在一个 list [1, 2, 3, 4, 5, 6, 7, 8, 9] 上，使用 map() 实现原理图如下： 来看一下 Python map 实现： 12345listDemo = [1, 2, 3, 4, 5, 6, 7, 8, 9]list_res = map(lambda x: x*x, listDemo)print(list(list_res))# [1, 4, 9, 16, 25, 36, 49, 64, 81] 注意，map() 函数可传入多个可迭代对象作为参数 &gt;&gt;&gt;&gt; 123456789listDemo1 = [1, 2, 3, 4, 5]listDemo2 = [3, 4, 5, 6, 7]new_list = map(lambda x,y: x + y, listDemo1,listDemo2)print(type(new_list))print(list(new_list))# Output# &lt;class 'map'&gt;# [4, 6, 8, 10, 12] 由于 map() 函数是直接由用 C 语言写的，运行时不需要通过 Python 解释器间接调用，并且内部做了诸多优化，所以相比其他方法，此方法的运行效率最高。 filter()Python 内建的 filter() 函数可用于过滤序列。 filter() 函数的功能是对 iterable 中的每个元素，都使用 function 函数判断，然后根据返回值是 True 还是 False 决定保留还是丢弃该元素，最后将返回 True 的元素组成一个新的可遍历的 filter 对象。 filter() 函数的基本语法格式如下： 1filter(function, iterable) 此格式中，funcition 参数表示要传入一个用于过滤的函数，iterable 表示一个待处理的可迭代对象。 【例 1】 list 中，删掉偶数，只保留奇数： 1234listDemo = [0,1,2,3,4,5,6,7,8,9]list_res = filter(lambda x: x % 2 == 1, listDemo)print(list(list_res))# [1, 3, 5, 7, 9] 【例 2】 把一个序列中的空字符串删掉： 1234listDemo = ['A', '', 'B', None, 'C', ' ']list_res = filter(lambda x: x and x.strip(), listDemo)print(list(list_res))# ['A', 'B', 'C'] 可见用 filter() 这个高阶函数，关键在于正确实现一个 “筛选” 函数。 reduce()reduce() 函数通常用来对一个集合做一些累积操作。其基本语法格式为： 1reduce(function, iterable) 其中，function 规定必须是一个包含 2 个参数的函数；iterable 表示可迭代对象。 注意，reduce() 内置函数在 Python 3.x 中已经被移除，相应功能已放入了 functools 模块。故使用前，需 from functools import reduce 导入 reduce。 如何理解 reduce() 要求 function 需要两个参数？怎样的累积操作？ &gt;&gt;&gt;&gt; reduce 把一个函数（必须接收两个参数）作用在一个序列 [x1, x2, x3, ...] 上，初始时 reduce 会从 iterable 中获取最开始的两个元素（x1 &amp;&amp; x2）进行 function 处理（得结果 f_d_1），然后将结果（f_d_1）继续和下一个元素（x3）进行 function 处理（得结果 f_d_2），这就是累积过程，继续…..直至完成最后一个元素的累积，其效果就是： 1reduce(function, [x1, x2, x3, x4]) = f(f(f(x1, x2), x3), x4) – 【 例 1】 序列求和： 12345from functools import reducelistDemo = [1, 3, 5, 7, 9]val = reduce(lambda x,y: x + y, listDemo)print(val)# 25 当然求和运算可以直接用 Python 内建函数 sum()，不适用 reduce（优先考虑）也可以。 【 例 2】 list(tuple) 序列转数字： 但是如果要把一个类似于 [1, 3, 5, 7, 9] 的序列变换成整数13579，reduce 就可以派上用场： 12345from functools import reducelistDemo = [1, 3, 5, 7, 9]res_value = reduce(lambda x,y: x * 10 + y, listDemo)print(res_value)# 13579 这个例子本身没多大用处，但是如果考虑到字符串 str 也是一个序列，对上面的例子稍加改动，配合 map()，我们就可以写出把 str 转换为 int 的函数： 【例 3】 数字字符串转数字（类似于 int(str) 一样的功能） 1234567from functools import reduceDIGITS = {'0': 0, '1': 1, '2': 2, '3': 3, '4': 4, '5': 5, '6': 6, '7': 7, '8': 8, '9': 9}digits_str = &quot;13579&quot;res_value = reduce(lambda x,y: x * 10 + y, map(lambda x: DIGITS[x], digits_str))print(type(res_value), res_value)# &lt;class 'int'&gt; 13579 也就是说，假设 Python 没有提供 int() 函数，你完全可以自己写一个把字符串转化为整数的函数。 函数式编程小节通常来说，当对集合中的元素进行一些操作时，如果操作非常简单，比如相加、累积这种，那么应该优先考虑使用 map()、filter()、reduce() 实现。另外，在数据量非常多的情况下（比如机器学习的应用），一般更倾向于函数式编程的表示，因为效率更高。 当然，在数据量不多的情况下，使用 for 循环等方式也可以。不过，如果要对集合中的元素做一些比较复杂的操作，考虑到代码的可读性，通常会使用 for 循环。 partial 偏函数Python 的 functools 模块提供了很多有用的功能，其中一个就是偏函数（Partial function）。要注意，这里的偏函数和数学意义上的偏函数不一样。 简单的理解偏函数，它是对原始函数的二次封装，是将现有函数的部分参数预先绑定为指定值，从而得到一个新的函数，该函数就称为偏函数。 相比原函数，偏函数具有较少的可变参数，从而降低了函数调用的难度。 定义偏函数，需使用 partial 关键字（位于 functools 模块中），其语法格式如下： 1偏函数名 = partial(func, *args, **kwargs) 其中，func 指的是要封装的原函数，*args 和 **kwargs 分别用于接收无关键字实参和关键字实参。 【例 1】 123456789101112from functools import partial# 定义个原函数def display(name,age): print(&quot;name:&quot;, name, &quot;age:&quot;, age)# 定义偏函数，其封装了 display() 函数，并为 name 参数设置了默认参数GaryFun = partial(display,name = 'Gary')# 由于 name 参数已经有默认值，因此调用偏函数时，可以不指定GaryFun(age = 13)# Output:# name: Gary age: 13 注意，当前偏函数调用时，必须采用关键字参数的形式给 age 形参传参，因为如果以无关键字参数的方式，该实参将试图传递给 name 形参，Python解释器会报 TypeError 错误。 结合以上示例不难分析出，偏函数的本质是将函数式编程、默认参数和冗余参数结合在一起，通过偏函数传入的参数调用关系，与正常函数的参数调用关系是一致的。 偏函数通过将任意数量（顺序）的参数，转化为另一个带有剩余参数的函数对象，从而实现了截取函数功能（偏向）的效果。在实际应用中，可以使用一个原函数，然后将其封装多个偏函数，在调用函数时全部调用偏函数，一定程序上可以提高程序的可读性。 sorted 内置排序函数排序也是在程序中经常用到的算法。无论使用冒泡排序还是快速排序，排序的核心是比较两个元素的大小。 如果是数字，我们可以直接比较；但如果是字符串或者两个 dict 呢？直接比较数学上的大小是没有意义的，因此，比较的过程必须通过函数抽象出来。 [1] &gt;&gt;&gt;&gt; list(int) 我们前面提到过的，Python内置的 sorted() 函数就可以对 list 进行排序： 12&gt;&gt;&gt; sorted([36, 5, -12, 9, -21])[-21, -12, 5, 9, 36] 此外，sorted() 函数也是一个高阶函数，它还可以接收一个 key 函数来实现自定义的排序，例如按绝对值大小排序： 12&gt;&gt;&gt; sorted([36, 5, -12, 9, -21], key=abs)[5, 9, -12, -21, 36] key 指定的函数将作用于 list 的每一个元素上，并根据 key 函数返回的结果进行排序。对比原始的 list 和经过 key=abs 处理过的 list： 123list = [36, 5, -12, 9, -21]keys = [36, 5, 12, 9, 21] 然后 sorted() 函数按照 keys 进行排序，并按照对应关系返回 list 相应的元素。 [2] &gt;&gt;&gt;&gt; list(str) 我们再看一个字符串排序的例子： 12&gt;&gt;&gt; sorted(['bob', 'about', 'Zoo', 'Credit'])['Credit', 'Zoo', 'about', 'bob'] 默认情况下，对字符串排序，是按照ASCII的大小比较的，由于'Z' &lt; 'a'，结果，大写字母Z会排在小写字母a的前面。 现在，我们提出排序应该忽略大小写，按照字母序排序。要实现这个算法，不必对现有代码大加改动，只要我们能用一个key函数把字符串映射为忽略大小写排序即可。忽略大小写来比较两个字符串，实际上就是先把字符串都变成大写（或者都变成小写），再比较。 这样，我们给 sorted 传入key函数，即可实现忽略大小写的排序： 12&gt;&gt;&gt; sorted(['bob', 'about', 'Zoo', 'Credit'], key=str.lower)['about', 'bob', 'Credit', 'Zoo'] 要进行反向排序，不必改动 key 函数，可以传入第三个参数 reverse=True： 12&gt;&gt;&gt; sorted(['bob', 'about', 'Zoo', 'Credit'], key=str.lower, reverse=True)['Zoo', 'Credit', 'bob', 'about'] 从上述例子可以看出，高阶函数的抽象能力是非常强大的，而且，核心代码可以保持得非常简洁。 用 sorted() 排序的关键在于实现一个映射函数。","link":"/2018/01/11/python-zhong-de-han-shu-sheng-jie/"},{"title":"Python 中的异常处理机制","text":"在程序运行过程中，总会遇到各种各样的错误，这会使得程序运行结果和预期不符，严重时甚至会导致程序奔溃。 在编码过程中使用合理的 异常处理机制，可以帮助程序在运行出现错误时，捕获并且并处理这些错误，进而尝试恢复程序的执行，或者进行一些程序崩溃前的必要工作（如内存中的数据写入文件等）。异常处理机制对于编写一个良好的、健壮的程序是至关重要的。 异常引入开发人员在编写程序时，难免会遇到各种各样的错误。 有的错误是编写人员疏忽造成的语法错误，比如缩进错误，语法格式使用错误等，这种错误是必须修复的。 有的错误是程序内部隐含逻辑问题造成的数据错误（调试时很方便检出），这种错误需要仔细分析相应的逻辑流程进行处理。 有的错误是由于用户输入造成的数据错误，比如让用户输入 URL 地址，结果得到一个空字符串，这种错误可以通过检查用户输入来做相应的处理。 还有一类错误是程序运行时与系统的规则冲突造成的系统错误，完全无法在程序运行过程中预测的，比如写入文件的时候，磁盘满了，写不进去了；或者从网络抓取数据，网络突然断掉了等等。这种错误在程序中通常是必须处理的，否则，程序会因为各种问题终止并退出。 总的来说，Python 中编写程序时遇到的错误可大致分为两类： 语法错误； 运行时错误。 语法错误语法错误，是指解析代码时出现的错误。 当代码不符合 Python 语法规则时，Python 解释器在解析时就会报出 SyntaxError 语法错误，与此同时还会明确指出最早解析到错误的语句。 例如，Python 3 中已不再支持下面这种写法，运行时，解释器会报错误： 123456print &quot;Hello,World!&quot;# File &quot;&lt;stdin&gt;&quot;, line 1# print &quot;Hello,World!&quot;# ^# SyntaxError: Missing parentheses in call to 'print'. 除此之外，其它 常见的语法错误类型如下表 &gt;&gt;&gt;&gt; 错误类型 含义 SyntaxError：unexpected EOF while parsing 语法错误：多了无法解析的符号，检查是否多了或者少了括号。 SyntaxError：invalid character in identifier 有无效标识符，检查一下是否使用中文符号。 SyntaxError -&gt; IndentationError: expected an indented block 解析时缩进错误：检查一下代码的缩进是否正确。 语法错误多是开发者疏忽导致的，属于真正意义上的错误，是解释器无法容忍的，只有将程序中的所有语法错误全部纠正，程序才能执行。 需要注意的是 &gt;&gt;&gt;&gt; 语法错误并不需要异常处理机制的参与，它由开发人员自己保证，我们更关注的是程序运行时产生的错误（异常）。 运行时异常运行时异常，即程序在语法上都是正确的，但在运行时发生了错误。 实例演示： 12345a = 1/0# Traceback (most recent call last):# File &quot;&lt;pyshell#2&gt;&quot;, line 1, in &lt;module&gt;# a = 1/0# ZeroDivisionError: division by zero 可以看到，用 1 除以 0，并赋值给 a 。因为 0 作除数是没有意义的，所以运行后会产生 ZeroDivisionError 错误。在输出结果中，前两段指明了错误的位置，最后一句表示出错的类型。 Python 中，把这种运行时产生错误的情况叫做 异常（Exceptions）。除此以外，Python 中异常情况包括很多种类，常见错误类型接下文。 常见异常类型Python 中的错误类型也是类，它们都是从 BaseException 类派生的，常见见下表。更多的错误类型和其继承关系请参见：Exception hierarchy。 错误类型 具体 含义 IndexError list index out of range 索引错误：数据超出索引范围，检查一下是否数据使用越界。 TypeError must be str, not int … 数据类型错误：不同类型数据之间的无效操作。比如字符串和数字直接拼接，此时检查一下数据类型是否使用错误。 KeyError KeyError:’fond’ 键错误：字典中没有该的 key（“fond”）对应的值，检查一下键名或者字典数据是否正确。 ValueError substring not found 值错误：输入的数据类型跟要求的不符合。 NameError name ‘a’ is not defined 未初始化对象：变量没有被定义就使用了，或者变量被删除后再次使用。 AttributeError ‘tuple’ object has no attribute ‘remove’ 对象属性错误：当试图访问的对象属性不存在时抛出的异常 SystemExit SystemExit 解释器请求退出，出现在 exit() 函数后。 IOError IOError 输入/输出操作失败 ImportError ModuleNotFoundError 导入模块/对象失败，检查一下模块是否存在或者能够正常使用。 UnicodeError UnicodeDecodeError / UnicodeEncodeError / UnicodeTranslateError Unicode 解码/编码/转换/时的错误：请检查字符解码/编码/转换。 AssertionError AssertionError 当 assert 关键字后的条件为假时，程序运行会停止并抛出 AssertionError 异常 引入异常处理机制当一个程序发生异常时，代表该程序在执行时出现了非正常的情况，无法再执行下去。默认情况下，程序是要终止的。 什么？！！你说你编写的程序不会出错？ 请记住，无论你是多么优秀的程序员，你都不能保证自己的程序永远不会出错。就算你的程序没有错，用户也不一定按照你设定的规则来使用你的程序，总有一些小白或者极客会“玩弄”你的程序。 除此以外，你也不能保证程序的运行环境永远稳定，比如网络可能无法连接，磁盘写满 …… 总之，你只可以保证你的程序语法正确（?），其它的… 但是，作为一个负责任的程序员，我们要让自己的程序尽可能的健壮 &gt;&gt;&gt;&gt; 代码要有异常处理 即，当程序运行过程中异常产生后，可以使用捕获异常的方式获取这个异常的名称，再通过其他的逻辑代码尝试恢复程序的执行，或者进行一些程序崩溃前的必要工作，这种根据异常做出相应逻辑处理的过程叫作 异常处理。 自然而然的引发一个问题 &gt;&gt;&gt;&gt; 那么，应该如何捕获和处理异常呢？？？ 幸运的时，所有的高级语言通常都内置了一套 try...except...finally... 用于捕获以及处理异常的 异常处理机制，Python 当然也不例外。 异常处理机制是现代编程语言不可或缺的能力，它已经成为衡量一门编程语言是否成熟和健壮的标准之一。 Python 中的异常处理机制先来看 Python 中的基本异常处理结构：try except 语句块，它是 Python 异常处理机制的核心结构。 try except 异常处理Python 中，使用 try except 语句块捕获并处理异常的基本语法结构如下： 123456789try: # 可能产生异常的代码块except [ (Error1, Error2, ... ) [as e] ]: # 处理异常的代码块1except [ (Error3, Error4, ... ) [as e] ]: # 处理异常的代码块2except [Exception]: # 处理其它异常 [1] &gt;&gt;&gt;&gt; 语法结构说明 关于 try except 语法结构说明分为两个部分：结构说明 &amp;&amp; 参数说明。 1）–&gt; 结构说明 try except 结构中，try 块有且仅有一个，但 except 代码块可以有多个（&gt;=0），并且每个 except 块都可以同时处理多种异常。 注意，except 代码块至少要有一个（没有 finally 块时，见后文），否则会产生语法错误（SyntaxError）： 123# SyntaxError: invalid syntax# 或者# SyntaxError: unexpected EOF while parsing 2）–&gt; 参数说明 [] 括起来的参数部分可以选择使用，也可以省略。其中各部分的含义如下： (Error1, Error2,…) 、(Error3, Error4,…)：其中，Error1、Error2、Error3 和 Error4 都是具体的异常类型（参见常见异常类型）。显然，一个 except 块可以同时处理多种异常； [as e]：作为可选参数，表示给异常类型起一个别名 e，这样做的好处是方便在 except 块中调用异常类型； [Exception]：作为可选参数，可以代指程序可能发生的所有异常情况，其通常用在最后一个 except 块。 [2] &gt;&gt;&gt;&gt; 执行流程说明 1）首先执行 try 中的代码块，如果执行过程中出现异常，系统会自动解析生成一个对应异常类型，并将该异常提交给 Python 解释器，此过程称为捕获异常。 2）当 Python 解释器收到异常对象时，会寻找能处理该异常对象的 except 块（取决于 except 语句中异常类型参数），如果找到合适的 except 块，则把该异常对象交给该 except 块处理，这个过程被称为处理异常。如果 Python 解释器找不到处理异常的 except 块，则程序运行终止，Python 解释器也将退出。 注意，如果此段程序没有用 try 包裹，又或者没有为该异常配置处理它的 except 块，则 Python 解释器将无法处理，程序就会停止运行；反之，不管程序代码块是否处于 try 块中，甚至包括 except 块中的代码，只要执行该代码块时出现了异常，系统都会自动解析生成对应类型的异常，捕获后由相应 except 处理完成，则程序可以继续执行。 来看一个实例： 12345678910111213141516print(&quot;Begin To Run&quot;)try: a = int(input(&quot;输入被除数：&quot;)) b = int(input(&quot;输入除数：&quot;)) c = a / b print(&quot;相除的结果是：&quot;, c ) except (ValueError, ArithmeticError): # 处理 ValueError &amp; ArithmeticError 异常的 except 块 print(&quot;程序发生了数字格式异常、算术异常之一&quot;) print(&quot;进行特定异常处理&quot;)except : # 其它不确定异常(省略 Exception 参数) print(&quot;未知异常&quot;) print(&quot;进行异常处理&quot;)print(&quot;Continue To Run&quot;) 程序运行结果为： 123456Begin To Run输入被除数： 3输入除数： 0程序发生了数字格式异常、算术异常之一进行特定异常处理Continue To Run 可以看到，第一个 except 块使用（ValueError, ArithmeticError）来指定可以处理的异常类型，这就表明该 except 块可以同时处理这 2 种类型的异常；第二个 except 块使用省略异常类的 except 语句（except Exception），它并未指定具体要处理的异常类型，表示可处理所有类型的异常，一般会作为异处理的最后一个 except 块。 上面，由于 try 块中引发了异常，并被 Python 解释器捕获，并找到第一个 except 块可处理相应异常，处理后，程序继续执行，输出 Continue To Run。 [3] &gt;&gt;&gt;&gt; 获取发生的特定异常相关信息 上面，我们已经可以捕获程序中可能发生的异常，并对其进行处理。 但是，由于一个 except 可以同时处理多个异常，那么我们如何知道当前处理的到底是哪种类型的异常呢？ 事实上，每种异常类型都具有了如下几个属性和方法，通过调用它们，就可以获取当前处理异常类型的相关信息： args：返回异常信息的描述字符串； str(e)：返回异常信息，但不包括异常信息的类型； repr(e)：返回较全的异常信息，包括异常信息的类型。 基于此，我们可以给捕获到的异常类型起一个别名 e（as e），就可以访问其属性输出相应异常信息了： 1234567891011try: 1/0except Exception as e: # 访问异常的描述信息 print(e.args) print(str(e)) print(repr(e))# ('division by zero',)# division by zero# ZeroDivisionError('division by zero',) 从程序中可以看到，由于 except 可能接收多种异常，因此为了操作方便，直接给每一个进入到此 except 块的异常，起一个统一的别名 e。 注意，在 Python 2.x 的早期版本中，除了使用 as e 这个格式，还可以将其中的 as 用逗号 , 代替（即 exception Exception, as）。 深入解读异常处理块查找机制我们知道，当位于 try 块中的程序执行出现异常时，会将该种异常捕获，同时找到对应的 except 块处理该异常。 那么这里就有一个问题，Python 解释器是如何找到对应的 except 块的呢？？？ [1] &gt;&gt;&gt;&gt; 异常类 我们知道，一个 try 块也可以对应多个 except 块，一个 except 块可以同时处理多种异常，并且如果我们想使用一个 except 块处理所有异常还可以使用省略异常类型的 except 关键字（或 Exception）。 你肯定困惑过，为什么 Exception 异常可以对应所有的异常处理？？？这就不得不提到异常类了。 事实上，异常也是类。为了表示程序中可能出现的各种异常，Python 提供了大量的异常类，这些异常类之间有严格的继承关系。如下（异常类详情请参见 Exception Hierarchy）： 可以看出，BaseException 是 Python 中所有异常类的基类，但对于我们来说，最主要的是 Exception 类，因为程序中可能出现的各种异常，都继承自 Exception。 了解了异常类以及其继承关系之后，就可以开始解读异常处理块的查找机制了 &gt;&gt;&gt;&gt; [2] &gt;&gt;&gt;&gt; 查找机制 当 try 块捕获到异常对象后，Python 解释器会拿这个异常类型依次和各个 except 块指定的异常类进行比较，如果捕获到的这个异常类，和某个 except 块后的异常类一样，又或者是该异常类的子类，那么 Python 解释器就会调用这个 except 块来处理异常。 反之，Python 解释器会继续比较，直到和最后一个 except 比较完，如果没有比对成功，则证明该异常无法处理。 异常处理块查找机制示意图如下所示： 简单的异常捕获的例子： 12345678910111213try: a = int(input(&quot;输入被除数 a：&quot;)) b = int(input(&quot;输入除数 b：&quot;)) print( a/b ) except ValueError: print(&quot;数值错误：程序只能接收整数参数&quot;) except ArithmeticError: print(&quot;算术错误：除数不能为 0&quot;) except Exception: print(&quot;未知异常&quot;) 该程序中，根据用户输入 a 和 b 值的不同，可能会导致 ValueError、ArithmeticError 异常： 如果用户输入的 a 或者 b 是其他字符，而不是数字，会发生 ValueError 异常，try 块会捕获到该类型异常，同时 Python 解释器会调用第一个 except 块处理异常； 如果用户输入的 a 和 b 是数字，但 b 的值为 0，由于在进行除法运算时除数不能为 0，因此会发生 ArithmeticError 异常，try 块会捕获该异常，同时 Python 解释器会调用第二个 except 块处理异常； 当然，程序运行过程中，还可能由于其他因素出现异常，try 块都可以捕获，同时 Python 会调用最后一个 except 块来处理。 [3] &gt;&gt;&gt;&gt; except 块异常类型定义规则 当一个 try 块配有多个 except 块时，这些 except 块应遵循这样一个排序规则，即可处理全部异常的 except 块（参数为 Exception，也可以省略）要放到所有 except 块的后面 并且，所有父类异常的 except 块要放到子类异常的 except 块的后面。这意味着，一旦父类放于前面，它不但捕获该类型的错误，还把其子类也“一网打尽”，会导致其子类的 except 块永远也无法执行到（无意义的 except 块）。 例如： 123456try: foo()except ValueError as e: print('ValueError')except UnicodeError as e: print('UnicodeError') 第二个 except 永远也处理 UnicodeError 异常，因为 UnicodeError 是 ValueError 的子类，如果有，也被第一个 except 给处理了。 try except 通用形式我们知道，try except 语句块结构是 Python 异常处理机制中的核心结构。 但在实际使用过程中，还可以根据实际需要在 try except 语句块结构基础上添加 else 块和 finally 块结构（都是可选的），这样就变为： try except else 语句块结构 try except finally 语句块结构 try except else finally 语句块结构 try except else 异常处理Python 异常处理还提供了一个 else 机制，也就是原有 try except 语句的基础上再添加一个 else 块，即 try except else 结构。 try except else 语句块结构如下： 123456789try: # 可能产生异常的代码块except [ (Error1, Error2, ... ) [as e] ]: # 处理异常的代码块except [Exception]: # 处理其它异常 else: # 没有捕获异常时执行 注意：使用 else 包裹的代码，只有当 try 块没有捕获到任何异常时，才会得到执行；反之，如果 try 块捕获到异常，即便调用对应的 except 处理完异常，else 块中的代码也不会得到执行。 实例如下： 123456789101112131415try: result = 20 / int(input('请输入除数:')) print(result)except ValueError: print('必须输入整数')except ArithmeticError: print('算术错误，除数不能为 0')else: print('没有出现异常') print(&quot;Continue to run&quot;)# 请输入除数: 4# 5.0# 没有出现异常# Continue to run 你可能会困惑，既然 Python 解释器按照顺序执行代码，那么 else 块有什么存在的必要呢？直接将 else 块中的代码编写在 try except 块的后面，不是一样吗？ 事实上，else 的功能，只有当 try 块捕获到异常时才能显现出来。在这种情况下，else 块中的代码不会得到执行的机会。如下运行： 123# 请输入除数: &quot;2&quot;# 必须输入整数# Continue to run try except finally 异常处理Python 异常处理机制还提供了一个 finally 语句，通常用来为 try 块中的程序做扫尾清理工作。 try except finally 基本结构如下： 123456789101112try: # 可能产生异常的代码块except [ (Error1, Error2, ... ) [as e] ]: # 处理异常的代码块except [Exception]: # 处理其它异常 else: # 没有捕获异常时执行 finally: # 是否捕获到异常都需要执行 结构说明：和 else 语句不同，finally 只要求和 try 搭配使用，而至于该结构中是否包含 except 以及 else，对于 finally 都不是必须的（else 必须和 try except 搭配使用）。 在整个异常处理机制中，finally 语句块的功能是：无论 try 块是否发生异常，最终都要进入 finally 语句，并执行其中的代码块。 [1] &gt;&gt;&gt;&gt; finally 语句块作用 Python 垃圾回收机制，只能帮我们回收变量、类对象、函数等占用的内存，而无法自动完成类似关闭文件、数据库连接等这些的工作。 基于上述 finally 语句块的特性，在某些情况下，当 try 块中的程序打开了一些物理资源（文件、数据库连接等）时，由于这些资源必须手动回收，而回收工作通常就可以放在 finally 块中。 当然了，回收这些物理资源并不是必须使用 finally 块，但使用 finally 块是比较好的选择。 这是由于，try 块不适合做资源回收工作，因为一旦 try 块中的某行代码发生异常，则其后续的代码将不会得到执行；其次 except 和 else 也不适合，它们都可能不会得到执行；而 finally 块中的代码，无论 try 块是否发生异常，该块中的代码都会被执行。 [2] &gt;&gt;&gt;&gt; 演示实例 1234567891011try: a = int(input(&quot;请输入 a 的值:&quot;)) print(20/a)except: print(&quot;发生异常！&quot;)else: print(&quot;执行 else 块中的代码&quot;) finally : print(&quot;执行 finally 块中的代码&quot;) 1）–&gt; 正常运行此程序： 1234请输入 a 的值: 45.0执行 else 块中的代码执行 finally 块中的代码 可以看到，当 try 块中代码未发生异常时，except 块不会执行，else 块和 finally 块中的代码会被执行。 2）–&gt; 运行中产生异常： 123请输入 a 的值: 0发生异常！执行 finally 块中的代码 可以看到，当 try 块中代码发生异常时，except 块得到执行，而 else 块中的代码将不执行，finally 块中的代码仍然会被执行。 3）–&gt; 程序异常退出情况 finally 块的强大还远不止此，即便当 try 块发生异常，且没有合适和 except 处理异常时，finally 块中的代码也会得到执行。例如： 123456789101112try: #发生异常 print(20/0)finally : print(&quot;执行 finally 块中的代码&quot;)# 执行 finally 块中的代码# Traceback (most recent call last):# File &quot;D:\\python3.6\\1.py&quot;, line 3, in &lt;module&gt;# print(20/0)# ZeroDivisionError: division by zero 可以看到，当 try 块中代码发生异常，导致程序崩溃时，在崩溃前 Python 解释器也会执行 finally 块中的代码。 try except else finally 异常处理通用形式Python 通用的异常处理语法结构如下： 123456789101112131415try: #业务实现代码except Exception1 as e: #异常处理块1 ...except Exception2 as e: #异常处理块2 ...#可以有多个 except...else: #正常处理块finally : #资源回收块 ... 异常处理结构流程图如下： 整个异常处理结构中，只有 try 块是必需的，也就是说： 如果没有 try 块，则不能有后面的 except 块、else 块和 finally 块。但是也不能只使用 try 块，要么使用 try except 结构，要么使用 try finally 结构； except 块、else 块、finally 块都是可选的，当然也可以同时出现 可以有多个 except 块，但捕获父类异常的 except 块应该位于捕获子类异常的 except 块的后面； 多个 except 块必须位于 try 块之后，finally 块必须位于所有的 except 块之后。 要使用 else 块，其前面必须包含 try 和 except。 程序退出情况下 finally 运行说明 &gt;&gt;&gt;&gt; [1] &gt;&gt;&gt;&gt; break、continue、return 退出情况 finally 语句不管异常是否发生都会执行。不仅如此，无论是正常退出、遇到异常退出，还是通过 break、continue、return 语句退出，finally 语句块都会执行。 [2] &gt;&gt;&gt;&gt; 解释器退出（os._exit(1)）情况 如果 try 块、except 块中调用了退出 Python 解释器的方法，则 finally 语句将无法得到执行。否则不管在 try 块、except 块中执行怎样的代码，出现怎样的情况，异常处理的 finally 块总会被执行。 实例演示： 12345import ostry: os._exit(1)finally: print(&quot;执行finally语句&quot;) 运行程序，没有任何输出。 [3] &gt;&gt;&gt;&gt; return、raise 中止语句 尽量避免在 finally 块里使用 return 或 raise 等导致方法中止的语句，它将会导致 try 块、except 块中的 return、raise 语句失效。如下： 12345678910111213def test(): try: print(&quot;try 块&quot;) # 因为 finally 块中包含了 return 语句 # 所以下面的 return 语句失去作用 return True finally: return Falseprint(test())# try 块# False 仔细思考一下，无论是否产生异常（不考虑解释器退出情况），finally 块均会执行。此时如果，try 块、except 块中包含 return、raise，而 finally 块也包含相应 return、raise 中止语句时，解释器到底该返回哪一个？？？ 如果 Python 程序在执行 try 块、except 块包含有 return 或 raise 语句，则 Python 解释器执行到该语句时，会先去查找 finally 块，如果没有 finally 块，程序才会立即执行 return 或 raise 语句。 反之，如果找到 finally 块，系统立即开始执行 finally 块，只有当 finally 块执行完成后，系统才会再次跳回来执行 try 块、except 块里的 return 或 raise 语句。如果此时 finally 块里也使用了 return 或 raise 等导致方法中止的语句，finally 块己经中止了方法，系统将不会跳回去执行 try 块、except 块里的任何代码。 Raise 手动抛出异常raise 语句的基本语法格式为： 1raise [exceptionName [(reason)]] 说明，用 [] 括起来的为可选参数，其作用是指定抛出的异常类型的名称，以及相应异常的描述信息。如果可选参数全部省略，则 raise 会把当前 Python 解释器检测到的上下文错误原样抛出；如果仅省略 (reason)，则在抛出指定异常时，将不附带任何的异常描述信息。 也就是说，raise 语句有如下三种常用的用法： raise：可选参数全部缺省。该语句会把当前 Python 解释器自动检测到的上下文错误原样抛出，如没有检测到其它上下文异常则默认引发 RuntimeError 异常； raise exceptionName：raise 后带一个异常类型名称，表示手动抛出一个指定的 exceptionName 类型的异常（该指定异常是 Python 内置的异常类型或用户自定义异常）； raise exceptionName(reason)：在抛出指定类型异常的同时，附带异常的描述信息。 你可能会感到非常困惑，我们都是想方设法地让程序正常运行，为什么还要手动抛出异常呢？？？ 通常情况下，手动让程序引发异常，很多时候并不是为了让其崩溃，而是针对程序运行中可能出现的异常进行手动捕获并处理。事实上，raise 语句引发的异常通常结合 try except（else finally）异常处理结构来捕获并进行处理。 实例演示： 123456789101112131415while True: try: a = input(&quot;Please enter a number: &quot;) # 判断用户输入的是否为数字 if(not a.isdigit()): raise ValueError(&quot;Input must be a number!!!&quot;) break except ValueError as e: print(&quot;引发异常：&quot;, repr(e))# Please enter a number: sdf3# 引发异常： Input must be a number!!!# Please enter a number: 22 程序执行时，当用户输入的不是数字时，程序会进入 if 判断语句，并执行 raise 引发 ValueError 异常。但由于其位于 try 块中，因为 raise 抛出的异常会被 try 捕获，并由 except 块进行处理。 可以看到，虽然程序中使用了 raise 语句引发异常，但程序的执行是正常的，手动抛出的异常并不会导致程序崩溃。 无参 raise &gt;&gt;&gt;&gt; 1）–&gt; 上下文中已引发过异常 12345678910111213141516try: a = input(&quot;Please enter a number: &quot;) # 判断用户输入的是否为数字 if(not a.isdigit()): raise ValueError(&quot;Input must be a number!!!&quot;)except ValueError as e: print(&quot;引发异常：&quot;, repr(e)) raise# Please enter a number: wer# 引发异常： Input must be a number!!!# Traceback (most recent call last)# File &quot;test.py&quot;, line 4, in &lt;module&gt;()# ----&gt; 5 raise ValueError(&quot;Input must be a number!!!&quot;)# ValueError: Input must be a number!!! 这里重点关注位于 except 块中的 raise，由于在其之前我们已经手动引发了 ValueError 异常，因此这里当再使用 raise 语句时，它会再次引发一次。 2）–&gt; 上下文中未引发过异常 需要注意的是，在没有引发过异常的程序使用无参的 raise 语句时，它默认引发的是 RuntimeError 异常。例如： 1234567891011try: a = input(&quot;Please enter a number: &quot;) # 判断用户输入的是否为数字 if(not a.isdigit()): raiseexcept RuntimeError as e: print(&quot;引发异常：&quot;, repr(e))# Please enter a number: abc# 引发异常： RuntimeError('No active exception to reraise',)","link":"/2018/01/14/python-zhong-de-yi-chang-chu-li-ji-zhi/"},{"title":"Python 中的缓存重用机制（常量池）","text":"为了减少高频使用数据创建时申请内存和销毁时撤销内存的开销，Python 中引入了 Python 缓存重用机制（常量池）以提高程序执行的效率。 何为缓存重用？Python 缓存重用机制，实际上就是 &gt;&gt;&gt;&gt; 在 Python 解释器启动时就从内存空间中开辟出一小部分（常量池），专门用来存储高频使用的数据，以大大减少高频使用数据创建时申请内存和销毁时撤销内存的开销。 Python 在存储数据时，会根据数据的读取频繁程度以及内存占用情况来考虑，是否按照一定的规则将数据存储在缓存中，这些缓存中的数据是不会被 GC（Garbage Collector）回收的。 那么问题来了，内存重用机制适用于哪些基本数据类型呢？或者说哪些基本数据类型的常量会被存放到常量池中呢？ 缓存哪些数据类型？Python 是否将指定数据存入缓存（常量池）中的规则： 数据类型 是否可以重用 生效范围 备注 范围在 [-5, 256] 之间的小整数 如果之前在程序中创建过，就直接存入缓存，后续不再创建 全局 小整数池 bool 类型 如果之前在程序中创建过，就直接存入缓存，后续不再创建 全局 bool 常量池 字符串类型数据(需符合命名规则 ) 如果之前在程序中创建过，就直接存入缓存，后续不再创建 全局 字符串常量池 大于 256 的整数 Or 大于 0 的浮点型小数 只要在本代码块内创建过，就直接缓存，后续不再创建 本代码块 小于 0 的浮点型小数 Or 小于 -5 的整数 不进行缓存，每次都需要额外创建 不使用常量池 PS &gt;&gt;&gt;&gt; 一般来说，Python 常量池小且有限，只会存放少量的数据对象。事实上，常量池的范围还和解释器以及编译器有关，例如在 Pycharm、VSCode 等 IED 中，大整数和较长、带有特殊字符的字符串也存在常量池。 实验验证实验展示缓存重用机制（常量池机制） &gt;&gt;&gt;&gt; 通过一段程序来演示 Python 缓存重用机制的规则: 代码中，id() 内置函数可以用于获取变量指向数据对象的内存地址。is：比较的是 两个实例对象是不是完全相同，是不是同一个对象（占用的内存地址是否相同，内容相同）。 123456789101112131415161718192021222324252627282930# 范围在 [-5, 256] 之间的小整数int1 = -5int2 = -5print(&quot;{[-5, 256] 情况下的两个变量}：&quot;, id(int1), id(int2), int1 is int2)# bool类型bool1 = Truebool2 = Trueprint(&quot;{bool 类型情况下的两个变量}：&quot;, id(bool1), id(bool2), bool1 is bool2)# 对于字符串s1 = &quot;3344&quot;s2 = &quot;3344&quot;print(&quot;{字符串情况下的两个变量}&quot;, id(s1), id(s2), s1 is s2)# 大于 256 的整数int3 = 9527int4 = 9527print(&quot;{大于 256 的整数情况下的两个变量}&quot;, id(int3), id(int4), int3 is int4)# 大于 0 的浮点数f1 = 9527.0f2 = 9527.0print(&quot;{大于 0 的浮点数情况下的两个变量}&quot;, id(f1), id(f2), f1 is f2)# 小于 0 的浮点数f3 = -2.45f4 = -2.45print(&quot;{小于 0 的浮点数情况下的两个变量}&quot;, id(f3), id(f4), f3 is f4)# 小于 -5 的整数n1 = -6n2 = -6print(&quot;{小于 -5 的整数情况下的两个变量}&quot;, id(n1), id(n2), n1 is n2) 运行该程序，其输出结果为： 1234567{[-5, 256] 情况下的两个变量}： 1801941456 1801941456 True{bool 类型情况下的两个变量}： 1801461008 1801461008 True{字符串情况下的两个变量} 2335217145592 2335217145592 True{大于 256 的整数情况下的两个变量} 2335216742288 2335216742288 True{大于 0 的浮点数情况下的两个变量} 2335210240160 2335210240160 True{小于 0 的浮点数情况下的两个变量} 2335210240112 2335210240136 False{小于 -5 的整数情况下的两个变量} 2335216742352 2335216742160 False 以上输出结果中，每行都输出了 2 个相对应的变量所指向的内存地址，如果相等，则表明 Python 内部对其使用了缓存机制，反之则没有。可对照以上输出结果来理解 【数据存入缓存（常量池）规则】 中具体说明。 神奇的 9527对于 【数据存入缓存（常量池）规则】 中所提到的代码块，Python 中的函数和类都被认为是在程序中开辟了一块新的代码块。以函数为例，函数内部的代码分属一个代码块，函数外部的代码属于另一个代码块。 Python 缓存机制在不同的代码块中也会有不同的表现。在上面例子代码的基础上，继续编写如下程序： 1234567891011121314151617181920212223def fun(): # [-5,256] int1 = -5 print(&quot;{fun 中 -5 的存储状态}&quot;,id(int1), id(int2), int1 is int2) # bool类型 bool3 = True print(&quot;{fun 中 bool 类型的存储状态}&quot;, id(bool3), id(bool2), bool3 is bool3) # 字符串类型 s1 = &quot;3344&quot; print(&quot;{fun 中 3344 字符串的存储状态}&quot;, id(s1), id(s2), s1 is s2) # 大于 256 int3 = 9527 print(&quot;{fun 中 9527 的存储状态}&quot;, id(int3), id(int4), int3 is int4) # 浮点类型 f1 = 9527.0 print(&quot;{fun 中 256.4 的存储状态}&quot;,id(f1), id(f2), f1 is f2) # 小于 -5 n1 = -6 print(&quot;{fun 中 -6 的存储状态}&quot;, id(n1), id(n2), n1 is n2) fun() 输出结果为： 123456{fun 中 -5 的存储状态} 140403724199328 140403724199328 True{fun 中 bool 类型的存储状态} 140403724013120 140403724013120 True{fun 中 3344 字符串的存储状态} 140403700614512 140403700614512 True{fun 中 9527 的存储状态} 140403702968720 140403704573872 False{fun 中 9527.0 的存储状态} 140403704701576 140403704701216 False{fun 中 -6 的存储状态} 140403702970768 140403702970800 False 根据输出结果可以分析出： 从 -5 、bool 类型以及字符串 “3344” 的输出结果可以得知，无论是在同一代码块，还是不同的代码块，它们都使用相同的缓存内容； 从 9527 和 9527.0 的输出结果可以得知，如果位于同一代码块，则使用相同的缓存内容；反之，则不使用； 从 -6 的输出结果得知，Python 没有对其缓存进行操作。 全流程验证 Python 解释器内部使用常量池机制这里再来附一篇关于 全流程验证 Python 解释器内部使用常量池机制 的博文： 转载至 nickchen 的博文 &gt;&gt;&gt;&gt; 通过代码验证 Python 解释器内部使用了常量池。 全文 + 个人理解如下： 变量的引入[1] –&gt; 为什么要有变量？ 我们知道，Python 世界就可以看作现实世界的【镜像】，我们想要做到的就是在镜像世界里面高效地解决现实世界里的繁琐任务。这首先就要求 Python 【镜像世界】中必然存在与现实世界物体（研究对象）对应的抽象表达，比如现实世界中最常见的数字、文字、图像、声音等等，在 Python 世界统一被称为：【数据】，有了数据才有后续的一切。 计算机语言开发者们为了使用计算机语言的人更好的在计算机中去描述这些实物数据，便在计算机语言中引入了变量这个概念，Python 也不例外。简单点说，变量就是用来描述世间万物的。 [2] –&gt; 定义变量 为了在计算机书写方便，定义一变量也有一定的规则，在这里我们仅说说Python中变量的定义规则，首先我们先定义两个变量： 12name = &quot;xuexi&quot;year = 2021 上述代码中我们便定义了两个变量，从上面定义的两个变量中，我们可以看到，变量的组成分为三个部分： 变量名：反应变量值所描述的意义，并且可以用来引用变量值； 赋值运算符：赋值； 变量值：存放数据，用来记录现实世界中的某种状态。 常量引入上面简单讲解了 Python 中的变量，通过字面意思，可以看到变量其实是一个变化的量，例如，下面这个实例： 123year = 2021year = year + 1print(year) # 输出结果：2022 刚开始我们赋予了 year 一个变量值为 2021，当我们对 year 进行加 1 操作时，可以发现 year 值变成了 2022 。对于上述现象我们不难理解，因为之前说过 Python 中变量是用来描述世间万物的，世间万物在现实中是可以变化的，变量当然也可以随之变化。 但是在某个局部范围内，变量可能是不会变化的，例如在 2021 年这一年，都只会是 2021 年，没有人会说 2021 年是 2022 年。如果你有丰富的开发经验，会明白变量定义出来不是存放在那里给你看的，更多的是要拿来用的。也就是说如果在 2021 年中的某个程序需要使用 year 这个变量，但这个变量是不需要进行修改的。为了防止误操作对 year 这个变量进行了修改，计算机语言便设计了常量这个概念，也就是说，常量相对于变量是一个不会变化的量。 在 Python 中，有没有常量呢？不严格的讲，其实是有的，只是在定义常量的时候常量名必须的全大写，例如，下面这个实例： 123YEAR = 2021YEAR = YEAR + 1print(YEAR) # 输出结果：2022 上面这个常量的实例令人大吃一惊，因为使用常量 YEAR 后和使用变量 year 的结果一致，也就是说常量 YEAR 遭到了更改。但是，稍微解释你就明白了。 在 Python 中，虽然也和其他很多计算机语言一样拥有常量这个概念，但更多的是约定俗成的，Python 并没有严格的对常量进行控制，只是规定常量名必须全部大写。原因很简单：都是常量了，你为什么还要修改？？？ 常量池引入上面讲到常量就是一个不会变化的变量，严格的讲，在 Python 中是没有常量这个概念的。但是，在 Python 中又有另外一种例外，那就是常量池，为了搞清楚常量池，首先我们得弄明白 Python 的几个小知识，接下来一一叙说。 Python 解释器上面提及到 Python 是计算机用来描述世间万物的一种语言，由于计算机没有人脑那么强大，计算机更多的只是认识高低压电频，再通过对高低压电频的转化进而编码成我们看到的一个又一个字符，也就是说计算机是无法直接认识利用 Python 写下的字符的（此处涉及计算机组成原理，不多做介绍）。 也就是说，当我们利用 Python 写下一个又一个字符并且交给电脑时，需要通过编码这个过程，而这个编码的过程有时候也被称为解释。解释的原理就相当于从中文转成英文，只不过此时不是需要让英文使用者看懂中文，而是让计算机能够看懂 Python。 中文转成英文的时候，可能需要一个翻译员或一个翻译软件，利用 Python 写下的字符转化为计算机能看懂的语言同样如此，这个转化过程也需要一个外物的帮助——Python 解释器。 Python 变量存储机制假设我们使用 Python 解释器定义了以下一个变量： 1year = 2021 现在假设江西师范大学相当于电脑内存，每当有一批新学生进入师大时，师大都会开辟出一个新教室给这批新同学使用，并且会给每一个教室一个独一无二的教室牌号。由于把师大看作是内存，这批新同学就可以看成是变量值，而教室牌号就是变量名。也就是说，对于师大这个大内存，每定义一个变量 year = 2021，就会在这个大内存中开辟一个小空间，小空间中放变量值 2021，然后大内存会给这个小空间定义一个变量名 year，此时变量名 year 指向变量值2021。 上面说到每当 Python 解释器解释一个变量时，会将这个变量存放到内存中的一个小空间中，但如何知道这个小空间的具体位置呢？此处介绍 Python 的一个内置函数 id()，通过这个函数可以获取某一个变量所在的内存地址，例如下面这个实例： 12year = 2021print(id(year)) Python 垃圾回收机制对于上述师大的例子，此处再做延伸。由于那一批学生所在班级新转来了几位同学，需要那一批学生更换更大一点教室，也就是给他们一个新的教室。那么学校应该会这样处理，首先开辟一个新的教室，然后拿下那一批学生原有教室的教室牌号更换到这个新教室，最后会清空原有教室。 在 Python 中，也是如此，如果到了新的一年，我们会重新定义一个 year 变量，也就是 year = 2022 。如果这是在同一个程序中如此做，Python 会沿用上述更换教室的方法，它首先会解除 year 和 2021 的连接，开辟一个新内存存放变量值 2022 ，让 year 与 2022 连接。此时，会发现 2021 这个变量值只有变量值而没有变量名，因此这个没有变量名的变量值会变成 Python 眼中的一个垃圾变量，从而触发 Python 垃圾回收机制(GC)，对这个 2021 所在的内存空间进行回收。 为了更好地理解 Python 垃圾回收机制，可以看下面这个例子： 1234567year = 2021print(id(year)) # 输出 2867780266704print(year) # 输出 2021year = 2022print(id(year)) # 输出 2867780267824print(year) # 输出 2022 通过上述例子，可以看到当新定义了一个 year 变量时，year 会与新的变量进行一个连接。当然，此处所说的垃圾回收机制只是为了引入 引用计数 这个概念，并不是完全正确的解释，并且上述实例还无法证明变量值 2021 所在内存是否被回收，下面将通过引用计数的实例会进一步说明并重新解释垃圾回收机制。 引用计数上面讲到如果某个变量值绑定着变量名，就是一个正常的变量，如果该变量值没有绑定着门牌号，这个变量就是一个垃圾变量，对于垃圾变量，Python 会触发垃圾回收机制回收这个变量所占有的内存。进而可以想到，Python 中一个变量名一定只能对应一个变量值。 在这里我们就不能沿用师大这个例子了，而得引出一个新的名词——引用计数。 为了解释引用计数，我们首先得明白在 Python 中，当定义了一个变量值为 2021 的变量时，它可以表示年份、也可以表示山的高度……也就是说一个变量名只能对应一个变量值，但是一个变量值可以对应不同的变量名，这种设计也是比较合理的。 现在我们引出 “引用计数” 这个概念，当相同的变量值被赋予不同的变量名时，变量值每增加一个变量名的赋予，则该变量值的引用计数加1。由于我们可以通过 Python 内置 sys 模块中的 getrefcount() 函数获取某一个变量的引用计数（getrefcount 输出值默认从 3 开始），可以通过下面这个例子感受下（命令行调用或 IDE 下运行）: 12345678910111213import sys# 引用计数初始值为 3print(sys.getrefcount(2021)) # 输出为 3year = 2021print(sys.getrefcount(2021)) # 输出为 4height = 2021print(sys.getrefcount(2021)) # 输出为 5del yearprint(sys.getrefcount(2021)) # 输出为 4 从上述代码可以看出变量值 2021 的引用计数由于每一次赋予新的变量名，引用计数都会增加，而当我们利用 del 关键字删除变量值 2021 的一个变量名 year 时，引用计数则会减少。 为了更加严谨的表达引用计数，此处不得不再次深入，引用计数字面意思可以理解为引用的次数，也就是说上面的例子其实并不严谨，更严谨的讲，只有当一个变量值每一次被直接或间接引用时，引用计数才会增加，在 Python 中让引用计数增加共有三种方法： 变量被创建，变量值引用计数加 1 变量被引用，变量值引用计数加 1 变量作为参数传入到一个函数，变量值引用计数加 2 具体看下述实例： 123456789101112131415161718import sys# 引用计数初始值为3print(sys.getrefcount(2021)) # 输出为 3# 变量被创建，变量值引用计数加 1year = 2021print(sys.getrefcount(2021)) # 输出为 4# 变量被引用，变量值引用计数加1height = yearprint(sys.getrefcount(2021)) # 输出为 5# 变量作为参数传入到一个函数，变量值引用计数加 2def func(year): print(sys.getrefcount(year)) func(year) # 输出为 7 Python 中既然有增加引用计数的方法， 也当然会减少引用计数的方法，共有以下 4 种： 变量值对应的变量名被销毁 变量值对应的变量名被赋予新的值 变量值对应的变量名离开它的作用域 变量值对应的变量名的容器被销毁 重新认识 Python垃圾回收机制有了 getrefcount() 方法并通过引用计数，我们就可以解开垃圾回收机制遗留的一个问题——如何判断是否触发了垃圾回收机制。每当一个变量定义，他的 getrefcount 默认输出值为 3，而如果该变量值被垃圾回收机制回收，则它的 getrefcount 输出值回到 3，可以通过下面实例验证上述猜想： 12345678910111213import sysprint(sys.getrefcount(2021)) # 输出为 3year = 2021print(sys.getrefcount(2021)) # 输出为 4print(id(year)) # 输出 4499932720print(year) # 输出 2021year = 2022print(sys.getrefcount(2021)) # 输出为 3print(id(year)) # 输出 4499932560print(year) # 输出 2022 通过上述实例，可以发现由于变量值 2021 对应的变量名被新的变量值 2022 引用，它的 getrefcount 输出值为 3，引用计数变成了 0 ，因此可以证明 Python 触发了垃圾回收机制。 如果对上述验证 Python 触发垃圾回收机制的实例深入挖掘，会发现当把 year 赋给变量值 2022 时，变量值的 2021 的引用计数为 0，此时触发了 Python 的垃圾回收机制，那么是否可以表明只有当变量值 2021 的引用计数为 0 时才能触发垃圾回收机制呢？而不是上一次说的当变量值的变量名被新的变量值被引用了才会销毁呢？因为变量值可以对应多个变量名，下面通过下述实例验证： 123456789101112131415import sysprint(sys.getrefcount(2021)) # 输出为 3year = 2021print(sys.getrefcount(2021)) # 输出为 4height = 2021print(sys.getrefcount(2021)) # 输出为 5year = 2022print(sys.getrefcount(2021)) # 输出为 4del heightprint(sys.getrefcount(2021)) # 输出为 3 通过上述实例，可以发现由于定义一个变量后，该变量对应的变量值引用计数可以不断增加，而只要引用计数不为 0，那么 Python 就一直还在内存中保留着这个变量值并且对其引用，只有当该变量的引用计数为 0 时，Python 才会触发垃圾回收机制对该变量值进行回收，这才是比较正确的垃圾回收机制。当然，如果深入，Python 的回收机制还有分代回收，此处不做延展，了解上述这些就足矣了解接下来讲的小整数池。 常量池在上述各个知识的打通之后，现在可以正式引入常量池这个概念。上面讲到在 Python 中严格的讲是没有常量这个概念的，即使你通过约定俗成的方法定义了一个常量，但这个常量也只是一个变量，也就是说只要你对这个常量做出修改，这个常量原有对应的常量值引用计数就会变成 0，由于常量等同于变量，它一样会被 Python 垃圾回收机制回收。 但是在 Python 中，存在着一些例外，这些例外就是一个小整数池，顾名思义，小整数池表示的是从 -5 到 256 范围内的整数，这些整数定义出来后就是一个常量，也就是说他们的引用计数即使为 0，也不会被 Python 的垃圾回收机制回收。 通过垃圾回收机制判断小整数池中的整数是否会被垃圾回收机制回收，可用如下实例证明: 123456789101112131415161718&gt;&gt;&gt; a = 5&gt;&gt;&gt; id(a)4529334480&gt;&gt;&gt; del a&gt;&gt;&gt; b = 5&gt;&gt;&gt; id(b)4529334480&gt;&gt;&gt;&gt;&gt;&gt; a = 257&gt;&gt;&gt; id(a)4533920752&gt;&gt;&gt; del a&gt;&gt;&gt; b = 257 # 消除分代回收对结果的影响&gt;&gt;&gt; del b&gt;&gt;&gt; b = 257&gt;&gt;&gt; id(b)4531031792&gt;&gt;&gt; 从上述实例中可以看出，变量值5即使被垃圾回收机制回收后，再次创建变量值为 5 的变量，该变量的内存地址始终无变化，即该变量未被垃圾回收机制回收，小整数池中的其他整数同理；而变量值 257 却已经被垃圾回收机制回收，非小整数池中的其他变量同理。 当然，还可以通过下述方法查看这些小整数池的整数的内存地址的变化，如下： 123456789101112131415a = 256b = int(&quot;256&quot;)print(id(a), id(b)) # 4544968752 4544968752a = 257b = int(&quot;257&quot;)print(id(a), id(b)) # 4548719792 4546289360a = -5b = int(&quot;-5&quot;)print(id(a), id(b)) # 4544960400 4544960400a = -6b = int(&quot;-6&quot;)print(id(a), id(b)) # 4690036912 4546289360 对于上述实例，在 Python 中，由于每生成一个变量便会开辟一个新的内存空间给该变量，但是上述实例表明当变量值为 -5 和 256 时，每次开辟的内存空间地址都是一样的；而当变量值不属于 [-5, 256] 时，每次定义变量值时，内存空间的地址都是不一样的。","link":"/2018/01/05/python-zhong-de-huan-cun-chong-yong-ji-zhi-chang-liang-chi/"},{"title":"Python 浮点数精确运算解决方案","text":"使用 Python 标准库中数字和数学模块 &gt;&gt;&gt;&gt; decimal 模块，实现 Python 浮点数精确运算，可以满足会计方面的应用和有高精度要求的应用场景。 前记前面的博文 [ &gt;&gt;&gt;&gt; 编程基础之进制详解 &lt;&lt;&lt;&lt; ] 中提到过，在计算机中浮点数并不能准确的表示十进制，这是由于十进制小数在转换成计算机可识别、处理的二进制小数时，存在无限问题，此时计算机会在某个精度上直接进行舍入，以至于运算还没开始，一个很小的舍入错误就已经产生了。 而有误差的两个数，其运算的结果，很可能和我们的期望不一样了，例如：0.1 + 0.2 &gt; 0.3。详情可参见博文：[ &gt;&gt;&gt;&gt; 为什么 0.1 + 0.2 不等于 0.3? &lt;&lt;&lt;&lt; ]。 并且在运算（即便最简单的数学运算）中也会由于近似处理、内存限制等原因出现舍入误差。同时，上述种种的舍入误差会在后续的计算过程中不断传递累计，最终带来不可控制的后果。 Python 近似机制这一小节的目的是认识一下 Python3 中浮点数的近似进制。 先不要运行 round(1.115)，考虑一下其结果是 1.11 还是 1.12 ？？？ 悄悄告诉你是（1.11），你猜对了么？！！ 计算机中大多数小数是不精确的，例如 1.115 在计算机中实际上是 1.1149999999999999911182。当你对这个小数精确到小数点后两位的时候，实际上小数点后第三位是 4，所以四舍五入的结果为 1.11。 再来看一个在计算机中可精确表示的小数 0.125（不要问为什么是精确的，好好看前记中提供的博文外链），考虑一下 round(0.125) 结果是 0.12 还是 0.13 ？？？ 运行后你会发现，把 0.125 精确到小数点后两位，四舍五入结果是 0.12，为什么这里四舍了？？？ 再来尝试一下 round(0.375)，其四舍五入结果是 0.38，这里为什么又五入了？！！ 事实上 &gt;&gt;&gt;&gt; Python3 中，round 对小数的精确度采用了 “四舍六入五成双” 的方式，需要使用 “奇进偶舍” 的处理方法进行判断。 舍入判断规则 &gt;&gt;&gt;&gt; [1] &gt;&gt;&gt;&gt; 对于一个小数 a.bcd，如需要精确到小数点后两位，那么就要看小数点后第三位。 [2] &gt;&gt;&gt;&gt; 如果 d &lt;= 4，直接舍去；如果 d &gt;= 6，直接进位。 [3] &gt;&gt;&gt;&gt; 如果 d==5 &gt;&gt;&gt;&gt; 1）d 后面没有数据 &amp;&amp; c 为偶数：那么不进位，保留 c；2）d 后面没有数据 &amp;&amp; c 为奇数：那么进位，c —&gt; c + 1；3）d 后面有数据，直接进位，c —&gt; c + 1。 谈到 Python 的近似机制，主要是由于在实际应用场景中都会涉及到精确度（近似）问题。就 Python 的浮点数运算而言，大多数计算机每次计算误差不会超过 2^53，但这对于大多数任务来说已经足够了。也就是说，我们允许（对结果无关紧要的）误差存在。 然而 &gt;&gt;&gt;&gt; 对于金融方面的应用和有高精度要求的应用场景，舍入误差就显得尤为明显了，这就需要用到 Python 中的 decimal 模块了。 decimal Moduledecimal 模块中，可以通过 整数，字符串，元组，或 浮点数，来构建 decimal.Decimal 对象，以实现精确计算。 先来看一个简单演示 —&gt; 如何使用 decimal 模块，使得 0.1 + 0.2 == 0.3（进行精确计算）？？？方法如下： 12345678from decimal import Decimala = Decimal('0.1')b = Decimal('0.2')sum = a + bprint(sum, type(sum))# 0.3 &lt;class 'decimal.Decimal'&gt; 如果是浮点数，特别注意因为浮点数本身存在误差，需要先将浮点数转化为字符串，再传入 Decimal。 易错点容易出错的是 &gt;&gt;&gt;&gt; [1] &gt;&gt;&gt; 浮点数直接参与构建 Decimal 对象 12345678from decimal import Decimala = Decimal(0.1)b = Decimal(0.2)sum = a + bprint(sum, type(sum))# 0.3000000000000000166533453694 &lt;class 'decimal.Decimal'&gt; 可以看到，此时浮点数未转换为字符串，直接用于构造 Decimal 对象，相当于没有用到精确计算。此时使用的是 0.1 &amp;&amp; 0.2 在计算机中的精确值,，可以打印出来看一下： 123456789from decimal import Decimala = Decimal(0.1)print(a)# 0.1000000000000000055511151231257827021181583404541015625b = Decimal(0.2)print(b)# 0.200000000000000011102230246251565404236316680908203125 你可以想到的是：如果一个小数在计算机中是精确的，那么直接使用（未转换为字符串）其构建的 Decimal 对象值刚好就是小数本身的值。 [2] &gt;&gt;&gt; 混合操作 Decimal 和浮点数 直接看样例： 123456from decimal import Decimala = Decimal('0.1')b = 0.125print(a + b)# TypeError: unsupported operand type(s) for +: 'decimal.Decimal' and 'float' Decimal 数值对象可以直接和整型（int）、布尔型（bool）数值进行计算。与浮点数或分数模块 fractions.Fraction 实例在算术运算中结合使用时会报错：TypeError（例如尝试将 Decimal 加到 float）。 但是，可以使用 Python 的比较运算符来比较 Decimal 实例 x 和另一个数字 y（浮点数也可以参与比较了）。 设置有效位数当使用十进制模块运算过程中出现无限小数时，可以通过设置 有效数字 来达到需要的目标精度： [1] &gt;&gt;&gt; decimal.getcontext().prec 12345from decimal import Decimal, getcontextgetcontext().prec = 6print(Decimal(1)/Decimal(7)) # 0.142857print(1/7) # 0.14285714285714285 [2] &gt;&gt;&gt; quantize(Decimal(‘0.000’)) 在截取有效位数时，你也可以使用 quantize 方法来决定 保留几位小数，同时支持自定义四舍五入（舍入）机制，: 12345678910111213from decimal import Decimal, ROUND_DOWNres = Decimal(1)/Decimal(7)print(res) # 0.1428571428571428571428571429res1 = res.quantize(Decimal('0.000')) # 四舍五入，保留3位有效数字print(res1) # 0.143res2 = res.quantize(Decimal('0.000'), rounding=ROUND_DOWN) # 向下舍入，保留3位有效数字print(res2) # 0.142print(res.quantize(Decimal('.1'))) # 0.1print(res.quantize(Decimal('.01'))) # 0.142print(res.quantize(Decimal('1.'))) # 0 你需要注意：保留有效数字 &amp;&amp; 保留小数点后几位 的区别！！！ | &gt;&gt;&gt;&gt; ===================== 需要注意的是 ====================== &lt;&lt;&lt;&lt; | 精度提升的同时，必然带来的是性能的损失。 在对数据要求特别精确的场合（例如财务结算），这些性能的损失是值得的。但是如果是大规模的科学计算，就需要考虑运行效率了。毕竟原生的 float 比 Decimal 对象肯定是要快很多的。 想要更好、更准确、更深入的使用 decimal 模块，你需要了解本章节内容，或者移步至 &gt;&gt;&gt;&gt; Python decimal 模块官方说明文档 &lt;&lt;&lt;&lt; 进行学习。 You Need Know MorePython 提供了 decimal 模块，用于支持正确舍入的十进制浮点算术。它具有如下特点： [1] &gt;&gt;&gt;&gt; Decimal 数字的表示是完全精确的 相较于浮点数据类型，像 1.1 &amp;&amp; 1.2 这样的数字在二进制浮点中是没有精确表示的，最终用户通常不希望 1.1 + 2.2 如二进制浮点数表示那样被显示为 3.3000000000000003。 [2] &gt;&gt;&gt;&gt; 数字表示的精确性会延续到算术类操作中 对于 decimal 浮点数，0.1 + 0.1 + 0.1 - 0.3 会精确地等于零。 而对于二进制浮点数，结果则为 5.5511151231257827e-017 。 虽然接近于零，但其中的误差将妨碍可靠的相等性检验，并且误差还会不断累积。 因此，decimal 更适合具有严格相等不变性要求的会计类应用。 [3] &gt;&gt;&gt;&gt; decimal 模块包含有效位的概念 Decimal 数字在计算后，会保留尾随零以表示有效位。例如：1.30 + 1.20 = 2.50 &amp;&amp; 1.3 * 1.2 = 1.56 &amp;&amp; 1.30 * 1.20 = 1.5600 等。 [4] &gt;&gt;&gt;&gt; decimal 模块支持用户自定义精度（默认是 28 位） 1234567from decimal import Decimal, getcontextprint(Decimal(1) / Decimal(7))# 0.1428571428571428571428571429getcontext().prec = 6print(Decimal(1) / Decimal(7))# 0.142857 [5] &gt;&gt;&gt;&gt; decimal 模块旨在支持“无偏差，精确无舍入的十进制算术（有时称为定点数算术）和有舍入的浮点数算术” decimal 模块的设计以三个概念为中心：decimal 数值（Decimal），算术上下文（Context），以及 信号。 decimal 数值（Decimal）decimal 数值是不可变对象，它由符号，系数和指数位组成。并且为了保持有效位，系数位不会截去末尾零。 [1] &gt;&gt;&gt;&gt; 构建 Decimal 实例 前面我们提到过，可以基于整数、字符串、浮点数或元组构造 Decimal 实例。decimal 数值中还可以是一些特殊值，例如 Infinity ，-Infinity 和 NaN，还区分 -0 和 +0。 来看一些构建实例 &gt;&gt;&gt;&gt; 1234567891011121314151617181920from decimal import Decimalprint(Decimal(10))# 10print(Decimal('3.14'))# 3.14print(Decimal(3.14))# 3.140000000000000124344978758017532527446746826171875print(Decimal((0, (3, 1, 4), -2)))# 3.14print(Decimal(str(2.0 ** 0.5)))# 1.4142135623730951print(Decimal(2) ** Decimal('0.5'))# 1.414213562373095048801688724print(Decimal('NaN'))# NaNprint(Decimal('-Infinity'))# -Infinityprint(Decimal('-0'))# -0 如果使用 tuple 进行构建，它应该有三个组件：一个符号（ 0 表示正数或 1 表示负数），一个数字的 tuple 和整数指数。 例如：Decimal((0, (1, 4, 1, 4), -3)) 返回 Decimal(‘1.414’)。 [2] &gt;&gt;&gt;&gt; decimal 模块可以和 Python 其它部分很好交互。 直接来看实例： 12345678910111213141516171819202122232425&gt;&gt;&gt; data = list(map(Decimal, '1.34 1.87 3.45 2.35 1.00 0.03 9.25'.split()))&gt;&gt;&gt; max(data)Decimal('9.25')&gt;&gt;&gt; min(data)Decimal('0.03')&gt;&gt;&gt; sorted(data)[Decimal('0.03'), Decimal('1.00'), Decimal('1.34'), Decimal('1.87'), Decimal('2.35'), Decimal('3.45'), Decimal('9.25')]&gt;&gt;&gt; sum(data)Decimal('19.29')&gt;&gt;&gt; a,b,c = data[:3]&gt;&gt;&gt; str(a)'1.34'&gt;&gt;&gt; float(a)1.34&gt;&gt;&gt; round(a, 1)Decimal('1.3')&gt;&gt;&gt; int(a)1&gt;&gt;&gt; a * 5Decimal('6.70')&gt;&gt;&gt; a * bDecimal('2.5058')&gt;&gt;&gt; c % aDecimal('0.77') Decimal 也可以使用一些数学函数： 123456789&gt;&gt;&gt; getcontext().prec = 28&gt;&gt;&gt; Decimal(2).sqrt()Decimal('1.414213562373095048801688724')&gt;&gt;&gt; Decimal(1).exp()Decimal('2.718281828459045235360287471')&gt;&gt;&gt; Decimal('10').ln()Decimal('2.302585092994045684017991455')&gt;&gt;&gt; Decimal('10').log10()Decimal('1') [3] &gt;&gt;&gt;&gt; 构建的 Decimal 的重要性仅由输入的数值决定， 上下文精度和舍入仅在算术运算期间发挥作用。 例如，上面我们通过 getcontext().prec = 6 这样的语句设置过精度，这就是通过算术上下文实现的。它无法影响一个新创建的 Decimal 对象的存储位数。 这里不理解也没关系，你可以通过先学习下面的【算术上下文（Context）】之后，再来进行理解学习。 12345678910111213from decimal import Decimal, getcontextgetcontext().prec = 6# 仅由输出数值的位数决定，上下文精度未发挥作用：print(Decimal('3.0'))# 3.0print(Decimal('3.1415926535'))# 3.1415926535# 上下文精度在运算时发挥作用：print(Decimal('3.1415926535') + Decimal('2.7182818285'))# 5.85987 后面你还会学到 getcontext().rounding = ROUND_UP 这样的语句，来设置运算时的舍入规则。它也仅在运算时生效。 1234567891011from decimal import Decimal, getcontextgetcontext().prec = 6getcontext().rounding = ROUND_UPprint(Decimal('3.1415926535'))# 3.1415926535# 舍入规则在运算时发挥作用：print(Decimal('3.1415926535') + Decimal('2.7182818285'))# 5.85988 算术上下文（Context）算术上下文是指算术运算所在的环境 &gt;&gt;&gt;&gt; 用于管理 decimal 模块算术运算期间的，精度、舍入规则、指数的限制范围，以及确定将哪些信号视为异常。 [1] &gt;&gt;&gt;&gt; getcontext() 函数 你可以通过 getcontext() 来查看当前的上下文环境，并在必要时为精度、舍入或启用的陷阱设置新值: 1234567891011121314# 使用前，记得导入from decimal import getcontext# 可以看到：是一个名为 `Context` 的上下文环境对象。# 其中，`prec` 属性表示：精度# `rounding` 属性表示：舍入规则# `Emin` &amp;&amp; `Emax` 属性分别表示：指数最小值和指数最大值# `flags` &amp;&amp; `traps` 属性分别表示：信号中的标志和陷阱启动器（不用深究，说明见下文【信号】章节）print(getcontext())# Context(prec=6, rounding=ROUND_UP, Emin=-999999, Emax=999999, capitals=1, clamp=0, flags=[], traps=[InvalidOperation, DivisionByZero, Overflow])getcontext().prec = 7 # Set a new precisiongetcontext().rounding=ROUND_DOWN # Set a new rounding 其中，上下文中支持的舍入（rounding）规则选项全集以及其解释如下： 123456789# 这里不用深究其参数含义，后续会通过实例进行说明ROUND_CEILING (towards Infinity),ROUND_DOWN (towards zero),ROUND_FLOOR (towards -Infinity),ROUND_HALF_DOWN (to nearest with ties going towards zero),ROUND_HALF_EVEN (to nearest with ties going to nearest even integer),ROUND_HALF_UP (to nearest with ties going away from zero), orROUND_UP (away from zero).ROUND_05UP (away from zero if last digit after rounding towards zero would have been 0 or 5; otherwise towards zero) 如上所示，getcontext() 函数访问当前上下文并允许更改设置，大多数程序仅在程序开始时调整当前上下文一次，这种方法满足大多数应用程序的需求。 [2] &gt;&gt;&gt;&gt; setcontext() 函数 &amp;&amp; Context() 构建函数 而对于更复杂的任务，例如你需要创建一个备用的上下文环境以便在某些情况下使用，你可以通过 Context() 构造函数创建一个备用的上下文，并且通过 setcontext() 函数来修改当前上下文。 Context 构造函数格式：decimal.Context(prec=None, rounding=None, Emin=None, Emax=None, capitals=None, clamp=None, flags=None, traps=None) 12345678910111213from decimal import Decimal, getcontext, setcontext, Context, ROUND_UPprint(getcontext())# Context(prec=28, rounding=ROUND_HALF_EVEN, Emin=-999999, Emax=999999, capitals=1, clamp=0, flags=[], traps=[InvalidOperation, DivisionByZero, Overflow])print(Decimal(1) / Decimal(7))# 0.1428571428571428571428571429myothercontext = Context(prec=40, rounding=ROUND_UP)setcontext(myothercontext)print(Decimal(1) / Decimal(7))# 0.1428571428571428571428571428571428571429print(getcontext())# Context(prec=40, rounding=ROUND_UP, Emin=-999999, Emax=999999, capitals=1, clamp=0, flags=[Inexact, Rounded], traps=[InvalidOperation, DivisionByZero, Overflow]) 并且，decimal 模块提供了两个现成的标准上下文 BasicContext 和 ExtendedContext。 decimal.BasicContext：精度设为 9；舍入设为 ROUND_HALF_UP；清除所有旗标；启用所有陷阱（视为异常），但 Inexact, Rounded 和 Subnormal 除外（由于启用了许多陷阱，此上下文适用于进行调试）。 decimal.ExtendedContext：精度设为 9；舍入设为 ROUND_HALF_EVEN；清除所有旗标；不启用任何陷阱（因此在计算期间不会引发异常）。由于禁用了陷阱，此上下文适用于希望结果值为 NaN 或 Infinity 而不是引发异常的应用。 这允许应用在出现当其他情况下会中止程序的条件时仍能完成运行。 12345678910111213141516171819202122from decimal import Decimal, getcontext, setcontext, ExtendedContext, BasicContextprint(getcontext())# Context(prec=28, rounding=ROUND_HALF_EVEN, Emin=-999999, Emax=999999, capitals=1, clamp=0, flags=[], traps=[InvalidOperation, DivisionByZero, Overflow])print(Decimal(1) / Decimal(7))# 0.1428571428571428571428571429print(ExtendedContext)# Context(prec=9, rounding=ROUND_HALF_EVEN, Emin=-999999, Emax=999999, capitals=1, clamp=0, flags=[], traps=[])setcontext(ExtendedContext)print(Decimal(1) / Decimal(7))# 0.142857143print(Decimal(23) / Decimal(0))# Infinityprint(BasicContext)Context(prec=9, rounding=ROUND_HALF_UP, Emin=-999999, Emax=999999, capitals=1, clamp=0, flags=[], traps=[Clamped, InvalidOperation, DivisionByZero, Overflow, Underflow])setcontext(BasicContext)print(Decimal(23) / Decimal(0))# DivisionByZero Traceback (most recent call last)# ---&gt; print(Decimal(23) / Decimal(0))# DivisionByZero: [&lt;class 'decimal.DivisionByZero'&gt;] 信号信号是 &gt;&gt;&gt;&gt; 在算术过程中可能出现的 异常条件组。并且根据应用程序的需要，信号可能会被忽略，被视为信息，或被视为异常。 decimal 模块中的信号有：Clamped、InvalidOperation、DivisionByZero、Inexact、Rounded、Subnormal、Overflow、Underflow 以及 FloatOperation。 对于每个信号，都有一个标志（flag）和一个陷阱启动器（trap）。遇到信号时，其标志会被设置为 1 ；然后，如果相应陷阱启用器也设置为 1，则引发异常。需要注意的是，标志是粘性的，因此用户需要在监控计算之前重置它们。 [1] &gt;&gt;&gt;&gt; 如何查看检测到的信号标志，以及启动相应陷阱： 并且，信号的标志（flags）以及陷阱启动器（trips）设置，也是由算术上下文进行管理的，分别对应 Context 中的 flags &amp;&amp; traps 字段。 例如，在标准上下文 ExtendedContext 中，使用上下文的 traps 字段中的字典设置单个陷阱 DivisionByZero： 123456789101112131415161718192021222324from decimal import Decimal, getcontext, setcontext, DivisionByZerosetcontext(ExtendedContext)print(getcontext())# Context(prec=9, rounding=ROUND_HALF_EVEN, Emin=-999999, Emax=999999, capitals=1, clamp=0, flags=[], traps=[])# 产生一个 `DivisionByZero` 信号，由于上下文中未启用陷阱故不引发异常，结果返回 `Infinity` ：print(Decimal(1) / Decimal(0))# Infinity# 检测到 `DivisionByZero` 信号，上下文中其标志被设置为 1（True），可见结果中 `flags=[DivisionByZero]`：print(getcontext())# Context(prec=9, rounding=ROUND_HALF_EVEN, Emin=-999999, Emax=999999, capitals=1, clamp=0, flags=[DivisionByZero], traps=[])# 设置 `DivisionByZero` 陷阱启动器为 1，即开启陷阱，可见结果中 `traps=[DivisionByZero]`：getcontext().traps[DivisionByZero] = 1print(getcontext())# Context(prec=9, rounding=ROUND_HALF_EVEN, Emin=-999999, Emax=999999, capitals=1, clamp=0, flags=[DivisionByZero], traps=[DivisionByZero])# 设置 `DivisionByZero` 陷阱启动器为 1 之后，当检测到 `DivisionByZero` 信号时，会产生异常：print(Decimal(1) / Decimal(0))# DivisionByZero Traceback (most recent call last)# ---&gt; print(Decimal(1) / Decimal(0))# DivisionByZero: [&lt;class 'decimal.DivisionByZero'&gt;] 另外，设置 FloatOperation 陷阱之后，如果其信号被捕获，Decimal 构造函数中的小数和浮点数的意外混合或排序比较会引发异常： 12345678910111213141516from decimal import Decimal, getcontext, FloatOperationc = getcontext()c.traps[FloatOperation] = Trueprint(c)Decimal(3.14)# Traceback (most recent call last):# decimal.FloatOperation: [&lt;class 'decimal.FloatOperation'&gt;]Decimal('3.5') &lt; 3.7# Traceback (most recent call last):# decimal.FloatOperation: [&lt;class 'decimal.FloatOperation'&gt;]Decimal('3.5') == 3.5# True [2] &gt;&gt;&gt;&gt; 信号粘性标志清除 我们知道，上下文环境可以监视到计算期间遇到的异常情况的信号标志，由于标志的粘性，其会保持设置直到明确清除。你可以使用 clear_flags() 方法清除每组受监控计算之前的标志: 123456789101112131415from decimal import Decimal, getcontext, ExtendedContextprint(getcontext())# Context(prec=28, rounding=ROUND_HALF_EVEN, Emin=-999999, Emax=999999, capitals=1, clamp=0, flags=[], traps=[InvalidOperation, DivisionByZero, Overflow])print(Decimal(355) / Decimal(113))# 3.141592920353982300884955752# 可见，`flags` 条目中显示对 `Pi` 的有理逼近被舍入（Inexact，超出上下文精度的数字被抛弃），并且结果是不精确的（Rounded，一些丢弃的数字不为零）。print(getcontext())# Context(prec=28, rounding=ROUND_HALF_EVEN, Emin=-999999, Emax=999999, capitals=1, clamp=0, flags=[Inexact, Rounded], traps=[InvalidOperation, DivisionByZero, Overflow])getcontext().clear_flags()print(getcontext())# Context(prec=28, rounding=ROUND_HALF_EVEN, Emin=-999999, Emax=999999, capitals=1, clamp=0, flags=[], traps=[InvalidOperation, DivisionByZero, Overflow]) Python 浮点数和十进制模块测试这一小节，我们通过具体的代码来比较浮点数（float）和十进制（decimal）模块的差异： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146from decimal import Decimal, getcontextfrom decimal import ROUND_UP, ROUND_DOWN, ROUND_CEILING, ROUND_FLOOR, ROUND_HALF_UP, ROUND_HALF_DOWN, ROUND_HALF_EVEN, ROUND_05UPx = 4.20y = 2.10a = 1.10b = 2.30def float_calculate(): sum = x + y print(sum) # 6.300000000000001 if sum == 6.30: print(&quot;Floating-point number addition is a precise calculations.&quot;) else: print(&quot;Floating-point number addition is a Inexact operations.&quot;) sub = a - b print(sub) # -1.1999999999999997 if sub == -1.2: print(&quot;Floating-point number subtraction is a precise calculations.&quot;) else: print(&quot;Floating-point number subtraction is a Inexact operations.&quot;) mul = x * a print(mul) # 4.620000000000001 if mul == 4.62: print( &quot;Floating-point number multiplication is a precise calculations.&quot;) else: print(&quot;Floating-point number multiplication is a Inexact operations.&quot;) div = x / 0.7 print(div) # 6.000000000000001 if div == 6.0: print(&quot;Floating-point number division is a precise calculations.&quot;) else: print(&quot;Floating-point number division is a Inexact operations.&quot;) e_round = round(195.00 / 24, 2) print(e_round) # 8.12 if e_round == 8.13: print(&quot;Floating-point number rounding is a precise operations.&quot;) else: print(&quot;Floating-point number rounding is a Inexact operations.&quot;)def decimal_calculate(): getcontext().prec = 3 # 设置 3 位有效数字 sum = Decimal(str(x)) + Decimal(str(y)) print(type(sum), sum) # &lt;class 'decimal.Decimal'&gt; 6.3 e_result = Decimal(&quot;195.00&quot;) / Decimal(&quot;24&quot;) print(e_result) # 8.12def float_info(): # a.bcd &gt;&gt;&gt;&gt; 精确到小数点后 2 位 i = 1.115 # 在计算机中实际上是: 1.1149999999999999911182 四舍五入：1.11 j = 0.125 # d 后面没有数据，且 c 为偶数，那么不进位，保留 c 四舍五入：0.12 k = 0.1251 # d 后面有数据，c --&gt; (c + 1) 四舍五入：0.13 m = 0.375 # d 后面没有数据，且 c 为奇数，那么进位，c --&gt; (c + 1) 四舍五入：0.38 print(&quot;round(1.115) &gt;&gt;&gt;&gt;&quot;, round(i, 2)) print(&quot;round(0.125) &gt;&gt;&gt;&gt;&quot;, round(j, 2)) print(&quot;round(0.1251) &gt;&gt;&gt;&gt;&quot;, round(k, 2)) print(&quot;round(0.375) &gt;&gt;&gt;&gt;&quot;, round(m, 2))def decimal_info(): # a.bcd &gt;&gt;&gt;&gt; 精确到小数点后 2 位 i = 1.115 # 在计算机中实际上是: 1.1149999999999999911182 四舍五入：1.11 j = 0.125 # d 后面没有数据，且 c 为偶数，那么不进位，保留 c 四舍五入：0.12 k = 0.1251 # d 后面有数据，c --&gt; (c + 1) 四舍五入：0.13 m = 0.375 # d 后面没有数据，且 c 为奇数，那么进位，c --&gt; (c + 1) 四舍五入：0.38 print(&quot;浮点数数据不精确 &gt;&gt;&gt;&quot;, Decimal(i)) print(&quot;浮点数数据精确 &gt;&gt;&gt;&quot;, Decimal(i)) print(&quot;默认上下文环境 &gt;&gt;&gt;&quot;, getcontext()) # 默认四舍五入 &gt;&gt;&gt;&gt; 规则：四舍六入五成双，奇进偶舍 print('传入的是浮点型默认方式四舍五入：', Decimal(i).quantize(Decimal('0.00'))) # 1.11 print('传入的是浮点型默认方式四舍五入：', Decimal(j).quantize(Decimal('0.00'))) # 0.12 print('传入的是浮点型默认方式四舍五入：', Decimal(k).quantize(Decimal('0.00'))) # 0.13 print('传入的是浮点型默认方式四舍五入：', Decimal(m).quantize(Decimal('0.00'))) # 0.38 print('传入的是字符串默认方式四舍五入：', Decimal(str(i)).quantize(Decimal('0.00'))) # 1.12 # 真实四舍五入 &gt;&gt;&gt;&gt; 规则：四舍五入 print('传入的是字符串真实四舍五入：', Decimal(str(i)).quantize(Decimal('0.00'), ROUND_HALF_UP)) # 1.12 print('传入的是字符串真实四舍五入：', Decimal(str(j)).quantize(Decimal('0.00'), ROUND_HALF_UP)) # 0.13 print('传入的是字符串真实四舍五入：', Decimal(str(k)).quantize(Decimal('0.00'), ROUND_HALF_UP)) # 0.13 print('传入的是字符串真实四舍五入：', Decimal(str(m)).quantize(Decimal('0.00'), ROUND_HALF_UP)) # 0.38 print(&quot;传入的是字符串向上取值：&quot;, Decimal(&quot;0.121&quot;).quantize(Decimal(&quot;0.00&quot;), ROUND_UP)) # 0.13 print(&quot;传入的是字符串向下取值：&quot;, Decimal(&quot;0.129&quot;).quantize(Decimal(&quot;0.00&quot;), ROUND_DOWN)) # 0.12 print(&quot;传入的是字符串向上真实四舍五入：&quot;, Decimal(&quot;0.125&quot;).quantize(Decimal(&quot;0.00&quot;), ROUND_HALF_UP)) # 最后一位是 5 向上入：0.13 print(&quot;传入的是字符串向下四舍五入：&quot;, Decimal(&quot;0.125&quot;).quantize(Decimal(&quot;0.00&quot;), ROUND_HALF_DOWN)) # 最后一位是 5 向下舍：0.12 print('传入的是字符串默认方式四舍五入：', Decimal('0.125').quantize( Decimal('0.00'), ROUND_HALF_EVEN)) # 默认四舍五入：0.12（quantize 默认设置） print('传入的是字符串默认方式四舍五入：', Decimal('0.375').quantize( Decimal('0.00'), ROUND_HALF_EVEN)) # 默认四舍五入：0.38（quantize 默认设置） print('传入的是字符串精确位数字为 5 入：', Decimal('5.351').quantize( Decimal('0.00'), ROUND_05UP)) # 精确的最后一位为 0 或者 5 向上入，否者向下舍：5.36 print('传入的是字符串精确位数字为 0 入：', Decimal('5.301').quantize( Decimal('0.00'), ROUND_05UP)) # 精确的最后一位为 0 或者 5 向上入，否者向下舍：5.31 print('传入的是字符串精确位数字非 0 和 5 舍：', Decimal('5.399').quantize( Decimal('0.00'), ROUND_05UP)) # 精确的最后一位为 0 或者 5 向上入，否者向下舍：5.39 print('传入的是字符串正数时与 ROUND_UP 一致：', Decimal('5.391').quantize(Decimal('0.00'), ROUND_CEILING)) # 5.40 print('传入的是字符串正数时与 ROUND_DOWN一致：', Decimal('5.399').quantize(Decimal('0.00'), ROUND_FLOOR)) # 5.39 print('传入的是字符串负数时与 ROUND_DOWN 一致：', Decimal('-5.399').quantize(Decimal('0.00'), ROUND_CEILING)) # -5.39 趋近于正无穷 print('传入的是字符串负数时与 ROUND_UP 一致：', Decimal('-5.399').quantize(Decimal('0.00'), ROUND_FLOOR)) # -5.40 趋近于负无穷 print('传入的是字符串与正负无关，最后一位始终进：', Decimal('-5.399').quantize(Decimal('0.00'), ROUND_UP)) # -5.40if __name__ == &quot;__main__&quot;: # float_calculate() # decimal_calculate() # float_info() decimal_info()","link":"/2018/01/08/python-fu-dian-shu-jing-que-yun-suan-jie-jue-fang-an/"},{"title":"Python 简介与开发环境搭建","text":"Foreword 不管是由于工作需要必须掌握 Python，或是抱着极其浓厚的兴趣想要学习 Python 程序设计语言，亦或是不甘落于人后（身边越来越多的人开始使用 Python）…… 不要困惑，我们已经站在 Python 花园秘境的入口，即将一睹大门背后绮丽的风景。 那句话怎么说来着？人生苦短，快来使用 Python 吧 …… 这一章节我们通过对以下两部分内容的解读，正式开启 Python 的学习之旅的第一站（叩门）： Python Introduction Python Development Envs Setup Python Introduction这一小节我们来简要介绍 Python 的相关背景知识，你可以将其作为 Python 学习入门需知。 注意：这里的相关介绍没必要深究，在后续正式进入 Python 学习生态环境之后，你会越来越深入理解其中的内容。 Python 发展历史Python 的创始人为荷兰人 Guido van Rossum（吉多·范罗苏姆）。1989 年圣诞节期间，吉多·范罗苏姆为了在阿姆斯特丹打发时间， 决心开发一个新的解释型脚本程序。之所以选中 Python（蟒语言）作为程序的名字，是因为他是一个叫 Monty Python 喜剧团的忠实粉丝。 大佬不愧为大佬啊….. 1991年，第一个 Python 解释器诞生，它是用 C 语言实现的，并能够调用 C 语言的库文件。 Python 2.0 于 2000 年 10 月发布，增加了完整的垃圾回收，并且支持 Unicode。 Python 3.0 于 2008 年 12 月发布，此版不完全兼容之前的 Python 源代码。不过，很多新特性也被移植到旧版本。 2019 年 12 月份世界编程语言排行榜中，Python 排名第三，成为了仅次于 Java 和 C 语言的黑马。 Python 能干什么？ 基础编程开发 Web 开发 网络爬虫 自动化运维 / 运维开发 自动化测试 / 测试开发 游戏开发 科学计算 大数据 / 数据分析 / 数据挖掘 人工智能 / 机器学习 &amp; 深度学习 …… 看到这里，你是不是了解了为什么 Python 经常被和 大数据、深度学习、人工智能 捆绑到一起作为 AI 关键词的原因了。 事实上，像 Google，Facebook，Yahoo，YouTube 以及著名的开源云计算平台 openstack，还有国内的豆瓣都是用 Python 写的 !!! Python 究竟是什么？相较于其它高级编程语言，Python 是一个高层次的 解释型的面向对象的交互式脚本语言。 Python 是一种解释型语言： 这意味着开发过程中没有了编译这个环节，类似于 PHP 和 Perl 语言。 Python 是一种交互式语言：这意味着，你可以在一个 Python 提示符（Shell）环境中，直接互动执行你编写的程序。 Python 是一种面向对象语言：这意味着 Python 支持面向对象的风格或代码封装于对象的编程技术。 Python 是一种初学者的语言：Python 对初级程序员而言，作为学习编程的入门语言再合适不过。它支持广泛的应用程序开发，从简单的文字处理到 WWW 浏览器再到游戏。 Python 特点相较于其它高级程序设计语言，Python 有如下特点： 易于阅读、学习：Python有相对较少的关键字，和明确定义的语法，代码结构清晰易读，学习起来更加简单。 互动模式：互动模式的支持，你可以从终端输入执行代码并获得结果的语言，互动的测试和调试代码片断。 跨平台：作为开源、免费的解释型语言，Python 已经被移植（跨平台）到许多平台。 广泛的类库支持：Python 的最大的优势之一是丰富的类库支持，在 UNIX，Windows 和Macintosh 兼容很好。 可扩展：如果你需要一段运行很快的关键代码，或者是想要编写一些不愿开放的算法，你可以使用 C 或 C++ 完成那部分程序，然后从你的 Python 程序中调用。 可嵌入: 你可以将 Python 嵌入到C/C++程序，让你的程序的用户获得”脚本化”的能力。 数据库：Python 提供所有主要的商业数据库的接口。 GUI 编程：Python 支持 GUI 可以创建和移植到许多系统调用。 Python 有缺点么 ？？？一味鼓吹 Python 没有缺陷是伪命题，任何编程语言都有缺点，Python 也不例外。 第一个缺点：运行速度慢 和 C 程序相比非常慢，因为 Python 是解释型语言，代码在被执行时会一行一行地翻译成 CPU 能理解的机器码，这个翻译过程非常耗时，所以很慢。而 C 程序是运行前直接被编译成 CPU 能执行的机器码，所以非常快。 但是大量的应用程序不需要这么快的运行速度，因为用户根本感觉不出来。例如开发一个网络应用程序，C 程序的运行时间需要 0.001 秒，而 Python 程序的运行时间需要 0.1 秒，慢了 100 倍，但由于网络更慢，需要等待 1 秒，你想，用户能感觉到 1.001 秒和 1.1 秒的区别吗？这就好比 F1 赛车和普通的出租车在北京三环路上行驶的道理一样，虽然 F1 赛车理论时速高达 400 公里，但由于三环路堵车的时速只有 20 公里，因此，作为乘客，你感觉的时速永远是 20 公里。 甚至我们可以将需要快速执行的 Python 代码段转成 C 内置于 Python 中以提升性能。 第二个缺点：代码不能加密 由于 Python 的开源、免费特性，如果要发布你的 Python 程序，实际上就是发布源代码，这一点跟 C 语言不同，C语言不用发布源代码，只需要把编译后的机器码（也就是你在 Windows 上常见的 xxx.exe 文件）发布出去。要从机器码反推出 C 代码是不可能的，所以，凡是编译型的语言，都没有这个问题，而解释型的语言，则必须把源码发布出去。 当然，想要加密 Python 代码，也并非无解，网络上也给出了一些 Python 加密方法用以提高其源码保密性。 然而，开源是软件产业的大趋势，传统程序员需要转变观念。 Python 彩蛋最后一部分，我们给出一个 Python 彩蛋：“Python 之歌”，它概要地解读了 Python 语言设计的特点。在后续我们介绍完 Python 开发环境搭建，你可以执行 Python 指令之后，重新返回到这一部分“敲开”彩蛋： 1234567891011121314151617181920212223242526# Python 交互式解释器环境下执行如下命令：import this# 可以获取到如下信息：The Zen of Python, by Tim PetersBeautiful is better than ugly.Explicit is better than implicit.Simple is better than complex.Complex is better than complicated.Flat is better than nested.Sparse is better than dense.Readability counts.Special cases aren't special enough to break the rules.Although practicality beats purity.Errors should never pass silently.Unless explicitly silenced.In the face of ambiguity, refuse the temptation to guess.There should be one-- and preferably only one --obvious way to do it.Although that way may not be obvious at first unless you're Dutch.Now is better than never.Although never is often better than *right* now.If the implementation is hard to explain, it's a bad idea.If the implementation is easy to explain, it may be a good idea.Namespaces are one honking great idea -- let's do more of those! Python Development Envs Setup工欲善其事，必先利其器。这一小节将向大家介绍如何搭建本地 Python 语言学习、开发环境。 前面我已经提到过 Python 具有良好的移植性（一次编写，多次运行），可应用于多平台：Windows、Linux 和 Mac OS X 等等，Python 官网 确实也提供了不同平台下的 Python 安装包以提供下载、安装。 安装后，你会得到一个 Python 解释器（负责解释运行 Python 程序），一个 命令行交互环境，还有一个简单的 集成开发环境（IDLE）。 下面我们正式开始本地 Python 语言开发、学习环境的搭建 &gt;&gt;&gt;&gt; 环境检查在开始正式安装之前，你可以通过在 终端窗口（Terminal）输入 python -V（或 python --version） 或者 python 命令来查看本地是否已经安装 Python 以及 Python 的安装版本信息。 如果输出如下信息表示当前系统中已安装有 Python，且当前系统中安装的 Python 版本为 3.5.0： 1234567891011121314# 查看系统中的 Python 版本信息：C:\\Users\\xxx &gt;python --versionPython 3.6.5# 进入 Python 命令行交互环境：C:\\Users\\xxx &gt;pythonPython 3.5.0 (default, Dec 1 2018, 17:15:02) [GCC 4.8.5 20150623 (Red Hat 4.8.5-28)] on linuxType &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.&gt;&gt;&gt;# 命令 `python -V（--version）` 会输出 Python 的版本信息；# 命令 `python` 会进入 Python 的命令行交互模式。# 你可以通过在输入提示符 `&gt;&gt;&gt;` 后面输入 `exit()` 可退出以上 Python 命令行交互模式。 目前 Python 有两个主要版本，一个是 2.x 版，一个是 3.x 版（2.x 的重大升级版），这两个版本是不兼容的，初学者一定要注意 Python 学习版本的选择。 关于 Python 安装版本选择 &gt;&gt;&gt; 个人建议选择 Python3.X，越来越多的开发者转战到 Python3，已成为目前主流的使用版本。如果当前系统已检查到 Python 安装版本 且 版本信息在 3.5x 以上（含 3.5x，稳定，较新），你可以直接跳至小节 【2.5 Python 运行方式】 开始学习。 如果当前系统中已安装 Python 版本不符合你的期望（不要卸载！！！可能会引发某些系统应用或者其它应用程序故障），或者 系统中没有查询到任何已安装 Python 信息，接下文 ↓↓↓↓↓ 注意在一个操作系统中，多个不同的 Python 版本是可以共存的！！！前提是你需要注意新安装的 Python 环境对原有环境的影响，严格遵循下文安装过程不会对系统原生环境产生影响，你可以放心安装。 这也就意味着：你可以使用下面的方法在系统中安装多个不同的、独立的 Python 版本（Python3.5 &amp;&amp; Python3.10 &amp;&amp; Python2.7 …）而不影响系统原生环境。 Python DownloadPython 最新源码，二进制文档，以及相关新闻资讯等可以在 Python 的官网查看到： Python 官网 &gt;&gt;&gt;&gt; [https://www.python.org/] ，以下给出各个平台 Python 安装包的下载地址： 并且，你可以在以下链接中下载 Python 的说明文档，包含 HTML、PDF 和 PostScript 等多种格式的文档。 Python 文档下载地址 &gt;&gt;&gt;&gt; [https://www.python.org/doc/] 。 Python Setup我们知道 Python 已经被移植在许多平台上（使它能够工作在不同平台上），类似于 Java，“一次编写，多次运行”。而 Python 的具体安装步骤视你所使用的操作系统（平台）和安装方式而异。 安装 Python 的 两种主流方式 ↓↓↓↓↓↓↓↓↓ 我们既可以选择使用 1）源码编译 的方式进行安装，同时也可以下载使用已经编译并且打包好的 2）二进制版本安装包 进行安装。 源码编译是万能的安装方式 &gt;&gt;&gt; 如果你选择的平台（例如：Unix/Linux）的二进制版本不可用，你可以使用手动编译源代码的方式进行安装。编译源代码的方式，功能上有更多的选择性， 为 Python 安装提供了更多的灵活性。 以下给出不同平台（Unix/Linux、Windows）上安装 Python3.X 的推荐方法： Source Code For Unix &amp; Linux Platform Binary Package For Windows Platform For Unix/Linux Platform由于 Unix &amp; Linux 平台一般自带相应版本的 Python（Python2/Python3），如果你选择在 Unix &amp; Linux 平台下学习 Python，那么你可以直接跳过后续教程（你已经可以开始使用 Python 了！）。 当然，有些同学就是想尝试一下 Python 的编译过程（或者 系统原生 Python 版本不是你学习使用所需要版本），下面给出在 Unix &amp; Linux 平台上安装 Python 的通用步骤: 源码编译安装通用步骤（先了解通用过程，你可以根据后续演示过程进行实践） &gt;&gt;&gt; 打开 WEB 浏览器访问 &gt;&gt;&gt;&gt; https://www.python.org/downloads/source/； 选择适用于 Unix/Linux 的源码压缩包； cd 到安装目录：/usr/local，下载及解压压缩包； 如果你需要自定义一些选项，可以修改 Modules/Setup； 执行 ./configure （配置）； make make install 执行以上操作后，Python 相关的可执行文件默认会被存放到：/usr/local/bin 中，库文件默认会被安装到：/usr/local/lib/pythonXX，XX 为你使用的 Python 的版本号。 这样的安装显得有点杂乱（安装文件存放的到处都是）…… 来认识一下：参数 configure --prefix=/，它的作用是 –&gt; 编译的时候用来指定程序存放路径。 |&gt;&gt;&gt;=============== ↓↓↓↓↓ prefix 选项用于配置安装的路径 ↓↓↓↓↓ ================| 如果不配置该选项，安装后可执行文件默认放在 /usr/local/bin，库文件默认放在 /usr/local/lib，配置文件默认放在 /usr/local/etc，其它的资源文件放在 /usr/local/share 如果配置 prefix，如：./configure --prefix=/usr/local/test，可以把所有的资源文件（可执行文件、库文件、配置文件等）放在 /usr/local/test 的路径。 了解之后，下面正式来看 Unix/Linux 平台下源码编译安装过程 &gt;&gt;&gt;&gt; Begin to Setup –&gt; 以 “Python-3.5.0 安装” 为样例演示上述安装过程（Python2.X 类似）： [1] &gt;&gt;&gt;&gt; 准备编译环境（系统环境中可能缺失必要编译环境，导致遇到各种问题，比如：wget 无法下载 https 链接文件，缺少了 zlib 的解压缩类库等） 12345# Centos[root@node1 ~]# yum install wget zlib-devel bzip2-devel openssl-devel ncurses-devel# Ubuntu[root@node1 ~]# apt-get install zlib* [2] &gt;&gt;&gt;&gt; 下载及解压 Python3.5.0 源代码包 123456789101112# 选择安装目录，这里是 '/usr/local/' ：[root@node1 ~]# cd /usr/local/# 通过相应 Python 版本安装包链接，进行下载：[root@node1 ~]# wget -c https://www.python.org/ftp/python/3.5.0/Python-3.5.0.tar.xz# 下载完成后进行减压：[root@node1 ~]# tar Jxvf Python-3.5.0.tar.xz# 减压后进入到相应目录，可以看到一个 README 文档。说明了如何进行安装：[root@node1 ~]# cd Python-3.5.0# 查看安装方法：[root@node1 Python-3.5.0]# cat README [3] &gt;&gt;&gt;&gt; 编译安装 12345678910111213# 配置以及编译（编译后你会在目录 [/usr/local] 下发现新产生的：[python3.5] 目录）[root@node1 Python-3.5.0]# ./configure --prefix=/usr/local/python3.5[root@node1 Python-3.5.0]# make &amp;&amp; make install### 日志信息如下：Ignoring indexes: https://pypi.python.org/simpleCollecting setuptoolsCollecting pipInstalling collected packages: setuptools, pipSuccessfully installed pip-7.1.2 setuptools-18.2# 同时提示成功安装 pip-7.12 与 setuptools！之后你就可以使用 pip 包管理器进行 Python 扩展包的安装了。# {关于 pip，当前你知道它是用来解决 Python 库包依赖的工具即可（一个扩展包的安装需要其它扩展包的安装支持）。} 至此 Unix &amp; Linux 平台下 Python 的安装已完成！请跳转至【Python 环境变量配置】章节完成最后的配置，即可开始 Unix &amp; Linux 平台下 Python 的学习之旅。 For Windows Platform以下是在 Windows 平台上安装 Python 的简单步骤： 二进制包安装 1）Python 2.X 版本安装： 以最新的 “Python 2.7 版本安装” 为样例： 打开 WEB 浏览器访问 https://www.python.org/downloads/windows/ ，查找合适的版本： 在下载列表中选择 Windows 平台安装包，包格式为：【python-XYZ.msi】 文件 ， XYZ 为你要安装的版本号。 要使用安装程序 【python-XYZ.msi】，Windows 系统必须支持 Microsoft Installer 2.0 安装工具。需要看看你的机器是否支持 MSI，Windows XP 和更高版本已经有 MSI，很多老机器也可以安装 MSI。 只要保存安装文件到本地计算机，然后运行它即可（安装时，根据提示 Next 即可）。注意！！！为防止对系统原生环境的影响，不要勾选有关自动添加环境变量的选项（默认不勾选），下文我们会手动设置 Python 环境变量。 2）Python 3.X 版本安装： 以 “Python 3.5.1 版本安装” 为样例： 打开 WEB 浏览器访问 https://www.python.org/ ，点击 Downloads，进入选择下载界面： 这里我选择的是：python3.5.1，会看到如下界面： 这里，我们需要安装的是 Windows 下的 Python 版本，所以在 Operating System 中可以选择对应的 Windows 版本。另外需要注意的是要根据系统位数选择相应位数（64-bit 或 32-bit） 的 Python 二进制版本进行安装，现在主流的都是 64-bit（x86-64）的。 其中，executable 表示可执行版本，需要安装后使用；embeddable 表示嵌入版，就是解压以后就可以直接使用的版本（免安装版本）；web-based 是基于网络的安装方式。 Begin to Setup –&gt; 1 –&gt; executable setup 这里，我们选择安装可执行版本（executable），可执行版安装比较简单，step by step，then ok。注意！！！为防止对系统原生环境的影响，不要勾选有关自动添加环境变量的选项（默认不勾选），随后我们会手动设置 Python 环境变量。 2 –&gt; embeddable setup embeddable 版本 Python 下载解压后即可（免安装），但一定需要配置环境变量。 Python 环境变量配置Python 默认安装完成后可能并不可以直接使用，即通过终端窗口输入 python -V 命令无法查看到 Python 版本信息（系统无法访问到安装好的 Python 可执行程序）如下，说明我们还需要为其配置系统环境变量。 123C:\\Users\\xxxxx&gt;python'python' 不是内部或外部命令，也不是可运行的程序或批处理文件。 为什么需要配置环境变量？我们想要运行的程序或可执行文件（python.exe）可能位于系统中的任意目录，而它们的路径很可能 不在操作系统提供的程序和可执行文件的搜索路径中。故，不可以直接执行这些程序或可执行文件（系统无法实现自动检索访问）。 而上述程序（可执行文件）路径可以添加到系统环境变量（PATH）中，这是由操作系统维护的一个命名的字符串。这个变量（$PATH）中包含了操作系统可直接访问的命令行解释器（Python 解释器）和其他程序的位置信息。 想要操作系统能够搜索到以及运行某些特定的程序或可执行文件，我们需要将其相应的路径添加到系统环境变量中（注意在添加时，要加上环境变量中原有的路径 :$PATH，否则会覆盖原始路径，导致系统出错）。 因此 &gt;&gt;&gt;&gt; 我们需要将 Python 相关的可执行文件（解释器）或程序路径添加到系统环境变量 $PATH 中。 查看当前操作系统环境变量（PATH）中已包含的可检索访问的程序或可执行文件信息： 12345# For WindowsC:\\Users\\xxxxx&gt; path# For Linux/Unix$ echo $PATH 下面我们来看不同平台下如何配置 Python 环境变量： For Unix/Linux Platform1）export PATH 方法（不推荐） 在 csh shell: 输入 setenv PATH &quot;$PATH:/usr/local/python&quot; 在 bash shell (Linux): 输入 export PATH=&quot;$PATH:/usr/local/python&quot; 在 sh 或者 ksh shell: 输入 PATH=&quot;$PATH:/usr/local/python&quot; 注意: 【/usr/local/python】 是 Python 的安装目录。 2）构建 Python 使用软链接（推荐） 以上面 “Python-3.5.0 安装 样例为示例： 12345678# 产生软连接时要注意系统中已存在的 Python 软链接（/usr/bin），防止原生 Python 调用被覆盖掉！！！# 查看系统中所有既存的 python 链接信息：$ ll /usr/bin | grep &quot;python*&quot;# 为了防止覆盖问题（尽量不要在系统 /usr/bin 下进行覆盖），你可以:[root@node1 Python-3.5.0]# ln -s /usr/local/python3.5/bin/python3.5 /usr/local/bin/python3.5# 这里由于【/usr/local/bin/】 路径已在 PATH 中，故可以将 Python 解释器路径放于 `/usr/local/bin` 下。 创建软链接后，在使用 Python 时，我们就可以在命令行下启动相应版本的 Python 了： 12345678# 启动系统原生环境：python# 启动 python2.7 环境：python2.7# 启动 python3.5 环境：python3.5 For Windows Platform在环境变量中添加 Python 目录： 1）cmd 方法（不推荐） 在命令提示框中(cmd) : 输入 1path=%path%;C:\\Python;C:\\Python\\Scripts; 注意: 这里 C:\\Python 是 Python 的实际安装目录。 2）GUI 方法（推荐） 右键点击”计算机”，然后点击”属性” 然后点击”高级系统设置” 选择 “系统变量” 窗口下面的 Path，双击即可 然后在 Path 行，添加 python 安装路径(C:\\Python) &gt;&gt;&gt;&gt; 行末添加!!!。 ps：记住，所有路径之间要用分号 “;” 隔开！ 检测是否配置成功？在 命令行（终端） 中输入： 1python 如果配置成功的话，会有 Python 版本信息输出，并进入 Python 命令行交互式环境（可交互执行 Python 语句）。如下： 1234Python 3.5.0 (default, Dec 1 2018, 17:15:02) [GCC 4.8.5 20150623 (Red Hat 4.8.5-28)] on linuxType &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.&gt;&gt;&gt; 至此，我们已经完成了 Python 本地环境的安装以及配置，下面我们给出一个 “Python Hello World” 来验证本地环境是否已经搭建成功： Python Hello World首先，在 命令行终端 中输入：python，会进入 Python 交互式解释器环境： 12345[root@node1 ~]# pythonPython 3.5.0 (default, Dec 1 2018, 17:15:02) [GCC 4.8.5 20150623 (Red Hat 4.8.5-28)] on linuxType &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.&gt;&gt;&gt; 然后在命令提示符 &gt;&gt;&gt; 之后输入命令： 1234# python 3 输入:print (&quot;Welcome to Python World&quot;)# python 2 输入:print &quot;Welcome to Python World&quot; 语句执行成功后会输出以下语句，表示 Python 本地环境搭建成功： 1Welcome to Python World 完美~~~至此，Python 环境的安装配置就完成了。 Python 运行方式Python 本地环境搭建成功之后，我们来看如何使用搭建好的 Python 环境编写、运行 Python 程序。 通常有以下三种方式： 交互式解释器你可以通过命令行窗口（Command Terminal）进入 Python 交互式解释器中开始编写 Python 代码。你可以在 Unix，DOS 或任何其他提供了命令行或者 shell 的系统进行 python 编码工作。如下： 123456# Unix/Linux &amp; Windows/DOS：Python 3.5.0 (default, Dec 1 2018, 17:15:02) [GCC 4.8.5 20150623 (Red Hat 4.8.5-28)] on linuxType &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.&gt;&gt;&gt;print (&quot;Hello Python World&quot;)Hello Python World Python 交互模式的代码是输入一行，解释执行一行。 退出交互式环境（exit()）： 12345# Unix/Linux &amp; Windows/DOS：Python 3.5.0 (default, Dec 1 2018, 17:15:02) [GCC 4.8.5 20150623 (Red Hat 4.8.5-28)] on linuxType &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.&gt;&gt;&gt;exit() 可见，Python 交互模式主要是为了调试 Python 代码用的，也便于初学者学习，它不是正式运行 Python 代码的环境！！！ 命令行脚本你可以在命令行中，通过 引入 Python 解释器（python） 直接解释执行你的 Python 脚本 【 HelloWorld.py 】，如下所示： 12345678# Unix/Linux：[root@node1 ~]# python HelloWorld.py Welcome to Python World# 或者# Windows/DOSC:&gt; python HelloWorld.pyWelcome to Python World 注意：在执行脚本时，系统会首先检查脚本是否有可执行权限，然后执行。命令行模式下直接运行 .py 文件是 一次性执行该文件内的所有代码。 集成开发环境（IDE：Integrated Development Environment）和大多数程序设计语言一样，一个体验良好的集成开发环境对于 Python 程序开发是必不可缺的。 IDLE &gt;&gt;&gt;Python 安装之后，会默认包含一个简单的 集成开发环境 –&gt; IDLE，你可以通过 Win –&gt; 查找 IDLE 尝试使用一下。 PyCharm IDE &gt;&gt;&gt;推荐使用 PyCharm（大多数 Python 开发人员的首选）。 PyCharm 是由 JetBrains 打造的一款 Python IDE，支持 macOS、 Windows、 Linux 系统。 PyCharm 功能 : 支持调试、语法高亮、Project 管理、代码跳转、智能提示、自动完成、单元测试、版本控制…… PyCharm 下载地址 &gt;&gt;&gt;&gt; [ https://www.jetbrains.com/pycharm/download/ ] 以下展示的是 PyCharm 工作界面样例图（是不看起来相当美观）： 关于 PyCharm In Windows 的入门使用教程，请参见：&gt;&gt;&gt;&gt; 【Pycharm-Community-In-Windows-Tutorial】。 | ================================= Split Line ================================ | 至此，这一章节的主要内容已经解读完成，基于上述内容的介绍你已经可以对照 Python 参考书开始 Python 语言的学习了。但我强烈建议你阅读下面的内容，它可以帮助你快速在 Python 学习中走的更远…… You Need Know MorePython 解释器详解前面我们一直提到 Python 解释器，当我们编写 Python 代码时，我们得到的是一个包含 Python 代码的以 .py 为扩展名的文本文件。要运行代码，就需要 Python 解释器去执行 .py 文件。 由于整个 Python 语言从规范到解释器都是开源的，所以理论上，只要水平够高，任何人都可以编写 Python 解释器来执行 Python 代码（当然难度很大）。事实上，确实存在多种 Python 解释器。 1 &gt;&gt;&gt;&gt; CPython 当我们从 Python 官方网站下载并安装好 Python 3.x 后，我们就直接获得了一个官方版本的解释器：CPython。这个解释器是用 C 语言开发的，所以叫 CPython。在命令行下运行 python 就是启动 CPython 解释器。所以 CPython 是使用最广的 Python 解释器。 2 &gt;&gt;&gt;&gt; IPython IPython 是基于 CPython 之上的一个交互式解释器，也就是说，IPython 只是在交互方式上有所增强，但是执行Python 代码的功能和 CPython 是完全一样的。好比很多国产浏览器虽然外观不同，但内核其实都是调用了 IE。 CPython 用 &gt;&gt;&gt; 作为提示符，而 IPython 用 In [序号]: 作为提示符。 3 &gt;&gt;&gt;&gt; Jython Jython 是运行在 Java 平台上的 Python 解释器，可以直接把 Python 代码编译成 Java 字节码执行。 4 &gt;&gt;&gt;&gt; PyPy PyPy 是另一个 Python 解释器，它的目标是执行速度。PyPy 采用 JIT（Just-in-time）技术，对 Python 代码进行动态编译（注意不是解释），所以可以显著提高 Python 代码的执行速度。 绝大部分 Python 代码都可以在 PyPy 下运行，但是 PyPy 和 CPython 有一些是不同的，这就导致相同的 Python 代码在两种解释器下执行可能会有不同的结果。 5 &gt;&gt;&gt;&gt; IronPython IronPython 和 Jython 类似，只不过 IronPython 是运行在微软 .Net 平台上的 Python 解释器，可以直接把 Python 代码编译成 .Net 的字节码。 注意：Python 的解释器很多，这里我们简单介绍了常见的几种，但使用最广泛的还是 CPython。如果要和 Java 或 .Net 平台进行交互，最好的办法不是用 Jython 或 IronPython，而是 通过网络调用来交互，确保各程序之间的独立性。 Python 安装目录详解Python 安装目录说明如下： DLLs：Python 的动态链接库，和平台以及编译器有关，和 Python 编程关系不大； Doc：Python 自带的说明文档，包含很多的实例； lnclude：包含共享目录，存放了一些 C 语言的头文件，可能是在使用 C/C++ 扩展 Python 功能时所需使用的头文件； Lib：存放库文件，包含 Python 标准库和安装的第三方扩展库（Lib/site-package）； libs：静态库存放目录； Scripts：存放可执行脚本或程序，例如 pip 的可执行程序； tcl：Python 默认内置的 GUI 工具 Tkinter； Tools：现成的工具包目录。 这一小节内容你可以先跳过，等后续对 Python 多版本环境使用有了较深的了解之后再来学习当前内容，这可以帮助你更深入、灵活地掌握 Python 环境的使用。 Python Versions Management设想这样的情景 –&gt; 场景一：A 项目是一个爬虫项目，需要用到 requests、pyspider、scrapy 等包或框架；B 项目是一个 GUI 界面项目，需要用到 GUI 相关的包或库；这需要把所有用到的包都安装到原生 Python 环境中，开发环境越来越臃肿。 场景二：C 项目是一个 Python2.x 项目；D 项目是一个 Python3.x；两项目要求的 Python 版本不兼容。怎么办？！！ 解决思路 &gt;&gt;&gt;&gt; 前面提到过一个系统中是可以同时存在多个不同的 Python 版本的，但是你需要注意新添加的 Python 环境对系统既有环境的影响，这就涉及到系统中 多个 Python 版本的管理 问题。 篇幅原因，关于 Python 版本管理问题，请查看系列博文： 之一 &gt;&gt;&gt; Python-Vers Management； 之二 &gt;&gt;&gt; Pythoner 神器之 virtualenv； 之三 &gt;&gt;&gt; 一文了解数据科学神器 Anaconda； 之四 &gt;&gt;&gt; Jupyter Tutorial。 至此，我们就搭建起了：Python3 + Anaconda（VirtualEnv） + Pycharm + Jupyter 的 Python 多版本开发以及学习环境。","link":"/2018/01/01/python-jian-jie-yu-kai-fa-huan-jing-da-jian/"},{"title":"Pythoner 神器之 virtualenv","text":"Foreword 实际 Python 学习、开发过程中，往往由于各种原因，多 Python 版本解释器环境 &amp;&amp; 多版本的 Python 库（模块）需求是我们必然要面对的问题，这使得很多人在 Python 的环境管理上产生极大的混乱。甚至，不同的项目，或同一项目的不同阶段需要不同的 Python 解释器和依赖库。 那么，为每个 Python 项目，甚至每个脚本各自建立一套 “独立、隔离” 的 Python 环境（环境中可以自定义特定的 Python 版本以及特定的依赖库） 是必要的。 更多 Python 版本管理以及运行环境相关内容，请关注博主 Git 博文系列： 之一 &gt;&gt;&gt; Python-Vers Management 之二 &gt;&gt;&gt; Pythoner 神器之 virtualenv 之三 &gt;&gt;&gt; 一文了解数据科学神器 Anaconda 之四 &gt;&gt;&gt; Jupyter Tutorial virtualenvvirtualenv 就是用来给每个 Python 项目，甚至每个脚本各自建立一套 “独立、隔离” 的 Python 运行环境的工具。 用 virtualenv 来保持一个干净、无污染的 Python 运行环境是非常有用的。 和主流的虚拟隔离环境工具类似，virtualenv 可以帮助你： 可以创建任意多个虚拟环境（可以看作成一个个容器），使用时指定到（切换到）某一虚拟环境之后，通过 Pip 工具安装的包、库就只会在这个环境（容器）下；并且各虚拟环境（容器）之间，以及虚拟环境和系统原生环境之间是隔离的（一个个相互独立、隔离的容器）。 假设某一个虚拟环境预计不再使用，可以直接删除掉相应虚拟环境，由于虚拟环境的独立、隔离性，不用关注文件残留、关联问题。 虚拟机制virtualenv 管理的多版本 Python 运行环境示意图如下： 图解： 每个 Python 解释器都有一个特定的指向自己的 pip 工具，两者一一对应； 一个操作系统中，可以同时安装有多个不同版本的 Python 解释器（注意保证无冲突共存），你可以将其看作是 “操作系统级别” 的 Python 解释器； virtualenv 可以将上述任一 “操作系统级别” 的 Python 解释器，虚拟成为一个 “虚拟级别” 的 Python 解释器，Python 版本取决于虚拟时所使用 “操作系统级别” 的 Python 解释器 版本； 每个 “虚拟级别” 的 Python 解释器都拥有自己独立的 pip 工具和 site-package。 Setup这一小节来看 virtualenv 在 Windows &amp;&amp; Linux 平台下的安装方法。但前提是： 你的操作系统中必须已安装有一个 Python 环境。这是重要的，因为 virtualenv 的安装需要依赖于 Python 的包管理器——pip。 1 –&gt; Begin to setup Python 多版本共存环境下，建议直接使用操作系统下环境变量中指定的 Python 版本所绑定的 pip，安装命令如下： 1pip install virtualenv 当然，你也可以选择操作系统中其它的 Python 版本所指向的 pip 进行安装，上面只是为了方便命令调用和管理。 看到如下安装信息，表示 virtualenv 成功安装： 123...Successfully installed virtualenv-20.4.4 appdirs-1.4.4 distlib-0.3.1 filelock-3.0.12 importlib-resources-3.2.1... 你可以看到，除了安装 virtualenv 外，pip 还为我们安装了一些必须的依赖包。 2 –&gt; Setup Test 安装成功之后，我们还可以进行 virtualenv 版本安装测试。成功安装的话，可以查看到版本信息： 12345678910111213# Windows InfoXXX Guo@LAPTOP-SNOSCKOB MINGW64 ~/Desktop$ pip -Vpip 9.0.3 from f:\\python\\python36\\lib\\site-packages (python 3.6)XXX Guo@LAPTOP-SNOSCKOB MINGW64 ~/Desktop$ virtualenv --versionvirtualenv 20.4.4 from f:\\python\\python36\\lib\\site-packages\\virtualenv\\__init__.py# Linux Inforoot@iZ2zeazcdax8nlsrpzpd83Z:~# pip -Vpip 20.3.4 from /usr/local/lib/python3.5/dist-packages/pip (python 3.5)root@iZ2zeazcdax8nlsrpzpd83Z:~# virtualenv --versionvirtualenv 20.4.4 from /usr/local/lib/python3.5/dist-packages/virtualenv/__init__.py 可以看到， 不管是 Windows 平台使用的是 python3.6，还是 Linux 平台下使用的 python3.5，virtualenv 均被成功安装到 操作系统下环境变量中指定的有效 Python 版本库（site-package/dist-package）中。 这时，你就可以使用安装好的 virtualenv 虚拟你所需要的虚拟环境了~~~ | &gt;&gt;&gt;&gt; ================================= Split Line =============================== &lt;&lt;&lt;&lt; | 你或许有疑惑？设想若 Windows（Linux） 下还存在一个 Python2.7，那我要虚拟 Python2.7 版本的环境怎么办？在 2.7 下也装一个 virtualenv？ 不需要的！virtualenv 可以指定虚拟的 Python 解释器版本，只要你本地操作系统的任一 Python 版本安装了 virtualenv 即可！ 关于 virtualenv 可以指定创建虚拟环境的 Python 解释器版本，可见下文中使用，这里有这个概念即可。 Envs Management这一小节来看，如何使用 virtualenv 进行虚拟隔离环境管理。 如何创建虚拟环境这里将以 Windows 为例来看如何使用 virtualenv 来创建虚拟环境，Linux 平台下与 Windows 操作无异。 使用 virtualenv 来管理所有的虚拟隔离环境，通常会建立一个单独的目录(virtualenvs_py)，用来放置 virtualenv 中管理的所有虚拟环境（你可以称之为：虚拟环境仓库）： 1mkdir E:\\virtualenvs_py 然后，先来为深度学习项目创建一个名为 for_tensorflow 的 Python 运行环境，执行如下命令： 1virtualenv -p F:\\\\Python\\\\Python36\\\\python.exe E:\\\\virtualenvs_py\\\\for_tensorflow 命令参数说明如下： -p：指定你要虚拟的 “操作系统级别” 的 Python 解释器版本，这里选择了系统中的 Python3.6.5； E:\\virtualenvs_py\\for_tensorflow：表示在 virtualenvs_py 目录下，建立一个名为 for_tensorflow 的虚拟环境，专门用于进行深度学习使用。 运行情况如下： 123456$ virtualenv -p F:\\\\Python\\\\Python36\\\\python.exe E:\\\\virtualenvs_py\\\\for_tensorflow created virtual environment CPython3.6.5.final.0-64 in 2759ms creator CPython3Windows(dest=E:\\virtualenvs_py\\for_tensorflow, clear=False, no_vcs_ignore=False, global=False) seeder FromAppData(download=False, pip=bundle, setuptools=bundle, wheel=bundle, via=copy, app_data_dir=C:\\Users\\XXX Guo\\AppData\\Local\\pypa\\virtualenv) added seed packages: pip==21.0.1, setuptools==56.0.0, wheel==0.36.2 activators BashActivator,BatchActivator,FishActivator,PowerShellActivator,PythonActivator,XonshActivator 找到 for_tensorflow 虚拟环境目录，你可以发现 virtualenv 帮助你创建了一个非常 “干净” 的 Python 运行环境！ |&gt;&gt;================== “干净”何解？ ================== virtualenv 的最新版本，以 20.0.0+ 为例，取消了 --no-site-packages 参数，默认已经使用了 –-no-site-packages 模式，表示 “虚拟级别” 的 Python 运行环境，不可以访问源 “操作系统级别” Python 解释器的第三方库。 与之相对的，还有另外一个参数 --system-site-packages，表示 可以访问源 “操作系统级别” Python 解释器的第三方库。一般推荐直接使用默认模式。 最终命令格式如下： 1virtualenv -p python_xxx envs_destination_dir 表示：使用 “操作系统级别” Python 解释器（python_xxx），来虚拟一个名为 “envs_destination” 的虚拟环境。并且，虚拟环境中不包含任何来源于 “python_xxx” 的第三方库（纯净）。 ==============================================&lt;&lt;| 几种常见的创建虚拟环境的命令格式以及其含义： 123456789# 1. 使用系统默认指定的 Python 解释器来创建虚拟环境 “env_py36”（不使用 &quot;-p&quot; 选项）$ virtualenv env_py36# 2. 多版本 Python 共存环境，创建指定 Python 版本的解释器虚拟环境$ virtualenv -p F:\\\\Python\\\\Python27\\\\python.exe env_py27 # 解释器为 python2.7（Linux）$ virtualenv -p python3.5 env_py35 # 解释器为 python3.5# 3. 创建继承系统第三方库的虚拟环境$ virtualenv --system-site-packages env_py34 如何激活虚拟环境虚拟环境创建成功之后，不能立即使用！使用某一虚拟环境之前，你需要启动（激活）特定的虚拟环境之后，才可以使用。 1 –&gt; For Windows 以 “for_tensorflow” 虚拟环境为例： 命令行下，进入你要使用的虚拟环境的目录下的 Script 文件夹，运行 activate 命令，或者使用绝对路径的方式调用该命令。 123456789101112131415161718192021E:\\virtualenvs_py\\for_tensorflow\\Scripts&gt;dirE:\\virtualenvs_py\\for_tensorflow\\Scripts 的目录2021/04/30 21:16 &lt;DIR&gt; .2021/04/30 21:16 &lt;DIR&gt; ..2021/04/30 21:16 2,152 activate # 环境激活命令2021/04/30 21:16 1,025 activate.bat2021/04/30 21:16 3,075 activate.fish2021/04/30 21:16 1,755 activate.ps12021/04/30 21:16 1,166 activate.xsh2021/04/30 21:16 1,193 activate_this.py2021/04/30 21:16 510 deactivate.bat2021/04/30 21:16 106,362 pip-3.6.exe2021/04/30 21:16 106,362 pip.exe......# 启动（激活）for_tensorflow 环境E:\\virtualenvs_py\\for_tensorflow\\Scripts&gt;activate.bat# 或者使用 `activate.bat` 的绝对路径(for_tensorflow) E:\\virtualenvs_py\\for_tensorflow\\Scripts&gt; 注意命令提示符（for_tensorflow），它表示你当前处在 for_tensorflow 这个虚拟环境内，你可以认为你当前处于一个刚下载好的、纯净的、可以正常使用的 Python 环境。 当前环境下，1. 运行 Python 命令；2. 使用 pip 工具安装第三方库。这些操作都会被限制、绑定到 for_tensorflow 这个虚拟环境，不会对操作系统原生的 Python 环境和其它虚拟环境产生任何影响。 2 –&gt; For Linux 对于 Linux 平台下，由于虚拟环境中的文件路径（activate）和脚本调用的方式（source）不同，激活虚拟环境和 Windows 有略微不同。 以 “env27” 虚拟环境为例： Linux 中 activate 脚本位于 &lt;env27\\bin&gt; 目录中，所以启动虚拟环境命令为： 12# 激活虚拟环境：$ source env27/bin/activate 这个命令会修改系统路径 $PATH，把 env27/bin 的路径置于系统路径之前。 如何退出虚拟环境Windows &amp;&amp; Linux 下，退出当前虚拟环境只需要执行如下命令，即可回退到系统原生的 Python 运行环境： 123456# 退出虚拟环境：# For Windows：&gt; deactivate.bat# For Linux:$ deactivate 如何删除虚拟环境当某一虚拟环境不再使用时，你可以将其删除释放系统资源。 Windows &amp;&amp; Linux 下，删除虚拟环境（for_test）时，你只需要将 virtualenvs_py 目录下，准备弃用的 for_tensorflow 虚拟环境目录删除掉即可！ Application这里给出一个 virtualenvs 虚拟环境管理器配合 pip 包管理工具，确保开发环境一致性的应用实例： 假设：在本地开发环境，已经准备好了 “项目 + 依赖包” 环境；。现在准备将项目上传至服务器，上线发布。那么，保证本地和服务器 Python 运行环境的一致性至关重要！ 解决方案 –&gt; 1 –&gt; pip list 首先，我们需要使用 pip list 命令，来查看当前 Python 运行环境中项目依赖包的安装情况： 12345678910111213141516171819202122(for_test1) E:\\virtualenvs_py\\for_test1&gt;pip listPackage Version------------------- ---------appdirs 1.4.4certifi 2020.12.5chardet 4.0.0distlib 0.3.1filelock 3.0.12idna 2.10importlib-metadata 4.0.1importlib-resources 5.1.2numpy 1.19.5pip 21.0.1requests 2.25.1setuptools 56.0.0six 1.15.0typing-extensions 3.7.4.3urllib3 1.26.4virtualenv 20.4.4wheel 0.36.2zipp 3.4.1WARNING: The repository located at mirrors.aliyun.com is not a trusted or secure host and is being ignored. If this repository is available via HTTPS we recommend you use HTTPS instead, otherwise you may silence this warning and allow it anyway with '--trusted-host mirrors.aliyun.com'. 2 –&gt; pip freeze virtualenv 虚拟环境，配合 pip 的 freeze 功能，可以将当前虚拟环境中所有的依赖包以及其版本信息以列表的形式存放到文件中： 12# 导出安装信息：$ pip freeze &gt; requirements.txt 3 –&gt; pip install xxx 对应的，我们可以将上述生成的文件上传至服务器项目发布目录，然后在服务器下创建 virtualenv，即可使用下面的命令在 venv 中重新安装项目所需的模块依赖： 12# 根据库文件安装依赖：$ pip install -r requirements.txt virtualenvwrappervirtualenvwrapper 是一个基于 virtualenv 的升级版本。相较于 virtualenv，virtualenvwrapper 更容易对所有的虚拟环境进行统一管理。 Why virtualenvwrapper参考上文，你可以发现 virtualenv 存在的一个最大缺点就是： 使用 virtualenv 创建虚拟环境时，如果你没有特别的，有意识的去统一管理虚拟环境目录，很容易导致虚拟环境放的到处都是。 其次，每次开启虚拟环境之前要去虚拟环境所在目录下的 bin（Scripts） 目录下 activate，这就需要我们记住每个虚拟环境所在的目录。并且还有可能你忘记了虚拟环境放在哪…… 而使用 virtualenvwrapper 默认会将所有的虚拟环境都统一管理在一个目录下，你可以很方便、快捷的找到所有的虚拟环境。 How To Setup我们同样需要使用 pip 工具来进行 virtualenvwrapper 的安装，并且 Windows &amp;&amp; Linux 平台下的安装、配置过程稍有不同： For Linux1 –&gt; Setup virtualenvwrapper 命令如下： 1$ pip install virtualenvwrapper Linux 中 virtualenvwrapper 默认将所有的虚拟环境放在 ～/.virtualenvs 目录下管理，另外可以通过修改环境变量 WORKON_HOME 来指定虚拟环境的保存目录。 12# 为了保持和后文 Windows 保持一致，可以设置为统一目录：Envsexport WORKON_HOME=~/Envs 2 –&gt; Config virtualenvwrapper Linux 中，每次打开一个 Shell 想要使用 virtualenvwrapper 工具之前，都必须先激活 virtualenvwrapper 服务 123root@iZ2zeazcdax8nlsrpzpd83Z:~# find / -name virtualenvwrapper.sh/usr/local/bin/virtualenvwrapper.shroot@iZ2zeazcdax8nlsrpzpd83Z:~# source /usr/local/bin/virtualenvwrapper.sh 这是麻烦的，可以将上述命令添加到：.bashrc || .profie 等 shell 启动文件中。以便 shell 登陆后可直接使用 virtualenvwrapper。 例如，在 .bashrc 中添加如下内容： 12export WORKON_HOME=~/Envs # 设置 virtualenv 的统一管理目录source /usr/local/bin/virtualenvwrapper.sh # 激活 virtualenvwrapper 工具 读取文件，使得配置生效： 1source ~/.bashrc For WindowsWindows 安装命令如下： 1pip install virtualenvwrapper-win 默认创建的虚拟环境管理目录位于 C:\\Users\\username\\Envs，可以通过环境变量 WORKON_HOME 来定制： 通过计算机–&gt;属性–&gt;高级系统设置–&gt;环境变量–&gt;在系统变量中新建“变量名”：WORKON_HOME,变量值：“你自定义的路径”。 Envs Management这一小节，我们来看：相较于 virtualenv 工具，virtualenvwrapper 是如何进行虚拟环境的统一管理。 Windows &amp;&amp; Linux 下 virtualenvwrapper 虚拟环境管理命令是一致的！ 如何创建虚拟环境使用下列命令可以在 ~/Envs 目录创建 for_tensorflow 虚拟环境目录： 12# 其中，`python_path` 为想要虚拟的系统级别的 Python 解释器路径$ mkvirtualenv -p python_path for_tensorflow 创建后，自动进入到相应虚拟环境中。 如何激活&amp;退出虚拟环境使用下列命令可以激活 for_tensorflow 虚拟环境： 1$ workon for_tensorflow workon env_name：可以实现在虚拟环境中来回切换。 使用下列命令可以退出 for_tensorflow 虚拟环境： 1$ deactivate 如何删除虚拟环境使用下列命令可以删除 for_tensorflow 虚拟环境： 1$ rmvirtualenv for_tensorflow 其它常用其他命令 lsvirtualenv列举所有的环境（可以直接使用 workon + Enter 代替）。cdvirtualenv导航到当前激活的虚拟环境的目录中。cdsitepackages导航到当前激活的虚拟环境的目录中的 site-packages 目录中。lssitepackages显示 site-packages 目录中的内容。virtualenvwrapper显示帮助信息 但要注意的是，不管是使用 virtualenv 还是 virtualenvwrapper 虚拟环境工具，其都依赖于“操作系统级别” 的 Python 解释器。 也就是说，只有当前操作系统中包含目标版本的 Python 解释器，才可以虚拟相应目标版本的 Python 解释器，这是不合理的！！！ 这时，你可以从系列博文关于 Anaconda 的介绍中需求解决方法 &gt;&gt;&gt;&gt; 【一文了解数据科学神器 Anaconda】。","link":"/2018/01/02/pythoner-shen-qi-zhi-virtualenv/"},{"title":"玩转 VSCode 之配置 Python 语言开发环境","text":"Linux &amp;&amp; Windows 平台下配置 VS Code + Python 语言学习、开发环境。 我们知道，配置 VSCode多重开发环境，就是组合安装配置多种语言相关插件以及相关语言工具库 的过程。 下面正式开始在 VS Code 中配置 Python 开发、调试环境（For Windows &amp;&amp; Linux）： Extensions Setup首先，需要安装 VSCode 中 Python 开发过程中可能会用到的插件 &gt;&gt;&gt;&gt; ↓↓↓↓↓↓ 推荐安装的扩展 ↓↓↓↓↓↓ Python：Python 语言支持插件，包括 Python 智能提示、代码规范和语法检查、代码格式化、调试功能以及单元测试等等。 官方说明：Support &gt;&gt;&gt;&gt; IntelliSense (Pylance), Linting, Debugging (multi-threaded, remote), Jupyter Notebooks, code formatting, refactoring, unit tests … 安装方式：打开 VSCode 插件商店【Ctrl + Alt + X】 &gt;&gt;&gt; 搜索栏中搜索【Python】 &gt;&gt;&gt; 【Install】即可。 Python Extension 是一个插件合集包，包含了 Python &amp;&amp; Pylance &amp;&amp; Jupyter（4 &lt;&lt;&lt; Jupyter Keymap &amp;&amp; Jupyter Notebook Renderers &amp;&amp; Jupyter Slide Show &amp;&amp; Jupyter Cell Tags）在内的 7 个插件，涉及了所有 Python 开发中可能用到的流行插件。 其中，Pylance 子插件提供了：代码补全、参数提示、代码诊断、引用和跳转等基础编码功能；Jupyter 子插件提供了 Jupyter Notebook 支持，可用于直接打开、编辑 .ipynb 格式的 Jupyter Notebook 文档。 插件禁用方式：禁用 Python 环境插件时，只需要将【Python】Extension 禁用掉即可，其子插件（7）也会一并被警用（适用于所有插件合集包警用）。 创建 Python 工程文件夹我们知道，VScode 是以文件夹的形式来组织管理工程项目的。 故，首先你需要创建一个用来存放整个工程代码的文件夹也被称为 【工作目录】，这里我的为：PyProjectWSC。 注意：工作目录路径中不能含有中文和空格和引号。 然后通过 VSCode 打开该文件夹【File –&gt; Open Folder 或使用快捷键 Ctrl + K + O】，选择刚才创建的那个文件夹（PyProjectWSC）即可。 事实上，此时你就可以将 VSCode 作为编辑器进行 Python 源码学习和编写了。 Reffs Configuration打起精神，重点来了…. 如果你只是将 VSCode 作为一个编辑器使用，那么上述就够了，当然这不是我们的目的。 再一次重申：VS Code 只是一个文本编辑器，并不是 IDE。 我们的目的是：想要在 VSCode 中直接进行 Python 代码的编写测试以及完成代码的 Debug（断点测试）功能，那么你还需要进行额外的配置。 需要配置那些？？？ 配置 Python 环境：你需要确定当前系统环境下确保有一个可以用来解释、执行 Python 的解释器，以及相关开发类库； 配置工程文件夹：你需要使用 VSCode 设置规则在工程文件夹中进行一些配置，以可以帮助我们完成多版本 Python 环境、代码格式化工具、代码检查工具、单元测试工具 …… 的设置。 关于 VSCode For Python 语言开发环境，在不同平台（Windows &amp; Linux）下的配置过程类似，有区别的地方会特别指出。 Begin to Start &gt;&gt;&gt; 配置 Python 环境首先，来配置 Python 运行必须的解释器环境： [1] &gt;&gt;&gt; 配置 Python 解释器环境 关于 Python 解释器的安装和配置，篇幅原因不再赘述，你可以参考博主前面的博文 &gt;&gt;&gt; Python 简介与开发环境搭建 中 【2 Python Development Envs Setup】小节，里面详细阐述了 Windows &amp; Linux 平台下 Python 环境的安装以及配置过程。 关于 Python 的多版本管理以及运行环境相关内容，感兴趣的同学可以关注博主相关博文系列： 之一 &gt;&gt;&gt; Python-Vers Management 之二 &gt;&gt;&gt; Pythoner 神器之 virtualenv 之三 &gt;&gt;&gt; 一文了解数据科学神器 Anaconda 注意 &gt;&gt;&gt;&gt; Python 环境安装完成之后，一定要确定完成 Python 环境变量的配置。这样，VS Code 才可以从操作系统中成功检索到你安装的 Python 解释器（包括操作系统 Python 解释器、VirtualEnv 虚拟环境、），这是关键的。 除了操作系统级别的 Python 解释器，VS Code 还可以自动检测到你通过 virtualenvwrapper &amp;&amp; anaconda 等工具已创建好的虚拟级别的 Python 解释器，这对于 VS Code 配置 Python 多版本环境是有益的！！！ [2] &gt;&gt;&gt; 配置 Python 开发相关的第三方库 这里，主要包含三个第三方库： flake8：Python 静态代码检测工具，代码规范器。作用：用于检查编写的 Python 代码是否不规范，是否存在语法错误； yapf：Google 开源的 Python 代码格式化工具，作用：一键美化代码； pytest：一个广泛使用的第三方单元测试框架，兼容 unittest（Python 默认测试工具） &amp;&amp; nose。 安装方式 &gt;&gt;&gt;&gt; 123$ pip install flake8$ pip install yapf$ pip install pytest 完美~~~，至此 关于 Python 环境的配置就完成了… 上面，我们已经创建了一个工程文件夹（目录：PyProjectWSC），并在 VSCode 中进行了打开。 下面我们来看如何为一个 Python 项目进行配置，即针对 Python 工程文件夹进行配置，涉及到我们前面讲解过的 “文件夹设置”。 配置工程文件夹关于工程文件夹设置内容主要包括：多版本 Python 解释器环境配置、IntelliSense 智能语言支持、代码格式化工具、代码检查工具、调试、单元测试工具等。更多设置可关注插件 &gt;&gt;&gt; Python Extension。 配置 Python 解释器Python 是一个解释型语言，故你需要先为 Python 工程文件夹选择一个适合项目的 Python 解释器。 官方文档：opening the Command Palette (Ctrl+Shift+P), start typing the Python: Select Interpreter command to search Config Method : 打开 VSCode 命令面板【Ctrl+Shift+P】 &gt;&gt;&gt;&gt; 搜索【Python: Select Interpreter】，此时你可以看到一个当前系统中存在的 Python 解释器列表（操作系统级别 Python 解释器 &amp;&amp; 虚拟级别 Python 解释器） &gt;&gt;&gt;&gt; 选择一个适合项目 Python 版本的 Python 解释器。 配置完成之后，可以在 VS Code 下方导航栏中看到你配置好的 Python 解释器，例如：Python 3.5.6(vscodePyWSC:conda)。这是由于我使用的是 Anaconda 创建的虚拟环境 vscodePyWSC，其中 Python 解释器版本为 3.5.6。 配置 IntelliSensePython Extension 中支持 IntelliSense（智能语言支持），提供代码自动补全，参数提醒、代码跳转等功能，可以极大的提高 Python 的变成效率。 一般情况下，Python 插件会自动读取本地的各种 Python Packages，然后为你提供智能提醒。 需要注意的是，如果你有一些第三方的 Python 脚本，但是它们并没有被 VS Code 的 Python 插件所识别，而你又希望能够获得它们的智能提示，那你可以通过生成 文件夹设置（.vscode/settings.json） 添加如下的配置来实现： 12&quot;python.autoComplete.extraPaths&quot;: [] 这样，Python 插件就会分析 python.autoComplete.extraPaths 下的所有文件夹，然后分析这些代码，并且提供 IntelliSense 功能。 配置代码格式化工具Python 插件默认是使用 autopep8 来进行代码的格式化，同时也支持 black 和 yapf。 当然，你可以通过 python.formatting.provider 设置项来进行格式化工具的配置： 1&quot;python.formatting.provider&quot;: &quot;yapf&quot; 当你第一次使用格式化文件（Format Document）时（快捷键：Shift + Alt + F），如果你本地并没有安装对应的格式化工具的话，VS Code会提出警告（formatter xxxxx is not installed. install?），此时你需要通过包管理器进行安装。 同时，推荐 &gt;&gt;&gt; 设置 editor.formatOnSave &amp;&amp; editor.formatOnType，对代码进行及时的格式化。 12&quot;editor.formatOnSave&quot;: true,&quot;editor.formatOnType&quot;: true 此外，还可以通过 python.formatting.autopep8Args &amp;&amp; python.formatting.yapfArgs &amp;&amp; python.formatting.blackArgs 来调整格式化参数。 配置代码检测工具默认情况，VS Code 会在你保存 Python 文件时，检查编写的 Python 代码是否不规范？是否存在语法错误？然后将错误显示在问题面板中。 默认使用的代码检测工具是 Pylint。如果你希望使用其他的 Linter，你可以：打开命令面板【Ctrl + Alt + P】 &gt;&gt;&gt;&gt; 搜索【Python: Select Linter】执行 &gt;&gt;&gt;&gt; 选择你想要使用的 Linter。 这里我们选用的代码检查工具是：flake8，【Python: Select Linter】选择之后，配置文件内容如下： 123&quot;python.linting.enabled&quot;: true,&quot;python.linting.pylintEnabled&quot;: false,&quot;python.linting.flake8Enabled&quot;: true, 行最长字符数 79 限制 &gt;&gt;&gt; 可设置单行最长字符限制 ： 1&quot;python.linting.flake8Args&quot;: [&quot;--max-line-length=248&quot;] 还可以忽略掉一些无关错误： 1&quot;python.linting.flake8Args&quot;: [&quot;--extend-ignore=E231,E203&quot;] 调试相关Python 代码的调试，并不需要安装其它插件，只要你选择了合适的 Python 解释器即可。 如果没有配置调试配置文件 launch.json 的话，VS Code 会默认调试当前文件，你可以编写个简单的 Hello Python Demo 通过 F5（Debug） 尝试一下。 调试时可能会遇到：无法加载文件 C:\\Users\\Jie Guo\\Documents\\WindowsPowerShell\\profile.ps1，因为在此系统上禁止运行脚本 的问题，解决方法见【4 Problems】小节。 需要注意的是：由于 Python 开发组已停止对 Python3.6 的维护，导致 VSCode 当前新版本的 Python 插件无法使用，且无法对代码 Debug，你可以选择升级 Python 版本至 3.7 以上版本；或者降低 Python 插件版本。 当你为当前 Python 工程创建调试配置 launch.json 时，Python 插件会自动提供多种不同的模板，比如在集成终端中调试当前文件，Attach 到某个正在运行的 Python 脚本上，调试 Python 模块，调试 Django 等等。 相信你还记得，在介绍调试器 launch.json 的书写时，提到过，各个调试器的配置选项都不完全相同，如果 Python 调试的模板不能满足你的需求，你可以通过 相关文档 来了解 Python 插件都支持哪些调试参数。 配置单元测试Python 插件既支持 Python 自带的 unittest，同时也支持第三方的 pytest 和 Nose 单元测试框架。想要使用第三方单元测试框架，你需要在当前 Python 环境中安装相应的测试框架 Python Package，正如我前面安装的 pytest。 你可以，打开【命令面板】 &gt;&gt;&gt;&gt; 执行 【Python: Configure Tests】 命令，Python 插件就会依次问以下问题： Select a test framework/tool to enable：选择测试框架，我们选择 pytest framework; Select the directory containing the tests：选择在哪个文件夹下搜索测试文件，我们选择根目录； 为了测试上述单元测试框架，我们分别给出示例代码和相应的 pytest 测试单元代码： [1] 计算器功能实现（示例代码：calculator.py），内容如下： 12345678910111213class Calculator: def add(self, a, b): return a + b def sub(self, a, b): return a - b def mul(self, a, b): return a * b def div(self, a, b): return a / b [2] 计算器功能 pytest 测试代码（test_calculator.py），内容如下： 123456789101112131415161718192021222324252627282930import pytestfrom calculator import Calculatorclass TestCalculator(): def test_add(self): c = Calculator() result = c.add(3, 5) assert result == 8 def test_sub(self): c = Calculator() result = c.sub(10, 5) assert result == 5 def test_mul(self): c = Calculator() result = c.mul(5, 7) assert result == 35 def test_div(self): c = Calculator() result = c.div(10, 5) assert result == 2if __name__ == '__main__': pytest.main(['-s', 'test_calculator.py']) 依照上述操作，配置单元测试。在测试被成功找到后，你能够看到测试文件里，每个测试的行号右侧都有一个 Run Test 标识，并且右键标识，还可以看到 Debug Test 条目，你可以点击它们进行测试的执行。 并且，你可以在左侧导航栏 &gt;&gt;&gt; Testing 资源区中可以看到所有的测试 Case。在该区域可以逐条对测试 Case 进行测试以及调试，还可以直接运行所有测试。 当然，真正发挥 VS Code 威力，还是通过 Debug Test 来调试某个单独的测试。你只需设置断点，点击 Debug Test 即可进入调试状态。 这里，整理一份完整的 Python 项目文件夹设置（settings.json），内容如下： 123456789101112131415161718192021222324252627282930313233343536{ &quot;files.autoSave&quot;: &quot;onWindowChange&quot;, // // 文件自动保存选项；参数说明：onFocusChange =&gt; 当前文件失去焦点后自动保存; onWindowChange =&gt; 需要当前 VScode 窗口失去焦点才会自动保存 &quot;files.autoSaveDelay&quot;: 5000, // // 间隔多少毫秒自动保存，默认「1000毫秒」;如果配置了保存格式化代码，这个配置下自动保存不会格式化代码 &quot;editor.tabSize&quot;: 4, // 配置 Tab 空格数 &quot;editor.formatOnSave&quot;: true, // 保存文件时进行格式化 &quot;editor.formatOnType&quot;: true, // 一行语句编辑完成之后格式化 &quot;code-runner.runInTerminal&quot;: true, // 设置成 false 会在 “output” 中进行输出，无法输入 &quot;code-runner.executorMap&quot;: { &quot;python&quot;: &quot;python -u&quot; }, &quot;code-runner.saveFileBeforeRun&quot;: true, // Run Code 前保存 &quot;code-runner.preserveFocus&quot;: true, // 若为 false，Run code 后光标会聚焦到终端上。如果需要频繁输入数据可设为 false； &quot;code-runner.clearPreviousOutput&quot;: true,// 每次 Run code 前清空终端中属于之前 Code runner 的日志消息 &quot;python.autoComplete.extraPaths&quot;: [], // 为路径下的第三方 Python 脚本提供 IntelliSense 功能 &quot;python.analysis.extraPaths&quot;: [], // 可解决 “Import “xxxxxx” could not be resolved from source” &quot;python.formatting.provider&quot;: &quot;yapf&quot;, // 配置文件格式化工具 &quot;python.formatting.yapfArgs&quot;: [], // yapf 工具格式化参数设置 &quot;python.linting.enabled&quot;: true, // 配置代码检查工具：flake8 &quot;python.linting.pylintEnabled&quot;: false, &quot;python.linting.flake8Enabled&quot;: true, &quot;python.linting.flake8Args&quot;: [ // 配置 flake8 工具 &quot;--max-line-length=200&quot;, &quot;--extend-ignore=xxx&quot; ], &quot;python.testing.unittestEnabled&quot;: false,// 配置单元测试框架 &quot;python.testing.pytestEnabled&quot;: true, &quot;python.testing.pytestArgs&quot;: [ &quot;.&quot; ]} Problems系统上禁止运行脚本问题终端调试脚本时，可能会遇到 无法加载文件 C:\\Users\\Jie Guo\\Documents\\WindowsPowerShell\\profile.ps1，因为在此系统上禁止运行脚本。 的问题。 Solution：以管理身份启动 VS Code，运行您编写的未签名脚本和来自其他用户的签名脚本，请使用以下命令将计算机上的执行策略更改为 RemoteSigned（默认为：Restricted）： 1$ set-ExecutionPolicy RemoteSigned 修改后，查看执行策略： 12$ get-ExecutionPolicyRestricted","link":"/2017/08/03/wan-zhuan-vscode-zhi-pei-zhi-python-yu-yan-kai-fa-huan-jing/"},{"title":"玩转 VSCode 之配置远程开发环境","text":"微软在 PyCon 2019 大会上发布了 VS Code Remote，开启了远程开发的新时代！这次发布包含了三款核心的全新插件，它们可以帮助开发者在容器，物理或虚拟机，以及 Windows Subsystem for Linux (WSL) 中实现无缝的远程开发。VSCode Remote 的提出彻底引发了一场 “谁才是新一代最强编辑器？” 的争论。 由于在安装配置使用过程中查阅了网络上很多的相关博文，也遇到过很多的问题，为了感谢过程中各位大佬的帮助以及分享给更多的新手使用，以作此文。文中如有表述不正确的地方，望各位大佬指正~~~ 更多 VS Code 相关内容，请关注博主 Visual Studio Code 博文系列： 之一 &gt;&gt;&gt; Visual Studio Code (VS Code) 你们都在用吗 ? 之二 &gt;&gt;&gt; 玩转 VSCode 之配置远程开发环境 之三 &gt;&gt;&gt; 玩转 VSCode 之配置 C/C++ 语言开发环境 之四 &gt;&gt;&gt; 玩转 VSCode 之配置 Python 语言开发环境 之五 &gt;&gt;&gt; 使用 VSCode 搭建一个惊人的 Markdown Editor Why Configure Remote Development-Envs先来思考一下，为什么需要配置远程开发环境？？？ 日常学习或者工作中，你可能正在面临这样的问题： 每当更换电脑就要轻（ying）轻（zhe）松（tou）松（pi）从新搭建一遍开发环境； 每当拉取完最新代码程序在本地跑不起来的时候，就要重新检查服务器和开发电脑的环境； 每当本地开发完代码需要部署到服务器上测试时发现 Bug 就想如果可以调试服务器代码多好啊。 尤其在项目开发过程中，通常大多数的 编辑和开发环境都是系统隔离的。 编辑 IDE 和开发环境的系统隔离比如后台服务器开发工作，远端的服务器 Linux 系统一般是没有图像用户界面的，也就没有 IDE 界面，IDE 部署在个人的本地 Windows 电脑。服务端的程序一般都是跑在 Linux 服务器上面，传统的开发流程是在 Window 或 Mac 的 IDE（假设目前在用 VS Code）环境编写代码，然后使用 SSH 客户端软件（XShell、PuTTY、MobaXterm…）实现 SSH 远程登录 Linux 服务器上传代码，这时候你的编辑 IDE 和开发环境（代码编译、运行）就是隔离的。 这种隔离性表现在你的代码编辑不会实时刷新到开发环境进行后续的编译 &amp; 测试 &amp; 验证。 如何打通系统隔离事实上，打通系统隔离的方法有挺多的： SSH 远程登录（XShell、XFtp、PuTTY…）； 共享服务器（Samba、Ftp…）； 版本管理工具（Git、SVN），编辑这边提交更改，开发环境那边 pull 下来。 传统的远程开发流程 &gt;&gt;&gt;&gt; 在本地 Windows 和 Linux 开发服务器之间开启一个同步程序（Samba），本地编辑代码，实时后台同步到 Linux 远端服务器，然后用 XShell 登录开发机编译、调试。 现在来看（有了 VS Code Remote），这个过程有点不够优雅：需要了解 【Samba 同步 &amp;&amp; XShell】 的使用，并且还需要熟悉 Linux 命令行操作，这给开发者带来了工作效率的困扰。 除此之外，上述方法是有使用条件的，比如远程开发机在外网 ip，或者企业内部做了机器隔离，或者只开通了 SSH 接口登录，怎么办？？！ 这时需要 –&gt; 配置基于 SSH 通信连接的远程开发环境。 配置之后你可以干啥 &gt;&gt;&gt;&gt; 把开发环境作为沙箱，以避免影响本地计算机配置； 让新手轻松上手，让每个人都保持一致的开发环境； 从多台不同的计算机访问现有的开发环境； …. 并且，配置之后，使用 VS Code 也可以实现 SSH 远程登录，而且使用 VS Code 进行登录后，可以向操作本地文件（夹）一样来操作远程主机上的文件（夹），而且在进行代码编写时，也可以复用 VS Code 支持的代码高亮、提示等功能…. 快来让你的工作效率飞起来吧~~~ 下面我们来看如何进行配置，本人的 Local OS 是 Windows10，Remote OS 是 Linux 远程服务器。 Pre-Preparation Before Envs-Configuration（SSH）VS Code 的安装比较简单，你可以参看博文系列中 &gt;&gt;&gt; 【Visual Studio Code (VS Code) 你们都在用吗 ?】的说明，此处默认本地 Windows 上已经安装好 VS Code。 远程开发插件安装（Remote-SSH）要能连上远程主机，首先我们需要下载 VS Code 远程开发插件 &gt;&gt;&gt; Remote Development。 点击 VS Code 插件按钮，或者使用快捷键 Ctrl + Shift + X，直接进入插件应用商店搜索：remote development（先不要安装！！！）： 事实上，Remote Development 插件是个插件合集包，包括了三个安装套件： Remote - SSH –&gt; 可以通过使用 SSH 链接虚拟或者实体 Linux 主机; Dev - Containers –&gt; 连接 Docker 开发容器; Remote - WSL –&gt; 连接 Windows Subsystem for Linux （Linux子系统）。 打开软件的扩展界面，搜索 Remote 开头的插件，也能看到这三个不同的远程开发插件。这里，我们连接的是远程 Linux 服务器，所以实际只需要安装 Remote - SSH 插件即可（当然你可以选择直接安装 Remote Development 插件包体验其它远程连接功能）。 Remote - SSH这里我只选择安装 Remote - SSH 插件，安装成功后，你会发现同时自动安装了一个名为 Remote - SSH: Editing Configuration Files 的插件，插件官方解释是用来 Edit SSH configuration files，不用深究，后续你会用到。 并且，你可以看到 VS Code UI 左侧多出来一个名为 Remote Explorer 的按钮（远程资源管理器），用于在当前菜单区域组织和管理远程资源： 同时，VS Code UI 最下方状态栏出现了一个通过点击可 唤醒远程命令弹窗 的图标： 远程命令弹窗中，可查看以及运行当前 VS Code 中支持的远程命令，包括连接服务器，查看远程配置文件等等。 Remote-SSH 工作原理下面是官方给出的 Remote-SSH 的工作原理解析图： 简单来说，就是在远程机器上运行 VSCode Server，本机的 VSCode 只负责编辑、展示等，两者通过 SSH-Tunnel 通信。 这种模式的优点是客户端基本没有压力（降低了客户端设备的配置要求），编译、运行、Debug 等处理操作全部在目标机器完成。开启 SSH 模式后插件全是安装在 Remote 端，只有部分 UI 相关的插件会装在 Local 端。 Remote-SSH 最终搭建起了一套 【远程终端 + 定制化插件（如代码高亮等） + 远程调试开发 + 可视化 linux 文件目录…..】 的远程开发环境。 直呼 NB 就完事~~~ SSH Setup &amp; Configuration本地 VS Code 采用 SSH 协议与远程服务端通信，所以要先安装和配置 SSH 环境。 最新版本的 Win10 中已经自带了 openSSL（支持 SSH 通信），但我们推荐使用 Git 中自带的 SSH 客户端程序，如果你还没装 Git 的话，这里要先安装 Git，参见 –&gt; Git 使用指南之初识。并且你需要配置 Git 的 bin 目录到环境变量的 PATH 变量下，这样 VS Code 连接的时候就能找到 SSH 了。 Win10 中由于自带有 openSSL 比较特殊，系统和 VS Code 可能会优先加载到 openSSL 中的 SSH 程序，这会导致后续 VS Code Remote 连接错误。你可以在 DOS 窗口下通过如下命令查看一下当前系统调用的 SSH 程序位置： 123&gt;where sshC:\\Users\\xxx Guo\\sshC:\\Windows\\System32\\OpenSSH\\ssh.exe 可以看到，当前我的系统默认中找到的是系统自带的 OpenSSH 中的 ssh.exe。 因此，此时需要你确保 VS Code 中 remote.SSH.path 设置项使用的是 Git 中的 ssh.exe，如果设置项为空的话，请显式设置 Git/bin 下的 ssh，例如： 1&quot;remote.SSH.path&quot;: &quot;E:\\\\Git\\\\usr\\\\bin\\\\ssh.exe&quot; 安装好 SSH 之后，你就可以正常使用 VS Code 连接远程服务器了~~~ Remote Connection这里来看，如何使用 VS Code 安装好的插件 –&gt; Remote Development，以及 SSH 工具 进行远程服务器的连接： Add Remote Host首先，在 VS Code 远程资源管理器（Remote Explore）中添加远程主机： 1] &gt;&gt;&gt; 切换到 Remote Explore。 2] &gt;&gt;&gt; 在 SSH TARGETS 处点击 +，而后会弹出如下图界面： 在 ssh hello@microsoft.com -A 处输入你的远程主机信息，其中： hello 位置填写你在远程主机处的用户名（注意字母大小写）； microsoft.com 位置填写远程主机的 IP 地址； -A 位置可不写。 例如：ssh ubuntu@81.xx.xxx.36 。 3] &gt;&gt;&gt; 按照上述格式填写信息后，然后 【Enter】，然后会询问你远程服务器连接配置文件存放位置： 选项一（...\\\\.ssh\\config）是保存到当前用户下，选项二（...\\ssh\\ssh_config）是保存到所有用户下；选择默认选项一即可，然后 【Enter】，右下角会出现提示： 1Host added ! 添加成功了，你可以查看一下 SSH TARGETS 区域，已经可以看到成功添加的服务器了~~~ 最后查看一下 ...\\user\\your-user-name\\.ssh\\config（当前用户目录下的 .ssh 目录） 中的服务器配置信息： 1234Host 81.xx.xxx.36 HostName 81.xx.xxx.36 User ubuntu Port 22 除了上述配置项，更完整的格式以及释义： 12345Host &lt;远程主机名称&gt; ==&gt; 远程主机别名，便于记忆 HostName &lt;远程主机IP&gt; ==&gt; 远程主机 IP User &lt;用户名&gt; ==&gt; 用于登录远程主机的用户名 Port &lt;ssh端口，默认22&gt; ==&gt; SSH 通信协议端口 IdentityFile &lt;本机SSH私钥路径&gt; ==&gt; 采用密钥方式登录时，需指定私钥的路径 =============================== 另一种添加 Remote Host 方法 =============================== 通过 「远程资源管理器」 之后的 「设置按钮」，可以直接生成且打开远程服务器连接配置文件，然后你可以按照上面的服务器配置格式以及参数进行配置，配置后自动添加服务器。 如连接多个远程服务器，可参考如上内容，配置多个即可； 12345678910Host &lt;远程主机名称1&gt; HostName &lt;远程主机1 IP&gt; User &lt;用户名1&gt; Port &lt;ssh端口，默认22&gt; IdentityFile &lt;本机SSH私钥路径&gt;Host &lt;远程主机名称2&gt; HostName &lt;远程主机2 IP&gt; User &lt;用户名2&gt; Port &lt;ssh端口，默认22&gt; IdentityFile &lt;本机SSH私钥路径&gt; Login Remote Host这里针对远程服务器的两种登录方式，VS Code Remote 提供两种相应的登录方法： 用户密码登录; 密钥（公私钥）登录。 用户密码登录在 SSH TARGETS 区域选中你要登入的服务器，右键选择新窗口中连接还是在当前窗口连接（服务器后方 ＋ 号表示直接在新窗口连接）。 这里选择 【当前窗口连接】，然后会重新加载弹出 Enter password for ubuntu@81.xx.xxx.36 让你输入 ubuntu 用户的密码，输入后 【Enter】 确认。 等待一会儿即可连接成功，VS Code 状态栏中用于唤醒远程命令弹窗的按钮可以看到已连接到的服务器名称~~~ 遗留问题：每次连接远程服务器都需要输入密码，太麻烦了，随后配置一下免密码登录。参加 【Reffs: Configuration –&gt; 配置免密登录】。 密钥登录密码登录机制是不安全的，很容易被网络上的其它人攻击，植入一些挖矿程序。而密钥登录替代密码的方式的连接特性，可以使得远程登录非常安全。公私钥的登录原理 是利用密钥生成器（ssh-kengen）制作一对密钥 –&gt; 一只公钥 &amp;&amp; 一只私钥。将公钥添加到服务器的某个账户上，然后在客户端持有私钥即可完成认证并登录。 这样一来，没有私钥，任何人都无法通过 SSH 暴力破解你的密码来远程登录到系统。此外，如果将公钥复制到其他账户甚至主机上，任何一个持有私钥的客户端就可以登录（保存好你的私钥！！！）。按照当前实际搭建情况如下图所示： Go Start &gt;&gt;&gt;&gt; 1 &gt;&gt;&gt; 密钥生成 密钥对的生成可以是本地的 Win10（Local OS），也可以通过服务器生成，只要遵循上图中密钥登录架构原理图即可。 这里，尝试选择在 Linux 服务器上生成密钥对： 1）通过 XShell 或者 Putty 工具连接 Linux 服务器。 2）服务器终端中输入如下指令（密钥生成器）建立密钥对（先不要执行，先看注意事项！！！）： 1$ ssh-keygen ↓↓↓↓↓↓↓ 注意事项 ↓↓↓↓↓↓↓1）如果之前你已经生成过密钥（Git），此操作可能会使用新的密钥文件覆盖你之前生成的密钥文件，这是有风险的！但你可以使用之前已经生成的密钥对（Git）进行配置，这是允许的。如果使用已有密钥对的话，你可以跳至下一小节（这里就不生成了，直接白嫖~）。2）如果你想要为当前远程连接生成一个单独的密钥对也是允许的，你可以参照 &gt;&gt;&gt; 博文【Git 使用指南之远程仓库】中关于【配置多个 SSH Key】的说明。 如果你第一次使用 SSH 可以放心生成密钥对，执行 ssh-keygen，继续往下看 ↓↓↓↓↓↓↓↓↓ 3）需要你确定密钥文件存储路径（这里你可以自定义安装路径），默认 【Enter】 即可： 1Enter file in which to save the key (/home/xx_usr/.ssh/id_rsa): 4）一路 【Enter】，即可自动生成公钥和私钥，下面是公私钥默认下存储路径： 12your identification has been saved in /home/xx_usr/.ssh/id_rsa. ==&gt; 私钥your public key has been saved in /home/xx_usr/.ssh/id_rsa_pub. ==&gt; 公钥 生成公私钥之后，就可以开始进行服务器端和客户端设置了，接下文 ↓↓↓↓↓↓ 2 &gt;&gt;&gt; 服务器上安装公钥 1）添加公钥到服务器授权名单： 1234$ cat ~/.ssh/id_rsa_pub &gt;&gt; ~/.ssh/authorized_keys# 查看确保成功添加公钥$ cat ~/.ssh/authorized_keys 2）为了确保连接成功，请保证以下文件权限正确： 12$ sudo chmod 600 ~/.ssh/zutorized_keys$ sudo chmod 700 ~/.ssh 3 &gt;&gt;&gt; 配置密钥登录 1）打开 SSH 服务端配置文件（sshd_config），查看确认以下两项配置（默认不需要修改）： 12345$ vim /etc/ssh/sshd_config....RSAAuthentication yesPublicAuthentication yes 2）禁用密码登录 你可以在 设置密钥登录成功之后 修改以下配置项为 no，来禁止密码登录提升访问安全性： 12# 推荐在完成所有配置之后再关闭（一定要确保设置密钥登录成功之后再关闭，否则你将无法登录服务器了）：PasswordAuthentication no 3）配置完成后需要重启服务器 SSH 服务才可生效 1$ sudo service sshd restart 4 &gt;&gt;&gt; 服务器私钥复制到客户端 前面生成的密钥是通过服务器生成的，因此需要把生成的私钥复制本地 Win10 上面，简单点你可以直接使用 XShell 文件传输组件（XFTP）直接拷贝到 Win10 下即可（推荐拷贝到：~/.ssh/ 下，重命名为 id_rsa_remote_ssh ，方便日后管理）。 下载私钥到本地 Win10 之后，修改 VS Code 中服务器配置信息： 12345Host 81.xx.xxx.36 HostName 81.xx.xxx.36 User ubuntu Port 22 IdentityFile ~/.ssh/id_rsa_remote_ssh 重新尝试连接，应该就可以成功了~~~~ 关于云服务器（阿里，腾讯…）中的密钥登录问题 &gt;&gt;&gt;&gt; 有些远程服务器设置为只可以使用密钥登录，例如阿里云创建实例后要求只能使用密钥进行登录，这时云平台会给你下发一个私钥文件，你的客户端持有改私钥文件，才可以访问云服务器。怎么配置远程登录？？？ 此时，公钥默认已安装到服务器上，你只需要直接在 VS Code Remote 配置文件中配置私钥路径即可，就可以尝试进行登录了。 关于 Windows 下已存在公私钥的问题 &gt;&gt;&gt;&gt; 前面我们是基于在服务器上创建密钥对，然后进行密钥登录配置的。并且也提到过，只要遵循密钥登录原理，密钥对的生成可以是本地的 Win10，也可以通过服务器生成。 既然，本地 Windows 端已经有了密钥对了（之前配置 Git 远程库时创建的），那自然是可以直接用的，作为远程密钥登录方式的密钥对，这是合理的。 可以成功登录服务器之后，你就可以尝试 VS Code Remote 连接服务器后的操作了： Remote Host Use登录成功，即可像操作本地环境一样，在 VS Code 客户端操作远程服务器了。 可视化 Linux 目录点击 Explorer 或者直接使用快捷键 Ctrl + Shift + E，点击 Open Folder 后可以在下述位置处，选择想要进入（cd）的远程主机位置： 选择好相应文件夹后，即可在 Explorer 资源管理区域看到可视化后的 Linux 目录，操作上面的文件和操作本地环境里的一样。 Remote Host Extensions同时，可以给远程 VS Code 安装需要的插件，安装的插件是在云服务器的 VS Code（VSCode-server）上，对本机的 VS Code 没有影响，插件在远端提供功能，比如代码审查、自动补齐等等，而这所有的一切就像在本地操作一样。 细心的你可以发现，之前我们本地安装的插件大部分都处于 disabled 状态，此时 VS Code 提示： 1This extension is disabled in this workspace because it is defined to run in the Remote Extension Host. Please install the extension in 'SSH: TC-DeepCoding' to enable. 简言之，就是说你当前处于远程服务器状态，本地插件在当前状态下不生效，如果你想使用的话，请将其安装在服务器端。之后，我们的插件资源管理器就变成这样的了： 但请 注意：连接到一个新服务器时，插件是需要重新安装的，这是合理的。并且有些插件是不适合远程开发模式的，插件资源管理器中支持你 install 的才可以安装。 Remote Terminal终端调试时，打开的是远端服务器的终端，直接在终端操作编译或者查看云/服务器信息等，这和在远端服务器上使用是一样的。 Reffs: Configuration配置免密登录前面在使用账号密码进行 VS Code 登录远程主机时，你会发现每次登录都需要输入密码，太麻烦了/(ㄒoㄒ)/~~这时可以设置免密登录远程服务器，什么是免密登录？？！ 将本机添加到远程服务器连接白名单，让服务器知道是已认证的电脑在连接。过程类似于 GitHub 网站添加本地电脑的 SSH 公钥。 那么，如何设置？？！ 生成公私钥12345# 方法一$ ssh-keygen# 方法二，参考使用 Git 生成密钥$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot; 拷贝公钥文件至远程主机拷贝 id_rsa.pub 至远程 Linux 上的 ~/.ssh 下的 authorized_keys 文件中。 也可以使用命令： 12345# Local M:$ scp -P 22 id_rsa.pub user@ip-of-your-remote-host:/home/user/.ssh/id_rsa.pub# Remote Host$ cat ~/.ssh/id_rsa.pub &gt; ~/.ssh/authorized_keys 免密登录已经配置完成了~~~你可以尝试登录时是否需要输入密码了。 免密登录 == 密钥登录方式 应该有眼尖的看官老爷们会发现，这里为账号密码登录配置免密登录的方式，和前面给出的 Windows 下创建密钥对进行密钥登陆的方式很相似啊！ 这里，配置免密登录只是把想要登录远程服务器的客户端公钥放到了服务器的“信任名单（authorized_keys）”，当远程服务器请求登录密码时，发现当前请求的客户端是信任设备，会直接采用上面密钥登录（跳过提供密码的环节）的访问方式，只要客户端中持有相应私钥，就可以直接访问远程服务器。 但要注意的是，这里的私钥一定要和配置免密登录中的公钥是一对。例如 ssh-keygen 默认情况下生成的公私钥：id_rsa --&gt; id_rsa.pub，如果免密登录中你拷贝至远程服务器中的是 vs_remote_id_rsa_pub，那么你必须在 VS Code Remote 配置文件（config）中显式的配置 IdentityFile 选项为 vs_remote_id_rsa。默认情况下，会自动使用私钥 id_rsa。 SSH 默认 22 端口无法登录目前使用校园网，可能无法使用 SSH 默认端口连接服务器，提示可以将 SSH 端口换成 2222。 以下为流程: 1 –&gt; 登录阿里云或腾讯云控制台，找到对应的服务器的安全组设置； 2 –&gt; 添加安全组规则：端口：2222 ，ip：0.0.0.0/0; 3 –&gt; 手机热点登录服务器进行配置 上面只是让相关服务器的网络防火墙（安全组）启用 2222 端口，允许外网可通过 2222 端口访问服务器，但服务器中 SSH 仍然使用的 22 端口，所以这里需要修改服务器的 SSH 配置，更换其通信端口为 2222，具体步骤如下： 12345678# 打开 SSH 配置文件$ sudo vim /etc/ssh/sshd_config# 找到 `#Port 22` 配置项，修改端口为 `22`Port 2222# 配置完成后，重启 SSH 服务使其生效$ sudo service ssh restart 测试完成后，即可以使用远程登录工具 Xshell 或者 Putty 进行登录测试了。测试通过后，就可以修改 VS Code Remote 配置文件 config 中相应服务器配置，例如： 12345Host 81.xx.xxx.36 HostName 81.xx.xxx.36 User ubuntu Port 2222 IdentityFile ~/.ssh/id_rsa_remote_ssh 完结，撒花~~~","link":"/2017/08/02/wan-zhuan-vscode-zhi-pei-zhi-yuan-cheng-kai-fa-huan-jing/"},{"title":"Git 使用指南之初识","text":"在日常项目开发中，我们肯定会或多或少地听说或者使用过 版本管理工具。之前我刚好有幸参与过公司项目版本管理—–SVN 版本控制系统的搭建与管理，再加上项目组日常项目开发使用 SVN，也就没有花费太多精力去学习其它版本管理工具。 初次接触 Git 还是因为常常会从 GitHub clone 一些大佬们开源的深度学习项目以供学习和借鉴，但对 Git 的使用仅限于：git clone XYZ（脸红）。而随着身边越来越多的人开始使用 Git，以及学习和工作需要，才发现：这年头不会点 Git 是真不行啊… 版权说明： 本文思路以及内容主要来自廖雪峰老师的 Git 教程 （强烈推荐膜拜原文），并结合个人使用所作，只作为学习记录使用。如内容有侵权请联系删除，禁止转载！ 更多 Git 相关内容，请关注博主 Git 博文系列： 之一 &gt;&gt;&gt; Git 使用指南之初识 之二 &gt;&gt;&gt; Git 使用指南之时光穿梭机 之三 &gt;&gt;&gt; Git 使用指南之远程仓库 之四 &gt;&gt;&gt; Git 使用指南之分支管理 之五 &gt;&gt;&gt; Git 使用指南之 WorkFlow (工作流) 之六 &gt;&gt;&gt; Git 使用指南之 Git 自定义 之七 &gt;&gt;&gt; Git 使用指南之 HEAD 指针 之八 &gt;&gt;&gt; Git 使用指南之 Git 中的黑魔法 Git 简介和 SVN 类似，Git 也是用于版本控制。Git 是时下最流行的分布式版本控制系统，没有之一。 何为版本控制？我们一直在说版本控制，那么究竟什么是版本控制？ 其实说到版本控制，我总会想到大学毕业写论文时的场景，你电脑上的毕业论文一定也出现过和我一样的场景： 以上就是使用最原始的方式进行版本控制，可以发现 存在着显著缺点： 当保留所有版本文件时，需要为每个版本保存一个文件… 当文档需要多人协同操作时，需要将文件打包发来发去，拿到后还需要修改整合… 容易丢失，被删除意味着永远失去… 为了解决以上版本控制存在问题，应运而生了一批版本控制系统或工具：VSS、CVS、SVN、Git 等，其中 Git 已经成为当前最流行的分布式版本控制系统。通过使用这些版本控制工具，你就结束了手动管理多个 “版本” 的史前时代，进入到版本控制的新世纪。 通过以上样例的解读，下面我们给出关于版本控制更加严格的解读： 版本控制是指对软件开发过程中各种程序代码、配置文件、以及说明文档等文件变更的管理。 通俗来说 &gt;&gt;&gt; 版本控制最主要的功能就是追踪文件的变更。它将什么时候、什么人更改了文件的什么内容等信息忠实地了记录下来。每一次文件的改变，文件的版本号都将增加。这些功能均由版本控制系统帮忙维护。 除了记录版本变更外，版本控制的另一个重要功能是并行开发。软件开发往往是多人协同作业，版本控制可以有效地解决版本的同步以及不同开发者之间的开发通信问题，提高协同开发的效率。 Example &gt;&gt;&gt; 例如使用 Git 版本控制工具我们可以清晰、便捷的管理文档的不同版本，如下图所示： Git 的诞生我们知道，Linux 是开源的代名词，Linux 的系统日益壮大是靠全世界热心的志愿者共同参与的，这么多人在世界各地为 Linux 编写代码，那 Linus（Linux 项目发起者） 的代码是如何管理整合的呢？ 事实是，起初世界各地的志愿者把源代码文件发给 Linus，然后由 Linus 本人通过手工方式合并代码！ 你也许会想，为什么 Linus 不把 Linux 代码放到现有的版本控制系统里呢？不是有 CVS、SVN 这些免费的版本控制系统吗？因为 Linus 坚定地反对 CVS 和 SVN，这些集中式的版本控制系统不但速度慢，而且必须联网才能使用。有一些商用的版本控制系统，虽然比 CVS、SVN 好用，但那是付费的，这和 Linux 的开源精神不符。 不过，随着 Linux 系统的不断发展，代码库之大让 Linus 很难继续通过手工方式管理了，社区的弟兄们也对这种方式表达了强烈不满，于是 Linus 选择了一个商业的版本控制系统 BitKeeper，BitKeeper 的东家 BitMover 公司出于人道主义精神，授权 Linux 社区免费使用这个版本控制系统。 没几年，这种安定团结的大好局面就被打破了。原因是 Linux 社区牛人聚集，不免沾染了一些梁山好汉的江湖习气。开发 Samba 的 Andrew 试图破解 BitKeeper 的协议（这么干的其实也不只他一个），被 BitMover 公司发现了（监控工作做得不错！），于是 BitMover 公司怒了，要收回 Linux 社区的免费使用权。 Linus 可以向 BitMover 公司道个歉，保证以后严格管教弟兄们…… 嗯，这是不可能的。实际情况是这样的：Linus 花了两周时间自己用 C 写了一个分布式版本控制系统，这就是 Git！一个月之内，Linux 系统的源码已经由 Git 管理了！牛是怎么定义的呢？大家可以体会一下。 Git 迅速成为最流行的分布式版本控制系统 。尤其是 GitHub 的上线，它为开源项目免费提供 Git 存储，无数开源项目开始迁移至 GitHub。 GitHub 是一个基于 Git 的远程文件托管平台。Git 本身完全可以做到版本控制，但其所有内容以及版本记录只能保存在本机。如果想要将文件内容以及版本记录同时保存在免费远程服务器，则需要结合 GitHub 来使用。 集中式 VS 分布式Linus 一直痛恨的 CVS、SVN 都是集中式的版本控制系统，而 Git 是分布式版本控制系统，集中式和分布式版本控制系统有什么区别呢？ 集中式版本控制系统先说集中式版本控制系统，都有一个单一的集中管理的中央服务器，保存所有的项目版本库。而协同工作的人们首先都需要通过客户端连到这台中央服务器取出最新的文档版本进行修改，修改完成后需要提交更新给中央服务器完成服务器上的修改。 多年以来，这已成为版本控制系统的标准做法。 集中式版本控制系统缺点在于：中央服务器的单点故障。 如果中央服务器宕机一小时，那么在这一小时内，谁都无法提交更新，也就无法协同工作。 如果中心数据库所在的磁盘发生损坏，又没有做恰当备份，毫无疑问你将丢失所有数据————包括项目的整个变更历史，只剩下人们在各自机器上保留的单独快照。 只要整个项目的历史记录被保存在单一位置，就有丢失所有历史更新记录的风险。 分布式版本控制系统那分布式版本控制系统与集中式版本控制系统有何不同呢？ 首先，分布式版本控制系统根本没有“中央服务器”，每个人的电脑上都是一个完整的版本库。这也导致和集中式版本控制系统相比，分布式版本控制系统的安全性要高很多，因为每个人电脑里都有完整的版本库，某一个人的电脑坏掉了不要紧，随便从其他人那里复制一个就可以了。 既然每个人电脑上都有一个完整的版本库，那多个人如何协作呢？当然可以相互之间进行推送，但在实际使用分布式版本控制系统时通常也有一台充当“中央服务器”的角色（服务器），但这个服务器的作用仅仅是用来方便 “交换” 大家的修改，没有它大家也一样干活，只是交换修改不方便而已。 当然，Git 的优势不单是分布式这么简单，后面我们还会看到 Git 极其强大的分支管理，把 SVN 等远远抛在了后面。 Git Setup最早 Git 是在 Linux 上开发的，很长一段时间内，Git 也只能在 Linux 和 Unix 系统上跑。 目前，Git 已经为 Linux、Unix、Mac 和 Windows 等多平台提供了支持。这一部分我们来看如何在不同平台下完成 Git 的安装： Setup For LinuxLinux 平台下，Centos &amp;&amp; Ubuntu OS 中 Git 的安装过程。 Centos Ubuntu Others Linux OS Centos Setup MethodsCentos 中提供了两种 Git 的安装方法： YUM Method Source Code Method（Recommended） YUM Method For Centos Git Setup Cnetos 中采用 yum 的方法进行 Git 安装的详细过程如下： 推荐使用源码方式进行 Centos 下 Git 的安装，这是由于 Git 的安装版本完全取决于 yum 源中支持的 Git 版本（一般要比最新发布 Git 版本低），你可以选择直接跳至下一部分。 1 -&gt; 检测系统是否安装有 Git 123$ gitThe program 'git' is currently not installed. You can install it by typing:sudo yum install git 如果系统已安装 Git，你可以使用 git --version 查看相应的安装版本，确定是否需要重新安装 Git（一般 Centos 系统 Git 版本较低，以 Centos7 为例为：git version 1.8.3.1）。这里我们给出 GitHub 上的 Git 版本发布界面，你可以查看最新的 Git 版本。 如果未安装有合适版本 Git，则继续执行下面步骤： 2 -&gt; Git 安装 登陆待安装服务器，输入如下命令进行下载安装： 1234567891011121314151617181920212223242526272829303132333435363738$ yum install git##### 日志信息如下：已加载插件：fastestmirror, langpacksgitlab_gitlab-ee/x86_64/signature | 836 B 00:00:00 gitlab_gitlab-ee/x86_64/signature | 1.0 kB 00:00:00 !!! gitlab_gitlab-ee-source/signature | 836 B 00:00:00 gitlab_gitlab-ee-source/signature | 951 B 00:00:00 !!! Loading mirror speeds from cached hostfile * base: centos.ustc.edu.cn * extras: centos.ustc.edu.cn * updates: centos-mirror.rbc.ru正在解决依赖关系--&gt; 正在检查事务---&gt; 软件包 git.x86_64.0.1.8.3.1-14.el7_5 将被 升级--&gt; 正在处理依赖关系 git = 1.8.3.1-14.el7_5，它被软件包 perl-Git-1.8.3.1-14.el7_5.noarch 需要---&gt; 软件包 git.x86_64.0.1.8.3.1-20.el7 将被 更新--&gt; 正在检查事务---&gt; 软件包 perl-Git.noarch.0.1.8.3.1-14.el7_5 将被 升级---&gt; 软件包 perl-Git.noarch.0.1.8.3.1-20.el7 将被 更新--&gt; 解决依赖关系完成依赖关系解决========================================================================================================================================================================================================== Package 架构 版本 源 大小==========================================================================================================================================================================================================正在更新: git x86_64 1.8.3.1-20.el7 updates 4.4 M为依赖而更新: perl-Git noarch 1.8.3.1-20.el7 updates 55 k事务概要==========================================================================================================================================================================================================升级 1 软件包 (+1 依赖软件包)总下载量：4.4 M 接着服务器会询问是否进行安装，输入 y，然后等待安装完成即可（接上）： 1234567891011121314151617181920212223242526272829303132## 日志信息如下：总下载量：4.4 MIs this ok [y/d/N]: yDownloading packages:updates/7/x86_64/prestodelta | 182 kB 00:00:04 Delta RPMs reduced 4.4 M of updates to 2.6 M (41% saved)(1/2): perl-Git-1.8.3.1-14.el7_5_1.8.3.1-20.el7.noarch.drpm | 28 kB 00:00:02 (2/2): git-1.8.3.1-14.el7_5_1.8.3.1-20.el7.x86_64.drpm | 2.6 MB 00:00:18 Finishing delta rebuilds of 1 package(s) (4.4 M)----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------总计 126 kB/s | 2.6 MB 00:00:21 Running transaction checkRunning transaction testTransaction test succeededRunning transaction 正在更新 : git-1.8.3.1-20.el7.x86_64 1/4 正在更新 : perl-Git-1.8.3.1-20.el7.noarch 2/4 清理 : git-1.8.3.1-14.el7_5.x86_64 3/4 清理 : perl-Git-1.8.3.1-14.el7_5.noarch 4/4 验证中 : perl-Git-1.8.3.1-20.el7.noarch 1/4 验证中 : git-1.8.3.1-20.el7.x86_64 2/4 验证中 : git-1.8.3.1-14.el7_5.x86_64 3/4 验证中 : perl-Git-1.8.3.1-14.el7_5.noarch 4/4 更新完毕: git.x86_64 0:1.8.3.1-20.el7 作为依赖被升级: perl-Git.noarch 0:1.8.3.1-20.el7 完毕！ 3 -&gt; 验证安装是否成功 输入命令： git --version，查看安装好的 Git 版本，验证是否安装成功： 12[root@node3 ~]# git --versiongit version 1.8.3.1 接下来来看，Centos 中采用 源码包 的方法进行 Git 安装的详细过程： Source Code Method For Centos Git Setup（Recommended） 我们会发现，使用 yum 安装之后 Git 版本和当前最新版本之间仍然差很多版本号（Git 版本号不太好控制，取决于系统中 yum 源中最新 Git 版本），那么如何解决这个问题？ 除了使用 yum 安装，还可以使用 Git 源码进行编译安装，我们可以根据需要下载相应版本的 Git 源码包进行安装（源码下载请前往：Git 版本发布界面）。下面我将给出 Centos7 下如何通过源码安装 Git v2.20.0： 安装前我们首先需要移除系统原有 Git： 1[root@node3 Download]# yum remove git 1 -&gt; 在目录 Download 中下载相应 Git 版本源码包： 1[root@node3 Download]# wget https://github.com/git/git/archive/v2.20.0.tar.gz 2 -&gt; 解压 v2.20.0.tar.gz 安装包： 12345[root@node3 Download]# tar -zxvf v2.20.0.tar.gz# 查看当前目录，可看到解压文件：[root@node3 Download]# lsgit-2.20.0 v2.20.0.tar.gz 3 -&gt; 准备编译环境，否则后续安装可能发生 Error： 123[root@node3 Download]# yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel gcc perl-ExtUtils-MakeMaker# 等待安装或更新完成即可... 4 -&gt; 进入解压文件目录 git-2.20.0，然后进行 Git 源码的配置、编译以及安装命令，耐心等待即可： 12345678910111213141516171819[root@node3 Download]# cd git-2.20.0# 配置 Git 的安装路径：[root@node3 Download]# ./configure prefix=/usr/local/git/|--------------------------------------------------------------|### 注意此处可能报错：'-bash: ./configure: 没有那个文件或目录'。# 按照如下步骤解决：# 生成 configure：$ make configure $ ./configure prefix=/usr/local/git/# 如果 make configure 的时候报错：/bin/sh: autoconf: command not found$ yum install install autoconf automake libtool|--------------------------------------------------------------|# 编译以及安装 Git 源码：[root@node3 Download]# make &amp;&amp; make install 5 -&gt; 配置环境变量： 1234567# 打开系统配置文件：/etc/profile[root@node3 Download]# vim /etc/profile# 添加如下环境变量：export PATH=$PATH:/usr/local/git/bin# 激活环境变量：$ source /etc/profile 6 -&gt; 验证安装是否成功: 12[root@node3 Download]# git --versiongit version 2.20.0 Ubuntu Setup Methods较新版本的 Debian 或 Ubuntu Linux 系统一般都自带较高版本的 Git。如果没有，直接可通过下列命令就可以完成 Git 的安装: 1$ sudo apt-get install git 老一点的 Debian 或 Ubuntu Linux，要把命令改为: 1$ sudo apt-get install git-core 这是由于：有个软件也叫 GIT（GNU Interactive Tools），结果 Git 就只能叫 git-core 了。由于 Git 名气实在太大，后来就把 GNU Interactive Tools 改成 gnuit，git-core 正式改为 git。 Other Linux OS Setup Methods其它版本 Linux 可以统一采用源码安装，具体安装方法不一一列出，使用时请自行百度。 Setup For Windows这一部分我们来看 Win 平台下如何安装和配置 Git（未提到安装页面选择默认即可）： Setup Tips1 -&gt; 从 Git 官网下载一个 Git For Windows 安装包（官网下载地址，这里我们再提供一个 国内下载站点）： 2 -&gt; 双击安装程序，进入欢迎界面阅读协议，然后点击 【 Next 】： 3 -&gt; 选择 Git 安装位置，点击 【 Next 】： 4 -&gt; 选择安装组件：推荐使用默认选项，然后点击 【 Next 】： 图标组件（Additional icons）：选择是否创建快速启动图标和桌面快捷方式 桌面浏览（Windows Explorer integration）使用 Git Bash 方式、Shell 方式 是否关联 Git 配置文件：该配置文件主要显示文本编辑器样式 是否关联 Shell 脚本文件：是否关联 Bash 命令执行脚本文件 使用 TrueType 编码：在命令行中是否使用 TrueType 编码，该编码是微软和苹果公司制定的通用编码 5 -&gt; 在开始菜单创建快捷方式，然后点击 【 Next 】： 6 -&gt; 选择默认的 Git 编辑器（默认 VIM），然后点击 【 Next 】： 7 -&gt; 设置环境，设置命令行工具（默认配置即可），然后点击 【 Next 】： Git自带：使用 Git 自带的 Git Bash 命令行工具； 系统自带以及第三方软件：使用 windows 系统以及第三方软件命令行工具； Git 自带和 Unix Tools：注意，这样会将 windows 中的 find.exe 和 sort.exe 工具覆盖，如果不懂这些尽量不要选择。 8 -&gt; 选择换行格式，然后点击 【 Next 】： 检查出 Windows 格式转换为 Unix 格式：将 Windows 格式的换行转为 Unix 格式的换行再进行提交; 检查出原来格式转换为 Unix 格式：不管什么格式的，一律转换为 Unix 格式的换行再进行提交； 不进行格式转换：不进行转换，检查出什么格式就提交什么格式。 9 -&gt; 配置 Git bash 终端仿真器（默认即可），然后点击 【 Next 】： 使用 MinTTY 终端 使用 Windows 默认的命令行 10 -&gt; 性能配置，是否启用文件系统缓存（默认即可），然后点击 【 install 】 等待安装完成即可： Git EnvsVar Config有时安装完成以后可能在 Windows CMD 中无法正常使用 Git，可以将 GIT_HOME/bin 添加到系统环境变量 path 中，就可以在 CMD 中正常使用 Git了。 Git Bash Here上面我们已经完成了 Git 的安装以及配置过程，这里我们可以尝试在 Windows 下打开 Git Bash 来看一下： 是不是不同于我们熟悉的 Linux shell 或者 Windows CMD？！！下面给出一种 Git 控制台美化方法： Git 控制台格式以及字体美化 &gt;&gt; 详细优化过程如下： 1 -&gt; 下载必要的配置文件： 12345678910### Git 控制台中 clone 美化配置仓库：$ git clone https://github.com/TheNightIsYoung/Git-Setting.git# 查看项目可以发现有 2 个文件目录：$ ls Git-SettingGit-Bash YaHei-Consolas-Hybrid-1.12# 仓库说明：## 1. Git-Bash ： Linux Shell 样式配置库以及说明## 2. YaHei-Consolas-Hybrid-1.12 ： 字体配置库以及说明 2 -&gt; 配置 Linux Shell 样式以及 YaHei 字体 Linux Shell 样式配置方法如下（操作文件见 Git-Bash 目录）： 1234# 将 git-completion.bash 配置文件 copy 当前用户主目录；# 将 git-prompt.sh 配置文件 copy 当前用户主目录；# 将 bash_profile_course 配置文件 copy 当前用户主目录，如果当前用户主目录中已存在名为 .bash_profile 的文件，则将 bash_profile_course 中的内容复制并粘贴到 .bash_profile 的尾部。如果不存在，通过 mv 命令将 bash_profile_course 重命名为 .bash_profile。 自此，关闭 Git Bash 再重新打开，你会发现其格式已经变为我们熟悉的 Linux Shell 样式： 有一个 Yahei 和 Consolas 的混合字体，相当漂亮，很适合在 Windows 平台下编程使用，我们之前已经从 GitHub 上 clone 了下来。 关于 Yahei 字体的配置使用方法，可见 YaHei-Consolas-Hybrid-1.12 目录中 README.md 说明文件。 后面的同学别睡了，正文开始 …… Git 的安装、配置、优化完成之后，下面正式开始进行 Git 的学习以及使用： 初识 Git Repository前面我们一直在提 Git 分布式系统中的每一个节点（用户设备）都是一个完整的版本库。那什么是版本库呢？！！版本库又名版本仓库（Repository）。 Repository 可以简单理解成一个目录，这个目录里面的所有文件都可以被 Git 管理起来。什么时候、什么人更改了目录下文件的什么内容等信息都能被 Git 忠实地跟踪以及记录下来。以便 Git 任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。 使用前，你需要明确（重要！重要！重要！）： 所有的版本控制系统，其实 只能跟踪文本文件的改动，比如TXT文件，网页，所有的程序代码等等，Git 也不例外。 版本控制系统可以告诉你文本文件每次的变更，比如在第 5 行加了一个单词 “Linux”，在第 8 行删了一个单词 “Windows”。 而图片、视频这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是只知道图片从 100KB 改成了 120KB，但到底改了啥，版本控制系统不知道，也没法知道。最初我使用过一个毕设论文示例其实是不恰当的，Microsoft Word 格式是二进制格式，因此 Git 是没法直接跟踪 Word 文件的改动的。 注意，上面我说的是 没法直接，并不是不能！需要使用第三方转化软件的协助 ，才可以进行版本控制。 还有一个很重要的问题就是 文本的编码问题。强烈建议使用标准的 UTF-8 编码，所有语言使用同一种编码，既没有冲突，又被所有平台所支持。 Config User &amp;&amp; E-Mail版本仓库用户以及邮箱设置 –&gt;&gt;&gt; 我们知道，Git 是分布式版本控制系统，所以每个机器都必须自报家门：你的名字和 Email 地址。也就是说在使用之前我们还需要为 Git 中的版本仓库设置用户以及邮箱。 通常我们会面临一种场景：公司工作时，我们一般会参与多个项目开发，而向不同的项目提交变更时，一般请求情况下提供的用户都是同一个，而我们为了方便可能会使用 全局设置 对 Git 进行统一的配置；但当我们处于学习变更自己的学习项目时，我们可能更多地不希望使用公司公用的用户以及邮箱配置，这就涉及到为特定的仓库（项目）进行 单独设置。 模拟场景： 公司参与多个项目：A、B、C、D，用于提交的公司用户名是：”staff_ming”，会使用 Git 全局配置； 个人学习项目：E，用于提交的个人学习用户名是：”Pilot_ming”,会为项目 E 进行单独配置。 全局配置步骤 1）Git Bash 控制台执行： 12345$ git config --global user.name &quot;staff_ming&quot;$ git config --global user.email &quot;staff_ming@xxxx.com&quot;# 使用 git config --list 可查看到 Git 全局配置 2）可在当前用户目录下生成一个 .gitconfig 配置文件，可以查看文件内容中的配置信息： 123[user] name = staff_ming email = staff_ming@163.com 注意 git config 命令的 --global 参数表示：当前机器上所有的 Git 版本仓库都会使用这个配置。 单独配置项目步骤 1）Git Bash 中进入项目所在目录（后续学习后你会知道 Git 管理下的项目目录会产生一个 .git 目录），执行： 12345$ git config user.name &quot;Pilot_ming&quot;$ git config user.email &quot;Pilot_ming@163.com&quot;# 使用 git config --list 可同时查看到 Git 全局以及当前项目配置 2）可在当前项目目录下的 .git 目录中生成一个 config 配置文件，可以查看当前仓库的配置信息。 用户名和邮箱配置之后，简单进行以下 Git 的实操。系列博文实操部分测试均在 Windows10 下完成，Linux 平台下同理。 Manage A New Project假设要新建一个 GitTest 的项目，要使用 Git 进行管理，你有两方面的工作要做： 创建 GitTest 版本库 –&gt;&gt;&gt; GitTestProject； 添加文件到版本库进行版本管理 1 –&gt; How To Create Git Repo 事实上，创建一个全新的 Git 版本库（由 Git 进行版本管理的项目目录）非常简单: 1）创建版本库目录（项目目录）： 123# Windows 系统下，为了避免遇到各种莫名其妙的问题，请确保目录名（包括父目录）不包含中文。$ mkdir GitTestProject$ cd GitTestProject 2）初始化版本库： 12345678910# git init 命令可以将当前目录变成 Git 可以管理的版本库：$ git initInitialized empty Git repository in F:/GitTestProject/.git/# 查看版本库（产生一个 .git 目录）：$ ll -altotal 8drwxr-xr-x 1 staff_ming 197121 0 12月 20 18:55 ./drwxr-xr-x 1 staff_ming 197121 0 12月 20 18:46 ../drwxr-xr-x 1 staff_ming 197121 0 12月 20 18:55 .git/ 注意：初始化后，会在当前目录自动创建 .git 目录（意味着 Git 来跟踪管理版本库的），该文件是 Git 中最重要的文件夹，因为 Git 相关文件以及版本都将保存 .git 中，.git 受损 Git 版本仓库就会被破坏掉。 如何添加文件到版本库中进行版本管理？ –&gt;&gt;&gt; 2 –&gt; How To Add A File To Repo For Vers Management 来看一下，一个简单的文本文件如何能够被 Git 版本库管理： 1234567891011121314151617# 1. 在版本库 GitTestProject 中创建一个用于 Git 管理的新文档：readme.txt，内容如下Git is a version control system.Git is free software.# 2. 创建好 readme.txt 之后并不意味着文档已被版本库所管理，需要告知 Git 把文件添加到仓库：$ git add readme.txt# 执行上面的命令，没有任何显示。Unix 的哲学是“没有消息就是好消息”，说明添加成功。# 3. git add 之后，我们还需要提交操作到仓库（后续我们会做解释）：$ git commit -m &quot;wrote a readme file&quot;# 日志信息如下表示成功：# 1 file changed：1 个文件被改动；2 insertions：插入了两行内容[master (root-commit) c31b827] wrote a readme file 1 file changed, 2 insertions(+) create mode 100644 readme.txt 注意：git commit 命令之后的 -m 参数表示的是：本次向 Git 版本库提交的说明（变更注释）。强烈建议添加变更说明！！！不加 -m 参数 Git 会跳转进入 VIM。 初次使用 git add 命令可能会产生： Warning： LF will be replaced by CRLF in ** 的警告信息，更多请参看：Warning：LF &amp;&amp; CRLF 部分。 事实上，我们更多的时候是需要在非空目录（既有项目）下使用 Git 管理，这也是可以的。 Manage A Existing Project|============================================================== 既存项目目录结构说明： GitTestProject 版本库包含：Server 目录、Client 目录、以及 readme.txt 说明文档。 Server 目录下包含一个名为：service.py 的文件，内容为： 1# This is a Test! Client 目录“看作”是一个空目录（仅包含一个名为 .gitignore 的占位文件，见后文说明）。 readme.txt 文件内容为： 12Git is a version control system.Git is free software. ==============================================================| 假设要使用 Git 管理一个既存的、名为 GitTestProject 的项目，你有两方面的工作要做： 初始化 GitTestProject 为版本库； 添加项目目录中的文件到版本库开启版本管理 1 –&gt; 初始化项目目录（GitTestProject）为版本库 12345678910111213141516# 进入项目目录$ cd GitTestProject# git init 命令可以将当前目录变成 Git 可以管理的版本库：$ git initInitialized empty Git repository in F:/GitTestProject/.git/# 查看版本库（产生一个 .git 目录）：$ ll -altotal 5drwxr-xr-x 1 Jie Guo 197121 0 8月 18 21:59 ./drwxr-xr-x 1 Jie Guo 197121 0 8月 18 16:36 ../drwxr-xr-x 1 Jie Guo 197121 0 8月 18 21:59 .git/drwxr-xr-x 1 Jie Guo 197121 0 8月 18 21:57 Client/-rw-r--r-- 1 Jie Guo 197121 55 8月 18 21:58 readme.txtdrwxr-xr-x 1 Jie Guo 197121 0 8月 18 21:58 Server/ 2 –&gt; 添加项目目录中的文件到版本库开启版本管理 非空目录下创建 Git 版本库，git init 之后版本库目录下的文件其实并没有被 Git 管理，想要将其填加到版本库的话可以： 12345678# git add + dir(目录)会将 dir 以及其下所有文件添加到 Git 版本库：$ git add Server/ Client/# 提交：$ git commit -m 'ADD Project Base'[master d9e0247] ADD Project Base 1 file changed, 1 insertion(+) create mode 100644 Server/service.py 补充：git add . 可以将当前目录下所有文件添加到版本库。 注意，项目中的空文件夹（空目录）不会被管理！！！解决方法：可以在相应目录添加 .gitkeep 或者 .gitignore 占位文件（不起其它作用）。 ================================== 恭喜你，通过 Git 的安装、配置以及简单测试说明，相信你已经对 Git 版本控制有了一定的理解了，后续博文将带你更进一步掌握 Git 版本控制的使用~ Warning：LF &amp;&amp; CRLF初次安装好 Git 之后，使用 git add 命令时，可能会产生警告 Warning： LF will be replaced by CRLF in **&lt;file&gt; 这是由于文本中存在换行符引发的，LF &amp;&amp; CRLF 事实上都是换行符（一行文本的结束）。 1 –&gt; LF（Line Feed）&amp;&amp; CRLF（Carriage Return） LF 代表：“换行”，是 Linux 和 Unix 系统的换行符。CRLF 代表：“回车”，是 Windows 系统的换行符。 2 –&gt; Git 换行符自动转换功能 不同操作系统下换行符规则的差异，给跨平台的协作的项目带来了问题，文件中到底是使用哪个规则呢？Git 中为了解决这个问题，提供了一个 ”换行符自动转换” 的功能，并且这个功能是默认处于”自动模式“即开启状态的。 换行符自动转换功能 会自动将文本（代码）里当前操作系统不相同的换行的方式，转换成当前系统的换行方式（即 LF 和 CRLF 之间的转换）。这样，当提交代码的时候，即使没有修改过某个文件，也被 Git 认为你修改过了，从而提示 LF will be replaced by CRLF in **。 3 –&gt; 解决办法 使用如下命令可以将 Git 的换行符自动转换功能关闭掉（不推荐）： 实际编程中，Warning 级别的警告是可以忽略的，当然你可以选择将自动转换功能关掉（强迫症~），但这里 不推荐关闭！！！ 12345# 仅对当前版本库生效git config core.autocrlf false# 全局有效git config --global core.autocrlf false 选择策略 &gt;&gt;&gt; 如果可以保证你的项目（代码，文档）不会跨平台，你可以设置关掉自动转换的功能。 否则，如果你和你的合作者用不同的系统进行工作时，关掉这个自动转换的功能可能会导致文档显示异常，此时不建议关闭。","link":"/2017/07/01/git-shi-yong-zhi-nan-zhi-chu-shi/"},{"title":"Git 使用指南之分支管理","text":"Git 的分支管理。使用过 SVN 等其它版本控制系统的童鞋可能会说：“SVN 也有分支管理啊”。但由于创建和切换分支慢的一批…那么，Git 分支管理功能有性能提升吗？”。 当然有！Git 的分支是与众不同的。无论创建、切换和删除分支，Git 都能在 1 秒钟 之内就能完成！无论你的版本库是 1 个文件还是 1 万个文件。这种跟版本库大小无关的特性，到底是怎么做到的？？！。 版权说明： 本文思路以及内容主要来自廖雪峰老师的 Git 教程 （强烈推荐膜拜原文），并结合个人使用所作，只作为学习记录使用。如内容有侵权请联系删除，禁止转载！ 更多 Git 相关内容，请关注博主 Git 博文系列： 之一 &gt;&gt;&gt; Git 使用指南之初识 之二 &gt;&gt;&gt; Git 使用指南之时光穿梭机 之三 &gt;&gt;&gt; Git 使用指南之远程仓库 之四 &gt;&gt;&gt; Git 使用指南之分支管理 之五 &gt;&gt;&gt; Git 使用指南之 WorkFlow (工作流) 之六 &gt;&gt;&gt; Git 使用指南之 Git 自定义 之七 &gt;&gt;&gt; Git 使用指南之 HEAD 指针 之八 &gt;&gt;&gt; Git 使用指南之 Git 中的黑魔法 Meet Branchs Management从使用场景上解释，是这么个概念： 【场景模拟】 ↓↓↓↓ 参与一个项目开发任务，需要为在线平台增加一个新功能，半个月过去了，开发任务按照预期完成了 50%，就在此时在线平台突然出现 BUG …… 如果立刻提交，由于代码还未完成，不完整的代码库会影响项目内其他人工作；如果等代码全部写完再一次提交，又存在丢失工作进度的巨大风险。 【解决思路】 &gt;&gt;&gt;&gt; 使用 Git 分支管理 可以帮助你完美解决上述问题~~~ 借用一句话就是：分支就像是科幻电影里面的平行宇宙，当你正在电脑前努力学习 Git 的时候，另一个你正在另一个平行宇宙里努力学习 SVN。如果两个平行宇宙（两条平行的时间线）互不干扰，那对现在的你也没啥影响。并且如果在某个时间点，两个平行宇宙合并了，结果你既学会了 Git 又学会了 SVN！ 有了分支管理，你可以创建一个属于你自己的分支，项目内其他人是无法看到的，还继续在原来的分支（master）上正常工作。而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，既安全，又不影响别人工作。 Branch 指针深入一点理解分支的（本质）话，是这么个概念： Git 中的分支，本质上仅仅是 指向提交对象（Commit objects）的可变指针，指向当前的最新提交（Commit，也称为：快照）。 在介绍版本回滚时，我们曾提到过：每次提交，Git 都把它们串成一条时间线，这条时间线就是一个分支，指针指向时间线上的最新时间点（commit）。 实际上，当我们起初使用 Git 的时候，就已经使用到分支了，因为 Git 的默认分支名字是 master，如果你有心的话，会发现执行 git init 后，命令行的输出头部已经默认在 master 分支了。 但是这个时候，还并未创建 master 分支，只有当有一个提交的时候，才会创建 master 分支。原因在于，分支的指针要指向提交的呀。 这里需要重新认识一下 HEAD 指针，你才能更深入的了解 Branch 的使用： HEAD 指针前面，我们介绍过 HEAD 指针是一个特别的指针，用于记录当前工作的位置（当前版本库所处的分支，以及当前分支的提交点）。 严格来说，一般情况（默认）下 HEAD 指针不是直接指向 commit 的，而是指向 branch 的，branch 才是指向提交的！！！ 事实上，HEAD 指针除了可以指向 branch 也可以移动 HEAD 指针指向快照（commit），但当 HEAD 指向 branch 时且执行提交操作（git add）后会和 branch 指针一起向后移动；当 HEAD 不指向 branch（指向分支上的某一个 commit）时且执行提交（git add）后会使得 HEAD 指针处于特殊的 detached（[dɪˈtætʃt]，游离）状态，关于 HEAD 指针在 detached 状态的说明可参加系列博文。 通俗来讲，分支（Branch）代表着不同的基于主时空（master branch）的平行时空，无干预时互不影响。HEAD 指针等同于处于不同平行宇宙时间线下的 你自己：你在哪儿（时间点），指针就在哪；你在哪个分支（时间线），HEAD 指针就指向哪个分支的指针。 Branch Working Principle Diagram这一小节，我们通过图解的方式来简单分析一下： Git 分支管理的工作机制，来增强对 Git 分支的认识。 我们知道，一开始的时候，Git 默认创建的 master 分支是一条线，Git 用 master 指向最新的提交，再用 HEAD 指向 master，就能确定当前分支，以及当前分支的提交点。 master 分支上，每一次提交，master 分支都会向前移动一步，随着你不断提交，master 分支的线也就越来越长： 创建并切换分支时（以 develop 分支为例），Git 将新建一个指针 develop，并将 develop 指针指向 master 相同的提交，然后再将 HEAD 指向 develop。表示当前分支在 develop 上： 这也可以看出，为什么 Git 创建分支会如此之快，工作区的文件都没有任何变化，并且只是增加了一个 develop 指针以及改变了 HEAD 的指向，此后对工作区的修改和提交就是针对 develop 分支了。 比如新提交一次后，develop 指针往前移动一步，而 master 指针不变： 一段时间后，我们成功在 develop 分支上完成新功能的开发，此时我们想把新功能整合到在线平台，也就是想把 develop 合并到 master 上，Git 如何实现呢？最简单的方法，就是直接把 master 指向 develop 的当前提交，就完成了合并： 可以看出，Git 合并分支也很快！就改改指针，工作区内容也不变！合并完分支后，甚至可以删除 develop 分支。删除 develop 分支就是把 develop 指针给删掉，删掉后，我们就剩下了一条 master 分支： 通过上面的学习，相信你已经对 Git 的分支管理有了相对深入的认识，下面正式开始 Git 分支管理的学习： 玩转 Branch 必备技能有关分支的命令不多，无非是换着花样的增删改查，掌握好以下基本的命令，以后就可以在 Branch 的草原上策马奔腾潇潇洒洒啦~~~ 重要的分支操作命令格式：CMD 13 –&gt;&gt;&gt; git branch &lt;options&gt; 创建分支创建分支的命令非常简单，命令格式如下： 1$ git branch &lt;branch name&gt; 使用起来非常简单，似乎简单到你只需要想个分支的名字就好了。但是在创建分支的时候，要想下：是否要从当前分支的内容基础上去开辟一条新分支？？？ 查看分支如何查看本地仓库以及远程库中的分支情况呢？三个命令，让你想看什么分支就看什么分支： 1 –&gt; 如何查看本地分支： 1$ git branch 2 –&gt; 如何查看远程分支： 1$ git branch -r 3 –&gt; 如何查看本地和远程的所有分支： 1$ git branch -a 重命名分支实际项目开发过程中，有时会涉及到 分支的重命名： 【场景一】：重命名本地分支 当本地的开发分支还没有推送到远程分支的时候，会在本地进行分支的重命名。 在当前分支时: 1$ git branch -m &lt;new branch name&gt; 不在当前分支时: 1$ git branch -m &lt;old branch name&gt; &lt;new branch name&gt; ====================================================================== 如果是已经推送到远端，应该怎么做呢？ 【场景二】：重命名远程库分支 假设是在当前分支，并且远端分支与本地分支名是一致的。 重命名本地分支 1$ git branch -m &lt;new branch name&gt; 删除远程分支 1$ git push origin --delete &lt;old branch name&gt; 上传新命名的本地分支 1$ git push origin &lt;new branch name&gt; 关联修改后的本地分支与远程分支 1$ git branch --set-upstream-to origin/&lt;new branch name&gt; 检出/切换分支检出分支的 “检出” 二字，算是个关于 Git 分支的专业术语了,可以理解为切换当前分支。 CMD 14 –&gt;&gt;&gt; git checkout &lt;-b&gt; &lt;branch name&gt; 当 checkout 表征 “检出” 含义时，checkout 操作是移动 HEAD 指针，将 HEAD 指针指向要切换的分支的指针处。 使用场景有两个： 已经存在的分支，现在要切换过去。 1$ git checkout &lt;branch name&gt; 创建一个新分支，且切换到新分支，这个一步到位的话需要 -b 参数 以当前分支为基础，创建一个新分支： 1$ git checkout -b &lt;branch name&gt; 以指定的某一个提交，创建一个新分支： 1$ git checkout -b &lt;branch name&gt; &lt;Commit-ID(SHA1)&gt; CMD 15 –&gt;&gt;&gt; git switch &lt;-c&gt; &lt;branch name&gt; 记忆力好的看官可能想到，前面撤销修改操作使用过 git checkout -- &lt;file&gt;，太迷惑了……事实上，Git提供了新的 git switch 命令来专门处理分支切换。 对应 checkout 的两种使用场景： 已经存在的分支，现在要切换过去。 1$ git switch &lt;branch name&gt; 创建一个新分支，且切换到新分支，这个一步到位的话需要 -b 参数 以当前分支为基础，创建一个新分支： 1$ git switch -c &lt;branch name&gt; 删除分支分支生命周期完成后，我们就可以放心删除了： 当本地分支删除后，推动到远程仓库后，远程仓库并不能自动删除对应的远程分支。意味着，分支的完全删除是分两个部分的： 本地分支的删除 远程分支的删除。 1 –&gt; 删除本地分支： 123456## 1. 一般删除：删除前会检查 merge 状态，只有满足删除条件才会执行删除操作$ git branch -d &lt;lacal branch name&gt;## 2. 强制删除：会直接执行删除操作# 如果要丢弃一个没有被合并过的分支，可以通过-D 强行删除$ git branch -D &lt;local branch name&gt; 参数 -D 比 -d 要粗暴一点。当被删除分支有新内容没有被合并的时候，使用 -D，会直接删除；使用 -d，会提示该分支有新内容没有被合并，不执行删除。删除需谨慎，建议非特殊情况下，使用温柔的 -d 要好一点，以免小手一抖，/(ㄒoㄒ)/~~ 2 –&gt; 删除远程分支： 1$ git push origin --delete &lt;remote branch name&gt; 以上，是分支的增删改查独立操作，但是 Git 创造这个分支，并不只是为了让它们自个儿和自个儿玩的，还需要它们之间的相互协作和配合。 就像日常项目开发过程中，分好开发任务，你和你的小伙伴新建了两个分支，你写你的 Butter，他写他的 Fly,到开发完成之后，肯定要合在一起，才能成就 Butterfly。合的这个动作，就涉及到了分支合并的概念。 Branch 合并大事记合并指定分支到当前分支的命令格式为：CMD 16 –&gt;&gt;&gt; git merge &lt;branch name&gt; git merge 命令可以加 -m &quot;message&quot; 参数添加合并提交日志。 Git 中分支的合并是非常智能的，目前有两种模式。两种模式的选择，不需要我们参与，而是 Git 根据分支情况不同，自行判断选择最适合的 Merge 模式。 个人在使用 Git 的过程中，执行分支合并时：有时需要输入提交信息，有时不需要，起初作为小白的我懵的不知所以然，后来才知道，原来是合并模式的问题啊！！！ 两种合并模式是： Fast-Forward（快进式） Recursive Strategy Merge（递归策略合并式，也称为三方合并式） Fast-Forward 如图，有两个分支，master 分支和 feature 分支。当这两个分支处于上面的关系时，当进行合并操作时，就会出现 fast-forward。 【说明】：由于当前 master 分支所指向的提交是 feature 分支的直接上游，所以 Git 只是简单的将指针向前移动。换句话说，当你试图合并两个分支时，如果顺着一个分支走下去能够到达另一个分支，那么 Git 在合并两者的时候，只会简单的将指针向前推进（指针右移）—-&gt;这就叫做 “快进（fast-forward）”。 合并后的分支指针位置如下： Recursive Strategy Merge这个合并方式，是为补充 fast-forward 而出现的。 因为你知道，在项目开发过程中，很多人开发的情况下，出现 fast-forward 的情况并不是很多，很多是类似下面这种。提交历史是分叉的，无法满足执行 fast-forward 的条件： 【说明】：，master 分支所在提交并不是 feature 分支所在提交的直接上游（祖先），Git 不得不做一些额外的工作。 出现这种情况的时候，Git 会使用两个分支的末端所指的快照（C4 和 C5）以及这两个分支的工作祖先（C3），做一个简单的三方合并,生成一个新的提交（C6）。 Branch Demo【2.玩转 Branch 必备技能】 &amp;&amp; 【3.Branch 合并大事记】，说起来就是一堆理论，这一小节我们基于 GitTestProject 来实操一下： 1）从 master 分支末尾，创建并切换 featureA 分支，并创建一个提交： 1234$ git checkout -b featureA$ touch ATest.txt$ git add .$ git commit -m &quot;Add ATest File For featureA&quot; 2）从 master 分支末尾，创建并切换 featureB 分支，并创建一个提交： 12345$ git checkout master$ git checkout -b featureB$ touch BTest.txt$ git add .$ git commit -m &quot;Add BTest File For featureB&quot; 3) 切换回 master 分支 1$ git switch master 测试分支 featureA &amp;&amp; featureB 完成后，就可以开始尝试分支的合并功能了： 4) Fast-Forward 合并 master 分支合并 featureA 时，是快进式合并： 123456$ git merge featureAUpdating 79c3a2c..fc2702bFast-forward ATest.txt | 0 1 file changed, 0 insertions(+), 0 deletions(-) create mode 100644 ATest.txt 图例如下： 5) Recursive Strategy Merge 合并 master 分支合并 featureA 后， 再合并 featureB 时，已经不满足快进式条件了，此时合并会触发一个三方合并，产生一个新的提交。 执行合并 featureB 命令，会跳到一个 VIM 页面，让我们编辑这个新提交的提交信息，你可以看到默认的提交信息是 “Merge branch ‘branch name’”。此时，按 i 进入编辑模式可编写提交信息, 编写好后，通过 ： + wq 保存并退出 VIM 页面即可完成合并。 12345$ git merge featureBMerge made by the 'recursive' strategy. BTest.txt | 0 1 file changed, 0 insertions(+), 0 deletions(-) create mode 100644 BTest.txt 图例如下： 最后再提供一下用来查看分支合并图的命令： CMD 16 –&gt;&gt;&gt; git log –graph –pretty=oneline –abbrev-commit 12345678910111213 $ git log --graph --pretty=oneline --abbrev-commit* 5f264b1 (HEAD -&gt; master) Merge branch 'featureB'|\\| * 4528426 (featureB) Add BTest File For featureB* | fc2702b (featureA) Add ATest File For|/* 79c3a2c (origin/master) Add git_rm_test.txt* fe3235b git tracks changes* d6ddc31 Git local data management test* 0f5a696 understand how stage works* ebba382 Add test code* da1fadc Add help info* 65586b3 ADD Project Base 其中，--pretty=oneline 参数表示提交以单行显示，--abbrev-commit 参数表示减少头部数据（缩短 SHA1 数值）。 No Fast ForwardFast Forward 意为 “快进模式”。主要使用在多分支合并的情况下。即：当前分支合并另一个分支的时候（如果合并的过程中没有 Conflict 冲突的时候，关于 Conflict 的说明见下一小节，这里不用深究），则会通过直接移动两个分支的指针，来达到合并的过程，这个过程就叫做 Fast Forward。 那么，何为 No Fast Forward？？？No Fast Forward 指的是，合并时禁用 fast forward 模式，采用 Recursive Strategy Merge 模式进行合并。 为什么要禁用 Fast Forward 模式，这就不得不提到 Fast Forward 的弊端了： 1 –&gt; Fast Forward 弊端 在 Fast Forward 模式下，当我们 merge 合并后，将会删除无用的分支。即：删除分支后，会丢掉分支的所有信息。 什么是丢掉分支信息呢？看下面的例子 &gt;&gt;&gt; 假设，新建一个名为 dev 的分支，在分支上进行了两次操作：1.Func-Add User；2.Func-Add Permission，然后切换至 master 主分支，使用 Fast Forward 模式进行合并分支，查看日志信息如下： 12345678910111213$ git merge devUpdating 5f264b1..8a39810Fast-forward dev_function.txt | 2 ++ 1 file changed, 2 insertions(+) create mode 100644 dev_function.txt$ git log --graph --pretty=oneline --abbrev-commit* 8a39810 (HEAD -&gt; master, dev) Func-Add Permission* 3d6d64d Func-Add User* ebba382 Add test code* da1fadc Add help info* 65586b3 ADD Project Base 可以看到，对于功能 Func-Add User &amp;&amp; Func-Add Permission，无法判断是 master 分支还是 dev 分支提交的。 怎么办？？？ 2 –&gt; No Fast Forward(–no-ff) 如果要强制禁用 Fast Forward 模式，Git 就会在 merge 时生成一个新的 commit，这样，从分支历史上就可以看出分支信息。命令格式如下： 1$ git merge --no-ff -m &quot;message&quot; &lt;branch name&gt; 对比一下： 1234567891011121314151617181920212223$ git switch masterSwitched to branch 'master'Your branch is ahead of 'origin/master' by 5 commits. (use &quot;git push&quot; to publish your local commits)$ git merge --no-ff -m &quot;Merge with no-ff&quot; devMerge made by the 'recursive' strategy. dev_function.txt | 3 +++ 1 file changed, 3 insertions(+)$ git log --graph --pretty=oneline --abbrev-commit* 28157d9 (HEAD -&gt; master) Merge with no-ff|\\| * 02636d0 (dev) Func-Add Permission(no-ff)| * b324182 Func-Add User(no-ff)|/* ================= Shortcut Line ================* 8a39810 Func-Add Permission* 3d6d64d Func-Add User......* ebba382 Add test code* da1fadc Add help info* 65586b3 ADD Project Base 可以看到，使用 no-ff 合并的方式可以保留分支信息。 如果合并分支之后，将 dev 分支删除了，你就找不到 dev 分支了，但在分支示意图上仍然可以看到分支结构： 1234567891011121314151617$ git branch -d devDeleted branch dev (was 02636d0).$ git log --graph --pretty=oneline --abbrev-commit* 28157d9 (HEAD -&gt; master) Merge with no-ff|\\| * 02636d0 Func-Add Permission(no-ff)| * b324182 Func-Add User(no-ff)|/* ================= Shortcut Line ================* 8a39810 Func-Add Permission* 3d6d64d Func-Add User*......* ebba382 Add test code* da1fadc Add help info* 65586b3 ADD Project Base |———————————————————— 友情提示： 我们知道 Git 创建、合并和删除分支都非常快（操作指针）。所以，Git 鼓励用户使用分支完成某个任务，合并后再删掉分支，这和直接在 master 分支上工作效果是一样的，但过程更安全。 ————————————————————| 和平解决 Branch 合并冲突有人在的地方就有江湖，有分支在的地方，就有冲突~~~ 很多时候，合并操作不会如此顺利。 如果你在两个不同的分支中，对同一个文件的同一个部分进行了不同的修改，Git 就没法干净的合并它们，于是就会发生冲突。 例如，分别在 master 和 featureA 下，在 ATest.txt 文件添加一行任意内容，然后两个分支合并，就会发生冲突。 1234$ git merge featureAAuto-merging ATest.txtCONFLICT (content): Merge conflict in ATest.txtAutomatic merge failed; fix conflicts and then commit the result. 这是，可以通过 git status，查看冲突的详细信息。冲突提示信息中，指明冲突文件为： ATest.txt。 1234567891011121314(master *+|MERGING) GitTestProject $ git statusOn branch masterYour branch is ahead of 'origin/master' by 9 commits. (use &quot;git push&quot; to publish your local commits)You have unmerged paths. (fix conflicts and run &quot;git commit&quot;) (use &quot;git merge --abort&quot; to abort the merge)Unmerged paths: (use &quot;git add &lt;file&gt;...&quot; to mark resolution) both modified: ATest.txtno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 需要说明的是：如果遇到冲突的话，git 就无法自动合并了，接下来要靠我们自己手动解决冲突，方法是： 查看造成冲突的文件，修改冲突部分; 对修改后冲突文件，执行 git add 操作; 创建一个修改冲突的提交。 先了解一下发现冲突的解决思路，接下来，一步一步仔细看～ 1 –&gt; 查看造成冲突的文件，修改冲突部分 冲突文件 ATest.txt 内容如下（Git 虽然无法解决冲突， 但是使用简单的三个符号，标明了冲突的地方，以及冲突的两个分支在该地方发生冲突时的内容）： 1234567&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD# This is a test about merge conflict.=======# This ia a test about merge conflict.&gt;&gt;&gt;&gt;&gt;&gt;&gt; featureA~~ 符号说明如下： 符号 分隔符 ======= 分隔符 &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD 至 ======= master 分支中该地方的内容 ======= 至 &gt;&gt;&gt;&gt;&gt;&gt;&gt; featureA featureA 分支中该地方为内容 接下来编辑 ATest.txt 文件，根据功能需要完成合并，确认之后，把 Git 冲突标识符号给删除掉即可。 2 &amp; 3 –&gt; 修改后冲突文件，add &amp;&amp; commit 12345678910111213141516171819202122$ git add ATest.txt(master +|MERGING) GitTestProject $ git statusOn branch masterYour branch is ahead of 'origin/master' by 9 commits. (use &quot;git push&quot; to publish your local commits)All conflicts fixed but you are still merging. (use &quot;git commit&quot; to conclude merge)Changes to be committed: modified: ATest.txt(master +|MERGING) GitTestProject $ git commit -m &quot;Dealing Merge Conflict&quot;[master fb50835] Dealing Merge Conflict(master) GitTestProject $ git statusOn branch masterYour branch is ahead of 'origin/master' by 11 commits. (use &quot;git push&quot; to publish your local commits)nothing to commit, working tree clean 关联本地分支&amp;&amp;远程分支学习了分支的概念后，你应该意识到：多人协作项目中，为了保证本地分支和远程库中分支保持数据同步，团队中的每一个 Partner 使用 git pull 或者 git push 拉取（或推送）最新分支内容时，需要明确指定从本地的哪个分支 拉取/推送 到远程的哪个分支，这是重要的！！！ Git Pull &amp;&amp; Git Push 参数详解补充说明在远程仓库中提到的：CMD 10 –&gt;&gt;&gt; git push &amp;&amp; git pull 1 –&gt; git push 123456789101.将本地当前分支 推送到 与本地当前分支同名的远程分支上（使用前提：本地分支&amp;&amp;远程分支实现关联）$ git push2.将本地当前分支 推送到 与本地当前分支同名的远程分支上$ git push origin &lt;local current branch name&gt;3.将本地当前分支 推送到 远程指定分支上$ git push origin &lt;local current branch name&gt;:&lt;remote brance name&gt;推荐使用第二种！！！ 2 –&gt; git pull 123456789101.将与本地当前分支同名的远程分支 拉取到 本地当前分支上（使用前提：本地分支&amp;&amp;远程分支实现关联）$ git pull2.将远程指定分支 拉取到 本地当前分支上$ git pull origin &lt;remote branch name&gt;3.将远程指定分支 拉取到 本地指定分支上$ git pull origin &lt;remote brance name&gt;:&lt;local current branch name&gt;推荐使用第二种！！！ 注意：pull or push 自身的动作，决定了后面跟随最近的仓库是远程的还是本地的。pull From –&gt; remote brance name；push To –&gt; local branch name。 实际中，上面推荐使用的第二种（可以直接使用）和第一种语法都常使用，然而第一种的使用前提是：需要先实现本地分支&amp;&amp;远程分支关联。 将本地仓库，以及远程仓库（“中央仓库”）关联起来，可以简化命令，但同样带来了混淆（两面性），你可以根据喜好选择性使用，适合自己的才是最好的。 那么如何将本地仓库，以及远程仓库（“中央仓库”）关联起来呢？？？ 推荐一个用来查看分支关联情况的命令： 1$ git branch -vv 关联方法将本地分支同远程分支进行关联，可以分为以下三种场景(以 dev 分支为例)： 场景一：本地库已创建分支 dev，而远程库没有 1234567# 添加参数：-u$ git push -u origin dev或者# 添加参数：--set-upstream$ git push --set-upstream origin dev 关联思路：推送时实现关联，之后就可以直接使用 git push 进行分支分容的推送了。 场景二：远程库已创建分支 dev，而本地库没有 1234567# 分为两步：## Step1：将远程分支 pull 到本地$ git pull origin dev# Step2：创建本地分支并且进行关联$ git checkout -b dev origin/dev 关联思路：先拉取远程分支到本地，然后本地创建切换分支且进行关联。之后就可以直接使用 git pull 进行远程分支内容拉取了。 场景三：本地库 &amp;&amp; 远程库均已创建分支 dev 事实上，git branch 命令支持直接将 本地当前分支 直接与 远程分支 相关联： 1234567# 添加参数：-u$ git branch -u origin/dev或者# 添加参数：--set-upstream-to$ git branch --set-upstream-to=origin/dev 当然，前提是本地和远程库中均有分支 dev。注意，这里只是以 dev 为例，并不是本地库和远程库必须同名！！！ 撤销关联下面的命令，可以 撤销 本地当前分支 与对应的远程分支 的关联关系： 1$ git branch --unset-upstream Demo这一小节我们来看分支关联的测试实例（以 GitTestProject 为例）： 场景一实例：远程库已创建分支 dev，本地无分支 1）查看需要关联的远程分支名： 1234$ git branch -a * master remotes/origin/dev remotes/origin/master 可以看到，远程也包含了 dev 分支：remotes/origin/dev，而本地是没有的。 2）根据关联方法中的介绍，这里有两种思路，来进行关联： 思路一： 12345678910111213# 本地新建一个和远程分支同名(dev)的分支 $ git checkout -b devSwitched to a new branch 'dev'# 将本地当前分支关联远程分支(dev) GitTestProject $ git branch --set-upstream-to=origin/devBranch 'dev' set up to track remote branch 'dev' from 'origin'.$ git branch -vv FeatureA c07648e Merge conflic test in FeatureA* dev fb50835 [origin/dev] Dealing Merge Conflict featureB 4528426 Add BTest File For featureB master fb50835 [origin/master: ahead 11] Dealing Merge Conflict 思路二： 注意，测试前需要将上面的关联取消掉，然后删除分支，再开始执行下面的命令： 12345678910111213141516# 将远程分支 pull 到本地$ git pull origin devFrom github.com:TheNightIsYoung/GitTestProject * branch dev -&gt; FETCH_HEADAlready up to date.# 创建本地分支并且进行关联(master) GitTestProject $ git checkout -b dev origin/devSwitched to a new branch 'dev'Branch 'dev' set up to track remote branch 'dev' from 'origin'.(dev) GitTestProject $ git branch -vv FeatureA c07648e Merge conflic test in FeatureA* dev fb50835 [origin/dev] Dealing Merge Conflict featureB 4528426 Add BTest File For featureB master fb50835 [origin/master: ahead 11] Dealing Merge Conflict 3）提交测试是否成功关联 123456789101112131415161718192021$ touch assi_demo.txtGitTestProject $ git add assi_demo.txt(dev +) GitTestProject $ git commit -m &quot;Branch assi Test&quot;[dev 3cb60e7] Branch assi Test 1 file changed, 0 insertions(+), 0 deletions(-) create mode 100644 assi_demo.txt(dev) GitTestProject $ git pullAlready up to date.(dev) GitTestProject $ git pushEnumerating objects: 3, done.Counting objects: 100% (3/3), done.Delta compression using up to 12 threadsCompressing objects: 100% (2/2), done.Writing objects: 100% (2/2), 251 bytes | 125.00 KiB/s, done.Total 2 (delta 1), reused 0 (delta 0), pack-reused 0remote: Resolving deltas: 100% (1/1), completed with 1 local object.To github.com:TheNightIsYoung/GitTestProject.git fb50835..3cb60e7 dev -&gt; dev 可以发现，已经成功关联分支，并可以提交代码到远程分支。 场景二实例：本地库已创建分支 dev，远程无分支 为了满足场景二需要，我们需要先删除场景一中的关联关系，并且删除远程的 dev 分支： 123456789$ git branch --unset-upstream$ git push origin --delete devTo github.com:TheNightIsYoung/GitTestProject.git - [deleted] dev$ git branch -a* dev master remotes/origin/master 1）查看当前仓库分支情况： 1234$ git branch -a* dev master remotes/origin/master 可以发现，远程库中只有 master 分支，而本地仓库中包含两个分支：dev &amp;&amp; master。 2）根据关联方法中的介绍，这里有两种思路，来进行关联： 思路一： 1234567891011121314151617181920212223242526272829# 将本地当前分支 推送到 远程库 $ git push origin devEnumerating objects: 30, done.Counting objects: 100% (30/30), done.Delta compression using up to 12 threadsCompressing objects: 100% (26/26), done.Writing objects: 100% (29/29), 2.70 KiB | 345.00 KiB/s, done.Total 29 (delta 16), reused 0 (delta 0), pack-reused 0remote: Resolving deltas: 100% (16/16), done.remote:remote: Create a pull request for 'dev' on GitHub by visiting:remote: https://github.com/TheNightIsYoung/GitTestProject/pull/new/devremote:To github.com:TheNightIsYoung/GitTestProject.git * [new branch] dev -&gt; dev# 查看分支关联情况，发现 dev 分支未关联 (dev) GitTestProject $ git branch -vv* dev 3cb60e7 Branch assi Test master fb50835 [origin/master: ahead 11] Dealing Merge Conflict# 将本地当前分支 与 远程分支进行 关联(dev) GitTestProject $ git branch -u origin/devBranch 'dev' set up to track remote branch 'dev' from 'origin'.# 重新查看分支关联情况，发现本地 dev 分支已和远程关联 (dev) GitTestProject $ git branch -vv* dev 3cb60e7 [origin/dev] Branch assi Test master fb50835 [origin/master: ahead 11] Dealing Merge Conflict 思路二： 注意，测试前需要将上面的关联取消掉，然后删除远程分支，再开始执行下面的命令： 123456789101112131415161718192021# 将本地当前分支 推送到 远程库，同时使用 -u 参数进行关联$ git push -u origin devEnumerating objects: 30, done.Counting objects: 100% (30/30), done.Delta compression using up to 12 threadsCompressing objects: 100% (26/26), done.Writing objects: 100% (29/29), 2.70 KiB | 212.00 KiB/s, done.Total 29 (delta 16), reused 0 (delta 0), pack-reused 0remote: Resolving deltas: 100% (16/16), done.remote:remote: Create a pull request for 'dev' on GitHub by visiting:remote: https://github.com/TheNightIsYoung/GitTestProject/pull/new/devremote:To github.com:TheNightIsYoung/GitTestProject.git * [new branch] dev -&gt; devBranch 'dev' set up to track remote branch 'dev' from 'origin'.# 重新查看分支关联情况，发现本地 dev 分支已和远程关联(dev) GitTestProject $ git branch -vv* dev 3cb60e7 [origin/dev] Branch assi Test master fb50835 [origin/master: ahead 11] Dealing Merge Conflict 如果你还不放心的话，还可以进行一次提交，然后使用 git push 进行推送，自己尝试一下吧~~~ Data Flow In Git前面我们提到过 Git 的三大分区，以及各区之间的数据传递流程图，这里我们已经可以给出 Git 的整体构架图： 工作区（Working Directory），简言之就是你工作的区域。对于 Git 而言，就是的本地工作目录。工作区的内容会包含提交到暂存区和版本库(当前提交点)的内容，同时也包含自己的修改内容。 暂存区（Stage Area, 又称为索引区 Index），是 Git 中一个非常重要的概念。在工作目录下有一个 .git 的目录，里面有个 index 文件，存储着关于暂存区的内容。git add 命令将工作区内容添加到暂存区。 本地仓库（Rocal Repository），版本控制系统的仓库，存在于本地。当执行 git commit 命令后，会将暂存区内容提交到仓库之中。在工作区下面有 .git 的目录，这个目录下的内容不属于工作区，里面便是仓库的数据信息，暂存区相关内容也在其中。这里也可以使用 merge 或 rebase 将远程仓库副本合并到本地仓库。图中的只有 merge，注意这里也可以使用 rebase。 远程版本库（Remote Repository），与本地仓库概念基本一致，不同之处在于一个存在远程，可用于远程协作，一个却是存在于本地。通过 push/pull 可实现本地与远程的交互。 远程仓库副本，可以理解为存在于本地的远程仓库缓存。如需更新，可通过 git fetch/pull 命令获取远程仓库内容。使用 fech 获取时，并未合并到本地仓库，此时可使用 git merge 实现远程仓库副本与本地仓库的合并。git pull 根据配置的不同，可为 git fetch + git merge 或 git fetch + git rebase。 这里引用知乎上，博主波罗学的说法。git pull 和 git fetch 的区别前参加 –&gt; 传送门 Get Branch From RemoteRepo日常的项目开发过程中，更常见的是从既存的远程仓库中拉取代码到本地，然后进行开发任务。前面提到过，会使用 git clone &lt;repo addr&gt; 命令，可以将项目整个克隆到我们的本地仓库。 然而，本地 Clone 仓库默认只会 clone 下 master 分支（clone 到指定目录）： 1234567891011121314# Clone 到指定目录语法：git clone &lt;repo addr&gt; &lt;myDirName&gt;$ git clone git@github.com:TheNightIsYoung/GitTestProject.git MyLocalRepoCloning into 'MyLocalRepo'...remote: Enumerating objects: 59, done.remote: Counting objects: 100% (59/59), done.remote: Compressing objects: 100% (25/25), done.remote: Total 59 (delta 22), reused 58 (delta 21), pack-reused 0Receiving objects: 100% (59/59), 5.00 KiB | 639.00 KiB/s, done.Resolving deltas: 100% (22/22), done.$ ls MyLocalRepo/ATest.txt Client/ git_rm_test.txt Server/BTest.txt dev_function.txt readme.txt$ cd MyLocalRepo/ 倘若远程仓库有多个分支，我们会发现，使用 git branch 查看本地分支时，只有一个 master 分支: 12$ git branch* master 此时，你可以使用 git branch -a 查看都有那些远程分支： 12345$ git branch -a* masterremotes/origin/HEAD -&gt; origin/masterremotes/origin/developremotes/origin/feature 但是，实际上大多数时候我们是需要在其他分支进行工作的，所以我们需要可以灵活的将远程的其它分支拉取下来。比如有时候你只想拉取远程仓库指定的某一个分支，有时候你想拉取远程的所有分支等等。 Pull a specified branch如何 Git 命令拉取远程仓库中指定的某一个分支呢？这里提供三种方法供大家参考： 1 –&gt; git clone -b 命令获取 命令格式： 1$ git clone -b &lt;remote branch name&gt; &lt;remote repo addr&gt; git clone -b &lt;分支名称&gt; &lt;仓库地址&gt; 命令可以将指定的某一个远程分支拉取到我们本地，而且拉取的本地分支自动和远程同名分支建立关联（追踪）关系，并且会将新创建的 HEAD 指向刚拉取下来的分支。 12345678$ git clone -b dev git@github.com:TheNightIsYoung/GitTestProject.git MyLocalRepoCloning into 'MyLocalRepo'...remote: Enumerating objects: 59, done.remote: Counting objects: 100% (59/59), done.remote: Compressing objects: 100% (25/25), done.remote: Total 59 (delta 22), reused 58 (delta 21), pack-reused 0Receiving objects: 100% (59/59), 5.00 KiB | 1023.00 KiB/s, done.Resolving deltas: 100% (22/22), done. 分支拉取结束以后，执行 git branch -a 命令，查看分支情况如下： 123456$ cd MyLocalRepo/(dev) MyLocalRepo $ git branch -a* dev remotes/origin/HEAD -&gt; origin/master remotes/origin/dev remotes/origin/master 当然，这里你也可以根据【关联本地分支&amp;&amp;远程分支】中介绍的方法，同时拉取其它分支进行工作（以 master 为例）： 12345678910111213141516171819$ git pull origin masterFrom github.com:TheNightIsYoung/GitTestProject * branch master -&gt; FETCH_HEADAlready up to date.Jie Guo (dev) MyLocalRepo $ git branch -a* dev remotes/origin/HEAD -&gt; origin/master remotes/origin/dev remotes/origin/master(dev) MyLocalRepo $ git checkout -b master origin/masterSwitched to a new branch 'master'Branch 'master' set up to track remote branch 'master' from 'origin'.(master) MyLocalRepo $ git branch -a dev* master remotes/origin/HEAD -&gt; origin/master remotes/origin/dev remotes/origin/master 2 –&gt; git fetch 命令获取 关于 git fetch 命令说明： 1234567# 1.将某个远程主机的所有更新，全部取回本地副本中，但不会将任何新内容合并到我们最近的工作文件中。$ git fetch &lt;远程主机名&gt;# 或者简写为：$ git fetch# 2.如果只想取回特定分支的更新$ git fetch &lt;远程主机名&gt; &lt;分支名&gt; 开始拉取指定分支 &gt;&gt;&gt;&gt; 12345678910111213141516171819# 1.拉取整个远程代码库$ git clone git@github.com:TheNightIsYoung/GitTestProject.git MyLocalRepoCloning into 'MyLocalRepo'...remote: Enumerating objects: 59, done.remote: Counting objects: 100% (59/59), done.remote: Compressing objects: 100% (25/25), done.remote: Total 59 (delta 22), reused 58 (delta 21), pack-reused 0Receiving objects: 100% (59/59), 5.00 KiB | 1023.00 KiB/s, done.Resolving deltas: 100% (22/22), done.gitWorkS $ cd MyLocalRepo/# 将远程仓库的所有分支拷贝到本地，建立远程库副本(master) MyLocalRepo $ git fetch# 切换到想要拉取的指定某一个分支的本地分支(master) MyLocalRepo $ git checkout devSwitched to a new branch 'dev'Branch 'dev' set up to track remote branch 'dev' from 'origin'. 切换分支后，你就可以看到本地仓库的 dev 开发分支和远程仓库的 dev 开发分支同步了。 这里不好理解的话，你可以在 git fetch 之后，使用 git checkout -b dev origin/dev + git merge origin/dev 实现同样的效果。 3 –&gt; git checkout 命令获取 这一方法你可以先自己思考下，提示需要借助 git pull 命令~~~ 先不要看下面的答案！ 先不要看下面的答案！！ 先不要看下面的答案！！！ 参考下面的详细步骤，是否和你思考的一样？： 123456789101112131415161718192021222324$ git clone git@github.com:TheNightIsYoung/GitTestProject.git MyLocalRepoCloning into 'MyLocalRepo'...remote: Enumerating objects: 59, done.remote: Counting objects: 100% (59/59), done.remote: Compressing objects: 100% (25/25), done.remote: Total 59 (delta 22), reused 58 (delta 21), pack-reused 0Receiving objects: 100% (59/59), 5.00 KiB | 1023.00 KiB/s, done.Resolving deltas: 100% (22/22), done.gitWorkS $ cd MyLocalRepo/(master) MyLocalRepo $ git branch -a* master remotes/origin/HEAD -&gt; origin/master remotes/origin/dev remotes/origin/master(master) MyLocalRepo $ git checkout -b dev origin/devSwitched to a new branch 'dev'Branch 'dev' set up to track remote branch 'dev' from 'origin'.(dev) MyLocalRepo $ git pull origin devFrom github.com:TheNightIsYoung/GitTestProject * branch dev -&gt; FETCH_HEADAlready up to date. 至此，你就可以灵活的实现 从远程仓库拉取指定某一分支，或者拉取指定的某些分支了~~~ Sync remote branch那么，如何一次性同步远程仓库中的所有分支到本地仓库中呢？ 1 –&gt; 跟踪（关联）所有远程分支 12345678910 $ git branch -r | grep -v '\\-&gt;' | while read remote; do git branch --track &quot;${remote#origin/}&quot; &quot;$remote&quot;; doneBranch 'dev' set up to track remote branch 'dev' from 'origin'.fatal: A branch named 'master' already exists.$ git branch -a dev* master remotes/origin/HEAD -&gt; origin/master remotes/origin/dev remotes/origin/master 2 –&gt; 将本地所有分支与远程保持同步 12$ git fetch --allFetching origin 3 –&gt; 拉取所有分支代码 123$ git pull --allFetching originAlready up to date.","link":"/2017/07/04/git-shi-yong-zhi-nan-zhi-fen-zhi-guan-li/"},{"title":"Git 使用指南之时光穿梭机","text":"上一篇博文你已经了解了 Git 版本控制系统的基本概念，不同平台下 Git 的安装以及相关配置，以及 Git 版本库初识。并且在上一篇博文中我们已经成功地演示了如何使用 Git 管理一个既存项目（GitTestProject），下面我们将基于这个版本库为实例继续来看 Git 版本库日常管理的常规操作。 叮咚~~，完成当前博文学习，即可达成 “初步项目版本管理” 成就！！！ 版权说明： 本文思路以及内容主要来自廖雪峰老师的 Git 教程 （强烈推荐膜拜原文），并结合个人使用所作，只作为学习记录使用。如内容有侵权请联系删除，禁止转载！ 更多 Git 相关内容，请关注博主 Git 博文系列： 之一 &gt;&gt;&gt; Git 使用指南之初识 之二 &gt;&gt;&gt; Git 使用指南之时光穿梭机 之三 &gt;&gt;&gt; Git 使用指南之远程仓库 之四 &gt;&gt;&gt; Git 使用指南之分支管理 之五 &gt;&gt;&gt; Git 使用指南之 WorkFlow (工作流) 之六 &gt;&gt;&gt; Git 使用指南之 Git 自定义 之七 &gt;&gt;&gt; Git 使用指南之 HEAD 指针 之八 &gt;&gt;&gt; Git 使用指南之 Git 中的黑魔法 | &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 上篇博文中 GitTestProject 版本库目录结构说明： GitTestProject 版本库包含：Server 目录、Client 目录、以及 readme.txt 说明文档。 Server 目录下包含一个名为：service.py 的文件，其内容为： 1# This is a Test! Client 目录视作是一个仅包含 Git 占位文件（.gitignore）的空目录。 readme.txt 文件内容为： 12Git is a version control system.Git is free software. ==============================================================| 下面一起来看 Git 到底有多神奇： File Modification In Repo来看版本库中的文件修改 &gt;&gt;&gt; 我们知道，Server 目录下包含一个名为：service.py 的文件，其内容如下： 1# This is a Test! 到了工作时间，我们想要接着继续写 service.py 脚本了，我做了如下变更： 123# Git is a distributed version control system.# Git is free software.# This is a Test! 通过上一篇博文知道，文件修改完成之后，想要 GitTestProject 版本库管理，还需要执行：添加（git add）&amp;&amp; 提交（git commit）的操作。 CMD 1 –&gt;&gt;&gt; git status 事实上，在添加、提交变更之前，我们需要关注的是：Git 版本库（GitTestProject）是否已经实时地跟踪到了我们的修改（很慌，要是没有识别到修改怎么办？），这是很重要的！！！当然是可以的，毕竟 Git 就是干这个的。 git status 命令说明： 可以让我们 时刻监控到版本仓库中所有管理文件的当前状态，我们在 Git Bash 中运行查看一下 Git监控信息： 123456789$ git statusOn branch masterChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: Server/service.pyno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 可以看到，Git 告诉我们 modified: Server/service.py（service.py 已经被修改），并且提醒我们 Changes not staged for commit（变更未提交）。 一般，一个文件的状态通常可以分为： 不受版本控制的 untracked 状态 受版本控制并且已修改的 modified 状态 受版本控制已修改并提交到暂存区的 staged 状态 从暂存区已经提交到本地仓库的 committed 状态 提交到本地仓库未修改或者从远程仓库克隆下来的 unmodified 状态 CMD 2 –&gt;&gt;&gt; git diff 上面我们知道，版本库确实检测到了 service.py 文件被变更了！但我们更加关注的是版本库检测到的 service.py 文件的修改，和我们手动修改是否一致？！！这时需要使用 git diff（git different） 命令来查看修改后文件和修改前文件的差异： 12345678910$ git diff Server/service.pydiff --git a/Server/service.py b/Server/service.pyindex 68f5fe0..433af3b 100644--- a/Server/service.py+++ b/Server/service.py@@ -1 +1,3 @@-This is a Test!+# Git is a distributed version control system.+# Git is free software.+# This is a Test! 可以看到 Git 已经跟踪了我们对 service.py 文件的修改，这下舒服了~，将其提交给版本库也就放心了。 CMD 3 –&gt;&gt;&gt; git add &amp;&amp; git commit -m 提交~提交 &gt;&gt;&gt; 12# 添加变更至暂存区（见下文 Git Stage 说明），等待 commit$ git add Server/service.py 执行后同样没有任何输出（成功信号）。在执行 git commit 之前，我们再次运行 git status 查看一下当前仓库的状态（不放心再确认一下）： 123456$ git statusOn branch masterChanges to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) modified: Server/service.py Git 告诉我们将要被提交的修改是：Server/service.py（心里默念一句 NB），确定之后我们直接提交给版本库： 123$ git commit -m 'Add help info'[master 8622ab2] Add help info 1 file changed, 3 insertions(+), 1 deletion(-) 提交完成后，我们再次查看版本库状态： 123$ git statusOn branch masternothing to commit, working tree clean Git 监控信息显示：当前没有需要提交的变更，并且工作目录是干净（working tree clean）的，完美~ Time ShuttleGit 实现时光穿梭（版本回滚） &gt;&gt;&gt; 上述版本库中文件的修改操作，再练习一次，修改 service.py 文件如下： 12345# Git is a distributed version control system.# Git is free software.# This is a Test!print ('Git is very useful!!!') 然后尝试添加 &amp;&amp; 提交： 1234$ git add Server/service.py$ git commit -m 'Add test code'[master dd32d2d] Add test code 1 file changed, 2 insertions(+) 像这样，不断对文件进行修改，然后不断提交变更到版本库里。这就好像游戏存档一样：打通一部分关卡，存档一次，形成不同的存档库。一旦失败的话，可以通过存档回滚到最新的存档。 Git 也是一样，每当你觉得文件修改到一定程度（完成某项功能，或某个版本）的时候，就可以 “保存一个快照”，这个快照在 Git 中被称为一次 commit。一旦你把文件改乱了，或者误删了文件，还可以从最近的一个 commit 恢复（版本回滚），然后继续工作，而不是把几个月的工作成果全部丢失。 变更历史记录在开始讲解 Git 版本库的回滚操作之前，我们先来回顾一下 service.py 一共有多少个 commit（版本、快照）被提交到 Git 仓库里： 明确了有多少、有哪些版本，才可以准确地在版本库中的不同版本间进行回滚 版本 1：ADD Project Base 123# service.py 被提交到 GitTestProject，内容如下：# This is a Test! 版本 2：Add help info 123# Git is a distributed version control system.# Git is free software.# This is a Test! 版本 3：ADD test code 12345# Git is a distributed version control system.# Git is free software.# This is a Test!print ('Git is very useful!!!') 截至目前为止，当前版本库中，我们执行过 3 次 commit 操作，形成了三个不同的版本。 版本 1：ADD Project Base 版本 2：Add help info 版本 3：ADD test code 以上列出的就是当前版本库中的项目的 变更历史记录。 CMD 4 –&gt;&gt;&gt; git log 然后，实际工作中，我们怎么可能记得一个几千行的文件变更了多少次、每次都改了什么内容（不然要版本控制系统干什么，和原始版本控制有何区别？），所以需要版本控制系统可以告诉我们 项目的变更历史记录。 git log 命令就是做这个事的，它会显示出版本库中：从最新到最远的提交日志。 123456789101112131415161718$ git logcommit 47f21abe1449214864c84c2abdf44168ee26df60 (HEAD -&gt; master)Author: staff_ming &lt;staff_ming@xxxx.com&gt;Date: Fri Dec 21 11:20:04 2018 +0800 Add test codecommit 277b8bf5e9d974f73f1ace2dcd20fea2afd0296aAuthor: staff_ming &lt;staff_ming@xxxx.com&gt;Date: Fri Dec 21 11:02:34 2018 +0800 Add help infocommit 6a8c6bab3053e25a64241a22a56083c549bf79f2Author: staff_ming &lt;staff_ming@xxxx.com&gt;Date: Thu Dec 20 19:53:06 2018 +0800 ADD Project Base 如果嫌输出信息太多，看得眼花缭乱的，可以试试加上 --pretty=oneline 参数（清晰了很多）： 1234$ git log --pretty=oneline47f21abe1449214864c84c2abdf44168ee26df60 (HEAD -&gt; master) ADD test code277b8bf5e9d974f73f1ace2dcd20fea2afd0296a Add help info6a8c6bab3053e25a64241a22a56083c549bf79f2 ADD Project Base 当然你也可以 查看单个文件的提交日志： 1$ git log Server/service.py | &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 历史变更记录解析 &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 你看到的一大串类似 47f21ab... 的是 commit id（版本号），和 SVN 不一样，Git 的 commit id 不是 1，2，3…… 递增的数字，而是一个非常大的数字（十六进制）。 为什么采用这种机制（SHA-1）？因为 Git 是分布式的版本控制系统，后面我们还要研究多人在同一个版本库里工作，如果大家都用 1，2，3…… 作为版本号，很容易就冲突了。 每提交一个新版本，实际上 Git 就会把它们自动串成一条时间线。如果使用可视化工具（Git GUI）查看 Git 历史，就可以更清楚地看到提交历史的时间线： ================================================================| 有了版本库时间线（变更历史记录线），接下来就可以启动时光穿梭机进行版本回滚了… 问题：假设 版本 3：ADD test code 有错误，我们想要将版本库回滚到上一个版本（版本 2：Add help info），怎么办？？！ HEAD 开始回滚前，需要简单介绍一下 HEAD 的基本概念： 我们知道，要想实现版本回滚，Git 必须被指定要回滚到哪个版本。在 Git 中，用 HEAD 关键字表示当前版本，也就是最新的提交 47f21ab...（commit id）。上一个版本表示为：HEAD^，上上一个版本可以表示为:HEAD^^，很多人就要问了那如果要表示往上 90 个版本呢，难道要写 90 个 ^，当然不可能！版本数目较多时可以表示为：HEAD~90。 时空穿梭有了以上的知识储备我们就可以进行版本库的 时光穿梭 了 &gt;&gt;&gt; CMD 5 –&gt;&gt;&gt; git reset –hard Git 版本库中的 “时光穿梭” 使用 git reset（版本库重置） 命令来实现其功能。 1 –&gt; 回到过去 现在我们来看如何从当前版本【 Add test code 】回滚到上一版本【 Add help info 】，即：Add test code -&gt;&gt;&gt; Add help info，指令如下： 12$ git reset --hard HEAD^HEAD is now at 8622ab2 Add help info 这里我们侧重看 git reset 实现功能，参数 --hard 会在后续补充说明，这里你只需知道它是版本指定相关参数即可。回滚后，我们来看 service.py 当前版本内容： 1234$ cat Server/service.py# Git is a distributed version control system.# Git is free software.# This is a Test! 我们发现，果然 service.py 时空倒流到上一个版本了。 2 –&gt; 穿梭到未来 如果你现在想重新回滚到 –&gt;&gt; 版本3：ADD test code 怎么办？ 此时，我们查看一下当前版本库的提交日志信息： 123$ git log --pretty=oneline277b8bf5e9d974f73f1ace2dcd20fea2afd0296a (HEAD -&gt; master) Add help info6a8c6bab3053e25a64241a22a56083c549bf79f2 ADD Project Base 可以发现，之前最新的那个版本 【 ADD test code 】 已经看不到了！就好比你从现在回到了过去，但你又想回到现在（未来），你想通过 git log 察看现在时间节点在时间线上的版本标识，结果发现你已经找不到了。难道只能活在过去了么？ 在给出办法之前你先祈祷吧…之前我们一直使用的 Git Bash 窗口你还没手贱关掉。我们可以找到先前 【 ADD test code 】 的 commit id 是 47f21abe....，这样又找到了回去的时间节点版本标识（确实关闭也不要紧，是不是有点慌，哈哈。2333），下一小节【HEAD &amp;&amp; Commit Id】中我们会给出 commit id 的查询方法）。如果你已经关闭，可以转至下一小节查询一下~ commit id 也可以作为 Git 版本库中时间线上的版本标识，在 Git 项目管理中这要比使用 HEAD 更加合理。 重新回滚到 –&gt;&gt; 版本3：Add test code 的指令如下： 12$ git reset --hard 47f21abeHEAD is now at 47f21abe ADD test code 注意：版本号（commit id）没必要写全，Git 会去自动检索的，当然也不能太少，否则可能无法和其它版本区别。 此时查看 service.py，发现我们已经回到了“未来”： 123456$ cat Server/service.py# Git is a distributed version control system.# Git is free software.# This is a Test!print ('Git is very useful!!!') 重新查看版本库变更历史记录如下： 1234git log --pretty=oneline47f21abe1449214864c84c2abdf44168ee26df60 (HEAD -&gt; master) ADD test code277b8bf5e9d974f73f1ace2dcd20fea2afd0296a Add help info6a8c6bab3053e25a64241a22a56083c549bf79f2 ADD Project Base 至此，你就可以自由地进行版本库的回滚了~ HEAD &amp;&amp; Commit Id区别于 SVN，在进行版本回滚的时候我们发现 Git 的版本回退速度非常快，这是由于 Git 内部的指针机制决定的。 Git 内部有个指向当前版本的指针，就是我们前面说的 Head。当你回滚版本的时候，Git 仅仅是把 HEAD 从指向 【 ADD test code 】 版本的地址： 移动指向 【 Add help info 】： 然后顺便把工作区的文件更新了。所以你让 HEAD 指向哪个版本号，你就把当前版本定位在哪（讲到这里很多人会想到程序设计语言中的指针）。 HEAD 所指向的版本地址就是： commit id。故版本库回滚时可以同时使用 HEAD &amp;&amp; commit id 作为版本标识。 CMD 6 –&gt;&gt;&gt; git reflog “穿越到未来” 中找不到 commit id 的问题解决方法 &gt;&gt;&gt; 前面我们在 穿越到未来 中提到 Git Bash 关掉后，表面看起来找不到最新版本的 commit id。实际上，Git 提供了指令 git reflog 用来记录你的每一次引用日志（HEAD 指针移动记录）： 123456$ git reflog47f21ab (HEAD -&gt; master) HEAD@{0}: reset: moving to 47f21abe14492277b8bf HEAD@{1}: reset: moving to HEAD^47f21ab (HEAD -&gt; master) HEAD@{2}: commit: ADD test code277b8bf HEAD@{3}: commit: Add help info6a8c6ba HEAD@{4}: commit (initial): ADD Project Base 从日志输出可以看出：Add test code 的 commit id 是 47f21ab。 Git StageGit 和其他版本控制系统（如：SVN）的一个很大的不同之处就是有 暂存区（stage） 的概念。 这一小节，我们将从 Git 的本地数据管理入手，深入了解 Git 中引入的暂存区（Stage）的作用。 Git Local Data ManagementGit 本地数据管理，大概可以分为三个区：工作区（Working Directory）、暂存区（Stage）、以及版本库（Repository）。 Working Directory我们将当前程序开发所在目录称为：工作区（Working Directory），也就是我们的项目开发目录（如：GitTestProject）。该区域的文件会有状态的变化且状态由 Git 自动检测，如果程序中文件做任何操作（增、删、改），文件状态均会被检测到（类似于 SVN）。 Repository工作区（GitTestProject）有一个隐藏目录 .git ，这个不算工作区，而是 Git 的 版本库（Repository）。 Git 的版本库里存储了很多东西，其中最重要的就是称为 stage（或者叫：index）的 暂存区；还有 Git 为我们自动创建第一个分支 master，以及指向 master 的一个指针叫 HEAD（分支的概念后续会有专门的博文进行讲解，这里将其理解为版本库中的一条时间线）。 Stage数据暂时存放的区域，可在工作区和版本库之间进行数据的友好交流。 Git 版本控制原理当工作区检测到有文件发生变化时，那么意味着：我们在上一个版本之后再次对项目进行了变更。变更完成之后，我们可以将当前变更当做下一版本进行提交（生成一个新的版本或快照），那么就是执行 git add . 将所有文件提交到暂存区（stage），然后再执行 git commit -m 'another version' 提交到版本库的当前分支。原理图如下： 简单理解为：首先将需要提交的文件修改通通放到暂存区，然后一次性提交暂存区的所有修改即可。 下面我们完成一个实例来深入了解 Git 版本控制原理，详细过程如下所示： 1 -&gt;&gt; 在工作区修改文件 Server/service.py 内容为： 12345678# Git is a distributed version control system.# Git is free software.# This is a Test!print ('Git is very useful!!!')# Git has a mutable index called stage.# Git tracks changes. 2 -&gt;&gt; 在工作区添加文件 Client/request.py（内容随意），然后查看版本库当前状态： 123456789101112$ git statusOn branch masterChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory) modified: Server/service.pyUntracked files: (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed) Client/request.pyno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) Git 非常清楚地告诉我们，Server/service.py 脚本被修改了，而 Client/request.py 还从来没有被添加过，所以它的状态是 Untracked。 3）git add . 将所有修改文件提交到暂存区（stage），然后查看此时版本库状态： 1234567$ git statusOn branch masterChanges to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) new file: Client/request.py modified: Server/service.py 4）git commit 一次性把暂存区的所有修改提交到分支。 1234$ git commit -m 'understand how stage works'[master 847e6ef] understand how stage works 2 files changed, 3 insertions(+) create mode 100644 Client/request.py 5）提交后，如果工作区没有做任何修改，那么工作区就是 “干净” 的： 123$ git statusOn branch masternothing to commit, working tree clean 此时版本库的暂存区（stage）内容会被提交的 master 分支。 看到这里，肯定会有很多看客老爷们会问：为啥要暂存区，通过工作区直接提交到本地仓库不就OK了？暂存区存在有什么作用？ 下文会给出说明： Data Flow In Git根据上文 ，我们给出当开发者通过 git 变更数据时，各区之间可能的数据传递流程示意图： 我们可以通过对比三个区之间的数据差别，来验证以上流程的正确性，这可以借助之前学过的 git diff 命令来实现： 命令 作用 git diff 工作区 vs 暂存区 git diff head 工作区 vs 版本库 git diff –cached 暂存区 vs 版本库 开始实验一 &gt;&gt;&gt;&gt; ： 上一个版本之后未进行任何变更（文件未修改，未 add，未 commit）时，执行 git diff 命令，结果都为空： 命令 结果 （工作区 vs 暂存区）git diff 无输出 （工作区 vs 版本库）git diff head 无输出 （暂存区 vs 版本库）git diff –cached 无输出 此时查看文件内容： 123456789$ cat Server/service.py# Git is a distributed version control system.# Git is free software.# This is a Test!print ('Git is very useful!!!')# Git has a mutable index called stage.# Git tracks changes. 然后对 Server/service.py 进行如下变更，现在工作区内容发生变化，暂存区和版本库内容一致。 12345678910# Git is a distributed version control system.# Git is free software.# This is a Test!print ('Git is very useful!!!')# Git has a mutable index called stage.# Git tracks changes.# Git local data management test. Result 1 &gt;&gt;&gt;&gt;：（工作区 vs 暂存区）git diff 1234567891011$ git diffdiff --git a/Server/service.py b/Server/service.pyindex 6bef824..5127360 100644--- a/Server/service.py+++ b/Server/service.py@@ -6,3 +6,5 @@ print ('Git is very useful!!!') # Git has a mutable index called stage. # Git tracks changes.++# Git local data management test. Result 2 &gt;&gt;&gt;&gt;：（工作区 vs 版本库）git diff head 1234567891011$ git diff headdiff --git a/Server/service.py b/Server/service.pyindex 6bef824..5127360 100644--- a/Server/service.py+++ b/Server/service.py@@ -6,3 +6,5 @@ print ('Git is very useful!!!') # Git has a mutable index called stage. # Git tracks changes.++# Git local data management test. Result 3 &gt;&gt;&gt;&gt;：（暂存区 vs 版本库）git diff –cached 12$ git diff --cached# 无输出 执行 git add 操作后，修改同步到暂存区，现在工作区和暂存区数据一致。 1$ git add Server/service.py Result 1 &gt;&gt;&gt;&gt;：（工作区 vs 暂存区）git diff 12$ git diff# 无输出 Result 2 &gt;&gt;&gt;&gt;：（工作区 vs 版本库）git diff head 1234567891011$ git diff headdiff --git a/Server/service.py b/Server/service.pyindex 6bef824..5127360 100644--- a/Server/service.py+++ b/Server/service.py@@ -6,3 +6,5 @@ print ('Git is very useful!!!') # Git has a mutable index called stage. # Git tracks changes.++# Git local data management test. Result 3 &gt;&gt;&gt;&gt;：（暂存区 vs 版本库）git diff –cached 1234567891011$ git diff --cacheddiff --git a/Server/service.py b/Server/service.pyindex 6bef824..5127360 100644--- a/Server/service.py+++ b/Server/service.py@@ -6,3 +6,5 @@ print ('Git is very useful!!!') # Git has a mutable index called stage. # Git tracks changes.++# Git local data management test. 执行 git commit 操作后，修改已经同步到版本库，三区数据再次保持一致。 命令 结果 （工作区 vs 暂存区）git diff 无输出 （工作区 vs 版本库）git diff head 无输出 （暂存区 vs 版本库）git diff –cached 无输出 开始实验二 &gt;&gt;&gt;&gt; ： 1）对 Server/service.py 进行第一次修改： 12345678# Git is a distributed version control system.# Git is free software.# This is a Test!print ('Git is very useful!!!')# Git has a mutable index called stage.# Git tracks changes. 2）将其添加到暂存区： 1234567$ git add Server/service.py$ git statusOn branch masterChanges to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) modified: Server/service.py 3）对 Server/service.py 进行第二次修改： 12345678# Git is a distributed version control system.# Git is free software.# This is a Test!print ('Git is very useful!!!')# Git has a mutable index called stage.# Git tracks changes of files. 4）提交： 12345678910111213$ git commit -m 'git tracks changes'[master 9046f26] git tracks changes 1 file changed, 1 insertion(+)$ git statusOn branch masterChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: Server/service.pyno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 我们发现还有一次修改未被提交，我们先回顾一下操作过程： 第一次修改 -&gt; git add -&gt; 第二次修改 -&gt; git commit 当你用 git add 命令后，在工作区的第一次修改被放入暂存区，准备提交。但是，在工作区的第二次修改并没有放入暂存区，所以，git commit 只负责把暂存区的修改提交了，也就是第一次的修改被提交了，第二次的修改不会被提交。 Result 1 &gt;&gt;&gt;&gt;：（工作区 vs 暂存区）git diff 1234567891011 $ git diffdiff --git a/Server/service.py b/Server/service.pyindex 6bef824..a17dbf0 100644--- a/Server/service.py+++ b/Server/service.py@@ -5,4 +5,4 @@ print ('Git is very useful!!!') # Git has a mutable index called stage.-# Git tracks changes.+# Git tracks changes of files. 此时，由于第二次修改内容未同步至暂存区，所以工作区和暂存区数据不一致。 Result 2 &gt;&gt;&gt;&gt;：（工作区 vs 版本库）git diff head 1234567891011$ git diff headdiff --git a/Server/service.py b/Server/service.pyindex 6bef824..a17dbf0 100644--- a/Server/service.py+++ b/Server/service.py@@ -5,4 +5,4 @@ print ('Git is very useful!!!') # Git has a mutable index called stage.-# Git tracks changes.+# Git tracks changes of files 可见，第二次修改确实没有被提交。所以：如果不用 git add 到暂存区，那就不会加入到 commit 快照中。 Result 3 &gt;&gt;&gt;&gt;：（暂存区 vs 版本库）git diff –cached 12$ git diff --cached# 无输出 此时，第一次修改的暂存区内容已提交至版本库，所以暂存区和版本库内容是保持一致的。 事实上，Stage 的引入，确实赋予了 Git 更多灵活的特性。 Git Reset –Options前面我们提到过，git reset 版本库重置命令可以根据历史变更记录（HEAD &amp;&amp; Commit ID）来实现 “时光穿梭”（版本库重置）。 上文通过对 Git 本地数据管理的说明，相信你已经对 Git 分区工作原理有了深入的了解。掌握这一小节之后，通过 git reset 不同的参数搭配使用，可以在工作区，暂存区和版本库之间，轻松进行数据的来回切换。 Git Reset 有三种模式（参数）：soft、mixed、hard。 下面分别来看使用上的区别： Mode：hard该模式下，Git 会使用 &lt;HEAD or Commit ID&gt; 所对应的版本重置 Stage 区和工作区（Working Directory）。命令格式： 1$ git reset --hard &lt;HEAD or Commit ID&gt; 命令说明：git reset 后面加了 --hard 参数时，你的 stage区和工作目录里的内容会被完全重置为 &lt;HEAD or Commit ID&gt; 所对应的新位置相同的内容。 简言之：你的没有 commit 的修改会被全部擦掉。 Demo &gt; &gt; &gt; &gt; 例如，上一次 commit 之后又对文件做了一些修改：将修改后的 Server/service.py 文件 add 到 Stage；修改后的 Client/request.py 保留在工作区（未执行 add）。查看此时版本库状态： 12345678910$ git statusOn branch masterChanges to be committed: (use &quot;git restore --staged &lt;file&gt;...&quot; to unstage) modified: Server/service.pyChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory) modified: Client/request.py 然后，查看 git reset --hard 效果： 12$ git reset --hard HEAD^HEAD is now at bf2ead8 Git Local Data Managemant 可以发现，当前版本库的 HEAD 切到上一条 commit 的同时，工作目录里的新改动（Client/request.py）和已经 add 到 stage 区的新改动（Server/service.py）也一起全都消失了： 123$ git statusOn branch masternothing to commit, working tree clean Mode：soft该模式下，Git 会使用 &lt;HEAD or Commit ID&gt; 所对应的版本进行重置，但注意，会保留 Stage 区和工作区（Working Directory）中的内容，并且会把重置 &lt;HEAD or Commit ID&gt; 所带来的新的差异放进暂存区。命令格式： 1$ git reset --soft &lt;HEAD or Commit ID&gt; 命令说明：什么是「重置 HEAD 所带来的新的差异」？由于 HEAD 的移动（A –&gt; C），版本 A 到 版本 C 之间的差异即为重置 HEAD 所带来的新的差异，会将这些由版本版本重置引发的差异放入暂存区。 简言之：保留工作目录和暂存区内容，并把重置 HEAD 所带来的新的差异放进暂存区。 可以想象到，当我们想合并「当前节点」与「reset 目标节点」之间不具太大意义的 commit 记录（可能是阶段性地频繁提交）時，可以考虑使用 Soft Reset 来让 commit 演进线图较为清晰点。 Demo &gt; &gt; &gt; &gt; 例如，上一次 commit 之后又对文件做了一些修改：将修改后的 Server/service.py 文件 add 到 Stage；修改后的 Client/request.py 保留在工作区（未执行 add）。查看此时版本库状态： 12345678910$ git statusOn branch masterChanges to be committed: (use &quot;git restore --staged &lt;file&gt;...&quot; to unstage) modified: Server/service.pyChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory) modified: Client/request.py 假设此时当前 commit 的改动内容是新增了 softtest.txt 文件。如果这时你执行： 123456789101112$ git reset --soft HEAD^$ git statusOn branch masterChanges to be committed: (use &quot;git restore --staged &lt;file&gt;...&quot; to unstage) modified: Server/service.py new file: softtest.txtChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory) modified: Client/request.py 可见，将版本库由 HEAD 重置为 HEAD^，重置 HEAD 所带来的差异为：新增了 softtest.txt 文件，故新增文件被存放到暂存区。 Mode：mixid该模式下（默认，不加参数），Git 会使用 &lt;HEAD or Commit ID&gt; 所对应的版本进行重置，注意，会保留工作区（Working Directory）中的内容，但会清空暂存区（Stage）。命令格式： 123$ git reset --mixed &lt;HEAD or Commit ID&gt;# 或者$ git reset &lt;HEAD or Commit ID&gt; 命令说明：保留工作区（Working Directory）中的内容，但会清空暂存区（Stage）。工作目录的修改、暂存区的内容以及由 reset 所导致的新的文件差异，都会被放进工作目录。 简言之：把所有差异都混合（mixed）放在工作目录中。 Demo &gt; &gt; &gt; &gt; 例如，上一次 commit 之后又对文件做了一些修改：将修改后的 Server/service.py 文件 add 到 Stage；修改后的 Client/request.py 保留在工作区（未执行 add）。查看此时版本库状态： 12345678910$ git statusOn branch masterChanges to be committed: (use &quot;git restore --staged &lt;file&gt;...&quot; to unstage) modified: Server/service.pyChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory) modified: Client/request.py 假设此时当前 commit 的改动内容是新增了 softtest.txt 文件。如果这时你执行不带参数的 reset： 1234567891011 $ git statusOn branch masterChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory) modified: Client/request.py modified: Server/service.pyUntracked files: (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed) softtest.txt 完美~ Undo Edit如何撤销修改？ &gt;&gt;&gt; 3.2 Data Flow In Git 实验二 中我们对 Server/service.py 文件做了两次修改，第一次修改为正确修改已被提交（commit）。第二次修改未提交（add），提交（add）前我们突然发现修改为错误修改： 123456789$ cat Server/service.py# Git is a distributed version control system.# Git is free software.# This is a Test!print ('Git is very useful!!!')# Git has a mutable index called stage.# Git tracks changes of files. 我们能想到的直接的纠正方法是手动把文件恢复到上一个版本的状态。但我们查看此时版本库状态： 123456789$ git statusOn branch masterChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: Server/service.pyno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) CMD 7 –&gt;&gt;&gt; git checkout – file 我们发现，Git 提示可以通过 git checkout -- file 可以丢弃工作区的修改，指令如下： 1$ git checkout -- Server/service.py 命令 git checkout -- Server/service.py 意思是：把 service.py 文件在工作区的修改全部撤销，这里有两种情况： 第一种是 service.py 自修改后还没有被放到暂存区，撤销修改就回到和版本库一模一样的状态； 第二种是 service.py 已经添加到暂存区后又作了修改，撤销修改就回到添加到暂存区后的状态。 简单地说：git checkout -- file 会让文件 file 回到上一次 git commit 或 git add 时的状态。 可以发现，丢弃工作区的修改之后 service.py 文件又恢复到之前的内容了： 123456789$ cat Server/service.py# Git is a distributed version control system.# Git is free software.# This is a Test!print ('Git is very useful!!!')# Git has a mutable index called stage.# Git tracks changes. 注意：git checkout -- file 命令中的参数 -- 很重要，没有 --，就变成了 “切换到另一个分支” 的命令，后面的分支管理中会再次遇到 git checkout 命令。 还能怎么操作可以实现上述功能？！！上一小节介绍的 git reset 也可以实现上述撤消操作。如下： 12$ git reset --hard HEADHEAD is now at 04aee1b git tracks changes 这里我们再来尝试 git checkout -- 的第二种情况（变更已经 add 到暂存区）：将 service.py 文件内容修改为上述中第二次修改内容，如下： 12345678# Git is a distributed version control system.# Git is free software.# This is a Test!print ('Git is very useful!!!')# Git has a mutable index called stage.# Git tracks changes of files. 然后将上述修改添加至暂存区： 1$ git add Server/service.py 添加后再进行修改，内容如下： 12345678910# Git is a distributed version control system.# Git is free software.# This is a Test!print ('Git is very useful!!!')# Git has a mutable index called stage.# Git tracks changes of files.# Git Second tracks changes of files. 随后，查看此时文件状态 12345678910$ git statusOn branch masterChanges to be committed: (use &quot;git restore --staged &lt;file&gt;...&quot; to unstage) modified: Server/service.pyChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory) modified: Server/service.py 此时，我们发现修改有误，需要撤销工作区中文件内容，指令如下： 1$ $ git checkout -- Server/service.py 查看文件内容，发现撤销修改回到添加到暂存区后的状态（仅仅撤销了第二次修改的内容）： 123456789$ cat Server/service.py# Git is a distributed version control system.# Git is free software.# This is a Test!print ('Git is very useful!!!')# Git has a mutable index called stage.# Git tracks changes of files. 事实上，我们第一次已经 add 到 暂存区的内容也是有问题的，怎么办？ git reset HEAD file 可以帮我们直接清楚暂存区内容。 如果你想将当前文件的修改从暂存区移除去，可以做如下操作： 123456789101112git reset HEAD Server/service.pyUnstaged changes after reset:M Server/service.py$ git statusOn branch masterChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory) modified: Server/service.pyno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 然后，我们对比一下，工作区和暂存区中 Server/service.py 文件差异： 1234567891011$ git diffdiff --git a/Server/service.py b/Server/service.pyindex 6bef824..a17dbf0 100644--- a/Server/service.py+++ b/Server/service.py@@ -5,4 +5,4 @@ print ('Git is very useful!!!') # Git has a mutable index called stage.-# Git tracks changes.+# Git tracks changes of files. 现在，上一小节的第二次修改也不想要了，怎么办？指令如下： 1$ git checkout -- Server/service.py 当然了，使用 git reset 可以很容易实现上述“复杂”的过程，但这里主要是为了引入 git reset HEAD file，掌握这一方法可以很快清空暂存区。 CMD 8 –&gt;&gt;&gt; git switch &amp;&amp; git restore 我们知道，git checkout 命令身兼数职（切换分支、文件撤回…），从 Git 2.23 版本开始引入了两个新的命令来分担 git checkout 功能： git switch：切换分支 git restore：文件撤回（检出） git switch 功能这里不进行详细介绍，在介绍 Git 分支功能时再详解。 git restore 命令详解： git restore file&gt;&gt;&gt; 指令使得在工作空间但是不在暂存区的文件撤销更改(内容恢复到没修改之前的状态)；【另一种说法：用暂存区或者版本库中的文件覆盖本地文件的修改可以达到回退修改的目的】 git restore –staged file&gt;&gt;&gt; 的作用是将暂存区的文件从暂存区撤出，但不会更改文件的内容。【另一种说法：使用版本库中的文件覆盖暂存区的文件，达到回退 git add 命令的目的】 Delete File前面我们接触的修改文件都是新建、修改等。那么，Git 中是如何管理文件删除的？？？ 下面我们通过一个删除实例来看 Git 如何管理删除，先添加一个新文件 git_rm_test.txt 到 Git 并且提交： 123456$ touch git_rm_test.txt$ git add git_rm_test.txt$ git commit -m 'Add git_rm_test.txt'[master 6516e48] Add git_rm_test.txt 1 file changed, 0 insertions(+), 0 deletions(-) create mode 100644 git_rm_test.txt 然后我们删除 git_rm_test.txt 文件。这时 Git 会跟踪删除文件操作，工作区和版本库就不一致了。此时我们来看版本库状态，会发现 Git 已经知道了我们的删除操作： 123456789$ git statusOn branch masterChanges not staged for commit: (use &quot;git add/rm &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) deleted: git_rm_test.txtno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 此时我们面临两个选择：一是确实要从版本库中删除该文件；那就用命令 git rm(add) file 删掉，并且 git commit 提交： 1234567$ git rm git_rm_test.txtrm 'git_rm_test.txt' $ git commit -m 'rm git_rm_test.txt'[master 4f15f79] rm git_rm_test.txt 1 file changed, 0 insertions(+), 0 deletions(-) delete mode 100644 git_rm_test.txt 另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本： 1$ git checkout -- git_rm_test.txt","link":"/2017/07/02/git-shi-yong-zhi-nan-zhi-shi-guang-chuan-suo-ji/"},{"title":"HTML 教程之 HTML 基本元素","text":"正式开始学习 HTML 中的基本元素。 你可以在 &gt;&gt;&gt; HTML 元素和有效 DOCTYPES &lt;&lt;&lt; 查询到所有的 HTML5/HTML 4.01/XHTML 元素，以及它们会出现在什么文档类型 (!DOCTYPE) 中。 HTML 标题HTML 文档中，标题（Heading）很重要，可用来呈现文档结构。合理使用标题可以使网页的层次结构更加清晰，有利于用户浏览你的网页。 HTML 中的标题可帮助搜索引擎理解网页的结构和内容，多见于博文页面。 HTML 中，提供了从 &lt;h1&gt; 到 &lt;h6&gt; 六个级别的标题标签（Heading），&lt;h1&gt; 标签的级别最高，&lt;h6&gt; 标签的级别最低。 并且，在网页上使用标题标签时，浏览器会自动地对标题内容进行加粗、加大（由标题级别决定）、换行，并且会在每个标题的上下添加一定的空白区域（外边距，可以使用 CSS margin 属性来调整空白区域的大小）。 示例代码如下： 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;HTML 标题标签演示&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;h1 标题&lt;/h1&gt; &lt;h2&gt;h2 标题&lt;/h2&gt; &lt;h3&gt;h3 标题&lt;/h3&gt; &lt;h4&gt;h4 标题&lt;/h4&gt; &lt;h5&gt;h5 标题&lt;/h5&gt; &lt;/br&gt; &lt;!-- 换行不代表添加空白行 --&gt; &lt;h6&gt;h6 标题&lt;/h6&gt;&lt;/body&gt;&lt;/html&gt; 关于标题标签的使用，你需要注意的是： HTML 标题标签只能用来定义标题，不可以使用标题标签来对文本进行加粗、大号设计； 搜索引擎会使用标题为网页的结构和内容编制索引； 要根据具体的使用环境，按照级别由高到低的使用标题标签。 应该使用 &lt;h1&gt; 标签来标记最重要的标题，该标题通常位于页面顶部，而且一个 HTML 文档中通常应该有且仅有一个 &lt;h1&gt; 标题；至于较低级别的标题标签（例如 &lt;h2&gt;、&lt;h3&gt;、&lt;h4&gt; 等）的使用则可以不加限制，但最多不要超过 4 层。 HTML 水平线HTML 中，提供了一个自闭合标签 &lt;hr /&gt; 水平线标签（Horizontal），用于在 HTML 页面中创建水平线。 hr 元素可用于分隔内容，使用该标签产生的水平线可以在视觉上将文档分隔成各个部分。 示例代码如下： 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;HTML 水平线标签演示&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;h1 标题&lt;/h1&gt; &lt;h2&gt;h2 标题&lt;/h2&gt; &lt;p&gt;这是一个段落。&lt;/p&gt; &lt;hr /&gt; &lt;h2&gt;h2 标题&lt;/h2&gt; &lt;p&gt;这是一个段落。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; HTML 段落HTML 中，提供了 &lt;p&gt; 段落标签（Paragraph），用于将 HTML 文档分割为若干个段落层次。其语法格式如下： 1&lt;p&gt;段落中的内容。&lt;/p&gt; 并且，在网页上使用段落标签时，浏览器会自动地进行换行，并且会在每个段落的上下添加一定的空白区域（外边距，可以使用 CSS margin 属性来调整空白区域的大小）。 在 &lt;p&gt; 标签中的文本会自动换行，不在 &lt;p&gt; 标签中的，不会自动换行。示例代码如下： 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;HTML 段落标签演示&lt;/title&gt;&lt;/head&gt;&lt;body&gt; 段落1 段落2 段落3 &lt;p&gt;段落 4&lt;/p&gt; &lt;p&gt;段落 5&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; HTML 换行HTML 中，提供了一个自闭合标签 &lt;br /&gt; 水平线标签（Barter Rabbet，更换槽口），用于实现换行功能。 br 元素可用于在不产生一个新起点（标签内容中）的情况下进行换行，否则可能产生一个空白行。 示例代码如下： 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;HTML 换行标签演示&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;这个&lt;br /&gt;段落&lt;br /&gt;用于演示了分行的效果&lt;br /&gt;&lt;/p&gt; &lt;br /&gt; &lt;!-- 这会生成一个空白行 --&gt; &lt;p&gt;这是另一个段落&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; HTML 格式化HTML 中存在一些不仅具有语义（含义），且有默认样式（Style）的文本格式化标签，例如 &lt;b&gt;（加粗）、&lt;em&gt; 斜体、&lt;blockquote&gt; 引用等。 通过使用这些标签，无需借助 CSS 就可以为网页中的内容定义一些基本的样式。 这里，为了方便记忆，根据需要格式化的文本内容的不同，将格式化标签分为三类： 文本类格式化标签； 计算机类格式化标签； 引用定义类格式化标签。 文本类格式化标签文本类格式化标签包括 11 个，分别为：&lt;b&gt; &amp;&amp; &lt;strong&gt; &amp;&amp; &lt;em&gt; &amp;&amp; &lt;i&gt; &amp;&amp; &lt;small&gt; &amp;&amp; &lt;big&gt; &amp;&amp; &lt;sup&gt; &amp;&amp; &lt;sub&gt; &amp;&amp; &lt;ins&gt; &amp;&amp; &lt;del&gt; &amp;&amp; &lt;mark&gt;。 [1] &gt;&gt;&gt; 加粗（Bold） &lt;b&gt; 元素用于将相关文本以 加粗（粗体）样式 显示（不暗示文本的重要性）。 示例代码如下： 1&lt;p&gt;这是一个普通的文本- &lt;b&gt;这是一个加粗文本&lt;/b&gt;。&lt;/p&gt; 推荐：使用 CSS Font 的 font-weight 属性来设置粗体文本。 [2] &gt;&gt;&gt; 粗体强调（Strong） &lt;strong&gt; 元素用于强调某些文本的重要性，且文本会以 加粗（粗体）样式 显示。 示例代码如下： 1&lt;strong&gt;强调该部分文本的重要性（以加粗（粗体）样式显示）&lt;/strong&gt; 推荐：如果只是为了达到某种视觉效果而使用的话，建议使用 CSS Font，可能会取得更丰富的效果。 &lt;b&gt; &amp;&amp; &lt;strong&gt; 区别 &gt;&gt;&gt; 虽然显示效果一样，但 &lt;b&gt; 元素不暗示文本的重要性，仅为了引起读者的注意。 [3] &gt;&gt;&gt; 斜体（Italic） &lt;i&gt; 元素用于将相关文本以 斜体样式 显示（不暗示文本的重要性）。 示例代码如下： 1&lt;p&gt;He named his car &lt;i&gt;The lightning&lt;/i&gt;, because it was very fast.&lt;/p&gt; 推荐：使用 CSS Font 的 font-style 属性来设置斜体文本。 [4] &gt;&gt;&gt; 斜体强调（Emphasized） &lt;em&gt; 元素用于强调某些文本的重要性，且文本会以 斜体样式 显示。 示例代码如下： 1&lt;em&gt;强调该部分文本的重要性（以斜体样式显示）&lt;/em&gt; 推荐：如果只是为了达到某种视觉效果而使用的话，建议使用 CSS Font，可能会取得更丰富的效果。 &lt;i&gt; &amp;&amp; &lt;em&gt; 区别 &gt;&gt;&gt; 虽然显示效果一样，且被用来表示科技术语、其他语种的成语俗语、想法、宇宙飞船的名字等等，但 &lt;i&gt; 元素不暗示文本的重要性，仅为了引起读者的注意。 [5] &gt;&gt;&gt; 字号缩小（small） &lt;small&gt; 元素可以使显示在浏览器中的文本变为较小一号的字体文本。 示例代码如下（支持嵌套，字体达到最小字号时失效）： 12&lt;p&gt;W3C - the world's largest web development site.&lt;/p&gt;&lt;p&gt;&lt;small&gt;Copyright &lt;small&gt;1999-2050&lt;/small&gt; by Refsnes Data&lt;/small&gt;&lt;/p&gt; HTML5 中该标签被重新定义，可以用来表示边注释或需要遵循的规则。 推荐：使用 CSS Font 的 font-size 属性来设置文本字体大小。 [6] &gt;&gt;&gt; 字号放大（big） HTML 4.01 支持 &lt;big&gt; 标签，但 HTML5 中已不再支持 &lt;big&gt; 标签，使用 CSS Font 的 font-size 属性来设置文本字体大小。 &lt;big&gt; 元素可以使显示在浏览器中的文本变为较大一号的字体文本。支持嵌套，字体达到最大字号时失效。 [7] &gt;&gt;&gt; 上标（Superscripted） &lt;sup&gt; 元素用来定义具有上标的文本，常用于数学公式或脚注，显示于。 示例代码如下： 123&lt;p&gt;This text contains &lt;sup&gt;superscript&lt;/sup&gt; text.&lt;/p&gt;&lt;p&gt;X&lt;sup&gt;2&lt;/sup&gt;&lt;/p&gt;&lt;p&gt;WWW&lt;sup&gt;1&lt;/sup&gt;&lt;/p&gt; [8] &gt;&gt;&gt; 下标（Subscripted） &lt;sub&gt; 元素用来定义具有下标的文本，常用于化学方程式。 示例代码如下： 12&lt;p&gt;This text contains &lt;sub&gt;subscript&lt;/sub&gt; text.&lt;/p&gt;&lt;p&gt;H&lt;sub&gt;2&lt;/sub&gt;O&lt;/p&gt; 上（下）标文本将会显示在当前文本流中字符高度的一半为基准线的上（下）方，但是与当前文本流中文字的字体和字号都是一样的。 [9] &gt;&gt;&gt; 删除（Deleted） &lt;del&gt; 元素用来定义，文档中已删除的文本。通常显示文本删除线效果，和 &lt;ins&gt; 元素搭配使用。 [10] &gt;&gt;&gt; 插入（Inserted） &lt;ins&gt; 元素用来定义，文档中更新和修正后插入文档中的文本。 对文档中的文本使用 &lt;ins&gt; 标签后，会显示文本下划线效果。 示例代码如下： 1&lt;p&gt;My favorite color is &lt;del&gt;blue&lt;/del&gt; &lt;ins&gt;red&lt;/ins&gt;!&lt;/p&gt; 注意：一般不要给普通文本加下划线，用户会误以为是一个超链接。 &lt;del&gt; 和 &lt;ins&gt; 一起搭配使用，描述文档中的更新和修正。浏览器通常会在已删除文本上添加一条删除线，在新插入文本下添加一条下划线。 [11] &gt;&gt;&gt; 高亮标记（Mark） &lt;mark&gt; 元素用来定义，带有记号（高亮）的文本，它是 HTML5 提供的新标签。 主流浏览器 Internet Explorer 9+（Internet Explorer 8 及更早版本不支持）、Firefox、Opera、Chrome 和 Safari 都支持 标签。 1&lt;p&gt;My favorite color is &lt;mark&gt;blue&lt;/mark&gt;!&lt;/p&gt; | &gt;&gt;&gt; ============================================ Split Line ============================================ &lt;&lt;&lt; 根据 HTML 5 的规范， &lt;b&gt; &amp;&amp; &lt;i&gt; 标签应该做为最后的选择，只有在没有其他标记比较合适时才使用。 被强调的文本（术语）应该用 &lt;em&gt; 标签表示，重要的文本应该用 &lt;strong&gt; 标签表示，被标记的或者高亮显示的文本应该用 &lt;mark&gt; 标签表示。 计算机类格式化标签计算机类格式化标签包括 5 个，分别为：&lt;code&gt; &amp;&amp; &lt;kbd&gt; &amp;&amp; &lt;samp&gt; &amp;&amp; &lt;var&gt; &amp;&amp; &lt;pre&gt;。 [1] &gt;&gt;&gt; 代码（Code） &lt;code&gt; 元素用于定义一段计算机代码文本，且文本会以 等宽字体样式 显示（以提示这段文本是源程序代码）。 示例代码如下： 1&lt;code&gt;print(&quot;Hello, welcome to HTML world.&quot;)&lt;/code&gt; 推荐：如果只是为了达到某种视觉效果而使用的话，建议使用 CSS，可能会取得更丰富的效果。 [2] &gt;&gt;&gt; 样例（Sample） &lt;samp&gt; 元素用于定义计算机程序的样例，且样例文本会以 浏览器默认的 monotype 字体 显示（以提示这段文本是源程序代码样本）。 示例代码如下： 1234&lt;!-- 比较一下显示效果 --&gt;&lt;code&gt;print(&quot;Hello, welcome to HTML4.01 world.&quot;)&lt;/code&gt;&lt;samp&gt;print(&quot;Hello, welcome to HTML5 world.&quot;)&lt;/samp&gt;&lt;samp&gt;print(&quot;Hello, welcome to XHTML1 world.&quot;)&lt;/samp&gt; 推荐：如果只是为了达到某种视觉效果而使用的话，建议使用 CSS，可能会取得更丰富的效果。 [3] &gt;&gt;&gt; 变量（Variable） &lt;var&gt; 元素用于定义数学表达式或编程上下文中的变量，且文本会以 斜体样式 显示。 示例代码如下： 1&lt;p&gt;&lt;var&gt;X&lt;/var&gt;+&lt;var&gt;Y&lt;/var&gt;=&lt;var&gt;Z&lt;/var&gt;&lt;/p&gt; 推荐：如果只是为了达到某种视觉效果而使用的话，建议使用 CSS，可能会取得更丰富的效果。 [4] &gt;&gt;&gt; 变量（Preformatted） &lt;pre&gt; 元素用于定义预格式化的文本，且文本会以 等宽字体样式 显示，会保留文本中的空格和换行符。 &lt;pre&gt; 标签与 &lt;code&gt; &amp;&amp; &lt;var&gt; 标签配合使用，常用来预格式计算机源代码文本。 示例代码如下（预格式化一段 Java 代码）： 12345678910111213141516171819202122&lt;p&gt;这里是没有用预格式的情况：&lt;/p&gt;public class HelloWorld {public static void main(String[] args) { System.out.println(&quot;Hello World&quot;);}}&lt;br/&gt;&lt;br/&gt;&lt;p&gt;使用预格式的情况:&lt;/p&gt;&lt;pre&gt;public class HelloWorld {public static void main(String[] args) { System.out.println(&quot;Hello World&quot;);}}&lt;/pre&gt; 需要注意的是，&lt;pre&gt; 元素是块级元素，但是只能包含文本或行内元素，任何块级元素都不能位于 &lt;pre&gt; 元素中。 [5] &gt;&gt;&gt; 键盘码（Keyboard） &lt;kbd&gt; 元素用于定义键盘输入文本，且文本会以 等宽字体样式 显示。 需要注意的是，&lt;kbd&gt; 标签已废弃，不推荐使用，如果只是为了达到某种视觉效果而使用的话，建议使用 CSS，可能会取得更丰富的效果。 引用定义类格式化标签计算机类格式化标签包括 7 个，分别为：&lt;abbr&gt; &amp;&amp; &lt;address&gt; &amp;&amp; &lt;blockquote&gt; &amp;&amp; &lt;q&gt; &amp;&amp; &lt;cite&gt; &amp;&amp; &lt;bdo&gt; &amp;&amp; &lt;dfn&gt;。 [1] &gt;&gt;&gt; 首字母缩略（Abbreviation） &lt;abbr&gt; 元素用于定义文本为其缩写词或者首字母缩略词，如 “WWW”（”World Wide Web”） &amp;&amp; “WHO”（”World Health Organization”）。 示例代码如下： 1&lt;p&gt;The &lt;abbr title=&quot;World Health Organization&quot;&gt;WHO&lt;/abbr&gt; was founded in 1948.&lt;/p&gt; 其中，&lt;abbr&gt; 标签的 title 属性，可被用来展示缩写词/首字母缩略词的完整版本。在某些浏览器中，缩略词文本会以 下划虚线样式 显示，且当你把鼠标移至缩写词/上时，会根据 title 属性值来展示其缩略词的完整形式。 该标签最初是在 HTML 4.0 中引入的，IE 6 或更早版本的 IE 浏览器不支持 &lt;abbr&gt; 标签。 [2] &gt;&gt;&gt; 作者联系信息（Address） &lt;address&gt; 元素用于定义作者的联系信息文本，例如：地址、名称、邮箱等，且文本会以 斜体样式 自动换行 显示。 示例代码如下： 1234567&lt;address&gt;Written by &lt;a href=&quot;mailto:webmaster@example.com&quot;&gt;Jon Doe&lt;/a&gt;.&lt;br&gt;Visit us at:&lt;br&gt;Example.com&lt;br&gt;Box 564, Disneyland&lt;br&gt;USA&lt;/address&gt; &lt;address&gt; 元素通常被包围在 &lt;footer&gt; 元素的其他信息中，用于描述站点作者信息。事实上，如果 &lt;address&gt; 元素位于 &lt;body&gt;元素内部，则它表示该文档作者/所有者的联系信息（同页脚）；如果 &lt;address&gt; 元素位于 &lt;article&gt; 元素内部，则它表示该文章作者/所有者的联系信息。 HTML 4.01 不支持 &lt;article&gt; 标签，因此在 HTML 4.01 中 &lt;address&gt; 标签总是定义文档的作者/所有者的联系信息。 [3] &gt;&gt;&gt; 块引用（Block Quotation） &lt;blockquote&gt; 元素用于定义一段长引用文本，且文本会以 块缩进样式 自动换行 显示。 示例代码如下： 123&lt;blockquote cite=&quot;http://www.worldwildlife.org/who/index.html&quot;&gt;For 50 years, WWF has been protecting the future of nature. The world's leading conservation organization, WWF works in 100 countries and is supported by 1.2 million members in the United States and close to 5 million globally.&lt;/blockquote&gt; 其中，&lt;blockquote&gt; 标签的 cite 属性表示引用源的 URL。 [4] &gt;&gt;&gt; 短引用（Quotation） &lt;q&gt; 元素用于定义一段短引用文本，且文本会以 引号包围样式 显示。 示例代码如下： 123&lt;p&gt;WWF's goal is to:&lt;q cite=&quot;http://www.xxxxxxxxxx&quot;&gt;Build a future where people live in harmony with nature.&lt;/q&gt;We hope they succeed.&lt;/p&gt; 其中，&lt;q&gt; 标签的 cite 属性表示引用源的 URL。 | &gt;&gt;&gt; ============================================ Split Line ============================================ &lt;&lt;&lt; 注意事项 &gt;&gt;&gt;&gt; 1）&lt;q&gt; 元素表示不需要段落分隔的短引用，为行内元素；&lt;blockquote&gt; 元素表示块引用，为块元素； 2）HTML 4.01 中，&lt;blockquote&gt; 标签定义一段长引用。而在 HTML5 中，&lt;blockquote&gt; 标签定义摘自另一个网页源的块引用（指定 cite）； 3）如需把页面作为 XHTML 进行验证，那么 &lt;blockquote&gt; 元素必须包含块级元素，比如： 123&lt;blockquote&gt;&lt;p&gt;Here is a long quotation here is a long quotation.&lt;/p&gt;&lt;/blockquote&gt; [5] &gt;&gt;&gt; 引用（Citation） &lt;cite&gt; 元素用于定义作品（比如书籍、杂志、歌曲、电影、电视节目、绘画、雕塑等等）的名称引用，且文本会以 斜体样式 显示。 示例代码如下： 1&lt;p&gt;&lt;cite&gt;The Scream&lt;/cite&gt; by Edward Munch. Painted in 1893.&lt;/p&gt; HTML 4.01 中， &lt;cite&gt; 标签定义一个引用，而在 HTML5 中， &lt;cite&gt; 标签定义作品的标题。 [6] &gt;&gt;&gt; 文本方向（Bi-Directional Override） &lt;bdo&gt; 元素用于定义文本排序的显示方向，且文本会以 从左到右（从右到左） 进行显示。 示例代码如下： 12&lt;p&gt;该段落文字从左到右显示。&lt;/p&gt;&lt;p&gt;&lt;bdo dir=&quot;rtl&quot;&gt;该段落文字从右到左显示。&lt;/bdo&gt;&lt;/p&gt; 其中，&lt;bdo&gt; 标签的 dir 属性排序方向，属性值有 “ltr”（Left to Right）&amp;&amp; “rtl”（Right to Left）。 [7] &gt;&gt;&gt; 术语（Defines Nomenclature） &lt;dfn&gt; 元素用于定义术语文本，且文本会以 斜体样式 显示。 示例代码如下： 1&lt;p&gt;&lt;dfn&gt;Deep Learning&lt;/dfn&gt;&lt;/p&gt; 推荐：如果只是为了达到某种视觉效果而使用的话，建议使用 CSS，可能会取得更丰富的效果。 HTML 图像一图胜千言，图片比文字更具表现力，恰当地使用图片可以让网页更加精美。 HTML 中，为我们提供了一个 &lt;img&gt; 自闭合标签（包含属性，XHTML 需要强制关闭），用于向 HTML 页面插入图片（Image）。 图像虽好，但仍慎用 &gt;&gt;&gt; 假如某个 HTML 页面包含十个图像，那么为了正确显示这个页面，需要加载 11 个图像资源文件。而加载图片是需要时间的，消耗网络资源的。 需要注意的是：img 元素是一个内联元素，无法自动换行。 实际上，HTML 中对 &lt;img&gt; 标签的使用，就是合理设置各种图像标签支持的属性来实现不同的图像效果： 图像源属性想要在页面上显示图像，你只需要在 &lt;img&gt; 标签中使用源属性（Src）即可。其语法格式如下： 12&lt;!-- 包含一个必要的 `src` 属性 --&gt;&lt;img src=&quot;url&quot;&gt; 源属性（Source）的值是图像的 URL 地址，用来指明 想要插入的图像的存储位置（地址或者路径），可以是相对路径或者绝对路径。并且，Src 支持多种图片格式，比如 JPG、JPEG、PNG、GIF 等。 下面来看几种应用实例： [1] &gt;&gt;&gt; 插入网络图像资源 我们知道，图像也是一种网络资源，就如你在网上冲浪时看到的图片，这些图片都是存储在全网可访问的 Web 服务器或者图床上的。你可以通过相应图像的 URL 插入到你的网页文档中。代码示例如下： 1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;HTML 图像演示&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;这是一个插入网络图像资源的演示&lt;/p&gt; &lt;img src=&quot;https://cdn.jsdelivr.net/gh/TheNightIsYoung/HexoImageBed0/Img/markdown_logo.jpeg&quot;&gt;&lt;/body&gt;&lt;/html&gt; [2] &gt;&gt;&gt; 插入本地图像资源 如果你仅仅想通过本地存储的一些图片资源进行 HTML 图像测试，这也是可以的。 假设此时，你的本地路径：E:\\HTMLDemo\\images 下有一个图片 kawayi.jpg，插入代码示例如下： 1234567891011&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;HTML 图像演示&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;这是一个插入本地图像资源的演示&lt;/p&gt; &lt;img src=&quot;file://E:/HTMLDemo/images/kawayi.jpg&quot;&gt;&lt;/body&gt;&lt;/html&gt; URL 前面的 file:// 表示当前访问资源是一个本地文件，当然你也可以不加尝试一下。 [3] &gt;&gt;&gt; 相对路径 &amp;&amp; 绝对路径 绝对路径好理解，就是图片在计算机中的实际存储路径，例如 E:/HTMLDemo/images/kawayi.jpg。而对于网络图片资源而言，绝对路径就是图片的 URL 链接。 而绝对路径是指，图片相对于当前 HTML 网页文档的路径。 假设，图片资源和 HTML 文档位于同一文件夹下，你可以通过如下代码使用图片： 1&lt;img src=&quot;kawayi.jpg&quot;&gt; 假设，图片资源位于 HTML 文档的上一级目录中，你可以通过如下代码使用图片： 1&lt;img src=&quot;../kawayi.jpg&quot;&gt; 同理，上上级就是 ../../kawayi.jpg，同级 images 目录下就是 images/kawayi.jpg（相当于下级目录）。 需要注意的是，并不是只有本地图片资源才可以使用相对路径！！！ 前面提到过，网站可以看作是一个绑定了特定域名的顶级目录，该目录位于提供 Web 服务的远程服务器上，故该网站中的网页可以访问到该顶级目录下的资源（图片、文件等）。 故，当你有了一个自己的 Web 站点之后，你在 Web 站点中的网页中插入图片时，也可以使用 Src 相对路径的定义方法。 如果你想深入了解 URL 的内容，可以参考博文系列中 &gt;&gt;&gt; 网站基础之 URL 全结构解析 一文。 图像替换属性加载页面时，要注意插入页面图像的路径，如果不能正确设置图像的地址或网络连接失败时，浏览器无法加载图片，图像标签就会显示一个破碎的图片。 浏览器无法加载图片（无法访问图片资源），不仅仅由于图片 URL 错误或者网络连接失败，还可能是本地图片资源被删除，或者之前提供网络图片资源的服务器不再提供访问了，这都可能导致。 当页面图片丢失时，仅提供一个图片缺省图标是不友好的。 HTML 页面中支持为丢失图片提供丢失信息描述，你需要在 &lt;img&gt; 标签中使用替换属性（Alt）。其语法格式如下： 12&lt;!-- 包含一个必要的 `src` 属性 --&gt;&lt;img src=&quot;url&quot; alt=&quot;image description text&quot;&gt; 这样，当图片资源无法访问时，就会显示丢失的图像信息描述。图片可以访问时不显示。 代码示例（插入一个不存在图片）： 1&lt;img src=&quot;../alt_test.jpg&quot; alt=&quot;Lost-picture description text&quot;&gt; 图像宽度和高度属性事实上，计算机中我们常说的某张图片的大小是 800 * 640 的，指的是图片宽度是 800 像素（px），高度是 640 像素（px）。 HTML 中，你可以在 &lt;img&gt; 标签中使用宽度（Width）和高度（Height）属性来设定图片的宽度和高度，其属性值的单位也是像素（px）。语法格式如下： 12&lt;!-- 图像缩小为一半 --&gt;&lt;img src=&quot;images/kawayi.jpg&quot; alt=&quot;Lost-picture description text&quot; width=&quot;400&quot; height=&quot;320&quot;&gt; 此外，也可以使用前面提到过的 style 通用属性来指定图片的宽度和高度（CSS 样式）： 12&lt;!-- 图像缩小为一半 --&gt;&lt;img src=&quot;images/kawayi.jpg&quot; alt=&quot;Lost-picture description text&quot; style=&quot;width: 400px; height: 320px;&quot;&gt; 图像大小设置建议 &gt;&gt;&gt; 为了防止 HTML 页面加载的原始图片过大或过小影响页面展示（页面布局失真或闪烁），所以插入图片时必须要控制图片的显示尺寸; 图片设置大于原始图片像素时，会导致图片失真，但并不会改变原始图片文件的像素大小； 设置时，为了防止图片变形（宽高像素比例发生变化），你可以只设置一个属性即可（Width 或者 Height），另一个会根据原始图像的像素比例进行显示; 设置时，要考虑页面布局空间。页面中图片设置过大或过小均影响页面显示（页面布局失真或闪烁）； 推荐页面使用 CSS 响应式布局（自适应布局），建议在上传图片之前裁剪好尺寸，而不要设置 Width 和 Height 属性，这样图片能够跟随屏幕宽度自动改变尺寸，从而不会变形，或者超出屏幕宽度。 图像映射属性HTML 中，你可以在 &lt;img&gt; 标签中使用其映射（Usemap）属性，来创建带有可供点击区域的 图像地图，每个可点击区域都是一个超链接。 例如，我们可以按照地图的划分，为每个国家或城市所在的区域定义超链接，通过点击相应的区域链接，你可以下钻到相应的地图区域。 图像地图的定义，需要三个标签的共同配合：&lt;img&gt; &amp;&amp; &lt;map&gt; &amp;&amp; &lt;area&gt;。其中，&lt;area&gt; 标签用于定义某个可点击区域，图像地图中存在多少个有效点击区域就应该设计多少个 &lt;area&gt; 元素，它们共同构成了一个图像地图（&lt;map&gt;）元素。故，&lt;area&gt; 元素永远嵌套在 &lt;map&gt; 元素内部一起使用，以实现图像地图（映射）定义。 其语法格式如下： 12345678&lt;!-- 预先定义当前图像是一个图像地图，图像地图名称为：&quot;chinamap&quot; --&gt;&lt;img src=&quot;images/kawayi.jpg&quot; alt=&quot;China Map&quot; width=&quot;400&quot; usemap=&quot;#chinamap&quot;&gt;&lt;!-- 定义存在两个映射区域的图像地图，其名称使用 `name` 属性定义为：&quot;chinamap&quot; --&gt;&lt;map id=&quot;chinamap&quot; name=&quot;chinamap&quot;&gt; &lt;area shape=&quot;poly&quot; coords=&quot;180,139,14&quot; href =&quot;url1&quot; alt=&quot;Shanxi&quot; /&gt; &lt;area shape=&quot;poly&quot; coords=&quot;129,161,10&quot; href =&quot;url2&quot; alt=&quot;Shanghai&quot; /&gt;&lt;/map&gt; 属性说明 &gt;&gt;&gt; [1] &gt;&gt;&gt; usemap &lt;img&gt; 标签中的 usemap 属性表示当前图像存在图像地图，其属性值为图像地图的名称。 [2] &gt;&gt;&gt; id &amp;&amp; name &lt;img&gt; 标签中的 usemap 属性可引用 &lt;map&gt; 中的 id 或 name 属性（取决于浏览器），推荐同时向 &lt;map&gt; 标签中添加 id 和 name 属性。 HTML5 中, 如果 id 属性在 &lt;map&gt; 标签中指定, 则你必须同样指定 name 属性。这也是同时添加两个属性的原因。而在 XHTML 中，name 属性已经废弃，使用 id 属性即可。 [3] &gt;&gt;&gt; shape &amp;&amp; coords &amp;&amp; href &amp;&amp; alt &lt;area&gt; 标签中的 shape 和 coords（Coordinates）属性搭配使用，分别用来规定映射区域的形状和坐标。 shape 属性的可选值有三个，分别是 rect（矩形）、circle（圆形）和 poly（多边形），coords 属性中坐标的值则取决于可点击区域的形状。 注意，这里的坐标都是相对于图片的左上角（0, 0）来计算的。 假如定义一个矩形的可点击区域，示例代码如下： 1&lt;area shape=&quot;rect&quot; coords=&quot;x1, y1, x2, y2&quot; href=&quot;url&quot; alt=&quot;description&quot;&gt; 其中 x1、y1 代表矩形的左上角坐标，x2、y2 代表矩形的右下角坐标。 假如定义一个圆形的可点击区域，示例代码如下： 1&lt;area shape=&quot;circle&quot; coords=&quot;x, y, radius&quot; href=&quot;url&quot; alt=&quot;description&quot;&gt; 其中 x、y 代表圆心的坐标，而 radius 则是圆的半径。 假如定义一个多边形的可点击区域，示例代码如下： 1&lt;area shape=&quot;poly&quot; coords=&quot;x1, y1, x2, y2, x3, y3, ..., xn, yn&quot; href=&quot;url&quot; alt=&quot;description&quot;&gt; 其中每对 x 和 y 的值都代表一个多边形的顶点坐标。并且，如果第一个坐标和最后一个坐标不一致，那么为了关闭多边形，浏览器必须添加最后一对坐标。 &lt;area&gt; 标签中的 href（Hypertext Reference）定义区域 URL，使用 href 属性必须添加 alt 属性搭配使用，作为替代文本。 HTML 4.01 中，以下属性：align &amp;&amp; border &amp;&amp; hspace &amp;&amp; vspace &amp;&amp; longdesc 已废弃。HTML5 中不再支持以下属性：align &amp;&amp; border &amp;&amp; hspace &amp;&amp; vspace &amp;&amp; longdesc。 HTML 超链接HTML 文档中，超链接（Hyperlink）很重要。超链接使得网页之间不再独立，它就像一根线，把网页连接在一起，形成一个网状结构。互联网之所以能够称之为“网”，就是因为有超链接的存在。 超链接，是指从当前网页指向另一个目标的连接关系，这个目标可以是另一个网页（或网络资源，例如图片，文件等），也可以是当前网页中的其它位置。链接的两端分别称为源锚点（Source Anchor）和目标锚点（Target Anchor），通过点击源锚点即可以跳转到目标锚点。 在 HTML 中使用 &lt;a&gt; 标签（Anchor）来定义超链接文本，其基本语法格式如下： 1&lt;a href=&quot;url&quot; target=&quot;opentype&quot;&gt;链接文本&lt;/a&gt; 其中，href 属性（Hypertext Reference）用来指明要跳转到的 URL，target 属性用来指明新页面的打开方式。链接文本 不必一定是文本。图片或其他 HTML 元素都可以成为链接。 示例代码如下： 12345&lt;!-- 链接到百度搜索 --&gt;&lt;a href=&quot;https://www.baidu.com&quot; target=&quot;_target&quot;&gt;百度一下，你就知道&lt;/a&gt;&lt;!-- 图片链接 --&gt;&lt;a href=&quot;https://www.baidu.com&quot; target=&quot;_target&quot; title=&quot;百度一下，你就知道&quot;&gt;&lt;img src=&quot;images/kawayi.jpg&quot; alt=&quot;Kawayi&quot; width=&quot;400&quot; /&gt;&lt;/a&gt; 你可以也可以通过 title 通用属性为 链接文本 添加描述内容信息。 链接超文本引用属性href 超文本引用属性，指定链接的目标，也就是要跳转到什么位置。既然是超文本引用，说明其可以指向网页（.html、.php、.jsp、.asp …） &amp;&amp; 图片（.jpg、.gif、.png …） &amp;&amp; 音频（.mp3、.wav …）、视频（.mp4、.mkv …） &amp;&amp; 一些下载网站的链接【压缩文件（.zip、.rar …）、可执行程序（.exe .air …）】。 href 本质上就是指向一个网络资源，这个网络资源（网页、图片、媒体、文件）几乎可以是任意格式的。如果浏览器支持这种格式，那么它就可以在浏览器上显示，比如常见的图片、音频、视频等，如果浏览器不支持这种格式，那么就提示用户下载。 链接打开方式属性HTML 链接中，提供有用于指明链接的打开方式的 target 属性，支持： _self：默认打开方式，在当前窗口中打开新页面，原窗口将被覆盖； _blank：在新窗口中打开新页面，原窗口将被保留； _parent：在当前框架的上一层打开新页面； _top：在顶层框架中打开新页面。 绝大部分情况下，target 属性要么不写，保持默认的 _self，要么将它的值设置为 _blank，在新窗口中打开页面。 链接默认样式浏览器会为 &lt;a&gt; 标签设置一些默认样式。 [1] &gt;&gt;&gt; 鼠标样式 当你把鼠标指针移动到网页中的某个链接上时，箭头会变为一只小手（表示此处是一个链接）。 [2] &gt;&gt;&gt; 颜色及下划线 超链接被点击之前为 蓝色，超链接被点击之后变成 紫色。超链接默认带有下划线，下划线颜色和文本颜色保持一致。 浏览器根据历史记录来判断超链接是否被点击过，如果 href 属性和历史记录中的某条 URL 重合，那么说明该链接被点击了。清空浏览器的历史记录会让超链接的颜色再次变回蓝色。 HTML 页面书签HTML 页面可以通过 &lt;a&gt; 标签和 id 属性实现页面书签功能，实现页面内滚动。 示例代码如下： 12345678910&lt;!-- 创建一个书签 --&gt;&lt;h1 id=&quot;tips&quot;&gt;Chapter 4&lt;/h1&gt;&lt;!-- 向上述书签，添加一个链接 &gt;&gt;&gt; 用于滚动到书签 &quot;第四章（Chapter 4）&quot; 处 --&gt;&lt;a href=&quot;#tips&quot;&gt;Visit the Useful Tips Section&lt;/a&gt;&lt;!-- 或者 --&gt;&lt;!-- 在另一张页面中，添加指向当前页面这个书签（Chapter 4）的链接 --&gt;&lt;a href=&quot;demo.html#tips&quot;&gt; Visit Chapter 4 in `demo.html` page&lt;/a&gt; 对于很长的页面（博文），书签可能很有用，可以帮助你快速跳转到特定部分（例如博文中特定章节）。当单击链接时，页面将滚动到带有书签的位置。 HTML 表格HTML 页面中，使用 &lt;table&gt; 标签来定义表格，类似于 Excel 中表格都包括行（row）、列（cell）、单元格（cell）、表头（table heading）等概念。 每个表格均有若干行（由 &lt;tr&gt; 标签（TableRow）定义）构成，每行被分割为若干单元格（由 &lt;td&gt; 标签（TableDataCell）定义）。其中，表头单元格由 &lt;th&gt; 标签定义，是一种特殊的数据单元格（粗体、居中显示），其它数据单元格为标准单元格。数据单元格内容可以是文本、图片、列表、段落、表单、水平线、表格等等。 其语法格式如下(三行三列)： 1234567891011121314151617&lt;table&gt; &lt;tr&gt; &lt;th&gt;名称&lt;/th&gt; &lt;th&gt;描述&lt;/th&gt; &lt;th&gt;补充&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Python&lt;/td&gt; &lt;td&gt;1&lt;/td&gt; &lt;td&gt;description&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Java&lt;/td&gt; &lt;td&gt;2&lt;/td&gt; &lt;td&gt;description&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 浏览器中已显示出了一个表格样式的数据，但默认情况下，表格是没有边框的。 表格边框你可以使用 &lt;table&gt; 标签中的 border 属性来设置表格的边框宽度，单默认位是像素（px），不用显式指明。 你可以尝试使用边框属性为上述表格样式添加宽度为 1 像素的边框： 123&lt;table border=&quot;1&quot;&gt; ...&lt;/table&gt; HTML5 中，border 属性仅用于指示表格是否用于布局目的，且只允许属性值 &quot;&quot; 或 &quot;1&quot;。”” 表格单元周围没有边框（表格可用于布局目的）。”1” 在表格单元周围添加边框（表格不用于布局目的）。 合并单元格HTML 中表格，也支持单元格的合并操作，包括跨行合并和跨列合并两种： rowspan：数据单元格跨行合并属性； colspan：数据单元格跨列合并属性。 注意，不论是 rowspan 还是 colspan 都是 数据单元格（&lt;td&gt; &amp;&amp; &lt;th&gt;） 标签的属性。 示例代码如下： 123456789101112131415161718192021222324&lt;table border=&quot;1&quot;&gt; &lt;tr&gt; &lt;th&gt;名称&lt;/th&gt; &lt;th&gt;描述&lt;/th&gt; &lt;th&gt;补充&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Python&lt;/td&gt; &lt;td&gt;1&lt;/td&gt; &lt;td&gt;description1&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td rowspan=&quot;2&quot;&gt;Java&lt;/td&gt; &lt;td&gt;2&lt;/td&gt; &lt;td&gt;description2&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;3&lt;/td&gt; &lt;td&gt;description3&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=&quot;3&quot;&gt;External PHP&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 需要注意的是，即使一个单元格中没有任何内容，仍推荐使用 &lt;td&gt; 或 &lt;th&gt; 元素来表示一个空单元格的存在，建议在内容中加入 &amp;nbsp;（空格），否则低版本的 IE 可能无法显示出这个单元格的边框。 更复杂的 HTML 表格也可能包括需要使用 &lt;caption&gt; &amp;&amp; &lt;col&gt; &amp;&amp; &lt;colgroup&gt; &amp;&amp; &lt;thead&gt; &amp;&amp; &lt;tfoot&gt; &amp;&amp; &lt;tbody&gt; 元素。 表格完整格式HTML 表格可以分为三个部分：头部（Table Header） &amp;&amp; 主体（Table Body） &amp;&amp; 页脚（Table Footer），功能类似 Word 中的页眉、正文、页脚。 头部，主体和页脚的对应的三个标签是： &lt;thead&gt;：创建单独的表头； &lt;tbody&gt;：表示表格的主体，用于存放表格中的行（tr）和数据单元格（td）； &lt;tfoot&gt;：创建一个单独的表页脚。 示例代码如下： 12345678910111213141516171819202122232425262728293031323334353637&lt;table border=&quot;1&quot;&gt; &lt;!-- Table Header --&gt; &lt;thead&gt; &lt;tr&gt; &lt;td colspan=&quot;3&quot;&gt;This is the head of the table&lt;/td&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;!-- Table Footer --&gt; &lt;tfoot&gt; &lt;tr&gt; &lt;td colspan=&quot;3&quot;&gt;This is the foot of the table&lt;/td&gt; &lt;/tr&gt; &lt;/tfoot&gt; &lt;!-- Table Body --&gt; &lt;tbody&gt; &lt;tr&gt; &lt;th&gt;名称&lt;/th&gt; &lt;th&gt;描述&lt;/th&gt; &lt;th&gt;补充&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Python&lt;/td&gt; &lt;td&gt;1&lt;/td&gt; &lt;td&gt;description1&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td rowspan=&quot;2&quot;&gt;Java&lt;/td&gt; &lt;td&gt;2&lt;/td&gt; &lt;td&gt;description2&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;3&lt;/td&gt; &lt;td&gt;description3&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt;&lt;/table&gt; HTML 5 中，不再支持 HTML 4.01 中 &lt;thead&gt; &amp;&amp; &lt;tbody&gt; &amp;&amp; &lt;tfoot&gt; 标签的任何属性。并且需要注意的是 &lt;thead&gt; &amp;&amp; &lt;tfoot&gt; 标签应出现在 &lt;tbody&gt; 之前。 表格标题HTML 允许使用 &lt;caption&gt; 标签来为表格设置标题，用来描述表格的内容。 &lt;caption&gt; 标签必须直接放置到 &lt;table&gt; 标签之后，这个标题会被居中于表格之上。示例代码如下： 123456789101112131415161718&lt;table border=&quot;1&quot;&gt; &lt;caption&gt;Language Description&lt;/caption&gt; &lt;tr&gt; &lt;th&gt;名称&lt;/th&gt; &lt;th&gt;描述&lt;/th&gt; &lt;th&gt;补充&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Python&lt;/td&gt; &lt;td&gt;1&lt;/td&gt; &lt;td&gt;description&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Java&lt;/td&gt; &lt;td&gt;2&lt;/td&gt; &lt;td&gt;description&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 表格列样式设置为了方便对表格中的列的样式进行设置，HTML 中提供了 &lt;colgroup&gt; 标签（列组），来为某个或某几个列（&lt;col&gt;）应用某种样式（列标签（&lt;col&gt;）需要包围在列组（&lt;colgroup&gt;）标签中使用），而不需要重复为每个单元格或每一行设置样式。 需要注意的是，列组（&lt;colgroup&gt;）标签只能在 &lt;table&gt; 元素之内，在任何一个 &lt;caption&gt; 元素之后，在任何一个 &lt;thead&gt; &amp;&amp; &lt;tbody&gt; &amp;&amp; &lt;tfoot&gt; &amp;&amp; &lt;tr&gt; 元素之前使用。 示例代码如下（为三个列设置了背景色）： 12345678910111213141516171819202122&lt;table border=&quot;1&quot;&gt; &lt;caption&gt;Language Description&lt;/caption&gt; &lt;colgroup&gt; &lt;col span=&quot;2&quot; style=&quot;background-color: red;&quot; /&gt; &lt;col style=&quot;background-color: blue;&quot; /&gt; &lt;/colgroup&gt; &lt;tr&gt; &lt;th&gt;名称&lt;/th&gt; &lt;th&gt;描述&lt;/th&gt; &lt;th&gt;补充&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Python&lt;/td&gt; &lt;td&gt;1&lt;/td&gt; &lt;td&gt;description&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;Java&lt;/td&gt; &lt;td&gt;2&lt;/td&gt; &lt;td&gt;description&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 其中，span 属性表示跨列的列数。 对于表格（Table）的更多样式设置，你可以使用 CSS 样式表进行设置。 表格嵌套你可以在一个表格中使用另一个表。可以使用 &lt;table&gt; 内的几乎所有标签（以上）。 HTML 列表HTML 中支持定义列表（List），列表中你可以放置​​文本、图像、链接等，也可以在一个列表中定义另一个列表（列表嵌套）。 HTML 中支持三种不同形式的列表定义： 有序列表（Ordered List）：使用 &lt;ol&gt; &amp;&amp; &lt;li&gt; 标签； 无序列表（Unordered List）：使用 &lt;ul&gt; &amp;&amp; &lt;li&gt; 标签； 自定义列表（Definition List）：使用 &lt;dl&gt; &amp;&amp; &lt;dt&gt; &amp;&amp; &lt;dd&gt; 标签。 有序列表有序列表适合各项目之间存在顺序关系的情况。 &lt;ol&gt;（Ordered List） 一般和 &lt;li&gt;（List Item） 配合使用，不会单独出现，而且不建议在 &lt;ol&gt; 中直接使用除 &lt;li&gt; 之外的其他标签。有序列表的项目编号默认从数字 1 开始。 示例代码如下： 12345678&lt;!-- Ordered List --&gt;&lt;p&gt;To Cook Rice: &lt;/p&gt;&lt;ol&gt; &lt;li&gt;bring water to a boil&lt;/li&gt; &lt;li&gt;add a teaspoon of rice&lt;/li&gt; &lt;li&gt;stir well&lt;/li&gt; &lt;li&gt;continue to cook for 10 minutes&lt;/li&gt;&lt;/ol&gt; 无序列表无序列表适合各项目之间无级别顺序关系的情况。 &lt;ul&gt;（Unordered List） 一般和 &lt;li&gt;（List Item） 配合使用，不会单独出现，而且不建议在 &lt;ul&gt; 中直接使用除 &lt;li&gt; 之外的其他标签。默认情况下，无序列表的每一项都使用 ● 符号表示。 示例代码如下： 12345678&lt;!-- Unordered List --&gt;&lt;p&gt;Breakfast: &lt;/p&gt;&lt;ul&gt; &lt;li&gt;Eggs&lt;/li&gt; &lt;li&gt;Milk&lt;/li&gt; &lt;li&gt;Bread&lt;/li&gt; &lt;li&gt;Lettuce&lt;/li&gt;&lt;/ul&gt; 自定义列表自定义列表不仅仅是一列项目，而是项目及其描述的组合。 自定义列表使用 &lt;dl&gt;（Definition List）标签定义，&lt;dt&gt;（Definition Term）和 &lt;dd&gt;（Definition Description）是同级标签，它们都是 &lt;dl&gt; 的子标签。一般情况下，每个 &lt;dt&gt; 搭配一个 &lt;dd&gt; 用于定义一个项目以及其描述，一个 &lt;dl&gt; 可以包含多对 &lt;dt&gt; 和 &lt;dd&gt;（多个项目）。 示例代码如下： 1234567&lt;!-- Definition List --&gt;&lt;dl&gt; &lt;dt&gt;Coffee&lt;/dt&gt; &lt;dd&gt;- black hot drink&lt;/dd&gt; &lt;dt&gt;Milk&lt;/dt&gt; &lt;dd&gt;- white cold drink&lt;/dd&gt;&lt;/dl&gt; 需要注意的是：&lt;dt&gt; 和 &lt;dd&gt; 虽然是同级标签，但是它们的默认显示样式不同，&lt;dd&gt; 带有一段缩进，而 &lt;dt&gt; 顶格显示，这样层次更加分明。 并且，自定义列表中的一个术语名（Term）可以对应多重定义或者多个术语名对应同一个定义（Description），对应关系不限。 列表样式对于列表杨样式，外边距、内边距和列表项标记等，你可以通过 CSS 样式表属性来修改。","link":"/2019/01/02/html-jiao-cheng-zhi-html-ji-ben-yuan-su/"},{"title":"HTML 教程之区块内联和页面布局","text":"HTML 中的区块 &amp;&amp; 内联元素以及页面布局。 块级 &amp;&amp; 内联元素HTML 中，标签（元素）可以分为两个类别，分别是块级元素（也叫区块元素）和内联元素（也叫行内元素）。 Box Model在介绍块级元素和内联元素之前，我们需要先简单 Box Model（盒子模型）的基本概念。 在 HTML 中，所有的 HTML 元素都可以看作一个个盒子，其示意图由下所示： [1] &gt;&gt;&gt; 图解 内容区（content）：用来在 HTML 页面显示内容的区域，可以是文本内容、图片、视频或者其他后代元素等； 内边距（padding）：指的是内容区至边框之间的空白区域； 边框（border）：包含内容区和内边距的边界； 外边距（margin）：指的是当前盒子模型的边框至其他盒子模型的边框之间的区域。 [2] &gt;&gt;&gt; 关于设置 width 属性和 height 属性设置盒子模型的内容区在页面中所占区域； border 属性、padding 属性和 margin 属性分别设置盒子的边框、内边距和外边距。 块级元素块级元素（Block Element）最主要的特点是，在浏览器显示独占一行，排斥与其他元素同一行的元素。 块级元素中最具代表性的就是 &lt;div&gt;，此外还有 ol ul li dl dt dd &amp;&amp; table caption tfoot thead tbody th tr &amp;&amp; h1-h6 &amp;&amp; form &amp;&amp; div header nav section article aside footer &amp;&amp; p address 等。 记忆口诀：三大列表和表格、六大标题和表单、网页布局必须算、段落地址要分块。 块级元素一般都具有特定的语义，可以使代码的可读性更强。 块级元素的主要特征如下所示： 不管是否使用换行标签 &lt;br&gt;，块级元素总是在新行上开始； 块级元素的宽度、高度以及外边距和内边距等都可以控制（CSS Style）； 如果省略块级元素的宽度，那么它的宽度默认为当前浏览器窗口的宽度； 块级元素中可以包含其它的内联元素和块级元素。 内联元素内联元素也可以称为行内元素（Inline Element）。其中最具代表性的就是 &lt;span&gt;，此外还有 b i u em strong sup sub big small ins del code cite dfn kbd var 等。 可以看出，内联元素往往带有某种特殊的显示效果，可以代替部分 CSS 样式。 行内元素的主要特征如下所示： 行内元素和其它元素会在同一行上显示（不会自动折行）； 行内元素宽（Width）、高（Height）设置无效，外边距和内边距部分可变； 内联元素中推荐只能容纳文本或者其他内联元素，不推荐嵌套块级元素。 [1] &gt;&gt;&gt; 行内元素不可以设置宽高（Width &amp;&amp; Height）属性，宽、高仅和内容相关（宽度会随着内容增加，高度随字体大小而改变）。[2] &gt;&gt;&gt; 内联元素可以设置部分外边界，外边界不对上下（margin-top/margin-bottom）起作用，只能对左右（margin-left/margin-right）起作用；[3] &gt;&gt;&gt; 内联元素也可以设置部分内边界，设置内边界不对上下（padding-top/padding-bottom）起作用，只能对左右（padding-left/padding-right）起作用。 F12浏览器中，通过快捷键 F12 可以打开浏览器开发者工具（Browser DevTools）。 你可以通过 DevTools 来查看浏览器当前打开页面的源码（Ctrl + U），以及页面中的元素（Elements）和元素的样式（Styles）。 以百度搜索为例，示例图如下： 如图所示，Elements 窗口中展示了当前 HTML 页面的所有元素，你可以通过鼠标选定某个元素（例如：&lt;html&gt;），然后右侧 Styles 窗口就会显示当前选定元素的样式信息，通过样式窗口的滑动条向下滑动你可以看到当前元素的盒子模型。 并且，你可以通过在不同元素上移动鼠标（不选定），可以在页面中查看到相应不同元素的盒子模型显示（根据颜色对比 Styles 窗口中 Box Model 组成颜色）以及盒子大小，如下所示： 上图展示了，&lt;ol&gt; 有序列表元素（块级元素）和 &lt;a&gt; 超链接（内联元素）元素的显示样式。 通过 DevTools 对元素样式的查看，希望你可以更深入的了解上述章节关于块级元素和内联元素的说明。 元素嵌套正如我们前面介绍的，HTML 中的元素支持嵌套的操作，嵌套深度也没有明确限制，包括： 块级元素可以嵌套块级元素，也可以嵌套内联元素； 内联元素可以嵌套内联元素，也可以嵌套块级元素（一般不推荐）。 不建议在内联元素中嵌套块级元素，这样不仅不符合开发规范，还会导致内联元素被撑开，独自占据一行。 但是有时候又不得不这样做，比如我们想实现一个板块链接到一套教程，为了让读者点击板块的任何一个地方都能跳转到教程页面，如下图所示： 当你点击灰色区域时可跳转至相应教程，我们就需要在 &lt;a&gt; 超链接标签中嵌套 &lt;div&gt;、&lt;h4&gt; 和 &lt;p&gt; 标签，代码如下： 12345678910&lt;a href=&quot;https://www.w3cschool.cn/html/&quot; target=&quot;_blank&quot;&gt; &lt;div&gt; &lt;img src=&quot;https://7n.w3cschool.cn/statics/images/logonew2.png&quot; alt=&quot;W3CSchool Icon&quot;&gt; &lt;/div&gt; &lt;div&gt; &lt;h4&gt;HTML Course&lt;/h4&gt; &lt;p&gt;HTML 是一种专门开发网页的标记语言，由浏览器解析。&lt;/p&gt; &lt;/div&gt;&lt;/a&gt; 总之，这是一条建议，不是强制规定。或者你可以看作 &lt;a&gt; 例外。 元素类型转换标签的很多默认行为都可以借助 CSS 改变，显示类型也不例外。 可以通过 CSS display 属性将块级元素修改为内联元素，或者将内联元素修改为块级元素，或者兼具两者优点，将标签设置为行内块级元素。 CSS 虽然可以改变标签的显示类型，但是不能改变标签的语义，读者还是应该根据语义去使用标签： &lt;div&gt; 标签用来布局，而不用来显示文本； &lt;p&gt; 标签用来显示文本，而不用来布局。 Div &amp;&amp; Span&lt;div&gt; 和 &lt;span&gt; 分别是最常用的块级元素和内联元素，用于将元素组合起来以便 CSS 使用。标签本身是没有任何显示效果，通常需要结合 CSS 进行样式以及页面布局设置的。 Div Tag&lt;div&gt; 是非常重要的块级标记，在网页布局（Layout）方面发挥着重要的作用，用于进行页面分割（Division）。 同时，如果与 CSS 一同使用，&lt;div&gt; 元素可用于对大的内容块设置样式属性。 &lt;div&gt; 标签及其包围的内容可以看做网页的一个板块（页面布局），&lt;div&gt; 标签本身并没有什么特殊的显示效果，需要借助 CSS 样式对外边距、内边距、背景、边框等进行设置，从而达到对板块布局的目的。 示例代码如下： 12345678&lt;p&gt;这是一些文本。&lt;/p&gt;&lt;div style=&quot;color:#00FFFF&quot;&gt;&lt;h3&gt;这是一个在 div 元素中的标题。&lt;/h3&gt;&lt;p&gt;这是一个在 div 元素中的文本。&lt;/p&gt;&lt;/div&gt;&lt;p&gt;这是一些文本。&lt;/p&gt; 这里不用深究，后续你再学习了 CSS 的使用后，会越来越多的接触到其使用。 Span TagHTML 中的 &lt;span&gt; 标签是一个用来组合其它行内元素的内联元素，以对 HTML 文档中的内容进行分组修饰。提供一种将文档的一部分独立出来的方式，以提供集体样式。 需要注意的是，此标签本身不会为文档内容提供任何视觉效果，需要与 CSS 结合使用来改变内容的样式，比如字体、颜色、大小、边框、背景等。。 示例代码如下： 1&lt;p&gt;我的母亲有 &lt;span style=&quot;color:blue;font-weight:bold&quot;&gt;蓝色&lt;/span&gt; 的眼睛，我得父亲有 &lt;span style=&quot;color:darkolivegreen;font-weight:bold&quot;&gt;碧绿色&lt;/span&gt; 的眼睛。&lt;/p&gt; 这里不用深究，后续你再学习了 CSS 的使用后，会越来越多的接触到其使用。 | &gt;&gt;&gt; ============================================== Split Line ============================================= &lt;&lt;&lt; | 设想一下： 通过 &lt;div&gt; 标签分割一个独立的网页板块，然后设置通用属性 id Or Class，再结合 CSS 统一设置板块内的样式，是不非常方便。 同理，通过 &lt;span&gt; 标签对网页内具有相同样式的行内元素包围起来，然后设置通用属性 id Or Class，再结合 CSS 统一为组内内容设置样式，极其方便。 嵌入 CSS 样式HTML 的学习离不开 CSS 样式的支持，这里我们先来初步了解一下 CSS 样式的使用，以避免很多看官学到这里了仍然一头雾水（最少先不陌生，甚至学习过程中可以掌握一些 CSS 的使用那就更好了），更详细的使用教程可参见网络相关的教程。 通过前面的学习，你应该已经发现 HTML 仅能呈现一些信息，表现能力非常有限，我们很多时候都推荐引入了 CSS 样式一起使用，以提供元素更多的设置，使页面更加精美。 何为 CSS？CSS（Cascading Style Sheet）可译为 “层叠样式表”。CSS 是在 HTML 4 开始使用的，是为了更好的渲染 HTML 元素而引入的。 简单来说，CSS 专门用于渲染 HTML 元素标签的样式，使用 CSS 可以实现 页面的布局、内容与表现形式分离，可以极大的提高工作效率 。 网页现在的新标准是 W3C 。目前的模式是 Html + Css + Javascript。如何理解呢？就是 Html 是网页的结构（布局 + 内容），CSS 是网页的样式，Javascript 是行为（交互）。 HTML 如何嵌入 CSS？CSS 样式既可以作为单独的文件（后缀为 .css 类型的文件）引入到 HTML 文档中，也可以直接写在 HTML 文档中。 CSS 可以通过以下四种方式添加到 HTML 中: 内联（行内）样式：使用 HTML 标签的 style 属性定义 CSS 样式； 内部样式表：使用 &lt;style&gt; 元素在 HTML 文档头部 &lt;head&gt; 区域定义 CSS 样式； 链接式（外部样式表）：使用 &lt;link&gt; 标签引入外部 CSS 样式表文件； 导入式（外部样式表）：使用 @import 命令导入外部 CSS 样式表文件。 最好的方式是通过外部样式表的方式，为 HTML 页面引入样式，以实现页面内容与表现形式分离。本小节所涉及到的具体 CSS 样式设置请对照 CSS 系列博文，这里只引入一些简单的 CSS 样式辅助理解。 内联样式你可以直接使用 HTML 标签的 style 属性来定义 CSS 样式。 其属性值是一个或多个由分号分隔的 CSS 属性:值 对，例如 style = “color:blue; text-align:center“。 一个修改字体、字体背景、字体颜色、字体大小、文本对齐方式以及 Div 块区使用内联样式的示例： 12345678910&lt;h1 style=&quot;font-family: verdana; text-align: center;&quot;&gt;A Center-aligned Heading&lt;/h1&gt;&lt;p style=&quot;background-color: aquamarine;&quot;&gt;A paragraph with background-color.&lt;/p&gt;&lt;p style=&quot;color:aquamarine;&quot;&gt;A paragraph with color.&lt;/p&gt;&lt;p style=&quot;font-size: 20px;&quot;&gt;A paragraph with 20px font-size.&lt;/p&gt;&lt;div style=&quot;background-color:bisque; color:blue; text-align: center;&quot;&gt; &lt;h2&gt;A Heading&lt;/h2&gt; &lt;p&gt;A paragraph.&lt;/p&gt; &lt;strong&gt;Inline elements: strong&lt;/strong&gt;&lt;/div&gt; 你可以发现，内联样式虽然编写简单，可以发现存在以下缺陷： 每一个标签要设置样式都需要添加 style 属性； 后期维护成本高，当修改页面时需要逐个打开网站每个页面一一修改； 添加如此多的行内样式，页面体积大，门户网站若釆用这种方式编写，那将浪费服务器带宽和流量。 内部样式表你可以直接使用嵌入到 HTML 文档头部 &lt;head&gt; 区域的 &lt;style&gt; 元素为当前文档定义 CSS 样式。 内部样式表的特点是该样式只能在此页使用，解决内联样式针对标签多次书写的弊端。 一个修改段落标签样式的示例： 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;HTML 演示&lt;/title&gt; &lt;style&gt; p{ text-align: left; /* 文本左对齐 */ font-size: 14px; /* 字体大小 14 像素 */ line-height: 25px; /* 行高 25 像素 */ text-indent: 2em; /* 首行缩进两个文字大小空间 */ width: 500px; /* 段落宽度 500 像素 */ margin: 0 auto; /* 浏览器下居中 */ } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;“百度”这一公司名称便来自宋词“众里寻他千百度”。（百度公司会议室名为青玉案，即是这首词的词牌）。而“熊掌”图标的想法来源于“猎人巡迹熊爪”的刺激，与李博士的“分析搜索技术”非常相似，从而构成百度的搜索概念，也最终成为了百度的图标形象。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 尽管解决了针对具有相同样式标签的多次设置，但仍然未实现网页结构与样式的分离。这就体现在，当样式需要被应用到很多页面的时候，仍然需要针对每个页面都要修改，不灵活啊。 链接式你可以直接使用 &lt;link /&gt; 标签在 HTML 文档头部 &lt;head&gt; 区域引入外部的 CSS 样式表文件，也称为外部样式表。这是络上网站应用最多的方式，同时也是最实用、最理想的方式。 链接式将 HTML 页面结构和样式完全分离，实现结构层和表示层的彻底分离，使 HTML 代码专门构建页面结构，而美化工作由 CSS 完成。增强了网页结构的扩展性和 CSS 样式的可维护性。 使用链接式为 HTML 代码应用样式示例： 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;HTML 演示&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css/style1.css&quot; type=&quot;text/css&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css/style2.css&quot; type=&quot;text/css&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;百度渊源&lt;/h2&gt; &lt;p&gt;“百度”这一公司名称便来自宋词“众里寻他千百度”。（百度公司会议室名为青玉案，即是这首词的词牌）。而“熊掌”图标的想法来源于“猎人巡迹熊爪”的刺激，与李博士的“分析搜索技术”非常相似，从而构成百度的搜索概念，也最终成为了百度的图标形象。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 其中，HTML 中 &lt;link&gt; 标签专门用来定义文档与外部资源的关系，最常见的用途是链接外部样式表。其 href 属性用于定义链接文档的 URL，rel 属性定义当前文档与被链接文档之间的关系，type 属性用来定义被链接文档的 MIME 类型。 两个外部样式表内容如下 &gt;&gt;&gt;&gt; style1.css 文件代码： 12345h2{ background-color: aqua; height: 50px; line-height: 50px;} style2.css 文件代码： 123456p{ text-align: left; /* 文本左对齐 */ font-size: 14px; /* 字体大小 14 像素 */ line-height: 25px; /* 行高 25 像素 */ text-indent: 2em; /* 首行缩进两个文字大小空间 */} 通常，网站制作者会将公共部分样式放入一个 CSS 文件，当前页面样式编写新的样式文件。 链接式导入 CSS 样式的好处： CSS 文件可以应用于不同的 HTML 文件中，使网站所有页面样式统一； 将 CSS 代码放入一个 CSS 文件中便于管理、减少代码以及维护时间； 修改 CSS 文件时，所有应用此 CSS 文件的 HTML 文件都将更新，而不必从服务器上将所有的页面取回再修改完毕后上传。 导入式你也可以直接使用 @import 命令导入外部 CSS 样式表文件，它是 CSS2.1 新引入的一张导入方式，一些低版本浏览器可能不支持。 这里简单了解一下就行，更多使用的链接式的导入方式。 导入样式使用 @import 命令导入外部样式表。导入样式书写方式： 1234567&lt;style&gt;@import test.css;@import &quot;test.css&quot;;@import url(test.css);@import url('test.css');@import url(&quot;test.css&quot;);&lt;/style&gt; 需要注意的是，在 HTML 文档中使用 @import 时，@import 需要定义在 &lt;style&gt; 标签中。如果 &lt;style&gt; 标签中还有其它的 CSS 样式，那么 @import 就必须定义在所有样式的最前面。示例代码如下： 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;HTML 演示&lt;/title&gt; &lt;style&gt; @import url(css/style1.css); @import &quot;css/style2.css&quot;; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;百度渊源&lt;/h2&gt; &lt;p&gt;“百度”这一公司名称便来自宋词“众里寻他千百度”。（百度公司会议室名为青玉案，即是这首词的词牌）。而“熊掌”图标的想法来源于“猎人巡迹熊爪”的刺激，与李博士的“分析搜索技术”非常相似，从而构成百度的搜索概念，也最终成为了百度的图标形象。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 和链接式不同的是：使用 &lt;link&gt; 标签引用的样式文件会随页面同时加载，而使用 @import 引用的样式文件会等待页面加载完成后再加载。 如果 @import 引用的样式文件过大、加载时间过长的话，在页面加载完成后就会出现没有样式的情况，影响用户体验。 网页布局网页布局是创建一个网站时一个必不可少的过程，通过布局可以改变网页中内容的排布方式，让网页看起来更加合理、美观。 早期，大多数网站会把内容安排到多个列中，类似于杂志或报纸那样的布局。 而由于 &lt;div&gt; 或者 &lt;table&gt; 元素可以创建多列。故，早期 HTML 网页中使用 &lt;div&gt; 或者 &lt;table&gt; 元素来进行网页布局，CSS 用于对元素进行定位，或者为页面创建背景以及色彩丰富的外观（实现布局和样式分离）。 下面分别来看如何使用 Div 和 Table 来实现传统页面的布局： Div 布局div 元素是用于分割 HTML 元素的块级元素。创建多列布局代码示例如下（推荐先看布局自己实现下）： 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;HTML 布局演示&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;container&quot; style=&quot;width: 500px;&quot;&gt; &lt;div id=&quot;header&quot; style=&quot;background-color: #FFA500;&quot;&gt; &lt;h1 style=&quot;margin: 0px;&quot;&gt;网页的主标题&lt;/h1&gt; &lt;/div&gt; &lt;div id=&quot;menu&quot; style=&quot;background-color: #FFD700; width: 100px; height: 500px; float: left;&quot;&gt; &lt;b&gt;Menu&lt;/b&gt; &lt;br/&gt; HTML 5 &lt;br/&gt; XHTML &lt;br/&gt; CSS &lt;br/&gt; &lt;/div&gt; &lt;div id=&quot;content&quot; style=&quot;background-color: #EEEEEE; width: 400px; height: 500px; float: left;&quot;&gt; The main content is here. &lt;/div&gt; &lt;div id=&quot;footer&quot; style=&quot;background-color: #FFA500; clear: both; text-align: center;&quot;&gt; Copyright © HTML WebSite.cc &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; Table 布局table 元素是是创建布局的一种简单的方式。创建如上多列布局代码示例如下（推荐先看布局自己实现下）： 12345678910111213141516171819202122232425&lt;table style=&quot;width: 500px;&quot; border=&quot;0&quot;&gt; &lt;tr style=&quot;background-color: #FFA500;&quot;&gt; &lt;td colspan=&quot;2&quot;&gt; &lt;h1&gt;网页的主标题&lt;/h1&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td style=&quot;background-color: #FFD700; width: 100px; height: 300px; vertical-align: top;&quot;&gt; &lt;b&gt;Menu&lt;/b&gt; &lt;br/&gt; HTML 5 &lt;br/&gt; XHTML &lt;br/&gt; CSS &lt;br/&gt; &lt;/td&gt; &lt;td style=&quot;background-color: #EEEEEE; width: 400px; height: 300px; vertical-align: top;&quot;&gt; The main content is here. &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan=&quot;2&quot; style=&quot;background-color: #FFA500; text-align: center;&quot;&gt; Copyright © HTML WebSite.cc &lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; 很多技术大佬，甚至可以使用 Table 设计出非常精美漂亮的 HTML 页面。 注意：虽然可以使用 HTML Table 标签来设计出漂亮的布局，但是 table 标签是不建议作为布局工具使用的 - 表格不是布局工具。 HTML5 布局新标签HTML4 主要依赖 &lt;div&gt; 标签进行布局。但是，&lt;div&gt; 是一个包罗万象的标签，不具有明确的语义，不能指明当前板块的作用，也不利于搜索引擎理解页面内容。 为了改进传统布局模式，HTML5 提出了多个专门用于布局的新标签（块级），它们用来定义网页的不同部分，语义更加明确。 HTML5 布局标签如下： 标签 说明 &lt;header&gt; 用于定义网页的头部，头部中一般包含一些介绍性的内容，例如网站名称、Logo 或者作者的信息 &lt;nav&gt; 用于定义网页中的导航栏 &lt;section&gt; 用于在网页中定义一个单独的部分，其中可以包含文本、图像、表格等等。代表 HTML 文档中的“节”或“段”，“段”可以理解为一篇文章里按照主题的分段，“节”则可以理解为一个页面里的分组。其主要作用就是 对页面的内容进行分块 &lt;article&gt; 用于定义文章或者其它独立的信息，代表一个页面中自成一体的内容，例如论坛的帖子、博客上的文章、一篇用户的评论等 &lt;aside&gt; 用于定义网页内容以外的部分，例如网页的侧边栏、侧边购物栏等 &lt;footer&gt; 用于定义网页的底部，例如作者、版权等信息 &lt;details&gt; 用于定义一些详细信息，并且可以根据需要隐藏或显示这些详细信息 &lt;summary&gt; 用于为 &lt;details&gt; 标签定义标题 各个标签详细使用可参考 HTML5 新元素支持，适用的板块如下图所示： 下面通过一个示例来演示如何使用上面介绍的标签来为网页布局： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;HTML 演示&lt;/title&gt; &lt;style&gt; nav, section { float: left; padding: 20px; min-height: 170px; box-sizing: border-box; } section { width: 80%; } nav { width: 20%; background: #d4d7dc; } nav ul { list-style: none; line-height: 24px; padding: 0px; } nav ul li a { color: #333; } .clearfix:after { content: &quot;.&quot;; display: block; height: 0; clear: both; visibility: hidden; } &lt;/style&gt;&lt;/head&gt;&lt;body style=&quot;font: 14px Arial, sans-serif; margin: 0px;&quot;&gt; &lt;div class=&quot;container&quot; style=&quot;width: 100%; background: #f2f2f2;&quot;&gt; &lt;header style=&quot;padding: 10px 20px; background: #acb3b9; font-size: 24px;&quot;&gt; &lt;h1 style=&quot;font-size: 24px;&quot;&gt;Programming Course&lt;/h1&gt; &lt;/header&gt; &lt;div class=&quot;wrapper clearfix&quot;&gt; &lt;nav&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;&quot;&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;http://c.biancheng.net/c/&quot; target=&quot;_blank&quot;&gt;C Tutorials&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;http://c.biancheng.net/java/&quot; target=&quot;_blank&quot;&gt;Java Tutorials&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;http://c.biancheng.net/python/&quot; target=&quot;_blank&quot;&gt;Python Tutorials&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;http://c.biancheng.net/sql/&quot; target=&quot;_blank&quot;&gt;SQL Tutorials&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;http://c.biancheng.net/html/&quot; target=&quot;_blank&quot;&gt;HTML Tutorials&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt; &lt;section&gt; &lt;h2&gt;Website Introduction&lt;/h2&gt; &lt;p&gt;C 语言中文网，是一个在线学习&lt;b&gt;编程&lt;/b&gt;的网站。C 语言中文网已经发布了众多优质编程教程，包括 C 语言、Java、Python 等，它们都通俗易懂，深入浅出。&lt;/p&gt; &lt;p&gt;C 语言中文网将会持续更新，并且不忘初心，坚持创作优质教程。&lt;/p&gt; &lt;/section&gt; &lt;/div&gt; &lt;footer style=&quot;background: #acb3b9; text-align: center; padding: 5px;&quot;&gt; &lt;p&gt;www.biancheng.net&lt;/p&gt; &lt;/footer&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 关于 HTML + Div + CSS 网页模板 &gt;&gt;&gt; 由于创建高级的布局非常耗时，使用模板是一个快速的选项。通过搜索引擎可以找到很多免费的网站模板，并基于这些预先构建好的网站布局，并优化它们！！！ 内嵌框架HTML 中，可以通过内联框架标签 &lt;iframe&gt; 来实现在当前网页中嵌入另一个网页，以致你可以在同一个浏览器窗口中显示不止一个页面。 &lt;iframe&gt; 标签会在网页中定义一个矩形区域，浏览器可以在这个区域内显示另一个页面的内容。语法格式如下： 1&lt;iframe src=&quot;url&quot; width=&quot;xx&quot; height=&quot;xx&quot;&gt;&lt;/iframe&gt; 其中，src 属性用来指定要嵌入的网页的 URL（矩形区域内容显示为 URL 地址指向的页面或资源）；width 和 height 属性用来指定框架的宽度和高度，(默认单位是像素，当然你也可以使用百分比）。 注意：HTML &lt;iframe&gt; 标签不利于搜索引擎抓取页面内容，对 SEO 具有负面效果，在现代 Web 设计中不建议使用。 给一个使用内联框架嵌入 C 语言中文网首页，宽度设置为 330 像素，高度设置为 580 像素效果的示例： 123456789101112&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;HTML 演示&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;下面的内联框架将嵌入 `C 语言中文网首页`，宽度设置为 330 像素，高度设置为 580 像素，以模拟手机端的显示效果:&lt;/p&gt; &lt;iframe src=&quot;http://c.biancheng.net/&quot; width=&quot;330&quot; height=&quot;580&quot; frameborder=&quot;0&quot;&gt;&lt;/iframe&gt;&lt;/body&gt;&lt;/html&gt; 注意，内联框架嵌显示区域默认带有一个边框，你可以通过 frameborder 属性（0 &amp;&amp; 1）取消边框（HTML5 中不支持该属性，通过 CSS 进行样式设置）。 目前，所有主流浏览器都支持 &lt;iframe&gt; 标签。你可以把需要的文本放置在 &lt;iframe&gt; 和 &lt;/iframe&gt; 之间，这样就可以应对不支持 &lt;iframe&gt; 的浏览器。HTML 中的内联框架 &lt;frameset&gt; &amp;&amp; &lt;frame&gt;，HTML5 中已不再支持。 显示目录链接页面 &gt;&gt;&gt; iframe 元素可以显示一个目标链接的页面： 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;HTML 演示&lt;/title&gt; &lt;style&gt; iframe{ background-color: bisque; border: 1px solid #ddd; } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;&lt;a href=&quot;http://c.biancheng.net/&quot; target=&quot;cbiancheng&quot;&gt;猛击这里查看 C 语言中文网在手机端的显示效果&lt;/a&gt;&lt;/p&gt; &lt;iframe name=&quot;cbiancheng&quot; width=&quot;330&quot; height=&quot;580&quot;&gt;&lt;/iframe&gt;&lt;/body&gt;&lt;/html&gt; 可以看到，内联框架区域默认设置一个样式（背景色 &amp;&amp; 边框）将其可视化，然后你可以通过点击相应链接达到页面内显示链接相应页面的效果。","link":"/2019/01/03/html-jiao-cheng-zhi-qu-kuai-nei-lian-he-ye-mian-bu-ju/"},{"title":"Python 中的数据类型","text":"从这一小节开始，我们将正式学习 Python 基本语法规则。本文首先来认识 Python 中的基本数据类型。 看过电影《奇异博士》的同学肯定记得：奇异博士利用魔法制造了镜像世界进行战斗，减少对现实世界的破坏。 就像 Python 世界就可以看作现实世界的【镜像】，我们想要做到的就是在镜像世界里面高效地解决现实世界里的繁琐任务。这首先就要求 Python 【镜像世界】中必然存在与现实世界物体（研究对象）对应的抽象表达，比如现实世界中最常见的数字、文字、图像、声音等等，在 Python 世界统一被称为：【数据】，有了数据才有后续的一切。 数据呀，『长相』不一样（有不同的类型），各司其职。只有认清各类型数据的『长相』，了解它们的功能，才能在镜像世界里完成现实世界的任务。所以，你应该认识到数据类型相关的小节都是重点，数据都玩不好还想啥（pi）吃？敲黑板…。 基础数据类型Python3 中支持六种标准的基础数据类型： Number（数值） String（字符串） Tuple（元组） List（列表） Dictionary（字典） Set（集合） Python3 的六个标准数据类型中： 不可变数据（3 个）：Number（数值）、String（字符串）、Tuple（元组）； 可变数据（3 个）：List（列表）、Dictionary（字典）、Set（集合）。 关于数据类型的可变和不可变属性可参考：Python-中的可变和不可变对象，等学过 Tuple（元组）、List（列表）或字典（Dict）、集合（Set）之后，可以返回来看这一部分内容，可以帮助我们进一步掌握上述六种标准数据类型的用法。 在开始学习数据类型之前，我们先来看 Python 中的变量概念： Python 变量和常量–&gt; 变量是什么？ 变量你可以将其看成是一个个带有标签（名字）的小盒子，用来存放我们的数据。 严格来说， 在 Python 中，变量就是指向一个计算机内存单元的引用，它没有类型。我们所说的 “变量的类型” 是变量指向的内存中数据对象的类型。 –&gt; 常量又是什么？ 和变量相对应的是 常量（Constant），它们都是用来“盛装”数据的小箱子，不同的是：变量保存的数据可以被多次修改，而常量一旦保存某个数据之后就不能修改了（事实上，Python 并没有严格的对常量进行控制，只是约定俗成的规定常量名必须全部大写）。 变量定义Python 中变量的定义不需要声明，赋值后可直接使用（即赋值时创建），这很便捷。 变量赋值数学等号（=）用来给变量赋值。 赋值运算符（=）左边是一个变量名，右边是存储在变量中的值。例如： 123counter = 100 # 整型变量miles = 1000.0 # 浮点型变量name = &quot;python&quot; # 字符串型变量 多变量赋值（不推荐） &gt;&gt;&gt;&gt; Python 允许你同时为多个变量赋值（注意：语法规范不允许这么使用），例如： 1a = b = c = 1 或者： 1a, b, c = 1, 2, &quot;python&quot; # 用法唯一，没有 a, b, c = 1；a, b, c = 1, 2 变量的内存表示当我们定义： 1test1 = 'ABC' 时，Python 解释器干了两件事情： 在内存中创建了一个'ABC'的字符串； 在内存中创建了一个名为 test 的变量，并把它指向'ABC'。 当然，也可以把一个变量 test1 赋值给另一个变量 test2，这个操作实际上是把变量 test2 指向变量 test1 所指向的数据，例如下面的代码： 12345test1 = 'ABC'test2 = test1test1 = 'XYZ'print(test2) # 输出：ABC =============================== Python 缓存重用机制 ================================ 事实上，Python 初始化变量时，不一定开辟新的内存空间！怎么理解？！！ 这是因为 Python 中存在缓存重用机制，也称为常量池（Constants Pool）机制，来判断是否需要新开辟内存。由于篇幅原因，关于缓存重用机制请参见博文：Python 中的缓存重用机制（常量池）。 动态语言特性Python 中可以把任意数据类型赋值给变量。同一个变量可以反复赋值，而且可以是不同类型的值，例如： 123test = 100 # 整型变量test = 1000.0 # 浮点型变量test = &quot;python&quot; # 字符串 这种变量本身类型不固定的语言称之为 动态语言，也称为 弱类型语言。 与之相对的是 静态语言（强类型语言），静态语言在定义变量时必须指定变量类型，如果赋值的数据类型和定义类型不匹配时，就会报错（例如：强类型语言的代表：Java，C，C++ 等）。 Python 数据类型下面我们将开始分别说明上述提到的六种标准数据类型：Number（数值）、String（字符串）、Tuple（元组）、List（列表）、Set（集合）、Dictionary（字典）。 Number（数值）Number 数据类型用于存储数值，Python 中支持四种不同的数值类型：整数（int）、布尔型（bool）、浮点数（float）和复数（complex）。 数值类型[1] –&gt; 整型（int） Python3 中只有一种整数类型 int，表示为长整型。Python3 整型是没有限制大小的，可以当作 Long 类型使用，所以 Python3 没有 Python2 的 Long 类型。 也就是说 int 可以处理任意大小（无限）的整数，当然包括负整数，在程序中的表示方法和 数学上的写法 一模一样，例如：1，100，-8080，0，等等（十进制写法，Decimal）。 计算机由于使用二进制，所以有时候用 二进制（Binary）、八进制（Octal）或者十六进制（Hexadecimal） 表示整数比较方便： 1234567891011&gt;&gt;&gt; number = 0xA0F # 十六进制（A~F, A -&gt; 10）&gt;&gt;&gt; number2575&gt;&gt;&gt; number= 0o37 # 八进制&gt;&gt;&gt; number31&gt;&gt;&gt; number = 0b1111111 # 二进制&gt;&gt;&gt; number127 –&gt; 如何将十进制转化为其它进制数？ 12345678910111213&gt;&gt;&gt; num = 127# 将一个整数（d/0o/0x）转化为二进制数：&gt;&gt;&gt; bin(num)'0b1111111'# 将一个整数（d/0b/0x）转化为八进制数：&gt;&gt;&gt; oct(num)'0o177'# 将一个整数（d/0o/0b）转化为十六进制数：&gt;&gt;&gt; hex(num)'0x7f' [2] –&gt; 浮点型（float） Python 只有一种小数类型，就是 float。 浮点数也就是小数，之所以称为浮点数，是因为按照科学记数法表示时，一个浮点数的小数点位置是可变的，比如：1.23 ×10^9 和 12.3 × 10^8 是完全相等的。 浮点数可以用 数学写法，如 1.23，3.14，-9.01 等等。但是对于很大或很小的浮点数，就必须用 科学计数法 表示，把 10 用 e 替代，1.23 × 10^9 就是1.23e9，或者 12.3e8，0.000012 可以写成1.2e-5，等等。 1234&gt;&gt;&gt; num = 1.23e5123000.0&gt;&gt;&gt; num = 1.23e-30.00123 | &gt;&gt;&gt; ================================ 浮点数计算精度问题 ================================ &lt;&lt;&lt; | 注意：永远不要直接比较两个浮点的大小。 12# 尝试一下比较如下大小：0.1 + 0.2 &gt; 0.3 // true 这是由于计算机中浮点型数值的计算是不精确的（十进制和二进制转换引发），这种问题不仅在 Python 中存在，在所有支持浮点数运算的编程语言中都会遇到，它不光是 Python 的 Bug。 详情请关注编程基础系列博文： [ &gt;&gt;&gt;&gt; 编程基础之进制详解 &lt;&lt;&lt;&lt; ][ &gt;&gt;&gt;&gt; 为什么 0.1 + 0.2 不等于 0.3? &lt;&lt;&lt;&lt; ] 明白了问题产生的原因之后，那么该如何解决呢？ Python 的浮点数运算而言，大多数计算机每次计算误差不会超过 2^53，但这对于大多数任务来说已经足够了。 如果对于会计方面的应用和有高精度要求的应用场景，可以借助 decimal 或者 fractions 分数模块，能够很好地解决浮点类型数之间运算的问题。关于高精度浮点数运算应用场景解决方案可参见 —&gt; [ &gt;&gt;&gt;&gt; Python 浮点数精确运算解决方案 &lt;&lt;&lt;&lt; ]。 [3] –&gt; 布尔型（bool） Python3 中，布尔值有 True、False 两种，并把 True 和 False 定义成关键字了（请注意大小写）。并且 bool 类型继承自整型 int， 故 可以直接和数字运算，它们的值对应 True == 1 和 False == 0， 123456&gt;&gt;&gt; print(True==1)True&gt;&gt;&gt; print(False==0)True&gt;&gt;&gt; print(True + 1)2 –&gt; 也可以通过比较运算符（&gt;、&lt;、==、!=）计算出来： 12345678&gt;&gt;&gt; TrueTrue&gt;&gt;&gt; FalseFalse&gt;&gt;&gt; 3 &gt; 2True&gt;&gt;&gt; 3 &gt; 5False –&gt; 布尔值还可以进行 and、or 和 not 逻辑运算： and 运算是”与运算”，只有所有都为 True，and 运算结果才是True； or 运算是”或运算”，只要其中有一个为 True，or 运算结果就是 True； not 运算是”非运算”，它是一个单目运算符，把 True 变成 False，False 变成 True 1234567891011121314&gt;&gt;&gt; print(True and &quot;test&quot;)test&gt;&gt;&gt; print(False and &quot;test&quot;)False&gt;&gt;&gt; print(False or &quot;test&quot;)test&gt;&gt;&gt; print(True or &quot;test&quot;)True&gt;&gt;&gt; print(not &quot;test&quot;)False&gt;&gt;&gt; print(not 0)True&gt;&gt;&gt; print(not 1)False –&gt; 布尔值还常常用于 条件判断（或 while 循环）中： 1234567891011121314151617181920212223242526272829303132333435363738# Python 中，所有的对象都可以进行真假值的测试，包括字符串、元组、列表、字典、集合、对象&gt;&gt;&gt; print(bool([]))False&gt;&gt;&gt; print(bool([1,2,3]))True&gt;&gt;&gt; print(bool(None))False&gt;&gt;&gt; print(bool(0))False&gt;&gt;&gt; print(bool(&quot;&quot;))False&gt;&gt;&gt; print(bool({}))False# 条件判断中以下数值会被认为是 False：# 为零的数：0 or 0.0；# 空字符串：''，&quot;&quot;；# 空值：None；# 空集合：()，[]，{}；# 其他的值都认为是 True。&gt;&gt;&gt; if ():... print(True)... else:... print(False)...False&gt;&gt;&gt; if &quot;123&quot;:... print(True)... else:... print(False)...True# 注意（仅在条件判断中）：&gt;&gt;&gt; print(True and [])[]&gt;&gt;&gt; &quot;&quot; and False'' [4] –&gt; 复数（complex ） Python还支持复数，复数由实数部分和虚数部分构成，可以用 a + bj ,或者 complex(a,b) 表示。注意，复数的实部 a 和虚部 b 都是浮点型数。 例如： 12345a = 1 + 2jb = 1.1 + 2.2j&gt;&gt;&gt; a = complex(1,2)&gt;&gt;&gt; print(a)(1+2j) Number 相关运算[1] – &gt; type(object) &amp;&amp; isinstance(objecrt, class_or_tuple) 内置的 type() 函数可以用来查询变量所指的 对象类型： 123&gt;&gt;&gt; a,b,c,d = 12, 2.3, True, 1+2j&gt;&gt;&gt; print(type(a), type(b), type(c), type(d))&lt;class 'int'&gt; &lt;class 'float'&gt; &lt;class 'bool'&gt; &lt;class 'complex'&gt; 此外还可以用 isinstance() 来判断： 123456&gt;&gt;&gt; isinstance(a, int)True# 可以看出 bool 型也是 int 型的一种：&gt;&gt;&gt; isinstance(c, int)True 那么，isinstance() 和 type() 的区别在于？： type() 不会认为子类是一种父类类型。 isinstance() 会认为子类是一种父类类型。 12345678910&gt;&gt;&gt; type(c) == boolTrue&gt;&gt;&gt; type(c) == intFalse&gt;&gt;&gt; isinstance(c, int)True# 注意：&gt;&gt;&gt; isinstance(True, (int,float))True [2] –&gt; del 我们知道当变量被赋值时，Number 对象将会被创建： 123&gt;&gt;&gt; number1 = 10&gt;&gt;&gt; number2 = 1.2&gt;&gt;&gt; number3 = True 我们还可以使用 del 语句删除 单个或多个对象的引用（变量），例如： 123456&gt;&gt;&gt; del number1&gt;&gt;&gt; del number2, number3&gt;&gt;&gt; print(number1)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;NameError: name 'number2' is not defined [3] –&gt; Number 数据类型之间的转换 有时候，我们需要对数据内置的类型进行转换。对于数据类型的转换，你只需要将数据类型作为函数名即可。 int(x) 将 x 转换为一个整数。 float(x) 将 x 转换到一个浮点数。 complex(x) 将 x 转换到一个复数，实数部分为 x，虚数部分为 0。 complex(x, y) 将 x 和 y 转换到一个复数，实数部分为 x，虚数部分为 y。x 和 y 是数字表达式。 注意：int、float 和 bool 可以相互转换；int、float 和 bool 均可以转换为 complex，但不可以反转。 12&gt;&gt;&gt; float(1+2j)TypeError: can't convert complex to float [4] –&gt; 数值计算 Python 解释器可以作为一个简单的计算器，您可以在解释器里输入一个数学表达式，它将输出表达式的值。 1234567891011121314151617&gt;&gt;&gt;5 + 4 # 加法9&gt;&gt;&gt; 4.3 - 2 # 减法2.3&gt;&gt;&gt; 3 * 7 # 乘法21&gt;&gt;&gt; 2 / 4 # 除法，得到一个浮点数0.5&gt;&gt;&gt; 2 // 4 # 向下取整0&gt;&gt;&gt; 17 % 3 # 取余 2&gt;&gt;&gt; 3 % 173&gt;&gt;&gt; 2 ** 5 # 幂运算32 注意：int，bool 以及 float 进行混合计算时，会得到浮点数： 123456&gt;&gt;&gt; 15 // 3.05.0&gt;&gt;&gt; 12 / True12.0&gt;&gt;&gt; 13 - 2.011.0 [5] –&gt; 常用数学函数 使用数学函数前，我们需要导入相应的 math 模块： 1import math 下面来看常用数学函数： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758# 常用数学常量&gt;&gt;&gt; math.pi3.141592653589793&gt;&gt;&gt; math.e2.718281828459045# 返回数字的绝对值&gt;&gt;&gt; a = -10&gt;&gt;&gt; abs(a)10&gt;&gt;&gt; math.fabs(a)10.0# 返回数字的向上取整（ceil，天花板）结果&gt;&gt;&gt; b = 12.3&gt;&gt;&gt; math.ceil(b)13&gt;&gt;&gt; c = 12.8&gt;&gt;&gt; math.ceil(c)13# # 返回数字的向下取整（floor，地板）结果&gt;&gt;&gt; math.floor(c)12&gt;&gt;&gt; math.floor(b)12# 返回 e 的 x 次幂&gt;&gt;&gt; math.exp(1)2.718281828459045# log 函数&gt;&gt;&gt; math.log(100)4.605170185988092&gt;&gt;&gt; math.log(100, 10)2.0# 返回以 10 为基数的 x 的对数&gt;&gt;&gt; math.log10(100)2.0# 返回给定参数的最大值，参数可以为序列。&gt;&gt;&gt; max(1, 2.0, 3, 4)4# 返回给定参数的最小值，参数可以为序列。&gt;&gt;&gt; min(1, 2.0, 3, 4)1# pow(x,y):返回 x**y 运算后的值&gt;&gt;&gt; pow(2,4)16# round(x,n):返回浮点数 x 的四舍五入值，如给出 n 值，则代表舍入到小数点后的位数&gt;&gt;&gt; round(2.71828,3)2.718# sqrt(x):返回数字 x 的平方根&gt;&gt;&gt; math.sqrt(100)10.0 三角函数相关方法： 123456789101112131415161718import math# math.sin(x)：返回 x 弧度的正弦值# math.cos(x)：返回 x 弧度的余弦值# math.tan(x)：返回 x 弧度的正切值# math.asin(x)：返回 x 的反正弦弧度值# math.acos(x)：返回 x 的反余弦弧度值# math.atan(x)：返回 x 的反正切弧度值# math.degrees(x)：将弧度转换为角度&gt;&gt;&gt; math.degrees(math.pi/2)90.0# math.radians(x)：将角度转换为弧度&gt;&gt;&gt; math.radians(90)1.5707963267948966&gt;&gt;&gt; math.pi/21.5707963267948966 String（字符串）字符串是 Python 中最常用的数据类型，是以单引号 ' 或双引号 &quot; 括起来的任意文本，同时使用反斜杠 \\ 来转义特殊字符。 创建字符串很简单，只要为变量分配一个值即可。例如： 1234&gt;&gt;&gt; str1 = 'abc'&gt;&gt;&gt; str2 = 'XYZ'&gt;&gt;&gt; type(str1)&lt;class 'str'&gt; 这里，'' 或 &quot;&quot; 本身只是一种表示方式，不是字符串的一部分，因此，字符串'abc'只有a，b，c这3个字符。 注意，Python 不支持单独的字符类型（char 型），一个字符就是长度为 1 的字符串。 –&gt; del 删除字符串变量 &gt;&gt;&gt;&gt; 可以使用 del 语句删除 单个或多个对象的引用（变量），例如： 1234567&gt;&gt;&gt; del str1&gt;&gt;&gt;&gt; del str2 str3&gt;&gt;&gt; print(str1)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;NameError: name 'str1' is not defined 单引号 ' 或双引号 &quot; 使用如果 ' 本身也是字符串中的一个字符，那就可以用 &quot;&quot; 括起来，比如 &quot;I' am OK&quot;。 当然如果 &quot; 也是字符串本身的一个字符的话，外面可以用 '' 括起来，如：'I&quot;m OK'。同理，如果 ' 是字符串本身的一个字符的话，外面可以用 &quot;&quot; 括起来，如：&quot;I'm OK&quot;。注意，都一致的话会报错： 12345&gt;&gt;&gt; print('I'm ok') File &quot;&lt;stdin&gt;&quot;, line 1 print('I'm ok') ^SyntaxError: invalid syntax 但切记不要混合使用，如下： 12# 语法错误：print(&quot;I'm OK') 思考一下？–&gt; 如果字符串内部既包含 ' 又包含 &quot; 怎么办？？？ 此时只能使用转义字符 \\ 来标识，比如： 1'I\\'m \\&quot;OK\\&quot;!' 表示的字符串内容是： 1I'm &quot;OK&quot;! 字符串中的转义字符转义字符 \\ 可以转义很多字符。比如，\\n 表示换行；\\t 表示制表符；\\r 表示回车；字符 \\ 本身也要转义，所以\\\\表示的字符就是\\。 可以在 Python 的交互式命令行用 print() 打印字符串看看： 12345678&gt;&gt;&gt; print('I\\'m ok.')I'm ok.&gt;&gt;&gt; print('I\\'m learning\\nPython.')I'm learningPython.&gt;&gt;&gt; print('\\\\\\n\\\\')\\\\ 字符串换行Python 不是格式自由的语言，它对程序的换行、缩进都有严格的语法要求。要想换行书写一个比较长的字符串，必须在行尾添加反斜杠 \\，请看下面的例子： 123s2 = 'It took me six months to write this Python tutorial. \\ Please give me more support. \\ I will keep it updated.' 上面 s2 字符串的比较长，所以使用了转义字符 \\ 对字符串内容进行了换行，这样就可以把一个长字符串写成多行。 Google Style 语法规范中是不推荐这样写的，回忆一下使用什么形式？？？ Python 中的长字符串前面提到过，使用三个单引号或者双引号（'''...''' 或 &quot;&quot;&quot;...&quot;&quot;&quot;）可以对多行内容进行注释，这其实就是 Python 长字符串的写法。 如果长字符串没有赋值给任何变量，那么这个长字符串就不会起到任何作用，和一段普通的文本无异，相当于被注释掉了。 长字符串的引入可以解决单引号 ' 或双引号 &quot; 使用问题（字符串内部既包含 ' 又包含 &quot;）。 尤其是当程序中有大段文本内容需要定义成字符串时，优先推荐使用长字符串形式，因为这种形式非常强大，可以在字符串中放置任何内容，而且 所见即所得，可以自己试试： 123456&gt;&gt;&gt; print('''line1... line2... line3''')line1line2line3 当然了，长字符串中反斜杠（\\）也有转义字符的含义，和在普通字符串的用法是一致的。 –&gt; 最大的好处： '''...''' 的书写方式让开发人员从 引号和特殊字符串的泥潭 里面解脱出来，自始至终保持一小块字符串（特殊字符串）的格式，即所见即所得（皮卡丘….）： 1234567891011121314print(''' へ ／| /＼7 ∠＿/ / │ ／ ／ │ Z ＿,＜ ／ /`ヽ │ ヽ / 〉 Y ` / / ｲ● ､ ● ⊂⊃〈 / () へ | ＼〈 &gt;ｰ ､_ ィ │ ／／ / へ / ﾉ＜| ＼＼ ヽ_ﾉ (_／ │／／ 7 |／ ＞―r￣￣`ｰ―＿''') 一个典型的用例是，当你需要一块 HTML 或者 SQL 时，这时用字符串组合，特殊字符串转义将会非常的繁琐。如果你使用长字符串： 123456789101112131415HTML = '''&lt;HTML&gt;&lt;HEAD&gt;&lt;TITLE&gt;Friends CGI Demo&lt;/TITLE&gt;&lt;/HEAD&gt;&lt;BODY&gt;&lt;H3&gt;ERROR&lt;/H3&gt;&lt;B&gt;%s&lt;/B&gt;&lt;P&gt;&lt;FORM&gt;&lt;INPUT TYPE=button VALUE=BackONCLICK=&quot;window.history.back()&quot;&gt;&lt;/FORM&gt;&lt;/BODY&gt;&lt;/HTML&gt;'''cursor.execute('''CREATE TABLE users ( login VARCHAR(8), uid INTEGER,prid INTEGER)''') Python 中的原始字符串在普通字符串或者长字符串的开头加上 r 前缀，就变成了原始字符串，具体格式为： 12str1 = r'原始字符串内容'str2 = r&quot;&quot;&quot;原始字符串内容&quot;&quot;&quot; 转义字符 \\ 可以用来转义，而使用 r 或（R） 可以让 \\ 不发生转义。。 如 r&quot;this is a line with \\n&quot; 则 \\n 会显示，并不是换行。同理，'''...''' 也可以和 r(R)组合，用于消掉多行字符串中的转义。 普通原始字符串中的引号问题 &gt;&gt;&gt;&gt;&gt; 如果普通格式（'...'）的原始字符串中出现引号（'），同样需要对引号（'）进行转义，但是和普通字符串不同的是，此时用于转义的反斜杠(\\)会变成字符串内容的一部分: 123&gt;&gt;&gt; str1 = r'I\\'m a great coder!'&gt;&gt;&gt; print(str1)I\\'m a great coder! 怎么办？？？ &gt;&gt;&gt; 使用长字符串 123&gt;&gt;&gt; str1 = r'''I'm a great coder!'''&gt;&gt;&gt; print(str1) 注意，不管是普通字符串还是长字符串，其原始字符串的结尾处不能是反斜杠。为什么？ 如果原始字符串的结尾处是反斜杠，那么字符串结尾处的引号会被转义，导致字符串不能正确结束。例如： 123# 结尾处的反斜杠都会转移后面的引号str1 = r'D:\\Program Files\\Python 3.8\\'str1 = r'''D:\\Program Files\\Python 3.8\\''' 怎么办？？？ &gt;&gt;&gt; 123# 结尾处的反斜杠都会转移后面的引号str1 = r'D:\\Program Files\\Python 3.8' + '\\\\'str1 = r'''D:\\Program Files\\Python 3.8''' + '\\\\' String 数据类型转化str(object) 函数可以将 Python 对象（数字、列表、元组、字典、集合等）转化为适于人阅读的形式。 123456789101112&gt;&gt;&gt; str(True)'True'&gt;&gt;&gt; str(123.32)'123.32'&gt;&gt;&gt; str([1,2,3,4])'[1, 2, 3, 4]'&gt;&gt;&gt; str((&quot;Google&quot;,&quot;Opera&quot;))&quot;('Google', 'Opera')&quot;&gt;&gt;&gt; str({&quot;Google&quot;:1,&quot;Opera&quot;:2})&quot;{'Google': 1, 'Opera': 2}&quot;&gt;&gt;&gt; str({&quot;Google&quot;, &quot;Opera&quot;})&quot;{'Google', 'Opera'}&quot; 哎？！前面我们知道了 Number 数据类型之间的相互转换，并且这里我们也了解了 str(object) 的使用，那么我们可以将字符串类型的数据强制转换成 Number 类型吗？ 当然也可以，只是存在一定的限制： 只有 符合整数规范 的字符串类数据，才能被强制转换。 –&gt; 如何理解？以 int() 强制转换字符串为例： 1、整数形式的字符串，比如 ‘6’ 和 ‘1’，可以被 int() 函数强制转换。 2、文字形式，比如中文、火星文或者标点符号，不可以被 int() 函数强制转换。 3、小数形式的字符串，由于 Python 的语法规则，也不能使用 int() 函数强制转换。 比方说下列代码（值异常：浮点类型字符串无法使用 int() 强制转换）： 123print(int('3.8'))# 运行后显示结果：ValueError：invalid literal for int() with base 10: '3.8' 你还可以尝试一下其它强制转换函数：float()，bool()，complex()，这里就不给出样例了。 字符串序列支持Python 中的字符串是一个不可变序列（Sequence），所以 Python 序列中支持的方法在字符串中都可使用： 【1】 &gt;&gt;&gt;&gt; 字符串索引与切片 Python 中的字符串有两种字符索引方式，从左往右以 0 开始（正向），从右往左以 -1 开始（反向）。可以使用 索引以及方括号 来截取字符串： 1234567891011str = 'Welcome to Python world' print (str) # 输出字符串# 1. 字符索引：print (str[0]) # 索引获得字符串第一个字符# 2. 字符串切片：print (str[0:-1]) # 输出第一个到倒数第二个的所有字符print (str[2:5]) # 输出从第三个开始到第五个的字符print (str[2:]) # 输出从第三个开始的后的所有字符 执行结果如下： 12345Welcome to Python worldWelcome to Python worlWlcolcome to Python world 请注意，字符串是不可变类型，故我们不能对索引到的字符串字符进行修改或删除： 12345678910&gt;&gt;&gt; str = &quot;welcome&quot;&gt;&gt;&gt; str[2] = '3'Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: 'str' object does not support item assignment&gt;&gt;&gt; del str1[2]Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: 'str' object doesn't support item deletion 【2】 &gt;&gt;&gt;&gt; 字符串加法（连接）和乘法 12345&gt;&gt;&gt; print(&quot;that&quot; + &quot;is&quot; + &quot;good&quot;)thisisgood&gt;&gt;&gt; print(&quot;good&quot; * 2)goodgood 注意，字符串连接符（+）连接的对象只能是字符串，不可以：&quot;123&quot; + 3 or &quot;123445&quot; + [1,2,3] or &quot;123445&quot; + {2:3, 3:4}。 【3】 &gt;&gt;&gt;&gt; 字符串成员检查 字符串成员检查就是就是，判断某字符串对象是否包含在另一个字符串对象中，返回的是布尔型值。 可用于判断字符串是否包含某个子串，如下（in &amp;&amp; not in）： 123456&gt;&gt;&gt; str1 = &quot;welcome to python world&quot;&gt;&gt;&gt; substr = &quot;come&quot;&gt;&gt;&gt; print(substr in str1)True&gt;&gt;&gt; print(substr not in str1)False 【4】 &gt;&gt;&gt;&gt; 字符串长度获取 通过通过 Python 内置函数 len(str) 获取字符串长度 1）len(s) len()方法返回对象（字符串、列表、元组等）长度或项目个数。 123&gt;&gt;&gt;str = &quot;python&quot;&gt;&gt;&gt; len(str) # 字符串长度6 【5】 &gt;&gt;&gt;&gt; 取字符串中的最大、小值 使用内置函数：max(str) &amp;&amp; min(str) max() 方法返回字符串中最大的字母。 123&gt;&gt;&gt; str = &quot;welcome&quot;&gt;&gt;&gt; print (&quot;最大字符: &quot; + max(str))最大字符: w min() 方法返回字符串中最小的字母。 123&gt;&gt;&gt; str = &quot;welcome&quot;&gt;&gt;&gt; print (&quot;最小字符: &quot; + min(str))最小字符: c 字符串相关运算假设实例变量 a 值为字符串 “Hello”，b 变量值为 “Python”： 12345678910111213141516171819202122232425262728&gt;&gt;&gt; a = 'Hello'&gt;&gt;&gt; b = 'Python'# 字符串连接: `+`&gt;&gt;&gt; print(a + b)HelloPython# 重复输出字符串: `*`&gt;&gt;&gt; print(a*2)HelloHello# 通过索引获取字符串中字符: `[]`&gt;&gt;&gt; print(a[3])l# 截取字符串：`[:]`&gt;&gt;&gt; print(a[1:3])el# 用于判断字符串是否包含某个子串：# 如果字符串中包含给定的字符返回 True :`in`&gt;&gt;&gt; print ('H' in a)True&gt;&gt;&gt; print ('Hel' in a)True# 如果字符串中不包含给定的字符返回 True ：`not in`&gt;&gt;&gt; print ('H' not in a)False 字符串常用方法整理这里要注意 ↓↓↓↓↓↓ Python 中的字符串是一个不可变对象，所以所有修改和生成字符串的操作的实现方法，都是在另一个内存片段中生成一个新字符串对象。 例如，'abc'.upper() 将会在划分另一个内存片段，并将返回的 ABC 保存在此内存中。 下面正式开始整理 Python 字符串中的常用方法： 字符串大小写转换[1] &gt;&gt;&gt;&gt; lower &amp;&amp; upper 12str.upper()str.lower() str.upper() 内置函数会将字符串中的所有字符都转换为大写；str.lower() 内置函数则将字符串中的所有字符转换为小写。 例如： 1234&gt;&gt;&gt; print('ab XY'.lower())ab xy&gt;&gt;&gt; print('ab XY'.upper())AB XY [2] &gt;&gt;&gt;&gt; title &amp;&amp; capitalize 12str.title()str.capitalize() str.title() 内置函数是英文标题式写法，会将字符串所有单词的首字母变成大写，而其他字母依然小写（单词直接可以使用其它非空格连接符）；str.capitalize() 内置函数是首字母大写（capitalize 原译），会将字符串首字母大，而其他字母依然小写。 例如： 1234&gt;&gt;&gt; print('ab XY'.title())Ab Xy&gt;&gt;&gt; print('abc DE'.capitalize())Abc de [3] &gt;&gt;&gt;&gt; swapcase 1str.swapcase() str.swapcase() 内置函数是对字符串进行大小写转换（swapcase 原译）。 例如： 12&gt;&gt;&gt; print('abc XYZ'.swapcase())ABC xyz isXXX 判断[1] &gt;&gt;&gt;&gt; isalpha，isdecimal，isdigit，isnumeric，isalnum 123456str.isdecimal()str.isdigit()str.isnumeric()str.isalpha()str.isalnum() 分别判断字符串 str 是否是数字、字母、字母或数字组合。 isdecimal，isdigit，isnumeric 均用来判断是否是数字，区别如下： 函数 描述 isdecimal() 是否为十进制数字符，包括 Unicode 数字、双字节全角数字，不包括罗马数字、汉字数字、小数。 isdigit() 是否为数字字符，包括 Unicode 数字，单字节数字，双字节全角数字，不包括汉字数字，罗马数字、小数。 isnumeric() 是否所有字符均为数值字符，包括 Unicode 数字、双字节全角数字、罗马数字、汉字数字，不包括小数。 例如： 123456&gt;&gt;&gt; print('34'.isdigit())True&gt;&gt;&gt; print('abc'.isalpha())True&gt;&gt;&gt; print('a34'.isalnum())True [2] &gt;&gt;&gt;&gt; islower，isupper，istitle 123str.islower()str.isupper()str.istitle() 分别判断字符串是否全部小写、全部大写、英文标题式写法。要求 str 中至少要包含一个字母，否则直接返回 False。例如不能是纯数字。 例如： 1234567891011121314151617181920&gt;&gt;&gt; print('a34'.islower())True&gt;&gt;&gt; print('AB'.isupper())True&gt;&gt;&gt; print('Aa'.isupper())False&gt;&gt;&gt; print('Aa Bc'.istitle())True&gt;&gt;&gt; print('Aa_Bc'.istitle())True&gt;&gt;&gt; print('Aa bc'.istitle())False# 单词使用 `_` 分隔符进行分隔&gt;&gt;&gt; print('Aa_bc'.istitle())False# 下面的返回 False，因为非首字母 C 不是小写&gt;&gt;&gt; print('Aa BC'.istitle())False [3] &gt;&gt;&gt;&gt; isspace，isprintable，isidentifier 123str.isspace()str.isprintable()str.isidentifier() 分别判断字符串是否是空白(空格、制表符、换行符等)字符，是否是可打印字符(例如制表符、换行符就不是可打印字符，但空格是)，是否满足标识符定义规则。 例如： 1）判断是否为空白（没有任何字符是不算是空白）: 12345678910&gt;&gt;&gt; print(' '.isspace())True&gt;&gt;&gt; print(' \\t'.isspace())True&gt;&gt;&gt; print('\\n'.isspace())True&gt;&gt;&gt; print(''.isspace())False&gt;&gt;&gt; print('Aa BC'.isspace())False 2）判断是否是可打印字符： 12345678910&gt;&gt;&gt; print('\\n'.isprintable())False&gt;&gt;&gt; print('\\t'.isprintable())False&gt;&gt;&gt; print('acd'.isprintable())True&gt;&gt;&gt; print(' '.isprintable())True&gt;&gt;&gt; print(''.isprintable())True 3）判断是否满足标识符定义规则（只能是字母或下划线开头、不能包含除数字、字母和下划线以外的任意字符）： 1234567891011121314&gt;&gt;&gt; print('abc'.isidentifier())True&gt;&gt;&gt; print('2abc'.isidentifier())False&gt;&gt;&gt; print('abc2'.isidentifier())True&gt;&gt;&gt; print('_abc2'.isidentifier())True&gt;&gt;&gt; print('_abc_2'.isidentifier())True&gt;&gt;&gt; print('_Abc_2'.isidentifier())True&gt;&gt;&gt; print('Abc_2'.isidentifier())True 字符串填充[1] &gt;&gt;&gt;&gt; center 1str.center(width[, fillchar]) 将字符串居中，左右两边使用 fillchar（默认为空格） 进行填充，使得整个字符串的长度为 width。如果设置的 width 小于字符串的长度，则无法填充直接返回字符串本身(不会创建新字符串对象)。 例如： 123456789101112&gt;&gt;&gt; print('ab'.center(4,'_'))_ab_&gt;&gt;&gt; print('ab'.center(5,'_'))__ab_&gt;&gt;&gt; print('ab'.center(4)) ab &gt;&gt;&gt; print(len('ab'.center(4)))4&gt;&gt;&gt; print('abcde'.center(3))abcde [2] &gt;&gt;&gt;&gt; ljust &amp;&amp; rjust 12str.ljust(width[, fillchar])str.rjust(width[, fillchar]) ljust() 函数使用 fillchar 填充在字符串 str 的右边，使得整体长度为 width。 rjust() 函数则是填充在左边。 如果不指定 fillchar，则默认使用空格填充。如果 width 小于或等于字符串 str 的长度，则无法填充，直接返回字符串本身(不会创建新字符串对象)。 例如： 1234&gt;&gt;&gt; print('xyz'.ljust(5,'_'))xyz__&gt;&gt;&gt; print('xyz'.rjust(5,'_'))__xyz [3] &gt;&gt;&gt;&gt; zfill 1str.zfill(width) zero fill 默认在字符串 str 的左边用 0 填充使其长度为 width。如果 str 前有正负号 +/-，则 0 填充在 +/- 符号后面，且符号也算入长度。 例如： 1234567891011121314151617&gt;&gt;&gt; print('abc'.zfill(5))00abc&gt;&gt;&gt; print('-abc'.zfill(5))-0abc&gt;&gt;&gt; print('+abc'.zfill(5))+0abc&gt;&gt;&gt; print('42'.zfill(5))00042&gt;&gt;&gt; print('-42'.zfill(5))-0042&gt;&gt;&gt; print('+42'.zfill(5))+0042 子串搜索[1] &gt;&gt;&gt;&gt; count 1str.count(sub[, start[, end]]) count 方法用于统计字符串里某个子串出现的次数。可选参数为在字符串搜索的开始与结束位置： sub – 搜索的子字符串 start – 字符串开始搜索的位置。默认为第一个字符,第一个字符索引值为0。 end – 字符串中结束搜索的位置。字符中第一个字符的索引为 0。默认为字符串的最后一个位置。 例如： 1234567891011121314&gt;&gt;&gt; print('xyabxyxy'.count('xy'))3# 次数2，因为从 index=1 算起，即从 'y' 开始查找，查找的范围为 'yabxyxy'&gt;&gt;&gt; print('xyabxyxy'.count('xy',1))2# 次数1，因为不包括 end，所以查找的范围为 'yabxyx'&gt;&gt;&gt; print('xyabxyxy'.count('xy',1,7))1# 次数2，因为查找的范围为 'yabxyxy'&gt;&gt;&gt; print('xyabxyxy'.count('xy',1,8))2 [2] &gt;&gt;&gt;&gt; endswith，startswith 12str.endswith(suffix[, start[, end]])str.startswith(prefix[, start[, end]]) endswith() 函数检查字符串 str 是否以 suffix 结尾，返回布尔值的 True 和 False。 suffix 可以是一个元组(tuple)。可以指定起始 start 和结尾 end 的搜索边界。同理，startswith() 用来判断字符串 str 是否是以 prefix 开头。 例如（startswith 和 endswith 用法相同）： 1）suffix 是普通的字符串时： 123456789101112&gt;&gt;&gt; print('abcxyz'.endswith('xyz'))True # False，因为搜索范围为'yz'&gt;&gt;&gt; print('abcxyz'.endswith('xyz',4))False # False，因为搜索范围为'abcxy'&gt;&gt;&gt; print('abcxyz'.endswith('xyz',0,5))False&gt;&gt;&gt; print('abcxyz'.endswith('xyz',0,6))True 2）suffix 是元组(tuple)时(只要 tuple 中任意一个元素满足 endswith 的条件，就返回 True): 1234567891011# tuple中的'xyz'满足条件&gt;&gt;&gt; print('abcxyz'.endswith(('ab','xyz')))True # tuple中'ab'和'xy'都不满足条件&gt;&gt;&gt; print('abcxyz'.endswith(('ab','xy')))False # tuple中的'z'满足条件&gt;&gt;&gt; print('abcxyz'.endswith(('ab','xy','z')))True [3] &gt;&gt;&gt;&gt; find，rfind &amp;&amp; index，rindex 1234str.find(sub[, start[, end]])str.rfind(sub[, start[, end]])str.index(sub[, start[, end]])str.rindex(sub[, start[, end]]) find() 搜索字符串 str 中是否包含子串 sub。如果包含，则返回 sub 的索引位置，否则返回 -1。可以指定起始 start 和结束 end 的搜索位置。而 index() 和 find() 一样，唯一不同点在于当找不到子串时，抛出 ValueError 错误。 rfind() 和 rindex() 是搜索最右边子串的位置，如果有返回索引位置，没有则返回 -1 或 ValueError 错误。 例如： 12345678910111213141516&gt;&gt;&gt; print('abcxyzXY'.find('xy'))3&gt;&gt;&gt; print('abcxyzXY'.find('Xy'))-1&gt;&gt;&gt; print('abcxyzXY'.find('xy',4))-1&gt;&gt;&gt; print('xyzabcabc'.find('bc'))4&gt;&gt;&gt; print('xyzabcabc'.rfind('bc'))7&gt;&gt;&gt; print('xyzabcabc'.rindex('bcd'))Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;ValueError: substring not found 字符串替换[1] &gt;&gt;&gt;&gt; replace 1str.replace(old, new[, count]) 将字符串中的子串 old 替换为 new 字符串。如果给定 count，则表示只替换前 count 个 old 子串。如果 str 中搜索不到子串 old，则直接返回字符串本身(不创建新字符串对象)。 [2] &gt;&gt;&gt;&gt; maketrans &amp;&amp; translate 12str.translate(table)static str.maketrans(x[, y[, z]]) str.maketrans() &amp;&amp; translate(table) 是需要配合使用的。str.maketrans() 函数会生成一个字符一一映射的 table(字符映射转换表，然后 translate(table) 使用字符映射转换表，转换字符串 str 中的字符。 例如：想要对 “I love Fairy” 做一个简单的加密，将里面部分字符（使用字符映射转换表）都替换为数字，这样别人就不知道转换后的这句话是什么意思。 123456789101112&gt;&gt; in_str='abcxyz'&gt;&gt;&gt; out_str='123456'# maketrans()生成映射表&gt;&gt;&gt; map_table=str.maketrans(in_str,out_str)# 使用translate()进行映射&gt;&gt;&gt; my_love='I love Fairy'&gt;&gt;&gt; result=my_love.translate(map_table)&gt;&gt;&gt; print(result)I love F1ir5 注意，maketrans(x[, y[, z]]) 中的 x 和 y 都是字符串，且长度必须相等。如果 maketrans(x[, y[, z]]) 给定了第三个参数 z，则这个参数字符串（z）中的每个字符都会被映射为 None。 12345678&gt;&gt;&gt; in_str='abcxyz'&gt;&gt;&gt; out_str='123456'&gt;&gt;&gt; map_table=str.maketrans(in_str,out_str,'ay')&gt;&gt;&gt; my_love='I love Fairy'&gt;&gt;&gt; result=my_love.translate(map_table)&gt;&gt;&gt; print(result)I love Fir 字符串分割[1] &gt;&gt;&gt;&gt; split，rsplit &amp;&amp; splitlines 123str.split(sep=None, maxsplit=-1)str.rsplit(sep=None, maxsplit=-1)str.splitlines([keepends=True]) 三者都是用来分割字符串，并生成一个列表。 split() 会根据指定的 sep 分隔符来对 str 进行分割，maxsplit 用于指定最大分割次数，如果不指定 maxsplit 或者给定值为 -1，则会从左向右搜索并且每遇到 sep 一次就分割直到搜索完字符串。如果不指定 sep 或者指定为 None，则改变分割算法：以空格为分隔符，且将连续的空白压缩为一个空格。rsplit() 和 split() 是一样的，只不过是从右边向左边搜索。 1234567&gt;&gt;&gt; str = &quot;this is string example....!!!&quot;&gt;&gt;&gt; print (str.split( )) # 以空格为分隔符['this', 'is', 'string', 'example....!!!']&gt;&gt;&gt; print (str.split(' ',1)) # 以空格为分隔符['this', 'is string example....!!!']&gt;&gt;&gt; print (str.split('i')) # 以 i 为分隔符['th', 's ', 's str', 'ng example....!!!'] splitlines() 可以按照字符串中的换行符 ('\\r', '\\r\\n', \\n') 对字符串进行分隔，返回一个包含各行作为元素的列表。如果参数 keepends 为 False，不包含换行符（默认）；如果为 True，则保留换行符。 123456&gt;&gt;&gt; 'ab c\\n\\nde fg\\rkl\\r\\n'.splitlines()['ab c', '', 'de fg', 'kl']&gt;&gt;&gt; 'ab c\\n\\nde fg\\rkl\\r\\n'.splitlines(False)['ab c', '', 'de fg', 'kl']&gt;&gt;&gt; 'ab c\\n\\nde fg\\rkl\\r\\n'.splitlines(True)['ab c\\n', '\\n', 'de fg\\r', 'kl\\r\\n'] [2] &gt;&gt;&gt;&gt; partition，rpartition 12str.partition(sep)str.rpartition(sep) 搜索字符串 str 中的是否含有子串 sep，并从 sep 处对 str 进行分割，最后返回一个包含 3 个元素的元组：sep 左边的部分是元组的第一个元素，sep 自身是元组的二个元素，sep 右边是元组的第三个元素。 partition(sep) 从左边第一个 sep 进行分割，rpartition(sep) 从右边第一个 sep 进行分割。如果搜索不到 sep，则返回的 3 元素元组中，有两个元素为空。partition() 是后两个元素为空，rpartition() 是前两个元素为空。 例如： 1234567891011121314151617# 只搜索到一个 sep 时，两者结果相同&gt;&gt;&gt; print('abcxyzopq'.partition('xy'))('abc', 'xy', 'zopq')&gt;&gt;&gt; print('abcxyzopq'.rpartition('xy'))('abc', 'xy', 'zopq')# 搜索到多个 sep 时，分别从左第一个、右第一个 sep 分割&gt;&gt;&gt; print('abcxyzxyopq'.partition('xy'))('abc', 'xy', 'zxyopq')&gt;&gt;&gt; print('abcxyzxyopq'.rpartition('xy'))('abcxyz', 'xy', 'opq')# 搜索不到 sep&gt;&gt;&gt; print('abcxyzxyopq'.partition('xyc'))('abcxyzxyopq', '', '')&gt;&gt;&gt; print('abcxyzxyopq'.rpartition('xyc'))('', '', 'abcxyzxyopq') join1str.join(iterable) 将可迭代对象(iterable)中的元素使用 ste 连接起来。注意，iterable 中必须全部是字符串类型，否则报错。 如果你还是 Python 的初学者，还不知道 iterable 是什么，你可以暂时将它理解为：字符串 string、列表 list、元组 tuple、字典 dict、集合 set。 例如： 1）字符串： 123&gt;&gt;&gt; L='python'&gt;&gt;&gt; '_'.join(L)'p_y_t_h_o_n' 2）元组： 123&gt;&gt;&gt; L1=('1','2','3')&gt;&gt;&gt; '_'.join(L1)'1_2_3' 3）集合（无序）： 123&gt;&gt;&gt; L2={'p','y','t','h','o','n'}&gt;&gt;&gt; '_'.join(L2)'n_o_p_h_y_t' 4）列表： 123&gt;&gt;&gt; L2=['py','th','o','n']&gt;&gt;&gt; '_'.join(L2)'py_th_o_n' 5）字典： 123&gt;&gt;&gt; L3={'name':&quot;malongshuai&quot;,'gender':'male','from':'China','age':18}&gt;&gt;&gt; '_'.join(L3)'name_gender_from_age 6）iterable 参与迭代的每个元素必须是字符串类型，不能包含数字或其他类型： 12345678&gt;&gt;&gt; L1=(1,2,3)&gt;&gt;&gt; '_'.join(L1)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: sequence item 0: expected str instance, int found&gt;&gt;&gt; L1=('ab',2)&gt;&gt;&gt; L2=('AB',{'a','cd'}) 7）join() 时的元素连接符指定为空（””）时，则会将可迭代对象的每个元素组成一个连接起来的字符串。有时候，这是很有用的: 123&gt;&gt;&gt; L=['a','b','c','d']&gt;&gt;&gt; ''.join(L)'abcd' 字符串修剪123str.strip([chars])str.lstrip([chars])str.rstrip([chars]) 分别是移除左右两边、左边、右边的字符 char。如果不指定 chars 或者指定为 None，则默认移除空白(空格、制表符、换行符)。 lstrip([chars])方法用于截掉字符串左边的 指定字符（默认为：空格、'Tab'，\\n）或指定字符。 12345678&gt;&gt;&gt; str = &quot; !!!this is string example....!!! \\n&quot;;&gt;&gt;&gt; print(str) !!!this is string example....!!!&gt;&gt;&gt; print( str.lstrip() );!!!this is string example....!!!&gt;&gt;&gt; rstrip([chars])方法用于截掉字符串左边的 指定字符（默认为空格、\\n）或指定字符。 123&gt;&gt;&gt; print( str.rstrip() ); !!!this is string example....!!!&gt;&gt;&gt; strip(chars) 方法用于移除字符串头尾 指定的字符（默认为空格、\\n）或字符序列。 12&gt;&gt;&gt; print( str.strip() );!!!this is string example....!!! 字符串编码 &amp;&amp; 解码str.encode(encoding=’UTF-8’,errors=’strict’) &amp;&amp; bytes.decode(encoding=”utf-8”, errors=”strict”) str.encode() 会以 encoding 指定的编码格式编码字符串。 errors 参数用于设置不同错误的处理方案。默认为 strict，意为解码错误引起一个 UnicodeError。其他可能得值有 ignore, replace, xmlcharrefreplace, backslashreplace 以及通过 codecs.register_error() 注册的任何值。 Python3 中没有 str decode 方法，这是合理的，编码之后 Python 字符串已经变成了一个 bytes 字节串了。所以我们可以使用 bytes 对象的 bytes.decode() 方法来解码给定的 bytes 对象，这个 bytes 对象可以由 str.encode() 来编码返回。 12345678910111213141516171819&gt;&gt;&gt; str = &quot;我想学中文&quot;;&gt;&gt;&gt; help(str.encode)&gt;&gt;&gt; str_utf8 = str.encode(&quot;UTF-8&quot;)&gt;&gt;&gt; str_gbk = str.encode(&quot;GBK&quot;)&gt;&gt;&gt; print(str)我想学中文&gt;&gt;&gt; print(&quot;UTF-8 编码：&quot;, str_utf8)UTF-8 编码： b'\\xe6\\x88\\x91\\xe6\\x83\\xb3\\xe5\\xad\\xa6\\xe4\\xb8\\xad\\xe6\\x96\\x87'&gt;&gt;&gt; print(&quot;GBK 编码：&quot;, str_gbk)&gt;&gt;&gt; help(bytes.decode)GBK 编码： b'\\xce\\xd2\\xcf\\xeb\\xd1\\xa7\\xd6\\xd0\\xce\\xc4'&gt;&gt;&gt; print(&quot;UTF-8 解码：&quot;, str_utf8.decode('UTF-8','strict'))UTF-8 解码： 我想学中文&gt;&gt;&gt; print(&quot;GBK 解码：&quot;, str_gbk.decode('GBK','strict'))GBK 解码： 我想学中文 字符串格式化字符串格式化涉及到的内容较多，考虑到篇幅原因我们在 Python 字符串之格式化输出 一文中进行了详细说明。这里是为了保持字符串章节完整性故设立一个链接模块。 字符串编码关于 Python 字符串编码涉及到的内容较多，考虑到篇幅原因我们在 Python 字符串之 Unicode 编码 一文中进行了详细说明。这里是为了保持字符串章节完整性故设立一个链接模块。 Python 中的序列开始学习元组（Tuple）和列表（List）之前，推荐先了解 Python 中的序列概念。篇幅原因，该部分内容请转至系列教程：Python 中的序列。","link":"/2018/01/05/python-zhong-de-shu-ju-lei-xing/"},{"title":"Python 中的运算符以及流程控制","text":"前面已经了解了 Python 中常用的数据结构，本文接着来看 Python 中的运算符以及程序流程控制，这是一个 可执行 Python 程序实现的必要部分。 前面我们已经熟悉并深入了解了 Python 支持的六种基本数据类型，这就意味着我们已经成功突破现实世界和镜像世界数据差异的墙。 但对于 Python 世界而言，光掌握正确使用 【镜像世界的数据】 还不够，还需要正确的 【沟通逻辑】 才能让Python 准确地执行我们下达的命令，这就需要了解 Python 中的运算符以及流程控制以帮助我们完成更多的功能。 Python 中的运算符开始后续的流程控制学习之前，我们需要系统的认识一下 Python 中的运算符。 我们先来看个简单的例子： 12&gt;&gt;&gt; 4 + 59 其中 4，5 被称为操作数，+ 被称之为运算符。 Python 语言支持以下类型的运算符: 算术运算符 赋值运算符 比较（关系）运算符 逻辑运算符 位运算符 成员运算符 身份运算符 本文将会针对上述运算符分类，进行分别学习： 运算符详解算术运算符在介绍 Number（数字）数据类型时，我们已经接触过算术运算了。这里我们来看如何使用算术运算符进行算术运算： [1] &gt;&gt;&gt;&gt; 加法： 12345678&gt;&gt;&gt; aNumber = 21&gt;&gt;&gt; bNumber = 10&gt;&gt;&gt; cNumber = 0# 加法：&gt;&gt;&gt; cNumber = aNumber + bNumber&gt;&gt;&gt; print(&quot;The value of cNumber:&quot;,cNumber)The value of cNumber: 31 当 + 用于数字（Number）时表示加法运算（加法运算符）；但是当 + 用于序列时表示连接运算（连接运算符），请参照 Python 中的序列说明。 [2] &gt;&gt;&gt;&gt; 减法： 123&gt;&gt;&gt; cNumber = aNumber - bNumber&gt;&gt;&gt; print(&quot;The value of cNumber:&quot;,cNumber)The value of cNumber: 11 - 除了可以用作减法运算之外，还可以用作求负运算（正数变负数，负数变正数），即取相反数。 [3] &gt;&gt;&gt;&gt; 乘法： 123&gt;&gt;&gt; cNumber = aNumber * bNumber&gt;&gt;&gt; print(&quot;The value of cNumber:&quot;,cNumber)The value of cNumber: 210 当 * 用于数字（Number）时表示乘法运算（乘法运算符）；但是当 * 用于序列时表示重复运算（重复运算符），用于将几个同样的序列连接起来，请参照 Python 中的序列说明。 [4] &gt;&gt;&gt;&gt; 除法： 123456789101112# 普通除法(计算结果总是小数，不管是否能除尽，也不管参与运算的是整数还是浮点数)：&gt;&gt;&gt; aNumber = 21&gt;&gt;&gt; bNumber = 10&gt;&gt;&gt; cNumber = 0&gt;&gt;&gt; cNumber = aNumber / bNumber&gt;&gt;&gt; print(&quot;The value of cNumber:&quot;,cNumber)The value of cNumber: 2.1# 整除（直接舍弃小数部分）：&gt;&gt;&gt; cNumber = aNumber // bNumber&gt;&gt;&gt; print(&quot;The value of cNumber:&quot;,cNumber)The value of cNumber: 2 注意：进行除法运算时，除数始终不能为 0，除以 0 是没有意义的，这将导致 ZeroDivisionError 错误。在某些编程语言中，除以 0 的结果是无穷大（包括正无穷大和负无穷大）。 [5] &gt;&gt;&gt;&gt; 取模（取余）： 123456&gt;&gt;&gt; aNumber = 21&gt;&gt;&gt; bNumber = 10&gt;&gt;&gt; cNumber = 0&gt;&gt;&gt; cNumber = aNumber % bNumber&gt;&gt;&gt; print(&quot;The value of cNumber:&quot;,cNumber)The value of cNumber: 1 [5] &gt;&gt;&gt;&gt; 幂运算： 123456&gt;&gt;&gt; aNumber = 21&gt;&gt;&gt; bNumber = 10&gt;&gt;&gt; cNumber = 0&gt;&gt;&gt; cNumber = aNumber ** bNumber&gt;&gt;&gt; print(&quot;The value of cNumber:&quot;,cNumber)The value of cNumber: 16679880978201 赋值运算符 运算符 描述 实例 = 简单的赋值运算符 c = a + b 将 a + b 的运算结果赋值为 c += 加法赋值运算符 c += a 等效于 c = c + a -= 减法赋值运算符 c -= a 等效于 c = c - a *= 乘法赋值运算符 c *= a 等效于 c = c * a /= 除法赋值运算符 c /= a 等效于 c = c / a %= 取模赋值运算符 c %= a 等效于 c = c % a **= 幂赋值运算符 c **= a 等效于 c = c ** a //= 取整除赋值运算符 c //= a 等效于 c = c // a 通常情况下，只要能使用扩展后的赋值运算符，都推荐使用这种赋值运算符。 注意：= 和 == 是两个不同的运算符。= 用来赋值，而 == 用来判断两边的值是否相等，千万不要混淆。 位运算符位运算符是把数字看作二进制来进行计算的。Python 中的按位运算法则如下： &amp;：按位与运算符：参与运算的两个值,如果两个相应位都为 1,则该位的结果为1,否则为 0; |：按位或运算符：只要对应的二个二进位有一个为 1 时，结果位就为 1； ^：按位异或运算符：当两对应的二进位相异时，结果为 1 ； ~：按位取反运算符：对数据的每个二进制位取反,即把 1 变为 0，把 0 变为 1； &lt;&lt;：左移动运算符：把 “&lt;&lt;” 左边的运算数各二进位全部左移若干位，”&lt;&lt;” 右边的数用来指定移动的位数，高位丢弃，低位补 0； &gt;&gt;：右移动运算符：把 “&gt;&gt;” 左边的运算数的各二进位全部右移若干位，”&gt;&gt;” 右边的数指定移动的位数。 代码演示： 123456789101112131415161718192021222324252627&gt;&gt;&gt; aNumber = 60 # 60 = 0011 1100&gt;&gt;&gt; bNumber = 13 # 13 = 0000 1101&gt;&gt;&gt; cNumber = 0&gt;&gt;&gt; cNumber = aNumber &amp; bNumber; # 12 = 0000 1100&gt;&gt;&gt; print (&quot;1.cNumber 的值为：&quot;, cNumber)1.cNumber 的值为： 12&gt;&gt;&gt; cNumber = aNumber | bNumber; # 61 = 0011 1101&gt;&gt;&gt; print (&quot;2.cNumber 的值为：&quot;, cNumber)2.cNumber 的值为： 61&gt;&gt;&gt; cNumber = aNumber ^ bNumber; # 49 = 0011 0001&gt;&gt;&gt; print (&quot;3.cNumber 的值为：&quot;, cNumber)3.cNumber 的值为： 49&gt;&gt;&gt; cNumber = ~aNumber; # -61 = 1100 0011&gt;&gt;&gt; print (&quot;4.cNumber 的值为：&quot;, cNumber)4.cNumber 的值为： -61&gt;&gt;&gt; cNumber = aNumber &lt;&lt; 2; # 240 = 1111 0000&gt;&gt;&gt; print (&quot;5.cNumber 的值为：&quot;, cNumber)5.cNumber 的值为： 240&gt;&gt;&gt; cNumber = aNumber &gt;&gt; 2; # 15 = 0000 1111&gt;&gt;&gt; print (&quot;6.cNumber 的值为：&quot;, c)6.cNumber 的值为： 15 比较（关系）运算符 运算符 说明 &gt; 大于，如果&gt;前面的值大于后面的值，则返回 True，否则返回 False。 &lt; 小于，如果&lt;前面的值小于后面的值，则返回 True，否则返回 False。 == 等于，如果==两边的值相等，则返回 True，否则返回 False。 &gt;= 大于等于（等价于数学中的 ≥），如果&gt;=前面的值大于或者等于后面的值，则返回 True，否则返回 False。 &lt;= 小于等于（等价于数学中的 ≤），如果&lt;=前面的值小于或者等于后面的值，则返回 True，否则返回 False。 != 不等于（等价于数学中的 ≠），如果!=两边的值不相等，则返回 True，否则返回 False。 实例如下： 12345678&gt;&gt;&gt; print(&quot;89是否大于100：&quot;, 89 &gt; 100)89是否大于100： False&gt;&gt;&gt; print(&quot;24*5是否大于等于76：&quot;, 24*5 &gt;= 76)24*5是否大于等于76： True&gt;&gt;&gt; print(&quot;86.5是否等于86.5：&quot;, 86.5 == 86.5)86.5是否等于86.5： True&gt;&gt;&gt; print(&quot;34是否等于34.0：&quot;, 34 == 34.0)34是否等于34.0： True 逻辑运算符Python 语言支持的逻辑运算符如下： a and b：等价于数学中的“且”，a 和 b 两个表达式都真为真，有假即假； a or b：等价于数学中的“或”，a 和 b 两个表达式有真即真，都假即假； not a：等价于数学中的“非”，如果 a 为真，那么 not a 的结果为假；如果 a 为假，那么 not a 的结果为真。相当于对 a 取反。 故，逻辑运算符一般和关系运算符结合使用，例如： 12345678910&gt;&gt;&gt; age = int(input(&quot;请输入年龄：&quot;))请输入年龄：23&gt;&gt;&gt; height = int(input(&quot;请输入身高：&quot;))请输入身高：178&gt;&gt;&gt; if age&gt;=18 and age&lt;=30 and height &gt;=170 and height &lt;= 185 :... print(&quot;恭喜，你符合报考飞行员的条件&quot;)... else:... print(&quot;抱歉，你不符合报考飞行员的条件&quot;)...恭喜，你符合报考飞行员的条件 注意，Python 逻辑运算符可以用来操作任何类型的表达式，不管表达式是不是 bool 类型；同时，逻辑运算的结果也不一定是 bool 类型，它也可以是任意类型。 逻辑运算符的本质 &gt;&gt;&gt;&gt; 对于 and 运算符，两边的值都为真时最终结果才为真，但是只要其中有一个值为假，那么最终结果就是假，所以 Python 按照下面的规则执行 and 运算： 如果左边表达式的值为假，那么就不用计算右边表达式的值了，因为不管右边表达式的值是什么，都不会影响最终结果，最终结果都是假，此时 and 会把左边表达式的值作为最终结果； 如果左边表达式的值为真，那么最终值是不能确定的，and 会继续计算右边表达式的值，并将右边表达式的值作为最终结果。 对于 or 运算符，情况是类似的，两边的值都为假时最终结果才为假，只要其中有一个值为真，那么最终结果就是真，所以 Python 按照下面的规则执行 or 运算： 如果左边表达式的值为真，那么就不用计算右边表达式的值了，因为不管右边表达式的值是什么，都不会影响最终结果，最终结果都是真，此时 or 会把左边表达式的值作为最终结果。 如果左边表达式的值为假，那么最终值是不能确定的，or 会继续计算右边表达式的值，并将右边表达式的值作为最终结果。 使用代码验证上面的结论： 123456789101112131415161718# Python 中，所有的对象都可以进行真假值的测试，包括字符串、元组、列表、字典、对象# 条件判断中以下数值会被认为是 False：# 为零的数：0 or 0.0；# 空字符串：''，&quot;&quot;；# 空值：None；# 空集合：()，[]，{}；# 其他的值都认为是 True。url = &quot;hello, pretty girl！&quot;print(&quot;----False and xxx-----&quot;)print( False and print(url) )print(&quot;----True and xxx-----&quot;)print( True and print(url) )print(&quot;----False or xxx-----&quot;)print( False or print(url) )print(&quot;----True or xxx-----&quot;)print( True or print(url) ) 运行看一下： 12345678910----False and xxx-----False----True and xxx-----hello, pretty girl!None----False or xxx-----hello, pretty girl!None----True or xxx-----True 成员运算符除了以上的一些运算符之外，Python 还支持成员运算符。正如我们在字符串（str），列表（list）或元组（tuple）、字典（dict）、集合（set）中进行的成员检查。 in：如果在指定的序列中找到值返回 True，否则返回 False； not in：如果在指定的序列中没有找到值返回 True，否则返回 False。 关于成员运算符的使用请参考前面字符串（str），列表（list）或元组（tuple）、字典（dict）、集合（set）部分。 身份运算符身份运算符用于比较两个对象的存储单元： is：is 判断两个变量所引用的对象是否相同，如果相同则返回 True，否则返回 False。 is not：is not 判断两个变量所引用的对象是否不相同，如果不相同则返回 True，否则返回 False。注意，id([object])函数用于获取对象的内存地址。 下面我们来看身份运算符如何使用： 12345678910111213141516171819202122232425262728293031&gt;&gt;&gt; aNumber = 20&gt;&gt;&gt; bNumber = 20&gt;&gt;&gt; if ( aNumber is bNumber ):... print (&quot;1 - aNumber 和 bNumber 有相同的标识&quot;)... else:... print (&quot;1 - aNumber 和 bNumber 没有相同的标识&quot;)...1 - aNumber 和 bNumber 有相同的标识&gt;&gt;&gt; if ( id(aNumber) == id(bNumber) ):... print (&quot;2 - aNumber 和 bNumber 有相同的标识&quot;)... else:... print (&quot;2 - aNumber 和 bNumber 没有相同的标识&quot;)...2 - aNumber 和 bNumber 有相同的标识 # 修改变量 b 的值&gt;&gt;&gt; bNumber = 30&gt;&gt;&gt; if ( aNumber is bNumber ):... print (&quot;3 - aNumber 和 bNumber 有相同的标识&quot;)... else:... print (&quot;3 - aNumber 和 bNumber 没有相同的标识&quot;)...3 - aNumber 和 bNumber 没有相同的标识&gt;&gt;&gt; if ( aNumber is not bNumber ):... print (&quot;4 - aNumber 和 bNumber 没有相同的标识&quot;)... else:... print (&quot;4 - aNumber 和 bNumber 有相同的标识&quot;)...4 - aNumber 和 bNumber 没有相同的标识 三目运算符除了上面介绍的基本运算符之外，Python 中还支持使用 if else 实现类似于其它编程语言中三目（三元）运算符 ? :，语法如下： 1exp1 if contion else exp2 说明 &gt;&gt;&gt;&gt; condition 是判断条件，exp1 和 exp2 是两个表达式。如果 condition 成立（结果为真），就执行 exp1，并把 exp1 的结果作为整个表达式的结果；如果 condition 不成立（结果为假），就执行 exp2，并把 exp2 的结果作为整个表达式的结果。 看下面的例子： 12345&gt;&gt;&gt; a = 3&gt;&gt;&gt; b = 4&gt;&gt;&gt; max = a if a&gt;b else b&gt;&gt;&gt; print(max)4 Python 三目运算符还支持嵌套，如此可以构成更加复杂的表达式。在嵌套时要需要注意 if 和 else 的配对： 1a if a&gt;b else c if c&gt;d else d 但为了保持代码的可读写，建议不要嵌套太多的三元运算符！ 运算符优先级以下给出出了从最高到最低优先级的所有运算符： 【**：指数 (最高优先级)】–&gt; 【~ + -：按位取反, 一元加号和减号 (表示正负号)】–&gt; 【* / % //：乘，除，取模和取整除】–&gt; 【+ -：加法减法】–&gt; 【&gt;&gt; &lt;&lt;：右移，左移运算符】– &gt; 【&amp; ^ |：位与，异或，位或】–&gt; 【&lt;= &lt; &gt; &gt;=：关系】–&gt; 【== !=：等于运算符】–&gt; 【= %= /= //= -= += *= **=：赋值运算符】–&gt; 【is is not：身份运算符】–&gt; 【in not in：成员运算符】–&gt; 【and or not：逻辑运算符】。 Python 中的流程控制结构和其它编程语言一样，按照执行流程划分，Python 程序也可分为三大结构，即顺序结构、选择（分支）结构和循环结构： 顺序结构：让程序按照从头到尾的顺序依次执行每一条 Python 代码，不重复执行任何代码，也不跳过任何代码； 选择结构：也称分支结构，就是让程序“拐弯”，有选择性的执行代码；换句话说，可以跳过没用的代码，只执行有用的代码； 循环结构，就是让程序“杀个回马枪”，不断地重复执行同一段代码。 分支结构Python 中，可以使用 if else 语句对条件进行判断，然后根据不同的结果执行不同的代码，这称为 选择结构 或者 分支结构。 分支结构形式Python 中的 if else 语句可以细分为三种形式，分别是 if 语句、if else 语句 和 if elif else 语句： [1] &gt;&gt;&gt;&gt; 单向判断 单项判断是最简单的分支结构，表示：”如果……就……“，其流程图如下所示： 代码实例如下： 123456age = 20if age &gt;= 18: # 条件满足时，做点什么： print(&quot;You are a man.&quot;)print(&quot;Continue Run&quot;) [2] &gt;&gt;&gt;&gt; 双向判断 双向判断可以帮助我们解决更为复杂的判断，表示：如果……就……，否则的话……，其流程图如下所示： 代码实例如下： 1234567891011age = 20if age &gt;= 18: # 条件满足时，做点什么： print('your age is', age) print('adult')else: # 当 if 条件不满足时，做的其它什么： print('your age is', age) print('teenager')print(&quot;Continue Run&quot;) 根据 Python 的缩进规则，如果 if 语句判断是 True，就把 if 缩进下的两行 print 语句执行了。否则执行 else 下的缩进代码块。 [3] &gt;&gt;&gt;&gt; 多向判断 事实上，上面的判断是很粗略的，完全可以用 if...elif...else... 实现更复杂判断，其流程图如下所示： Python 会从上到下逐个判断表达式是否成立，一旦遇到某个成立的表达式，就执行后面紧跟的语句块，此时，剩下的代码就不再执行了，不管后面的表达式是否成立。如果所有的表达式都不成立，就执行 else 后面的代码块。 代码结构如下： 123456if condition_1: statement_block_1elif condition_2: statement_block_2else: statement_block_3 另外注意，Python 中是没有 switch – case 语句的。 并且当多向判断条件比较多时，可以通过数轴进行包含关系判断，这是很有用的。 if 语句嵌套上面详细介绍了 3 种形式的条件语句，即 if、if else 和 if elif else，这 3 种条件语句之间可以相互嵌套。例如： 123456789101112if 表达式1: 语句 if 表达式2: 语句 elif 表达式3: 语句 else: 语句elif 表达式4: 语句else: 语句 当然，嵌套使用上很灵活。你还可以； 12345678if 表达式1: 语句 if 表达式2: 语句elif 表达式4: 语句else: 语句 事实上，嵌套的关键在于你要分清楚各判断层的逻辑，由外向内一层层分析，就像剥洋葱一样。 空语句 pass在实际开发中，有时候我们会先搭建起程序的整体逻辑结构，但是暂时不去实现某些细节，而是在这些地方加一些注释，方面以后再添加代码，请看下面的例子： 1234567891011age = int( input(&quot;请输入你的年龄：&quot;) )if age &lt; 12 : print(&quot;婴幼儿&quot;)elif age &gt;= 12 and age &lt; 18: print(&quot;青少年&quot;)elif age &gt;= 18 and age &lt; 30: print(&quot;成年人&quot;)elif age &gt;= 30 and age &lt; 50: #TODO: 成年人else: print(&quot;老年人&quot;) 当年龄大于等于 30 并且小于 50 时，我们没有使用 print() 语句，而是使用了一个注释(#TODO)，希望以后再处理成年人的情况。当 Python 执行到该 elif 分支时，会跳过注释，什么都不执行。 Python 提供了一种更加专业的做法，就是空语句 pass，用来让解释器跳过此处，什么都不做。 就像上面的情况，有时候程序需要 占一个位置，或者放一条语句，但又不希望这条语句做任何事情，此时就可以通过 pass 语句来实现。使用 pass 语句比使用注释更加优雅。如下： 12345678class MyEmptyClass: pass def nop(): passif age &gt;= 18: pass 断言函数 assertassert 语句，又称断言语句，语法结构为： 1assert 表达式 可以看做是功能缩小版的 if 语句，它用于判断某个表达式的值，如果值为真，则程序可以继续往下执行；反之，Python 解释器会报 AssertionError 错误。 assert 语句的执行流程可以用 if 判断语句表示，如下所示： 1234if 表达式==True: 程序继续执行else: 程序报 AssertionError 错误 有读者可能会问，明明 assert 会令程序崩溃，为什么还要使用它呢？这是因为，与其让程序在晚些时候崩溃，不如在错误条件出现时，就直接让程序崩溃，这有利于我们对程序排错，提高程序的健壮性。 assert 语句通常用于检查用户的输入是否符合规定，或者限定函数参数类型等。如下： 123456789def func(input): assert isinstance(input, list), '输入内容必须是列表' # 下面的操作都是基于前提：input 必须是 list if len(input) == 1: ... elif len(input) == 2: ... else: ... 循环结构循环结构应用场景： 每个人的生活和工作都充满了循环，很多时候，循环意味着重复和枯燥： 比如你需要下载很多很多张图片，本来你是要手动操作的，而计算机通过【循环】，就可以依照某些规则，帮你一张一张地下载图片，你在一旁歇着就好。再比如作为运营，可能需要去解散很多的用户群，本来要一个一个手动点击，而计算机通过【循环】，就可以依照某些规则，帮人一个一个解散。 Python 中的【循环语句】，可以让计算机能够重复性地、自动地执行指令。 Python 中提供了常用的两种循环结构支持： for … in（For 循环） while …（while 循环） for 循环[1] &gt;&gt;&gt;&gt; for … in … Python for 循环可以遍历任何序列或者可迭代（Iterable）的数据元素，如 列表、字符串、元组、字典、集合 等。其一般格式如下： 12for &lt;variable&gt; in &lt;sequence/Iterable&gt;: &lt;statements&gt; 例如循环访问列表中元素对象的实例： 12345678&gt;&gt;&gt; languages = [&quot;C&quot;, &quot;C++&quot;, &quot;Perl&quot;, &quot;Python&quot;]&gt;&gt;&gt; for x in languages:... print (x)...CC++PerlPython 一个很形象的 for 循环结构工作流程图 &gt;&gt;&gt;&gt; 1234567for i in [1,2,3,4,5]: print(i)# 有一群数字在排队办业务，也就是列表[1,2,3,4,5]# 它们中的每一个被叫到号的时候(for i in)，就轮流进去一个空房间办业务# 每一个数字进去房间之后，计算机都会说：“编号为 x 的用户正在办理业务”，也就是 print(i)# 然后计算机忠实的为每一个数字提供服务，并将用户服务编号 1,2,3,4,5 都打印在了屏幕上用以表示正被使用 是不很好理解？ 事实上，循环结构就是从一个定义好的元素队列中不断取值，然后完成相应操作，依此类推（循环）的过程。 [2] &gt;&gt;&gt;&gt; for … in … else … 除了上述的结构外，for ... in 语句还可以和 else 联合使用（不常见），构成如下循环结构： 12345678910111213&gt;&gt;&gt; languages = [&quot;C&quot;, &quot;C++&quot;, &quot;Perl&quot;, &quot;Python&quot;]&gt;&gt;&gt; for x in languages:... print(x)... else:... print(&quot;No elements!!!&quot;)...CC++PerlPythonNo elements!!!&gt;&gt;&gt; print(&quot;循环完毕&quot;)循环完毕 如上，for 循环结束后给出结束信息，以标识循环部分结束。 [3] &gt;&gt;&gt;&gt; for 循环中的 range() 函数的使用 前面在讲解序列的时候，我们提到过 range 也是一种序列结构，事实上，借助它可以生成一个自定义的数字序列。故，如果需要通过 数字序列 实现循环时，还可以使用 Python 内置的 range()（） 函数。例如: 123456789# range(x) 会自动生成一个从 0 到 x-1 的整数序列：&gt;&gt;&gt; for index in range(5):... print(index)...01234 也可以使用 range() 来限定数字序列区间的取值范围，甚至是步长。如下： 123456789# 生成从 0 到 9，步长为 2 的五个整数组成的序列：&gt;&gt;&gt; for index in range(0,10,2):... print(index)...02468 我们再来看看 len() &amp;&amp; range() 的组合用法以通过序列索引遍历序列（常见用法），这是有时是很方便的： 1234567&gt;&gt;&gt; website = [&quot;Google&quot;, &quot;Baidu&quot;, &quot;Opera&quot;]&gt;&gt;&gt; for index in range(len(website)):... print(index, website[index])...0 Google1 Baidu2 Opera while 循环[1] &gt;&gt;&gt;&gt; while 先来给出 while 循环的工作流程图： while 循环表示：满足条件，就按照流程办事。 Python 中 while 语句的一般形式： 12while 判断条件： 语句 循环实例（1~100求和）： 123456789&gt;&gt;&gt; n = 100&gt;&gt;&gt; sum = 0&gt;&gt;&gt; counter = 1&gt;&gt;&gt; while counter &lt;= n:... sum += counter... counter += 1...&gt;&gt;&gt; print(&quot;The sum is :&quot;,sum)The sum is : 5050 可见，对于 【1~100求和】，只要满足条件【counter &lt;= 100】就累加求和。 [2] &gt;&gt;&gt;&gt; while … else … 和 for ... in 语句一样，while ... else 也可以和 else，配合使用: 123456789101112&gt;&gt;&gt; n = 100&gt;&gt;&gt; sum = 0&gt;&gt;&gt; counter = 1&gt;&gt;&gt; while counter &lt;= n:... sum += counter... counter += 1... else:... print(&quot;n &gt; 100&quot;)...n &gt; 100&gt;&gt;&gt; print(&quot;The sum is :&quot;,sum)The sum is : 5050 [3] &gt;&gt;&gt;&gt; while 死循环 没有终止条件，就会导致无限循环（死循环）： 12while True： learn() # Python 中没有 learn() 函数，但我们要终生学习 for…in or while…考虑一下：这两种循环结构什么场景下都适用么？？！ for 循环和 whlie 循环选择的最大的区别在于【循环的工作量是否确定】 &gt;&gt;&gt;&gt; for 循环就像空房间依次办理业务，直到把【所有工作做完】才下班。但 while 循环就像哨卡放行，【满足条件就一直工作】，直到不满足条件就关闭哨卡。 所以说，当我们【工作量确定】的时候，我们就可以让 for 循环来完成重复性工作。反之，要【工作量不确定时】可以让 while 循环来工作： 12345678# 适合用 for...in... 循环for i in 'HelloWorld': print(i)# 适合用 while 循环（不知道第几次可以输入正确）password = ''while password != '816': password = input('请尝试输入密码：') 注意，类似于分支结构，for…in 和 while… 循环结构也是支持嵌套的！！！ Break &amp;&amp; Continue当我们在循环任务中，由于达到我们的目的不想再继续循环执行下去时，可以借助 break &amp;&amp; continue 来进行循环的中止： [1] &gt;&gt;&gt;&gt; break：跳出当前循环 break 语句可以跳出 for 和 while 的循环体。如果你从 for 或 while 循环中终止，任何对应的循环 else 块将不执行。实例如下： 1234567891011121314151617181920&gt;&gt;&gt; Astr = &quot;Google&quot;&gt;&gt;&gt; flags = 5&gt;&gt;&gt; while flags &gt; 0:... print(&quot;Current number:&quot;,flags)... for char in Astr:... if char == &quot;o&quot;:... break... print(&quot;Current char:&quot;,char)... flags -= 1...Current number: 5Current char: GCurrent number: 4Current char: GCurrent number: 3Current char: GCurrent number: 2Current char: GCurrent number: 1Current char: G 可以发现，当存在循环嵌套时，break 只能跳出当前循环体，而外部循环仍在进行。 [2] &gt;&gt;&gt;&gt; continue: 跳过当次循环 continue 语句被用来告诉 Python 解释器跳过当前循环块中的剩余语句，然后继续进行下一轮循环。 123456789&gt;&gt;&gt; flags = 5&gt;&gt;&gt; while flags &gt;= 3:... flags -= 1... if flags == 3:... continue... print(flags)...42 注意，我们知道循环语句可以有 else 子句，它在穷尽列表（ for 循环）或条件变为 false （while 循环）导致循环终止时被执行，但循环被 break 终止时会跳过 else 语句块 不执行。 了解了分支结构以及循环结构，来运用一下吧： 冒泡排序冒泡排序是数据结构中的经典算法，算法的实现思想遵循以下几步： 比较相邻的元素，如果第一个比第二个大，就交换它们两个； 从最开始的第一对到结尾的最后一对，对每一对相邻元素做步骤 1 所描述的比较工作，并将最大的元素放在后面。这样，当从最开始的第一对到结尾的最后一对都执行完后，整个序列中的最后一个元素便是最大的数； 将循环缩短，除去最后一个数（因为最后一个已经是最大的了），再重复步骤 2 的操作，得到倒数第二大的数； 持续做步骤 3 的操作，每次将循环缩短一位，并得到本次循环中的最大数。直到循环个数缩短为 1，即没有任何一对数字需要比较，此时便得到了一个从小到大排序的序列。 例如，使用 for 循环实现用冒泡排序算法对 [5,8,4,1] 进行排序： 1234567data = [5,8,4,1]#实现冒泡排序for i in range(len(data)-1): for j in range(len(data)-i-1): if(data[j]&gt;data[j+1]): data[j],data[j+1] = data[j+1],data[j]print(&quot;排序后：&quot;,data) 运行结果如下： 1排序后： [1, 4, 5, 8] Python 中的推导式推导式（又称解析器），是 Python 独有的一种特性。 前面在介绍列表、元组、字典以及集合等数据类型的创建时，都给出过使用推导式的创建方法，但只是简单提了一下。 事实上，使用推导式可以快速生成符合条件的列表、元组、字典以及集合类型的数据，因此推导式又可细分为 列表推导式、元组推导式、字典推导式 以及 集合推导式。 推导式统一语法格式如下： 1[{( 表达式 for 迭代变量 in 可迭代对象 [if 条件表达式] )}] 此格式中，具体使用那种括号视数据类型而定；且 [if 条件表达式] 不是必须的，用于进行元素过滤。 列表推导式列表推导式可以利用 range 区间、元组、列表、字典和集合等数据类型，快速生成一个满足指定需求的列表。 列表推导式的语法格式如下： 1[表达式 for 迭代变量 in 可迭代对象 [if 条件表达式] ] 初学者可以这样认为，它只是对 for 循环语句的格式做了一下简单的变形，并用 [] 括起来而已，只不过最大的不同之处在于，列表推导式最终会将循环过程中，表达式计算得到的一系列值组成一个列表。 例如如下代码（程序一）： 1234567a_range = range(10)# 对a_range执行for表达式a_list = [x * x for x in a_range]# a_list集合包含10个元素print(a_list)# 输出：[0 , 1 , 4 , 9 , 16 , 25 , 36 , 49 , 64, 81] 还可以在列表推导式中添加 [if 条件语句]，过滤符合条件的元素： 123456# 偶数b_list = [x * x for x in a_range if x % 2 == 0]# a_list集合包含5个元素print(b_list)# 输出：[0 ,4 , 16, 36, 64] 另外，以上所看到的列表推导式都只有一个循环，实际上它可使用多个循环，就像嵌套循环一样。例如如下代码： 1234567src_a = [30, 12, 66, 34, 39, 78, 36, 57, 121]src_b = [3, 5, 7, 11]# 只要y能整除x，就将它们配对在一起result = [(x, y) for x in src_b for y in src_a if y % x == 0]print(result)# 输出： [(3, 30), (3, 12), (3, 66), (3, 39), (3, 78), (3, 36), (3, 57), (5, 30), (11, 66), (11, 121)] 元组推导式元组推导式可以利用 range 区间、元组、列表、字典和集合等数据类型，快速生成一个满足指定需求的元组。 元组推导式的语法格式如下： 1(表达式 for 迭代变量 in 可迭代对象 [if 条件表达式] ) 通过和列表推导式做对比，你会发现，除了元组推导式是用 () 圆括号将各部分括起来，而列表推导式用的是 []，其它完全相同。不仅如此，元组推导式和列表推导式的用法也完全相同。 例如，我们可以使用下面的代码生成一个包含数字 1~9 的元组： 12a = (x for x in range(1,10))print(a) 输出结果： 1&lt;generator object &lt;genexpr&gt; at 0x0000020BAD136620&gt; 可以看出，使用元组推导式生成的结果并不是一个元组，而是一个生成器对象（后续会介绍），这一点和列表推导式是不同的。 如果我们想要使用元组推导式获得新元组或新元组中的元素，有以下三种方式： 1.使用 tuple() 函数，可以直接将生成器对象转换成元组，例如： 123a = (x for x in range(1,10))print(tuple(a))# 运行结果为：(1, 2, 3, 4, 5, 6, 7, 8, 9) 2.直接使用 for 循环遍历生成器对象，可以获得各个元素，例如： 12345a = (x for x in range(1,10))for i in a: print(i,end=' ')print(tuple(a))# 运行结果：1 2 3 4 5 6 7 8 9 () 3.使用 next() 方法遍历生成器对象，也可以获得各个元素，例如： 123456a = (x for x in range(3))print(a.__next__())print(a.__next__())print(a.__next__())a = tuple(a)print(&quot;转换后的元组：&quot;,a) 运行结果为： 1234012转换后的元组： () 无论是使用 for 循环遍历生成器对象，还是使用 next() 方法遍历生成器对象，遍历后原生成器对象将不复存在，这就是遍历后转换原生成器对象却得到空元组的原因。 字典推导式字典推导式可以借助列表、元组、字典、集合以及 range 区间，快速生成符合需求的字典。 字典推导式的语法格式如下： 1{表达式 for 迭代变量 in 可迭代对象 [if 条件表达式]} 可以看到，和其它推导式的语法格式相比，唯一不同在于，字典推导式用的是大括号{}。 【例 1】 123456listdemo = ['C语言中文网','c.biancheng.net']#将列表中各字符串值为键，各字符串的长度为值，组成键值对newdict = {key:len(key) for key in listdemo}print(newdict)# Output: {'C语言中文网': 6, 'c.biancheng.net': 15} 【例 2】 交换现有字典中各键值对的键和值 12345olddict={'test': 6, 'test2': 15}newdict = {v: k for k, v in olddict.items()}print(newdict)# Output: {6: 'test', 15: 'test2'} 【例 3】 使用 if 表达式筛选符合条件的键值对 12345olddict={'test': 6, 'test2': 15}newdict = {v: k for k, v in olddict.items() if v&gt;10}print(newdict)# Output: {15: 'test2'} 集合推导式集合推导式可以借助列表、元组、字典、集合以及 range 区间，快速生成符合需求的集合。 集合推导式的语法格式如下： 1{表达式 for 迭代变量 in 可迭代对象 [if 条件表达式]} 集合推导式和字典推导式的格式完全相同，那么给定一个类似的推导式，如何判断是哪种推导式呢？最简单直接的方式，就是根据表达式进行判断，如果表达式以键值对（key：value）的形式，则证明此推导式是字典推导式；反之，则是集合推导式。 【例 1】 既然生成的是集合，那么其保存的元素必须是唯一的 12345tupledemo = (1,1,2,3,4,5,6,6)setnew = {x**2 for x in tupledemo if x%2==0}print(setnew)# Output: {16, 4, 36}","link":"/2018/01/09/python-zhong-de-yun-suan-fu-yi-ji-liu-cheng-kong-zhi/"},{"title":"Python 数据结构之 Dict and Set","text":"Python 基本数据类型，前面已经认识了 Pthon 中的数字(Number)、字符串(String）、元组(Tuple)、列表(List)。接下来来看 Python 中的 字典（Dict） 和 集合（Set）。 Python 中的字典（Dict）和集合（Set）容器模型： 字典（Dict）Python 中另一个非常有用的内置数据类型是字典（Dictionary），相当于其他语言中的 Map（表征映射关系）。 认识字典Python 字典（dict）是一种 无序的、可变的 数据集，它的元素是以 “键值对（key-value）” 的形式存储，是 Python 中唯一的 映射类型。 映射 是数学中的术语，简单理解，它指的是元素之间相互对应的关系，即通过一个元素，可以唯一找到另一个元素。 例如，期中考试小明、小红、小刚分别考了 95、90 和 90 分。结合之前的知识，自然而然，我们想到了使用列表的形式来存放上述数据，我们需要新创建一个列表来专门放分数，而且要保证和姓名的顺序是一致的，这是很麻烦。 字典的出现，为我们提供了一种更好的方式来 表达这种具有映射关系的数据（小明 –&gt; 95，小红 –&gt; 90，小刚 –&gt; 90）。 事实上，字典类型很像我们学生时代常用的新华字典。我们知道，通过新华字典中的音节表，可以快速找到想要查找的汉字。其中，字典里的音节表就相当于字典类型中的键（Key），而键对应的汉字则相当于值（Value）。 Key-Value &gt;&gt;&gt;&gt; 类似于 List &amp;&amp; tuple，字典中，习惯将各元素对应的索引称为键（key），各个键对应的元素称为值（value），一起构成了 “key-value” (键值对)。 通过键（Key）来获取相应值（Value）的模式（key-value）要求： key（键）字典中的键必须唯一，且不可变（只能使用数字、字符串或者元组，不能使用列表）； value（值）是无序、可变的元素对象，可以是 Python 支持的任意数据类型。 小结：字典（dict）是 Python 中一种无序、可变的，采用 key-value 键值对来表述具有映射关系数据的内置数据类型。 字典的构建创建字典的方式有很多，下面开始一一介绍： [1] &gt;&gt;&gt;&gt; 字典的标准创建格式: 字典的标准创建格式很简单，用大括号 { } 来标识。它是一个无序的 key:value 键值对的集合，相邻元素之间使用逗号 , 分隔： 1dict1 = {key1 : value1, key2 : value2 } 代码示范： 1234567# 使用字符串作为keystudents_scores = {'小明':95, '小红':90, '小刚':90}print(students_scores)# 使用元组和数字作为 keydict1 = {(20, 30):'great', 30:[1,2,3]}print(dict1) 可以看到，字典的键可以是整数、字符串或者元组，只要符合唯一和不可变的特性就行；字典的值可以是 Python 支持的任意数据类型。 空字典 &gt;&gt;&gt;&gt; 使用此方式创建字典时，字典中 key-value 可以有多个，也可以一个都没有（空字典），例如： 12345&gt;&gt;&gt; emptydict = {}&gt;&gt;&gt; emptydict{}&gt;&gt;&gt; type(emptydict)&lt;class 'dict'&gt; [2] &gt;&gt;&gt;&gt; fromkeys() 字典方法创建: Python dict 中，提供了 fromkeys() 方法来根据 Key 列表创建带有默认值的字典，具体格式为： 1dictname = dict.fromkeys(list，value=None) 其中，list 参数表示字典中所有键的列表（list）；value 参数表示默认值，如果不写，则为空值 None。 例如： 1234&gt;&gt;&gt; knowledge = ['语文', '数学', '英语']&gt;&gt;&gt; scores = dict.fromkeys(knowledge, 60)&gt;&gt;&gt; print(scores){'语文': 60, '数学': 60, '英语': 60} 这种创建方式通常用于初始化字典，设置 value 的默认值。 [3] &gt;&gt;&gt;&gt; dict() 内建函数创建字典: 语法规则如下: 123class dict(**kwarg) # 传入关键字class dict(mapping, **kwarg) # 映射函数方式来构造字典class dict(iterable, **kwarg) # 可迭代对象方式来构造字典 官方是这么解释的： dict() 方法会返回一个新的字典，并且基于可选的位置参数（mapping 或者 iterable）和可能为空的关键字（Key）参数集来初始化新字典。 如果没有给出位置参数以及关键字参数集，将创建一个空字典; 如果给出一个位置参数并且其属于映射对象（mapping），将创建一个具有与映射对象相同键值对的字典;否则的话，位置参数必须为一个 iterable 对象。 该可迭代对象中的每一项本身必须为一个刚好包含两个元素的可迭代对象。 每一项中的第一个对象将成为新字典的一个键，第二个对象将成为其对应的值。 如果一个键出现一次以上，该键的最后一个值将成为其在新字典中对应的值； 如果给出了关键字参数集（key-vaule），则关键字参数及其值（例如：one=1）会被加入到基于位置参数创建的字典。 如果要加入的键已存在，来自关键字参数的值将替代来自位置参数的值。 详细示例如下（请对照参看）： 12345678910111213141516171819202122232425262728293031323334353637383940&gt;&gt;&gt; # 没有给出位置参数以及关键字参数集&gt;&gt;&gt; dict1 = dict()&gt;&gt;&gt; dict1{}&gt;&gt;&gt; # 1. 给出位置参数且其属于映射对象（`mapping`）&gt;&gt;&gt; dict2 = dict(zip(['one', 'two', 'three'], [1, 2, 3]))&gt;&gt;&gt; dict2{'one': 1, 'two': 2, 'three': 3}&gt;&gt;&gt; # 2. 给出位置参数且是一个 `iterable` 对象（List 或者 元组 或者字典）# List&gt;&gt;&gt; dict3 = dict([('two',2), ('one',1), ('three',3)])&gt;&gt;&gt; dict3{'two': 2, 'one': 1, 'three': 3}&gt;&gt;&gt; dict4 = dict([['two',2], ['one',1], ['three',3]])&gt;&gt;&gt; dict4{'two': 2, 'one': 1, 'three': 3}# Tuple&gt;&gt;&gt; dict5 = dict((['two',2], ['one',1], ['three',3]))&gt;&gt;&gt; dict5{'two': 2, 'one': 1, 'three': 3}&gt;&gt;&gt; dict5 = dict((('two',2), ('one',1), ('three',3)))&gt;&gt;&gt; dict5{'two': 2, 'one': 1, 'three': 3}# Dict&gt;&gt;&gt; dict6 = dict({'three': 3, 'one': 1, 'two': 2})&gt;&gt;&gt; dict6{'three': 3, 'one': 1, 'two': 2}&gt;&gt;&gt; # 3. 给出位置参数（dict）以及关键字参数集（two=2）&gt;&gt;&gt; dict7 = dict({'one': 1, 'three': 3}, two=2)&gt;&gt;&gt; dict7{'one': 1, 'three': 3, 'two': 2}# 验证字典的无序性&gt;&gt;&gt; dict1 == dict2 == dict3 == dict4 == dict5 == dict6 == dict7False [4] &gt;&gt;&gt;&gt; 推导式方法创建字典： 和列表的推导式方法定义类似，我们同样还可以使用推导式的方法创建字典： 12&gt;&gt;&gt; {x:x**2 for x in (2,4,6,8)}{2: 4, 4: 16, 6: 36, 8: 64} 字典的删除和删除列表、元组一样，手动删除字典也可以使用 del 关键字，例如： 123456789&gt;&gt;&gt; a = dict(two=0.65, one=88, three=100, four=-59)&gt;&gt;&gt; print(a){'two': 0.65, 'one': 88, 'three': 100, 'four': -59}&gt;&gt;&gt; del a&gt;&gt;&gt; print(a)Traceback (most recent call last): File &quot;C:\\Users\\mozhiyan\\Desktop\\demo.py&quot;, line 4, in &lt;module&gt; print(a)NameError: name 'a' is not defined Python 自带垃圾回收功能，会自动销毁不用的字典，所以一般不需要通过 del 来手动删除。 深入解读 Key-Value 键值对我们知道，字典中存放的就是具有映射关系的 key:value 无序数据，键值对可以很好的表征字典（Dict）的映射特性。 并且，键值对中的键（Key）必须是不可变类型（Number，Str 或者 Tuple，常用的是数值或字符串），且必须唯一；而值则可以是 Python 支持的任意类型对象。 映射数据场景下，通过 List 来比较一下 Dict 的优势： [1] &gt;&gt;&gt;&gt; list &amp;&amp; dict 场景模拟 举个例子，假设要根据公司员工的名字查找对应的薪资，如果用 list 实现，需要两个 list： 12&gt;&gt;&gt; names = ['Google', 'Baidu', '360', 'Opera']&gt;&gt;&gt; salary = [5888, 3888, 2888, 4300] 给定一个名字，要查找对应的薪资，就先要在 names 中找到对应的位置（索引），再利用索引从 salary 取出对应的成绩。且 list 越长，耗时越长。 123&gt;&gt;&gt; indx = names.index(&quot;Opera&quot;)&gt;&gt;&gt; salary[indx]4300 但如果使用 dict 实现，只需要一个 名字:薪资 的对照表，直接根据名字查找薪资。 123&gt;&gt;&gt; staff = {'Google':5888, 'Baidu':3888, '360':2888, 'Opera':4300}&gt;&gt;&gt; staff[&quot;Opera&quot;]4300 相较于 List 的使用，键值对（key-value）的引入带来了访问性能上的提升，使得字典具有极快的查找速度。而且无论这个表有多大，查找速度都不会变慢。 [2] &gt;&gt;&gt;&gt; 键值对（Key-Value）检索模式 很迷惑啊！键值对到底干了啥？如何理解？？？ &gt;&gt;&gt;&gt; dict 之所以查找速度这么快，是因为其实现原理和查字典是一样的。 假设字典包含了 1 万个汉字，我们要查某一个字： –&gt; 第一种办法（list 方法）： 把字典从第一页往后翻，直到找到我们想要的字为止，这种方法就是在 list 中查找元素的方法，list 越大，查找越慢。 –&gt; 第二种方法（dict 方法）： 先在字典的索引表里（比如部首表）查这个字对应的页码，然后直接翻到该页，找到这个字。无论找哪个字，这种查找速度都非常快，不会随着字典大小的增加而变慢。 字典（dict）就是第二种实现方式，给定一个名字，比如 Opera，dict 在内部就可以直接计算出 Opera 对应的存放薪资的“页码”，也就是 4300 这个数字存放的内存地址，直接取出来，所以速度非常快。 可以猜想到，这种 key-value 存储方式，在放进去的时候，必须根据 key 算出 value 的存放位置，这样，取的时候才能根据 key 直接拿到 value。 [3] &gt;&gt;&gt;&gt; Dict VS List 和 list 比较，dict 有以下几个特点： 查找和插入的速度极快，不会随着 key 的增加而变慢； 需要占用大量的内存，内存浪费多。 而 list 刚好相反： 查找和插入的时间随着元素的增加而增加； 占用空间小，浪费内存很少。 所以，dict 是用空间来换取时间的一种方法，用在需要高速查找的很多地方。 [4] &gt;&gt;&gt;&gt; 键（Key）唯一不可变解释 正确使用 dict 非常重要，需要牢记的第一条就是 dict 的 key 必须是唯一、不可变对象。 这是因为 dict 需要根据 key 来计算 value 的存储位置，如果每次计算相同的 key 得出的结果不同，那 dict 内部就完全混乱了。 这种通过 key 计算位置的算法称为哈希算法（Hash）。要保证 hash 的正确性，作为 key 的对象就不能变。 访问字典里的值前面已经知道，字典（Dict）中必须根据 key 算出 value 的存放位置，即 key 对应了 value 元素对象的引用（索引），也就是说 dict 种需要根据 key 来获取 value 取值。 字典中的元素是无序的，每个元素的位置都不固定，所以字典不能像列表和元组那样，采用切片的方式一次性访问多个元素。 [1] &gt;&gt;&gt;&gt; dictname[key] 12&gt;&gt;&gt; print(&quot;dict[&quot;Google&quot;]:&quot;,staff[&quot;Google&quot;])dict[&quot;Google&quot;]: 5888 如果使用字典里没有的键访问数值时，会输出如下错误： 1234&gt;&gt;&gt; staff[&quot;www&quot;]Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;KeyError: 'www' [2] &gt;&gt;&gt;&gt; dict 类型支持的 get() 方法 get() 方法的语法格式为： 1dictname.get(key[,default]) 其中，key 表示指定的键，default 用于指定要查询的键不存在时，此方法返回的默认值，如果不手动指定，会返回 None。 示例： 1234567&gt;&gt;&gt; a = dict(two=0.65, one=88, three=100, four=-59)&gt;&gt;&gt; print( a.get('one') )88&gt;&gt;&gt; a = dict(two=0.65, one=88, three=100, four=-59)&gt;&gt;&gt; print( a.get('five', None) )None | &gt;&gt;&gt;&gt; =========================================================== 推荐使用 get() 方法，可保证字典键值有效性 &gt;&gt;&gt;&gt; 12345678staff = {'Google': 5888, 'Baidu': 3888, '360': 2888, 'Opera': 4300}state = staff.get（'4396'， None）if not state: .... # 等价于：if '4396' not in staff or staff['4396'] is None or not staff['4396']: ... 成立有三种情况： dict中不存在 dict中存在，但值是：None dict中存在而且也不是 None，但是是一个等同于 False 的值，比如说空字符串或者空列表。 =========================================================== &lt;&lt;&lt;&lt; | 字典基本操作字典（Dict）也是一种可变数据类型。所以我们可以单独对字典中的数据项（key:value 对）进行修改、增加、以及删除等操作。 常见的字典操作有以下几种： 向现有字典中添加新的键值对； 修改现有字典中的键值对； 从现有字典中删除指定的键值对； 判断现有字典中是否存在指定的键值对。 字典是由一个一个的 key-value 构成的，key 是找到数据的关键，Python 对字典的操作都是通过 key 来完成的。 [0] &gt;&gt;&gt;&gt; 字典容量查询 len(dict) 方法计算字典元素个数（获取字典容量），即键值对的总数： 123&gt;&gt;&gt; staff = {'Google': 5888, 'Baidu': 3888, '360': 2888, 'Opera': 4300, 'Sogo': 3200}&gt;&gt;&gt; len(staff)5 [1] &gt;&gt;&gt;&gt; 字典添加键值对 把键值对放入 dict 的方法，除了初始化时指定外，为字典添加新的键值对很简单，直接给不存在的 key 赋值即可，具体语法格式如下： 1dictname[key] = value 代码演示: 1234&gt;&gt;&gt; staff = {'Google': 5888, 'Baidu': 3888, '360': 2888, 'Opera': 4300}&gt;&gt;&gt; staff[&quot;Sogo&quot;] = 3000&gt;&gt;&gt; staff{'Google': 5888, 'Baidu': 3888, '360': 2888, 'Opera': 4300, 'Sogo': 3000} [2] &gt;&gt;&gt;&gt; 字典修改键值对 注意，由于字典种一个 key 只能对应一个 value，多次对一个 key 放入 value，后面的值会把前面的值冲掉，以此达到修改元素值的目的。请看下面的代码： 1234&gt;&gt;&gt; staff = {'Google': 5888, 'Baidu': 3888, '360': 2888, 'Opera': 4300, 'Sogo': 3000}&gt;&gt;&gt; staff[&quot;Sogo&quot;] = 3200 # 3000 --&gt; 3200&gt;&gt;&gt; staff{'Google': 5888, 'Baidu': 3888, '360': 2888, 'Opera': 4300, 'Sogo': 3200} [3] &gt;&gt;&gt;&gt; 字典删除键值对 如果要删除字典中的键值对，还是可以使用 del 语句。例如： 12345678910111213141516171819&gt;&gt;&gt; staff = {'Google': 5888, 'Baidu': 3888, '360': 2888, 'Opera': 4300, 'Sogo': 3200}# 删除键值对：&gt;&gt;&gt; del staff[&quot;Sogo&quot;]&gt;&gt;&gt; print(staff){'Google': 5888, 'Baidu': 4000, '360': 2888, 'Opera': 4300}# 清空字典&gt;&gt;&gt; staff.clear()&gt;&gt;&gt; staff{}# 删除字典（实质上就是删除了用来存放字典的变量）&gt;&gt;&gt; del staff&gt;&gt;&gt; staffTraceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;NameError: name 'staff' is not defined [3] &gt;&gt;&gt;&gt; 判断字典中是否存在指定键值对 判断字典是否包含指定键值对的键，可以使用 in 或 not in 运算符: in 操作符用于判断键是否存在于字典中，如果键在字典 dict 里返回 true，否则返回 false。 而 not in 操作符刚好相反，如果键在字典 dict 里返回 false，否则返回 true。 1234567891011121314&gt;&gt;&gt; staff = {'Google': 5888, 'Baidu': 3888, '360': 2888, 'Opera': 4300}&gt;&gt;&gt; if 'Google' in staff:... print(&quot;Key of Google exist&quot;)... else:... print(&quot;Key of Google not exist&quot;)...Key of Google exist&gt;&gt;&gt; if 'Sogo' in staff:... print(&quot;Key of Sogo exist&quot;)... else:... print(&quot;Key of Sogo not exist&quot;)...Key of Sogo not exist 注意，key (not) in dict 常应用于判断某一 key 是否在字典中有定义。如果存在，由于通过键可以很轻易的获取对应的值，因此很容易就能判断出字典中是否有指定的键值对。 字典方法全攻略Python 字典的数据类型为 dict，我们可使用 dir(dict) 来查看该类型包含哪些方法，例如： 12&gt;&gt;&gt; dir(dict)['clear', 'copy', 'fromkeys', 'get', 'items', 'keys', 'pop', 'popitem', 'setdefault', 'update', 'values'] 这些方法中，fromkeys()、get() 以及 clear() 的用法上面有过说明，这里介绍剩下的方法： [1] &gt;&gt;&gt;&gt; keys() &amp;&amp; values() &amp;&amp; items() 将这三个方法放在一起介绍，是因为它们都用来获取字典中的特定数据： keys() 方法用于返回字典中的所有键（key）； values() 方法用于返回字典中所有键对应的值（value）； items() 用于返回字典中所有的键值对（key-value）。 代码演示： 1234567&gt;&gt;&gt; dict2 = {'one': 1, 'two': 2, 'three': 3}&gt;&gt;&gt; print(dict2.keys())dict_keys(['one', 'two', 'three'])&gt;&gt;&gt; print(dict2.values())dict_values([1, 2, 3])&gt;&gt;&gt; print(dict2.items())dict_items([('one', 1), ('two', 2), ('three', 3)]) 可以发现，keys()、values() 和 items() 返回值的类型分别为 dict_keys、dict_values 和 dict_items，它们都是可迭代对象（Iterable）。 在 Python 2.x 中，上面三个方法的返回值都是列表（list）类型。但在 Python 3.x 中，它们的返回值并不是我们常见的列表或者元组类型，因为 Python 3.x 不希望用户直接操作这几个方法的返回值。 故，你不能以索引的方式直接访问其中的数据： 1234&gt;&gt;&gt; dict2.keys()[0]Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: 'dict_keys' object is not subscriptable 如果想使用这三个方法返回的数据，一般有下面两种方案： 1）–&gt; 使用 list() 函数，将它们返回的数据转换成列表，例如： 1234567891011&gt;&gt;&gt; keyslist = list(dict2.keys())&gt;&gt;&gt; keyslist['one', 'two', 'three']&gt;&gt;&gt; valueslist = list(dict2.values())&gt;&gt;&gt; valueslist[1, 2, 3]# 返回的是一个由 key-value 元组组成的列表&gt;&gt;&gt; itemslist = list(dict2.items())&gt;&gt;&gt; itemslist[('one', 1), ('two', 2), ('three', 3)] 2）–&gt; for … in … 循环遍历 既然是可迭代对象（Iterable），故可以通过 for in 进行循环遍历： 1234567891011121314&gt;&gt;&gt; for key in dict2.keys():... print(key, end=';')...one;two;three;&gt;&gt;&gt; for value in dict2.values():... print(value, end=';')...1;2;3;&gt;&gt;&gt; for item in dict2.items():... print(item, end=';')...('one', 1);('two', 2);('three', 3); [2] &gt;&gt;&gt;&gt; copy() copy() 方法返回一个字典的拷贝，也即返回一个具有相同键值对的新字典，例如： 1234&gt;&gt;&gt; a = {'one': 1, 'two': 2, 'three': [1,2,3]}&gt;&gt;&gt; b = a.copy()&gt;&gt;&gt; print(b){'one': 1, 'two': 2, 'three': [1, 2, 3]} 可以看到，copy() 方法将字典 a 的数据全部拷贝给了字典 b。 注意，copy() 方法所遵循的拷贝原理，既有深拷贝，也有浅拷贝（这和前面 list.copy() 方法是一样的）。事实上，这还有由于 Python 中元素对象属于不可变还是可变决定的，内容解读参见：Python 中的可变对象和不可变对象。 [3] &gt;&gt;&gt;&gt; update() update() 方法可以使用一个新的字典所包含的键值对来更新己有的字典。 更新原则：如果被更新的字典中己包含对应的键值对，那么原 value 会被覆盖；如果被更新的字典中不包含对应的键值对，则该键值对被添加进去。 代码演示： 1234&gt;&gt;&gt; a = {'one': 1, 'two': 2, 'three': 3}&gt;&gt;&gt; a.update({'one':4.5, 'four': 9.3})&gt;&gt;&gt; print(a){'one': 4.5, 'two': 2, 'three': 3, 'four': 9.3} [4] &gt;&gt;&gt;&gt; pop() &amp;&amp; popitem() pop() 和 popitem() 函数都用来删除字典中的键值对，不同的是，pop() 用来删除指定的键值对，而 popitem() 用来随机删除一个键值对，它们的语法格式如下： 12dictname.pop(key)dictname.popitem() 代码演示: 123456789&gt;&gt;&gt; print(a) = {'one': 4.5, 'two': 2, 'three': 3, 'four': 9.3}&gt;&gt;&gt; a.pop(&quot;one&quot;)4.5&gt;&gt;&gt; print(a){'two': 2, 'three': 3, 'four': 9.3}&gt;&gt;&gt; a.popitem()('four', 9.3)&gt;&gt;&gt; print(a){'two': 2, 'three': 3} 注意，pop() 和 popitem() 函数返回值为被删除的值。 [5] &gt;&gt;&gt;&gt; setdefault() setdefault() 方法用来返回某个 key 对应的 value，其语法格式如下： 1dictname.setdefault(key, defaultvalue) setdefault() 方法总能返回指定 key 对应的 value： 如果该 key 存在，那么直接返回该 key 对应的 value； 当指定的 key 不存在时，setdefault() 会先为这个不存在的 key 设置一个默认的 defaultvalue，然后再返回 defaultvalue。 1234567891011121314a = {'数学': 95, '语文': 89, '英语': 90}print(a)# key不存在，指定默认值a.setdefault('物理', 94)print(a)# key不存在，不指定默认值a.setdefault('化学')print(a)# key存在，指定默认值a.setdefault('数学', 100)print(a) 运行结果如下： 1234{'数学': 95, '语文': 89, '英语': 90}{'数学': 95, '语文': 89, '英语': 90, '物理': 94}{'数学': 95, '语文': 89, '英语': 90, '物理': 94, '化学': None}{'数学': 95, '语文': 89, '英语': 90, '物理': 94, '化学': None} 字典遍历 &amp;&amp; 合并基于上述我们了解的内容，实现常用的字典遍历 &amp;&amp; 字典合并功能： [1] &gt;&gt;&gt;&gt; 字典遍历 1）–&gt; 成员检测方法： 12345&gt;&gt;&gt; staff = {'Google': 5888, 'Baidu': 3888, '360': 2888, 'Opera': 4300}&gt;&gt;&gt; for key in staff:... print(key, end=';')...Google;Baidu;360;Opera;&gt;&gt;&gt; 2）–&gt; key:value 键值对方法： 12345&gt;&gt;&gt; staff = {'Google': 5888, 'Baidu': 3888, '360': 2888, 'Opera': 4300}&gt;&gt;&gt; for key,value in staff.items():... print(key,&quot;:&quot;,value,end=';')...Google : 5888;Baidu : 3888;360 : 2888;Opera : 4300; 3）–&gt; 键（Key）遍历方法： 123456&gt;&gt;&gt; staff = {'Google': 5888, 'Baidu': 3888, '360': 2888, 'Opera': 4300}&gt;&gt;&gt; for key in staff.keys():... print(key,end=';')...Google;Baidu;360;Opera; [2] &gt;&gt;&gt;&gt; 字典合并 1）–&gt; 常规方法： 12345678&gt;&gt;&gt; dict1 = {'a':1, 'b':2}&gt;&gt;&gt; dict2 = {'c':1, 'd':2}&gt;&gt;&gt; for key,value in dict1.items():... dict2[key] = value...&gt;&gt;&gt; dict2{'c': 1, 'd': 2, 'a': 1, 'b': 2} 2）–&gt; dict( list(dict1.items()) + list(dict2.items()) ) 方法： 123456&gt;&gt;&gt; dict1 = {'a':1, 'b':2}&gt;&gt;&gt; dict2 = {'a':3, 'd':2}&gt;&gt;&gt; dict3 = dict(list(dict1.items()) + list(dict2.items()))&gt;&gt;&gt; dict3{'a': 3, 'b': 2, 'd': 2} 3）–&gt; 字典的 update 方法： 12345&gt;&gt;&gt; dict5 = {}&gt;&gt;&gt; dict5.update(dict1)&gt;&gt;&gt; dict5.update(dict2)&gt;&gt;&gt; dict5{'a': 3, 'b': 2, 'd': 2} 4）–&gt; dict(dict1, **dict2) 方法： 123456&gt;&gt;&gt; dict1 = {'a':1, 'b':2}&gt;&gt;&gt; dict2 = {'a':3, 'd':2}&gt;&gt;&gt; dict4 = dict(dict1, **dict2)&gt;&gt;&gt; dict4{'a': 3, 'b': 2, 'd': 2} 集合（Set）Python 中的集合，和数学中的集合概念一样（有限、互异、无序），用来保存不重复的元素。 你可以将其和 dict 进行比较，是一组 key 的集合，但不存储value。所以在 set 中，也没有重复的 key。和字典类似，Python 集合会将所有元素放在一对大括号 {} 中，相邻元素之间用 “,” 分隔，如下： 1{element1,element2,...,elementn} 类似于 dict 中的 key 唯一性，所以同一集合中，只能存储不可变的数据类型，包括整形、浮点型、字符串、元组，无法存储列表、字典、集合这些可变的数据类型，否则 Python 解释器会抛出 TypeError 错误。比如说： 123456789101112131415&gt;&gt;&gt; {{'a':1}}Traceback (most recent call last): File &quot;&lt;pyshell#8&gt;&quot;, line 1, in &lt;module&gt; {{'a':1}}TypeError: unhashable type: 'dict'&gt;&gt;&gt; {[1,2,3]}Traceback (most recent call last): File &quot;&lt;pyshell#9&gt;&quot;, line 1, in &lt;module&gt; {[1,2,3]}TypeError: unhashable type: 'list'&gt;&gt;&gt; {{1,2,3}}Traceback (most recent call last): File &quot;&lt;pyshell#10&gt;&quot;, line 1, in &lt;module&gt; {{1,2,3}}TypeError: unhashable type: 'set' 提示你数据类型错误，非哈希类型~~~ 集合构建Python 中提供了两种集合的创建方法： [1] &gt;&gt;&gt;&gt; 集合的标准创建格式: 类似与 Dict，Python 提供了使用大括号 {} 创建集合，并用 , 分隔元素对象，创建格式如下： 123parame = {value01,value02,...}或者set(value) 创建实例如下： 123456&gt;&gt;&gt; set1 = {&quot;Google&quot;, &quot;Baidu&quot;, &quot;Opera&quot;, &quot;Baidu&quot;}&gt;&gt;&gt; print(set1){'Opera', 'Google', 'Baidu'}&gt;&gt;&gt; set2 = {&quot;Welcom&quot;, 32, 123.321}&gt;&gt;&gt; print(set2){32, 123.321, 'Welcom'} [2] &gt;&gt;&gt;&gt; set() 内建函数创建集合: 除了使用 {} 创建列表外，Python 还提供了一个内置的函数 set(Iterable)，使用它可以将其它可迭代对象转换为集合类型（自动去重）。 123456789101112131415&gt;&gt;&gt; set3 = set(&quot;abcdefg&quot;)&gt;&gt;&gt; set3{'d', 'c', 'g', 'f', 'e', 'b', 'a'}&gt;&gt;&gt; set4 = set([&quot;Google&quot;, &quot;Baidu&quot;, &quot;Opera&quot;])&gt;&gt;&gt; print(set4){'Opera', 'Google', 'Baidu'}&gt;&gt;&gt; set5 = set((&quot;Google&quot;, &quot;Baidu&quot;, &quot;Opera&quot;, &quot;Google&quot;))&gt;&gt;&gt; print(set5){'Opera', 'Google', 'Baidu'}&gt;&gt;&gt; set6 = set({&quot;one&quot;:1, &quot;two&quot;:2})&gt;&gt;&gt; set6{'one', 'two'} 空集合 &gt;&gt;&gt;&gt; 创建一个空集合必须用 set() 而不是 {...,... }，因为 { } 是用来创建一个空字典的（已被占用）。 1234&gt;&gt;&gt; dict1 = {}&gt;&gt;&gt; set1 = set()&gt;&gt;&gt; print(type(dict1),type(set1))&lt;class 'dict'&gt; &lt;class 'set'&gt; [3] &gt;&gt;&gt;&gt; 推导式方法创建列表： 类似列表、字典的推导式，同样，集合也支持集合推导式: 123&gt;&gt;&gt; setA = {x for x in 'abcdr' if x not in 'abc'}&gt;&gt;&gt; setA{'d', 'r'} 集合的删除和删除列表、元组、字典一样，手动删除字典也可以使用 del 关键字，例如： 12345678&gt;&gt;&gt; a = {1,'c',1,(1,2,3),'c'}&gt;&gt;&gt; a{1, 'c', (1, 2, 3)}&gt;&gt;&gt; del a&gt;&gt;&gt; aTraceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;NameError: name 'a' is not defined 访问集合里的值由于集合中的元素是无序的，因此无法向列表那样使用下标访问元素。 Python 中，访问集合元素最常用的方法是使用循环结构，将集合中的数据逐一读取出来: 12345&gt;&gt;&gt; a = {1,'c',1,(1,2,3)}&gt;&gt;&gt; for ele in a:... print(ele,end=' ')...1 c (1, 2, 3) 集合基本操作集合（Set）也是一种可变数据类型。所以我们可以单独对集合中的数据项进行增加、删除以及集合之间做交集、并集、差集等运算。 [0] &gt;&gt;&gt;&gt; 集合容量查询 len(set) 方法可以来计算集合 set 元素个数。 123&gt;&gt;&gt; setA = {&quot;Google&quot;, &quot;Baidu&quot;, &quot;Opera&quot;}&gt;&gt;&gt; len(setA)3 [1] &gt;&gt;&gt;&gt; 成员检查（in or not in） x in set 方法可用于判断元素 x 是否在集合 set 中，存在返回 True，不存在返回 False。 123&gt;&gt;&gt; setA = {&quot;Google&quot;, &quot;Baidu&quot;, &quot;Opera&quot;}&gt;&gt;&gt; &quot;Google&quot; in setATrue [2] &gt;&gt;&gt;&gt; 向 set 集合中添加元素 1）–&gt; add() 集合方法 set.add( x ) 可以将元素 x 添加到集合 set 中，如果元素已存在，则不进行任何操作。 1234&gt;&gt;&gt; setA = {&quot;Google&quot;, &quot;Baidu&quot;, &quot;Opera&quot;}&gt;&gt;&gt; setA.add(&quot;Sogo&quot;)&gt;&gt;&gt; print(setA){'Opera', 'Google', 'Baidu', 'Sogo'}) 使用 add() 方法添加的元素，只能是数字、字符串、元组或者布尔类型（True 和 False）值，不能添加列表、字典、集合这类可变的数据，否则 Python 解释器会报 TypeError 错误： 1234Traceback (most recent call last): File &quot;C:\\Users\\mengma\\Desktop\\1.py&quot;, line 4, in &lt;module&gt; a.add([1,2])TypeError: unhashable type: 'list' 2）–&gt; update() set.update( x )方法也可以添加元素，且参数可以是字符串，列表，元组，字典，集合等： 12345678910111213141516171819202122&gt;&gt;&gt; setA = {&quot;Google&quot;, &quot;Baidu&quot;}&gt;&gt;&gt; setA.update(&quot;Opera&quot;)&gt;&gt;&gt; setA{'Baidu', 'r', 'p', 'Google', 'e', 'O', 'a'}&gt;&gt;&gt; setA.update([1,2],[3,4])&gt;&gt;&gt; setA{1, 2, 3, 4, 'Baidu', 'r', 'p', 'Google', 'e', 'O', 'a'}&gt;&gt;&gt; setA.update((&quot;Opera&quot;,&quot;360&quot;))&gt;&gt;&gt; setA{1, 2, 3, 4, '360', 'Baidu', 'r', 'Opera', 'p', 'Google', 'e', 'O', 'a'}# 并集：合并集合&gt;&gt;&gt; setA.update({&quot;Google&quot;, &quot;Sogo&quot;})&gt;&gt;&gt; setA{1, 2, 3, 4, '360', 'Baidu', 'r', 'Opera', 'p', 'Google', 'Sogo', 'e', 'O', 'a'}&gt;&gt;&gt; setA.update({&quot;jinshan&quot;:36})&gt;&gt;&gt; setA{1, 2, 3, 4, '360', 'Baidu', 'r', 'Opera', 'p', 'Google', 'Sogo', 'e', 'O', 'a', 'jinshan'} [3] &gt;&gt;&gt;&gt; 从 set 集合中删除元素 1）–&gt; remove() set.remove( x )方法将元素 x 从集合 set 中移除，如果元素不存在，则会发生错误。 123456789&gt;&gt;&gt; setA = {1, 2, 3, 4, '360', 'Baidu', 'r', 'Opera', 'p', 'Google', 'Sogo', 'e', 'O', 'a', 'jinshan'}&gt;&gt;&gt; setA.remove('jinshan')&gt;&gt;&gt; setA{1, 2, 3, 4, '360', 'Baidu', 'r', 'Opera', 'p', 'Google', 'Sogo', 'e', 'O', 'a'}&gt;&gt;&gt; setA.remove(5)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;KeyError: 5 2）–&gt; discard() set.discard( x ) 也是移除集合中的元素，且如果元素不存在，不会发生错误。 1234567&gt;&gt;&gt; setA = {&quot;Google&quot;, &quot;Baidu&quot;, &quot;Opera&quot;}&gt;&gt;&gt; setA.discard(&quot;Baidu&quot;)&gt;&gt;&gt; setA{'Google', 'Opera'}&gt;&gt;&gt; setA.discard(&quot;360&quot;)&gt;&gt;&gt; setA{'Google', 'Opera'} 3）–&gt; clear() clear() 方法用于移除集合中的所有元素。 1234&gt;&gt;&gt; setA = {&quot;Google&quot;, &quot;Baidu&quot;, &quot;Opera&quot;}&gt;&gt;&gt; setA.clear()&gt;&gt;&gt; setAset() [4] &gt;&gt;&gt;&gt; 集合间运算 结合数学集合概念，我们来看两个集合间的运算： 1234567891011121314151617181920212223# 集合中元素自动去重&gt;&gt;&gt; setA = set(&quot;abcdefghabc&quot;)&gt;&gt;&gt; print(setA){'d', 'c', 'h', 'g', 'f', 'e', 'b', 'a'}&gt;&gt;&gt; setB = set(&quot;fghijklmjklm&quot;)&gt;&gt;&gt; print(setB){'h', 'm', 'g', 'i', 'j', 'f', 'k', 'l'}# 差集：集合 setA 中包含而集合 setB 中不包含的元素&gt;&gt;&gt; setA - setB{'d', 'c', 'e', 'b', 'a'}# 并集：集合 setA 或 setB 中包含的所有元素&gt;&gt;&gt; setA | setB{'d', 'c', 'h', 'g', 'm', 'i', 'j', 'f', 'e', 'k', 'b', 'l', 'a'}# 交集：集合 setA 和 setB 中都包含了的元素&gt;&gt;&gt; setA &amp; setB{'h', 'f', 'g'}# 互异：不同时包含于 setA 和 setB 的元素&gt;&gt;&gt; setA ^ setB{'m', 'd', 'i', 'c', 'a', 'j', 'e', 'k', 'l', 'b'} 集合常用方法整理[1] &gt;&gt;&gt;&gt; set.difference(set) difference() 方法用于返回集合的差集，即返回的集合元素包含在第一个集合中，但不包含在第二个集合(方法的参数)中。 12345678&gt;&gt;&gt; setA = set(&quot;abcdefghabc&quot;)&gt;&gt;&gt; setB = set(&quot;fghijklmjklm&quot;)&gt;&gt;&gt; setA.difference(setB){'b', 'd', 'c', 'a', 'e'}# 等价于 setA - setB&gt;&gt;&gt; setA - setB{'b', 'd', 'c', 'a', 'e'} [2] &gt;&gt;&gt;&gt; set.intersection(set1, set2 … etc) intersection() 方法用于返回两个或更多集合中都包含的元素，即交集。 12345&gt;&gt;&gt; x = {&quot;a&quot;, &quot;b&quot;, &quot;c&quot;}&gt;&gt;&gt; y = {&quot;c&quot;, &quot;d&quot;, &quot;e&quot;}&gt;&gt;&gt; z = {&quot;f&quot;, &quot;g&quot;, &quot;c&quot;}&gt;&gt;&gt; x.intersection(y,z){'c'} [3] &gt;&gt;&gt;&gt; set.issubset(set) &amp;&amp; set.issuperset(set) issubset() 方法用于判断集合的所有元素是否都包含在指定集合中，如果是则返回 True，否则返回 False。即判断是否为子集关系。 12345&gt;&gt;&gt; x = {&quot;a&quot;, &quot;b&quot;, &quot;c&quot;}&gt;&gt;&gt; y = {&quot;f&quot;, &quot;e&quot;, &quot;d&quot;, &quot;c&quot;, &quot;b&quot;, &quot;a&quot;}&gt;&gt;&gt; z = x.issubset(y)&gt;&gt;&gt; print(z)True issuperset() 方法用于判断指定集合的所有元素是否都包含在原始的集合中，如果是则返回 True，否则返回 False。 12345&gt;&gt;&gt; x = {&quot;f&quot;, &quot;e&quot;, &quot;d&quot;, &quot;c&quot;, &quot;b&quot;, &quot;a&quot;}&gt;&gt;&gt; y = {&quot;a&quot;, &quot;b&quot;, &quot;c&quot;}&gt;&gt;&gt; z = x.issuperset(y)&gt;&gt;&gt; print(z)True 5）set.union(set1, set2…) union() 方法返回两个集合的并集，即包含了所有集合的元素，重复的元素只会出现一次。 123456&gt;&gt;&gt; x = {&quot;a&quot;, &quot;b&quot;, &quot;c&quot;}&gt;&gt;&gt; y = {&quot;f&quot;, &quot;d&quot;, &quot;a&quot;}&gt;&gt;&gt; z = {&quot;c&quot;, &quot;d&quot;, &quot;e&quot;}&gt;&gt;&gt; result = x.union(y, z)&gt;&gt;&gt; result{'b', 'c', 'f', 'a', 'd', 'e'} Frozenset 集合set 集合的不可变版本 &gt;&gt;&gt;&gt; frozenset 集合 set 集合是可变的，程序可以改变序列中的元素；frozenset 集合是不可变序列，程序不能改变序列中的元素。set 集合中所有能改变集合本身的方法，比如 remove()、discard()、add() 等，frozenset 都不支持；set 集合中不改变集合本身的方法，fronzenset 都支持。 我们可以在交互式编程环境中输入 dir(frozenset) 来查看 frozenset 集合支持的方法： 12&gt;&gt;&gt; dir(frozenset)['copy', 'difference', 'intersection', 'isdisjoint', 'issubset', 'issuperset', 'symmetric_difference', 'union'] 两种情况下可以使用 fronzenset： 当集合的元素不需要改变时，我们可以使用 fronzenset 替代 set，这样更加安全。 有时候程序要求必须是不可变对象，这个时候也要使用 fronzenset 替代 set。比如，字典（dict）的键（key）就要求是不可变对象。 程序演示: 1234567891011121314&gt;&gt;&gt; s = {'Python', 'C', 'C++'}&gt;&gt;&gt; fs = frozenset(['Java', 'Shell'])&gt;&gt;&gt; s_sub = {'PHP', 'C#'}# 向 set 集合中添加 frozenset&gt;&gt;&gt; s.add(fs)&gt;&gt;&gt; print('s =', s)s = {'C', frozenset({'Java', 'Shell'}), 'C++', 'Python'}# 向为 set 集合添加子 set 集合&gt;&gt;&gt; s.add(s_sub)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: unhashable type: 'set' 至此，关于 Python 基本数据类型的介绍已经完成，下面我们简单补充说明一下 Python 中的空值和不可变对象: 空值（None）空值是 Python 里一个特殊的值，用None表示。None 不能理解为 0、&quot;&quot; 等，因为 0 &amp;&amp; ‘“”‘ 是有意义的，而 None是一个特殊的空值。 1234&gt;&gt;&gt; None is []False&gt;&gt;&gt; None is &quot;&quot;False None 是一个对象，其数据类型为 NoneType，其对应的 bool 值为 false。好比 0 是一个对象，其类型为 int，其 bool 值为 false。 12&gt;&gt;&gt; type(None)&lt;class 'NoneType'&gt; None 是 NoneType 数据类型的唯一值（其他编程语言可能称这个值为 null、nil 或 undefined），也就是说，我们不能再创建其它 NoneType 类型的变量，但是可以将 None 赋值给任何变量。 None 常用于 assert、判断以及函数无返回值的情况。对于所有没有 return 语句的函数定义，Python 都会在末尾加上 return None，使用不带值的 return 语句（也就是只有 return 关键字本身），那么就返回 None。 可变、不可变对象前面我们说过，str 是不变对象，而 list 是可变对象。 对于可变对象，比如 list，对 list 进行操作，list 内部的内容是会变化的，比如： 1234&gt;&gt;&gt; list1 = ['c', 'b', 'a']&gt;&gt;&gt; list1.sort()&gt;&gt;&gt; list1['a', 'b', 'c'] 而对于不可变对象，比如 str，对 str 进行操作呢： 12345&gt;&gt;&gt; str1 = 'abc'&gt;&gt;&gt; str1.replace('a', 'A')'Abc'&gt;&gt;&gt; str1'abc' 虽然字符串有个replace()方法，也确实变出了'Abc'，但变量str1最后仍是'abc'，应该怎么理解呢？ 再来看： 123456&gt;&gt;&gt; str1 = 'abc'&gt;&gt;&gt; str2 = str1.replace('a', 'A')&gt;&gt;&gt; str1'abc'&gt;&gt;&gt; str2'Abc' 事实上，str1 是变量，而 'abc' 才是字符串对象！有些时候，我们经常说，对象 str1 的内容是 'abc'，但其实是指，str1 本身是一个变量，它指向的对象的内容才是 'abc'。 当我们调用 str1.replace('a', 'A') 时，实际上调用方法 replace 是作用在字符串对象 'abc' 上的，而这个方法虽然名字叫 replace，但却没有改变字符串 'abc' 的内容。相反，replace 方法创建了一个新字符串 'Abc' 并返回，如果我们用变量 str2 指向该新字符串，就容易理解了，变量 str1 仍指向原有的字符串 'abc'，但变量 str2 却指向新字符串 'Abc' 了。 所以，对于不变对象来说，调用对象自身的任意方法，也不会改变该对象自身的内容。相反，这些方法会创建新的对象并返回，这样，就保证了不可变对象本身永远是不可变的。而可变对象就不一定了。 关于 Python 中的可变和不可不对象内容的详细解读请参见：Python 中的可变对象和不可变对象。","link":"/2018/01/07/python-shu-ju-jie-gou-zhi-dict-and-set/"},{"title":"Python 数据结构之 List and Tuple","text":"关于 Python 基本数据类型，我们已经介绍了数字（Number）、字符串（String）。这一小节我们来看 Python 中的 元组（tuple）和列表（list）。 元组和列表都属于序列（Sequence），在开始介绍元组（tuple）和列表（list）之前我们需要先简单了解一下序列。 Python 中的序列序列是一系列数据元素的集合，是 Python 中最基本的一种数据结构。 序列中的每个元素都分配一个 数字（指元素的位置，或索引），第一个索引是 0，第二个索引是 1，依此类推。每个索引对应一个元素。 Python 包含 6 中内建的序列，包括列表、元组、字符串、Unicode 字符串、buffer 对象 和 xrange 对象。 对于序列，都可以使用以下操作： 索引 切片 加 乘 成员检查 计算序列的长度 取序列中的最大、最小值 你可以和我们前面介绍过的字符串（String）类型进行一一验证（都介绍过~~~）。 关于序列详细解读可以参见博文：Python 中的序列详解。 列表（List）List（列表） 是 Python 中使用最频繁的数据类型。 列表的创建和前面我们介绍过的数值（Number ）和字符串（str）类似，我们如何创建一个列表？提供三种方法： [1] &gt;&gt;&gt;&gt; 列表的标准创建格式： 只要把 逗号分隔的不同的数据元素（有序） 使用 方括号（“[]”）括起来就可以完成一个列表的定义，如下： 123&gt;&gt;&gt; classmates = ['Michael', 'Bob', 'Tracy']&gt;&gt;&gt; classmates['Michael', 'Bob', 'Tracy'] 但请注意，列表中的数据元素可以具有不同的数据类型（支持数字、字符串，甚至可以包含列表（所谓的列表嵌套），以及后续将要学习的元组、字典、集合等）： 123456 &gt;&gt;&gt; list1 = ['string test', 123.321, [1,2], {&quot;name&quot;:1,&quot;age&quot;:2}, (1,2,&quot;test&quot;)]&gt;&gt;&gt; list1['string test', 123.321, [1, 2], {'name': 1, 'age': 2}, (1, 2, 'test')]&gt;&gt;&gt; type(list1)&lt;class 'list'&gt; 注意：在实际使用列表时，虽然可以将不同类型的数据放入到同一个列表中，但通常情况下不这么做，同一列表中只放入同一类型的数据，这样可以提高程序的可读性。 空列表 &gt;&gt;&gt;&gt; 使用此方式创建列表时，列表中元素可以有多个，也可以一个都没有（空列表），例如： 123&gt;&gt;&gt; emptylist = []&gt;&gt;&gt; emptylist[] [2] &gt;&gt;&gt;&gt; list(Iterable) 内建函数创建列表： 除了使用 [] 创建列表外，Python 还提供了一个内置的函数 list(Iterable)，使用它可以将其它可迭代对象转换为列表类型。 关于 Python 中可迭代对象的说明请参见博文：Python 中的可迭代对象(Iterable)。 例如： 12345678910111213141516171819202122# 将字符串转换成列表：list1 = list(&quot;hello&quot;)print(list1)# 将元组转换成列表：tuple1 = ('Python', 'Java', 'C++', 'JavaScript')list2 = list(tuple1)print(list2)# 将字典转换成列表dict1 = {'a':100, 'b':42, 'c':9}list3 = list(dict1)print(list3)# 将区间转换成列表：range1 = range(1, 6)list4 = list(range1)print(list4)# 创建空列表list5 = list()print(list5) 运行结果如下 12345['h', 'e', 'l', 'l', 'o']['Python', 'Java', 'C++', 'JavaScript']['a', 'b', 'c'][1, 2, 3, 4, 5][] [3] &gt;&gt;&gt;&gt; 推导式方法创建列表： 除此之外，我们还可以使用 推导式方法 创建列表： 123&gt;&gt;&gt; list2 = [x for x in &quot;abcdefg&quot;]&gt;&gt;&gt; list2['a', 'b', 'c', 'd', 'e', 'f', 'g'] ======================================================== 实际情况下，第 2，3 中方法使用较多，尤其是通过 range() 函数可以快速初始化一个数字列表。 range() 函数常常和 Python 循环结构、推导式（后续会讲，这里先不涉及）一起使用，几乎能够创建任何需要的数字列表。 列表的删除对于已经创建的列表，如果不再使用，可以使用 del 关键字将其删除。 实际开发中并不经常使用 del 来删除列表，因为 Python 自带的垃圾回收机制会自动销毁无用的列表，即使开发者不手动删除，Python 也会自动将其回收。 del 关键字的语法格式为： 1del listname Python 删除列表实例演示： 12345678910&gt;&gt;&gt; intlist = [1, 45, 8, 34]&gt;&gt;&gt; print(intlist)[1, 45, 8, 34]&gt;&gt;&gt; del intlist&gt;&gt;&gt; print(intlist)Traceback (most recent call last): File &quot;C:\\Users\\xxxxx\\Desktop\\demo.py&quot;, line 4, in &lt;module&gt; print(intlist)NameError: name 'intlist' is not defined 序列支持的操作由于列表（List）属于 Python 的内建序列，故序列（seq）中包含的基本操作 List 也具有。例如：1.索引、2.切片、3.加、4.乘、5.成员检查、6.获取序列的长度、7.取序列中的最大、最小值。 列表索引和切片[1] &gt;&gt;&gt;&gt; 访问单个列表元素 列表中，可以用索引来访问 list 中每一个对应位置的元素。索引是从 0 开始的（-1 为从末尾的开始位置的逆向索引）： 1234567891011&gt;&gt;&gt; classmates = ['Michael', 'Bob', 'Tracy']&gt;&gt;&gt; len(classmates)3&gt;&gt;&gt; classmates[0]'Michael'&gt;&gt;&gt; classmates[1]'Bob'&gt;&gt;&gt; classmates[-1]'Tracy'&gt;&gt;&gt; classmates[-2]'Bob' 对于嵌套列表元素的特殊索引： 123456789&gt;&gt;&gt; list1 = ['str1', 'str2', ['list_element1', 'list_element2']]&gt;&gt;&gt; list1[0]'str1'&gt;&gt;&gt; list1[2]['list_element1', 'list_element2']&gt;&gt;&gt; list1[2][0]'list_element1'&gt;&gt;&gt; list1[2][1]'list_element2' 注意，当索引超出了 list 范围时，Python 会报一个 IndexError 错误，所以，要确保索引不要越界（超出列表的容量）。 1234&gt;&gt;&gt; classmates[3]Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;IndexError: list index out of range [2] &gt;&gt;&gt;&gt; 切片 与字符串的分割（切片）一样，我们可以通过[] 和 : 对列表进行切片操作，以获得列表中的多个元素对象： 1234567&gt;&gt;&gt; list1 = [5,6,7,8,9]&gt;&gt;&gt; print(list1[:])[5,6,7,8,9]&gt;&gt;&gt; print(list2[2:])[7,8,9]&gt;&gt;&gt; print(list2[2:4])[7,8] 和字符串一样，我们甚至可以指定切片的步长（不常用）： 123456&gt;&gt;&gt; classmates = ['Michael', 'Bob', 'Tracy']&gt;&gt;&gt; classmates[0:len(classmates):2]['Michael', 'Tracy']&gt;&gt;&gt; str = &quot;weqrqewrewq&quot;&gt;&gt;&gt; str[0:len(str):2]'wqqweq' 列表拼接（+）和重复（*）123456&gt;&gt;&gt; list1 = [1.0, 'welcome']&gt;&gt;&gt; list2 = [&quot;python&quot;, &quot;world&quot;]&gt;&gt;&gt; print(list1 * 3)[1.0, 'welcome', 1.0, 'welcome', 1.0, 'welcome']&gt;&gt;&gt; print(list1 + list2)[1.0, 'welcome', 'python', 'world'] 成员检查可用于判断数据元素（数据项）是否存在于列表中： 123456&gt;&gt;&gt; list1 = [1.0, 'welcome']&gt;&gt;&gt; list2 = [&quot;python&quot;, &quot;world&quot;]&gt;&gt;&gt; 'welcome' in list1True&gt;&gt;&gt; 'welcome' not in list2True 获取序列长度len(list) 方法可返回列表元素（数据项）对象个数，也称为列表的长度或容量。 123&gt;&gt;&gt; list1 = [1, 2.0, &quot;welcome&quot;, [1, 2, 3]]&gt;&gt;&gt; print(len(list1))4 max(list) &amp;&amp; min(list)max(list)方法用于返回列表元素中的最大值，min(list)方法用于返回列表元素中的最小值。 12345&gt;&gt;&gt; list1, list2 = ['Google', 'Baidu', '360'], [12, 100, 200]&gt;&gt;&gt; print (&quot;list1 最大元素值 : &quot;, max(list1))list1 最大元素值 : Google&gt;&gt;&gt; print (&quot;list2 最小元素值 : &quot;, min(list2))list2 最小元素值 : 12 注意，在获取列表最大或最小值时，必须保证列表元素对象类型一致。 1234567&gt;&gt;&gt; list1, list2 = ['Google', 'Baidu', '360'], [12, 100, &quot;200&quot;]&gt;&gt;&gt; print (&quot;list1 最大元素值 : &quot;, max(list1))list1 最大元素值 : Google&gt;&gt;&gt; print (&quot;list2 最小元素值 : &quot;, min(list2))Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: '&lt;' not supported between instances of 'str' and 'int' 列表类型转换前面，我们使用 list(Iterable) 内建函数来创建列表，使用它可以将其它可迭代对象转换为列表类型： 12345678910111213141516&gt;&gt;&gt; aTuple = (123.321, 'Google', 'Baidu', '360')&gt;&gt;&gt; list1 = list(aTuple)&gt;&gt;&gt; print (&quot;列表元素 : &quot;, list1)列表元素 : [123.321, 'Google', 'Baidu', '360']&gt;&gt;&gt; str=&quot;Hello World&quot;&gt;&gt;&gt; list2=list(str)&gt;&gt;&gt; print (&quot;列表元素 : &quot;, list2)列表元素 : ['H', 'e', 'l', 'l', 'o', ' ', 'W', 'o', 'r', 'l', 'd']&gt;&gt;&gt; set1 = {'a', 'b', 'c'}&gt;&gt;&gt; dict1 = {'a':1, 'b':2}&gt;&gt;&gt; list(set1)['b', 'a', 'c']&gt;&gt;&gt; list(dict1)['a', 'b'] 列表常用操作整理由于列表是一个可变的序列对象，实际开发中，经常需要对 Python 列表进行查找和更新操作，包括向列表中添加元素、修改表中元素、删除元素以及进行元素查找。 列表添加元素[1] &gt;&gt;&gt;&gt; 加法（列表连接） + 运算符可以将多个（同类型）序列连接起来，对于列表而言，相当于在第一个列表的末尾添加了另一个列表生成一个新的列表，原有的列表不会被改变： 12345678910&gt;&gt;&gt; language = [&quot;Python&quot;, &quot;C++&quot;, &quot;Java&quot;]&gt;&gt;&gt; birthday = [1991, 1998, 1995]&gt;&gt;&gt; info = language + birthday&gt;&gt;&gt; print(&quot;language =&quot;, language)language = ['Python', 'C++', 'Java']&gt;&gt;&gt; print(&quot;birthday =&quot;, birthday)birthday = [1991, 1998, 1995]&gt;&gt;&gt; print(&quot;info =&quot;, info)info = ['Python', 'C++', 'Java', 1991, 1998, 1995] 注意：+ 更多的是用来拼接列表，而且执行效率并不高，如果想在列表中插入元素，应该使用下面几个专门的方法。 [2] &gt;&gt;&gt;&gt; append（列表追加） append() 方法用于在列表的末尾追加一个新元素对象，该方法的语法格式如下： 1listname.append(obj) 注意，obj 表示到添加到列表末尾的数据，它可以是单个元素，也可以是列表、元组、集合、字典等。 1234&gt;&gt;&gt; list = ['Google', 'Baidu', '360', &quot;Google&quot;]&gt;&gt;&gt; list.append(&quot;Opera&quot;)&gt;&gt;&gt; print (&quot;更新后的列表 : &quot;, list)更新后的列表 : ['Google', 'Baidu', '360', 'Opera'] 为什么要强调单个元素 &gt;&gt;&gt;&gt; 1234567891011&gt;&gt;&gt; list1 = [1,2]&gt;&gt;&gt; list1.append(3)&gt;&gt;&gt; print(list1)[1,2,3]&gt;&gt;&gt; list1.append([4,5])&gt;&gt;&gt; print(list1)[1,2,3,[4,5]]# 下面添加了两个元素，会报错：&gt;&gt;&gt; list1.append(4,5)TypeError: append() takes exactly one argument (2 given) 可以看到，当追加元素对象为列表、元组时，会将它们视为一个整体，作为一个元素添加到列表中，从而形成包含列表和元组的新列表。 [3] &gt;&gt;&gt;&gt; extend（列表扩展） extend(iterable) 和 append(obj) 的不同之处在于：extend(iterable) 不会把可迭代对象视为一个整体，而是把它们包含的元素逐个从列表末尾添加到列表中。 这里 iterable 可以是字符串、列表、元组、集合、字典等。若为字典，则仅会将键（key）作为元素依次添加至原列表的末尾。 12345&gt;&gt;&gt; list1 = ['Google', 'Baidu', '360']&gt;&gt;&gt; list2 = list(range(5))&gt;&gt;&gt; list1.extend(list2)&gt;&gt;&gt; print(&quot;扩展后的列表:&quot;,list1)扩展后的列表: ['Google', 'Baidu', '360', 0, 1, 2, 3, 4] | &gt;&gt;&gt;&gt; ============================================================= 深入理解列表中的 +、extend()、append() &gt;&gt;&gt;&gt; + 可以生成一个新的列表，而 extend(iterable) 和 append(obj) 是在原列表的基础上操作的，不会生成新的列表，无返回值（None）。 12345678910111213141516171819# 定义一个包含多个类型的 listlist1 = [1, 4, 3.4, &quot;yes&quot;, [1,2]]print(list1, id(list1))print(&quot;{:*^20}&quot;.format(&quot;1&quot;))# 比较 list 中添加元素的几种方法的用法和区别list3 = [6,7]l2 = list1 + list3print(l2,id(l2))print(&quot;{:*^20}&quot;.format(&quot;2&quot;))l2 = list1.extend(list3)print(l2,id(l2))print(list1,id(list1))print(&quot;{:*^20}&quot;.format(&quot;3&quot;))l2 = list1.append(list3)print(l2,id(l2))print(list1,id(list1)) 输出结果为： 123456789[1, 4, 3.4, 'yes', [1, 2]] 140201757210184*********1**********[1, 4, 3.4, 'yes', [1, 2], 6, 7] 140201757213064*********2**********None 140201780587376[1, 4, 3.4, 'yes', [1, 2], 6, 7] 140201757210184*********3**********None 140201780587376[1, 4, 3.4, 'yes', [1, 2], 6, 7, [6, 7]] 140201757210184 可以看到，+ 可以生成一个新列表，而 extend()、append() 是没有返回值（NoneType），所以千万不能放在等式的右侧（无意义），这是编程时常犯的错误，一定要引起注意！！！ ============================================================= &lt;&lt;&lt;&lt; | [4] &gt;&gt;&gt;&gt; insert（插入元素） 前面提到的，append() 和 extend() 方法只能在列表末尾插入元素，如果希望在列表中间某个位置插入元素，可以使用 insert(index, obj) 方法（插入的是元素对象）： 1listname.insert(index , obj) 其中，index 表示指定位置的索引值。insert() 会将 obj 元素对象插入到 listname 列表第 index 个元素的位置（相当于其它元素对象后移）。 12345678910&gt;&gt;&gt; list4 = ['Python', 'C++', 'Java']&gt;&gt;&gt; id(list4[1])1961084417456&gt;&gt;&gt; list4.insert(1, 'C')&gt;&gt;&gt; list4['Python', 'C', 'C++', 'Java']&gt;&gt;&gt; id(list4[1])1961052167280&gt;&gt;&gt; id(list4[2])1961084417456 当插入列表或者元祖时，insert() 也会将它们视为一个整体，作为一个元素插入到列表中，这一点和 append() 是一样的。 12345678&gt;&gt;&gt; list4.insert(2, ['C#', 'JavaScript'])&gt;&gt;&gt; list4['Python', 'C', ['C#', 'JavaScript'], 'C++', 'Java']&gt;&gt;&gt; lt5 = list4.insert(1, &quot;test&quot;)&gt;&gt;&gt; lt5&gt;&gt;&gt; list4['Python', 'test', 'C', ['C#', 'JavaScript'], 'C++', 'Java']&gt;&gt;&gt; 注意，和 extend()、append() 方法一样，insert() 也是没有返回值（NoneType），所以不要放在等式的右侧（无意义）。如果希望在列表的末尾追加元素，更建议使用 append() 和 extend()（insert() 不高效，）。 列表删除元素Python 列表中删除元素主要分为以下 3 种场景： 根据目标 元素所在位置的索引 进行删除，可以使用 del 关键字或者 pop() 方法； 根据 元素本身的值 进行删除，可使用列表（list类型）提供的 remove() 方法； 将列表中 所有元素全部删除，可使用列表（list类型）提供的 clear() 方法。 [1] &gt;&gt;&gt;&gt;&gt; 根据元素索引删除元素 1）–&gt; del del 可以删除列表中的单个元素，格式为： 1del listname[index] 例如： 123456789lang = [&quot;Python&quot;, &quot;C++&quot;, &quot;Java&quot;, &quot;PHP&quot;, &quot;Ruby&quot;, &quot;MATLAB&quot;]# 使用正数索引del lang[2]print(lang)# 使用负数索引del lang[-2]print(lang) del 也可以删除中间一段连续的元素，格式为： 1del listname[start : end] 其中，start 表示起始索引，end 表示结束索引。del 会删除从索引 start 到 end 之间的元素，不包括 end 位置的元素（前闭后开）。 例如： 12345678lang = [&quot;Python&quot;, &quot;C++&quot;, &quot;Java&quot;, &quot;PHP&quot;, &quot;Ruby&quot;, &quot;MATLAB&quot;]del lang[1: 4]print(lang)lang.extend([&quot;SQL&quot;, &quot;C#&quot;, &quot;Go&quot;])del lang[-5: -2]print(lang) | &gt;&gt;&gt;&gt; ============================================================= 深入理解列表中的 del &gt;&gt;&gt;&gt; 一定要搞清楚 –&gt; 删除的到底是变量还是数据？: 1234567891011121314&gt;&gt;&gt; #定义一个包含多个类型的 list&gt;&gt;&gt; list1 = [1,4,3.4,&quot;yes&quot;,[1,2]]&gt;&gt;&gt; list2 = list1&gt;&gt;&gt; print(id(list2),id(list1))1765451922248 1765451922248&gt;&gt;&gt; del list1&gt;&gt;&gt; print(list2)[1, 4, 'hello', 3.4, 'yes', [1, 2]]&gt;&gt;&gt; print(list1)Traceback (most recent call last): File &quot;C:\\Users\\mengma\\Desktop\\demo.py&quot;, line 8, in &lt;module&gt; print(list1)NameError: name 'list1' is not defined 另外，在实际过程中，即便使用 del 关键字删除了指定变量，且该变量所占用的内存再没有其他变量使用，此内存空间也不会真正地被系统回收并进行二次使用，它只是会被标记为无效内存。 如果想让系统回收这些可用的内存，需要借助 GC 库中的 collect() 函数。例如： 1234567891011&gt;&gt;&gt; import gc&gt;&gt;&gt; list1 = [1, 2, 3, 4, &quot;yes&quot;]&gt;&gt;&gt; del list1&gt;&gt;&gt; list1Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;NameError: name 'list1' is not defined&gt;&gt;&gt; gc.collect()0 Python 中具有缓存重用机制，系统为了提升性能，会将一部分变量驻留在内存中。这个机制对于，多线程并发时程序产生大量占用内存的变量无法得到释放，或者某些不再需要使用的全局变量占用着大的内存，导致后续运行中出现内存不足的情况，此时就可以使用 del 关键字来回收内存，使系统的性能得以提升。同时，它可以为团队省去扩充大量内存的成本。 ============================================================= &gt;&gt;&gt;&gt; | 2）–&gt; pop([index=-1]) Python pop(index) 方法用来删除列表中指定索引处的元素，具体格式如下： 1listname.pop(index=-1) 其中，如果指定 index 参数，默认会删除列表中的最后一个元素，类似于数据结构中的 “出栈” 操作。 用法举例： 1234567891011&gt;&gt;&gt; list1 = ['Google', 'Baidu', '360']&gt;&gt;&gt; list1.pop()'360'&gt;&gt;&gt; print (&quot;列表现在为 : &quot;, list1)列表现在为 : ['Google', 'Baidu']&gt;&gt;&gt; &gt;&gt;&gt; list2 = list1.pop(1)&gt;&gt;&gt; print (&quot;列表现在为 : &quot;, list1)列表现在为 : ['Google']&gt;&gt;&gt; list2'Baidu' pop() 函数有返回值，意味着 “出栈” 元素是可获取。 大部分编程语言都会提供和 pop() 相对应的方法，就是 push()，该方法用来将元素添加到列表的尾部，类似于数据结构中的“入栈”操作。但是 Python 是个例外，Python 并没有提供 push() 方法，因为完全可以使用 append() 来代替 push() 的功能。 [2] &gt;&gt;&gt;&gt;&gt; 根据元素值删除元素 remove(obj) 函数可用于移除列表中某个值的第一个匹配项。而且必须保证该元素是存在的，否则会引发 ValueError 错误。 123456789101112&gt;&gt;&gt; list1 = ['Google', 'Baidu', '360', &quot;Google&quot;]&gt;&gt;&gt; list1.remove(&quot;Google&quot;)&gt;&gt;&gt; print (&quot;列表现在为 : &quot;, list1)列表现在为 : ['Baidu', '360', 'Google']&gt;&gt;&gt; list1.remove(&quot;Google&quot;)&gt;&gt;&gt; print (&quot;列表现在为 : &quot;, list1)列表现在为 : ['Baidu', '360']&gt;&gt;&gt; list1.remove(&quot;Google&quot;)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;ValueError: list.remove(x): x not in list remove(obj) 函数无返回值，可用来进行列表元素对象过滤。 [3] &gt;&gt;&gt;&gt;&gt; 删除列表所有元素 clear() 函数可用于删除列表的所有元素（清空列表），类似于 **del a[:]**。 1234&gt;&gt;&gt; list = ['Google', 'Baidu', '360']&gt;&gt;&gt; list.clear()&gt;&gt;&gt; print(&quot;清空后的列表：&quot;,list)清空后的列表： [] 列表修改元素Python 提供了两种修改列表（list）元素的方法，你可以每次修改单个元素，也可以每次修改一组元素（多个）。 [1] &gt;&gt;&gt;&gt;&gt; 修改单个元素 修改单个元素非常简单，直接对元素进行赋值即可： 12345678&gt;&gt;&gt; list = ['Google', 'Baidu', '360', 999]&gt;&gt;&gt; print (&quot;第三个元素为 : &quot;, list[2])第三个元素为 : 360&gt;&gt;&gt; list[3] = 1999&gt;&gt;&gt; print (&quot;更新后的第三个元素为 : &quot;, list[2])更新后的第三个元素为 : 360&gt;&gt;&gt; print(list)&gt;&gt;&gt; ['Google', 'Baidu', '360', 1999] [2] &gt;&gt;&gt;&gt;&gt; 修改一组元素 Python 支持通过切片（slice）语法给一组元素赋值，并且是一组值（单个值会报错）。 1234nums = [40, 36, 89, 2, 36, 100, 7]# 修改第 1~4 个元素的值（不包括第4个元素）nums[1: 4] = [45.25, -77, -52.5]print(nums) 如果对空切片（slice）赋值，就相当于插入一组新的元素： 1234nums = [40, 36, 89, 2, 36, 100, 7]# 在 4 个位置插入元素nums[4: 4] = [-77, -52.5, 999]print(nums) 注意，如果不指定步长（step 参数），Python 就不要求新赋值的元素个数与原来的元素个数相同；这意味，该操作既可以为列表添加元素，也可以为列表删除元素。 123456789&gt;&gt;&gt; nums = [40, 36, 89, 2, 36, 100, 7]&gt;&gt;&gt; nums[1:4] = 77Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: can only assign an iterable&gt;&gt;&gt; nums[1:4] = [77, 1]&gt;&gt;&gt;&gt; nums[40, 77, 1, 36, 100, 7] 列表查找元素Python 列表（list）提供了 index() 和 count() 方法，它们都可以用来查找元素。 [1] &gt;&gt;&gt;&gt;&gt; 元素数目查询 count() 方法用来统计某个元素在列表中出现的次数，基本语法格式为： 1listname.count(obj) 其中，obj 表示要统计的元素对象。如果 count() 返回 0，就表示列表中不存在该元素，所以 count() 也可以用来判断列表中的某个元素是否存在。 123456789101112&gt;&gt;&gt; nums = [40, 36, 89, 2, 36, 100, 7, -20.5, 36]&gt;&gt;&gt; # 统计元素出现的次数&gt;&gt;&gt; print(&quot;36 出现了 %d 次&quot; % nums.count(36))36 出现了 3 次&gt;&gt;&gt; # 判断一个元素是否存在&gt;&gt;&gt; if nums.count(100):&gt;&gt;&gt; print(&quot;列表中存在 100 这个元素&quot;)&gt;&gt;&gt; else:&gt;&gt;&gt; print(&quot;列表中不存在 100 这个元素&quot;)列表中存在 100 这个元素 [2] &gt;&gt;&gt;&gt;&gt; 元素索引查询 list.index() 函数可以用于从列表中找出某个值第一个匹配项的索引位置，如果没有找到对象则抛出异常。所以在查找之前最好使用 count() 方法或者 in &amp;&amp; not in 判断一下是否存在。 index() 的语法格式为： 1listname.index(obj, start, end) 其中，obj 表示要查找的元素，并且你可以限定查找范围：start 表示起始位置，end 表示结束位置。 1234567&gt;&gt;&gt; list = ['Google', 'Baidu', '360']&gt;&gt;&gt; list.index(&quot;Baidu&quot;)1&gt;&gt;&gt; list.index(&quot;Opera&quot;)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;ValueError: 'Opera' is not in list 其它常用操作[1] &gt;&gt;&gt;&gt;&gt; list.reverse() reverse(list) 函数用于反向列表中元素。没有返回值，但是会对列表的元素进行反向排序。 1234&gt;&gt;&gt; list = ['Google', 'Baidu', '360']&gt;&gt;&gt; list.reverse()&gt;&gt;&gt; print (&quot;列表反转后: &quot;, list)列表反转后: ['360', 'Baidu', 'Google'] 这里还可以使用序列中的内置函数 reversed(seq)，其功能是对于给定的序列（包括列表、元组、字符串以及 range(n) 区间），该函数可以返回一个逆序序列的迭代器（用于遍历该逆序序列）。 反向遍历列表的方法（不影响原列表） &gt;&gt;&gt;&gt; 12345678910111213list1 = [1, 2, 3, 4]# Method 1:for item in list1[::-1]: print(item)# Method 2:for item in range(len(list1) - 1, -1, -1): print(list1[item])# Method 3:for item in reversed(list1): print(item) 但还是尽量使用迭代器吧，数据量很大的时候不用迭代器的话有可能会占用过多的内存。 [2] &gt;&gt;&gt;&gt;&gt; list.sort( key=None, reverse=False) sort() 函数用于对原列表进行排序。该方法没有返回值，但是会对列表的对象进行排序。参数说明： key：指定用来进行比较的元素。取自于可迭代对象中，指定可迭代对象中的哪一个元素来进行排序。 reverse：定义排序规则，reverse = True 降序， reverse = False 升序（默认）。 12345678910111213141516171819&gt;&gt;&gt; list = [1, 2, 3, 4]&gt;&gt;&gt; list.sort()&gt;&gt;&gt; print ( &quot;List : &quot;, list)List : [1, 2, 3, 4]&gt;&gt;&gt; list.sort(reverse=True)&gt;&gt;&gt; print ( &quot;List : &quot;, list)List : [4, 3, 2, 1]# 获取列表的第二个元素&gt;&gt;&gt; def takeSecond(elem):... return elem[1]...&gt;&gt;&gt; # 列表&gt;&gt;&gt; random = [(2, 2), (3, 4), (4, 1), (1, 3)]# 指定第二个元素排序&gt;&gt;&gt; random.sort(key=takeSecond)# 输出类别&gt;&gt;&gt; print ('排序列表：', random)排序列表： [(4, 1), (2, 2), (1, 3), (3, 4)] [3] &gt;&gt;&gt;&gt;&gt; list.copy() copy() 函数用于复制列表（深、浅拷贝混合），返回复制后的新列表。 1234567891011&gt;&gt;&gt; list1 = ['Google', (1,2), [1, 2]]&gt;&gt;&gt; list2 = list1.copy()&gt;&gt;&gt; print(&quot;List2：&quot;,list2)List2： ['Google', 'Baidu', '360']&gt;&gt;&gt; print(id(list1), id(list2))1961085147392 1961085159808&gt;&gt;&gt; print(id(list1[1]), id(list2[1]))1961084342016 1961084342016&gt;&gt;&gt; print(id(list1[1][1]), id(list2[1][1]))140724350033696 140724350033696 Python 中栈和队列的实现我们知道，队列（Queue [kju]）和栈（Stack）是两种数据结构，其内部都是按照固定顺序来存放变量的，二者的区别在于对数据的存、取顺序： 队列是，先存入的数据最先取出，即“先进先出”； 栈是，最后存入的数据最先取出，即“后进先出”。 List 实现栈和队列Python 中list 类型数据本身的存放就是有顺序的，而且内部元素又可以是各不相同的类型，非常适合用于队列和栈的实现。 [1] &gt;&gt;&gt;&gt; List 实现队列 使用 list 列表模拟队列功能的实现方法是：定义一个 list 变量，存入数据时使用 insert() 方法，设置其第一个参数为 0，即表示每次都从最前面插入数据；读取数据时，使用 pop() 方法，即将队列的最后一个元素弹出。 如此 list 列表中数据的存取顺序就符合 “先进先出” 的特点。实现代码如下： 123456789101112# 定义一个空列表，当做队列queue = []# 向列表中插入元素queue.insert(0,1)queue.insert(0,2)queue.insert(0,&quot;hello&quot;)print(queue)print(&quot;取一个元素：&quot;,queue.pop())print(&quot;取一个元素：&quot;,queue.pop())print(&quot;取一个元素：&quot;,queue.pop()) [2] &gt;&gt;&gt;&gt; List 实现栈 使用 list 列表模拟栈功能的实现方法是，使用 append() 方法存入数据；使用 pop() 方法读取数据。 如此 list 列表中数据的存取顺序就符合“先进先出”的特点。实现代码如下： 1234567891011# 定义一个空 list 当做栈stack = []stack.append(1)stack.append(2)stack.append(&quot;hello&quot;)print(stack)print(&quot;取一个元素：&quot;,stack.pop())print(&quot;取一个元素：&quot;,stack.pop())print(&quot;取一个元素：&quot;,stack.pop()) collections 实现栈和队列List 中实现队列的方法中，插入数据的部分是通过 insert() 方法实现的，这种方法效率并不高，因为每次从列表的开头插入一个数据，列表中所有元素都得向后移动一个位置。 一个相对更高效的方法，即使用标准库的 collections 模块中的 deque（double-end queue） 结构体，它被设计成在两端存入和读取都很快的特殊 list，可以用来实现栈和队列的功能。 举个例子： 1234567891011121314queueAndStack = deque()queueAndStack.append(1)queueAndStack.append(2)queueAndStack.append(&quot;hello&quot;)print(list(queueAndStack))#实现队列功能，从队列中取一个元素，根据先进先出原则，这里应输出 1print(queueAndStack.popleft())#实现栈功能，从栈里取一个元素，根据后进先出原则，这里应输出 helloprint(queueAndStack.pop())#再次打印列表print(list(queueAndStack)) 元组（Tuple）元组与列表是非常类似的（序列），区别在于元组的元素值不能修改（不可变数据类型），元组是放在括号中，列表是放于方括号中。 元组的创建Python 提供了两种创建元组的方法： [1] &gt;&gt;&gt;&gt; 元组的标准创建格式： 元组创建也很简单，只需要在小括号中添加元素（数据项），并使用逗号隔开即可： 1234&gt;&gt;&gt; tup1 = ('Google', 'Baidu', '360')&gt;&gt;&gt; tup2 = 'welcome', 'python', 'world', 1996, 123.321;&gt;&gt;&gt; type(tup2)&lt;class 'tuple'&gt; 注意，当元组中 只包含一个元素 时，需要在元素后面添加逗号，否则括号会被当作运算符使用： 1234567&gt;&gt;&gt;tup1 = (50)&gt;&gt;&gt; type(tup1) # 不加逗号，类型为整型&lt;class 'int'&gt; &gt;&gt;&gt; tup1 = (50,)&gt;&gt;&gt; type(tup1) # 加上逗号，类型为元组&lt;class 'tuple'&gt; 同理，元组中的元素类型也可以是不同的数据类型（数字类型、字符串、元组、列表、字典等）： 123&gt;&gt;&gt; tuple1 = ('tuple test', 123.321, [1,2], {&quot;name&quot;:1,&quot;age&quot;:2}, (1,2,&quot;test&quot;))&gt;&gt;&gt; print(type(tuple1), tuple1)&lt;class 'tuple'&gt; ('tuple test', 123.321, [1, 2], {'name': 1, 'age': 2}, (1, 2, 'test')) 不规范写法 &gt;&gt;&gt;&gt; Python 中，元组通常都是使用一对小括号将所有元素包围起来的，但小括号不是必须的，只要将各元素用逗号隔开，Python 就会将其视为元组: 123&gt;&gt;&gt; tup1 = '123', '456'&gt;&gt;&gt; print(tup1, type(tup1))('123', '456') &lt;class 'tuple'&gt; 空元组 &gt;&gt;&gt;&gt; 123&gt;&gt;&gt; tup1 = ()&gt;&gt;&gt; type(tup1)&lt;class 'tuple'&gt; [2] &gt;&gt;&gt;&gt; tuple(Iterable) 内建函数创建列表： 除了使用 () 创建列表外，Python 还提供了一个内置的函数 tuple(Iterable)，使用它可以将其它可迭代对象转换为元组类型。 关于 Python 中可迭代对象的说明请参见博文：Python 中的可迭代对象(Iterable)。 使用示例： 12345678910111213141516171819202122232425# 将字符串转换成元组tup1 = tuple(&quot;hello&quot;)print(tup1)# 将列表转换成元组list1 = ['Python', 'Java', 'C++', 'JavaScript']tup2 = tuple(list1)print(tup2)# 将字典转换成元组dict1 = {'a':100, 'b':42, 'c':9}tup3 = tuple(dict1)print(tup3)# 将区间转换成元组range1 = range(1, 6)tup4 = tuple(range1)print(tup4)# 将推导式转换成元组tup5 = tuple(x for x in &quot;abcdefgh&quot;)print(tup4)# 创建空元组print(tuple()) 运行结果如下： 12345('h', 'e', 'l', 'l', 'o')('Python', 'Java', 'C++', 'JavaScript')('a', 'b', 'c')(1, 2, 3, 4, 5)() 序列支持的操作由于元组（tuple）属于 Python 的内建序列，故序列（seq）中包含的基本操作 tuple也具有。例如：1.索引、2.切片、3.加、4.乘、5.成员检查、6.获取序列的长度、7.取序列中的最大、最小值等。 –&gt; 字符串和元组 相较于列表，字符串（str）可执行操作要更接近于元组（tuple），这是由于两者都是属于不可变数据类型导致。但是我们要注意，尽管 tuple 元素不可改变，但它可以包含可变对象，比如列表、字典等。 Python 中的元组是一个不可变对象，所以所有修改和生成元组的操作的实现方法，都是在另一个内存片段中生成一个新字符串对象。 元组索引和切片[1] &gt;&gt;&gt;&gt; 访问单个元组元素 类似于列表，元组中，可以用索引来访问 list 中每一个对应位置的元素。索引是从 0 开始的（-1 为从末尾的开始位置的逆向索引）： 1234567891011&gt;&gt;&gt; website = ('Google', 'Baidu', '360')&gt;&gt;&gt; len(website)3&gt;&gt;&gt; website[0]'Google'&gt;&gt;&gt; website[1]'Baidu'&gt;&gt;&gt; website[-1]'360'&gt;&gt;&gt; website[-2]'Baidu' 对于嵌套元组索引： 1234567&gt;&gt;&gt; tup1 = ('str1', 'str2', ['list_element1', 'list_element2'])&gt;&gt;&gt; tup1[0]'str1'&gt;&gt;&gt; tup1[2][0]'list_element1'&gt;&gt;&gt; tup1[2][1]'list_element2' 注意，当索引超出了 tuple 范围时，Python 会报一个IndexError错误，所以，要确保索引不要越界。 1234&gt;&gt;&gt; website[3]Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;IndexError: tuple index out of range [2] &gt;&gt;&gt;&gt; 切片 与列表的分割（切片）一样，我们同样可以通过[] 和 :对元组进行切片操作： 123&gt;&gt;&gt; website = ('Google', 'Baidu', '360')&gt;&gt;&gt; website[0:len(classmates)]('Google', 'Baidu', '360') 和字符串一样，我们甚至可以指定切片的步长： 12345&gt;&gt;&gt; website = ('Google', 'Baidu', '360')&gt;&gt;&gt; website[0:len(classmates):1]('Google', 'Baidu', '360')&gt;&gt;&gt; website[0:len(classmates):2]('Google', '360') 元组拼接（+）和重复（*）123456&gt;&gt;&gt; tup1 = (1.0, 'welcome')&gt;&gt;&gt; tup2 = (&quot;python&quot;, &quot;world&quot;)&gt;&gt;&gt; print(tup1 * 3)(1.0, 'welcome', 1.0, 'welcome', 1.0, 'welcome')&gt;&gt;&gt; print(tup1 + tup2)(1.0, 'welcome', 'python', 'world') 成员检查可用于判断数据元素（数据项）是否存在于列表中： 123456&gt;&gt;&gt; tup1 = (1.0, 'welcome')&gt;&gt;&gt; tup2 = (&quot;python&quot;, &quot;world&quot;)&gt;&gt;&gt; 'welcome' in tup1True&gt;&gt;&gt; 'welcome' not in tup2True 获取序列长度len(tuple) 方法可返回元组元素（数据项）个数，也称为元组的长度或容量。 123&gt;&gt;&gt; tup1 = ('Google', 'Baidu', '360')&gt;&gt;&gt; print(len(tup1))3 max(tuple) &amp;&amp; min(tuple)max(tuple)方法用于返回元组元素中的最大值，min(tuple)方法用于返回元组元素中的最小值。 12345&gt;&gt;&gt; tup1, tup2 = ('Google', 'Baidu', '360'), (12, 100, 200)&gt;&gt;&gt; print (&quot;tup1 最大元素值 : &quot;, max(tup1))tup1 最大元素值 : Google&gt;&gt;&gt; print (&quot;tup2 最小元素值 : &quot;, min(tup2))tup2 最小元素值 : 12 注意，在获取元组最大或最小值时，必须保证元组元素类型一致。 1234567&gt;&gt;&gt; tup1, tup2 = ('Google', 'Baidu', '360'), (12, 100, '200')&gt;&gt;&gt; print (&quot;tup1 最大元素值 : &quot;, max(tup1))tup1 最大元素值 : Google&gt;&gt;&gt; print (&quot;tup2 最小元素值 : &quot;, min(tup2))Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: '&lt;' not supported between instances of 'str' and 'int' 元组类型转换前面，我们使用 tuple(Iterable) 内建函数来创建列表，使用它可以将其它可迭代对象转换为列表类型： 1234567891011121314151617&gt;&gt;&gt; list1 = [123.321, 'Google', 'Baidu', '360']&gt;&gt;&gt; tup1 = tuple(list1)&gt;&gt;&gt; print (&quot;元组元素 : &quot;, tup1)元组元素 : (123.321, 'Google', 'Baidu', '360')&gt;&gt;&gt; str=&quot;Hello World&quot;&gt;&gt;&gt; tup2=tuple(str)&gt;&gt;&gt; print (&quot;元组元素 : &quot;, tup2)元组元素 : ('H', 'e', 'l', 'l', 'o', ' ', 'W', 'o', 'r', 'l', 'd')&gt;&gt;&gt; set1 = {'a', 'b', 'c'}&gt;&gt;&gt; dict1 = {'a':1, 'b':2}&gt;&gt;&gt; tuple(set1)('b', 'a', 'c')&gt;&gt;&gt; tuple(dict1)('a', 'b') 元组的更新与删除正如我们之前说的，和列表不同的是，tuple 是不可变数据类型，其元素值是不允许修改的。 所以，和字符串中一样，修改元组元素操作是非法的： 12345&gt;&gt;&gt; website = ('Google', 'Baidu', '360')&gt;&gt;&gt; website[2] = &quot;Opera&quot;Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: 'tuple' object does not support item assignment 同理，元组中的元素值是不允许删除的，但我们可以使用 del 语句来删除整个元组（引用）： 1234567891011&gt;&gt;&gt; website = ('Google', 'Baidu', '360')&gt;&gt;&gt; del website[2]Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: 'tuple' object doesn't support item deletion&gt;&gt;&gt; del website&gt;&gt;&gt; print(website)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;NameError: name 'website' is not defined “可变的” tuple ??? &gt;&gt;&gt;&gt; 但是我们要注意：尽管 tuple 元素不可改变，但它可以包含可变对象，比如 list、set、dict等。 先来给出一个样例： 12345&gt;&gt;&gt; tup1 = ('a', 'b', ['A', 'B'])&gt;&gt;&gt; tup1[2][0] = 'E'&gt;&gt;&gt; tup1[2][1] = 'F'&gt;&gt;&gt; print(tup1)('a', 'b', ['E', 'F']) 哎？之前不是说 tuple一旦定义后就不可变了吗？怎么后来又变了？ 表面上看，tuple 的元素确实变了，但其实变的不是 tuple 的元素，而是 list 的元素。tuple 一开始指向的 list 并没有改成别的 list。所以，tuple 所谓的“不变”是说，tuple 的每个元素，指向永远不变。即指向'a'，就不能改成指向'b'，指向一个 list，就不能改成指向其他对象，但指向的这个 list 本身是可变的！!! 深入了解 List &amp;&amp; Tuple这一小节内容可以解释为什么我们会将 List 和 Tuple 放在一篇博文里面阐述。 元组和列表同属序列类型，且都可以按照特定顺序存放一组数据，数据类型不受限制，只要是 Python 支持的数据类型就可以。 元组和列表最大的区别就是 &gt;&gt;&gt;&gt; 元组是一个不可变对象，而列表是一个可变对象 你可以理解为：tuple 元组是一个只读版本的 list 列表。 需要注意的是，这样的差异势必会反应到两者的存储方式上: [1] &gt;&gt;&gt;&gt; List 先研究一下 Python 中 List 的结构： 1234567891011121314151617typedef struct { PyObject_VAR_HEAD /* Vector of pointers to list elements. list[0] is ob_item[0], etc. */ PyObject **ob_item; /* ob_item contains space for 'allocated' elements. The number * currently in use is ob_size. * Invariants: * 0 &lt;= ob_size &lt;= allocated * len(list) == ob_size * ob_item == NULL implies ob_size == allocated == 0 * list.sort() temporarily sets allocated to -1 to detect mutations. * * Items must normally not be NULL, except during construction when * the list is not yet visible outside the function that builds it. */ Py_ssize_t allocated;} PyListObject; list 本质上是一个长度可变的连续数组。其中 ob_item 是一个指针列表，里边的每一个指针都指向列表中的元素（前面我们也提到过，索引指向的是相应对象元素的内存空间，或着说，它对应了元素对象的引用），而 allocated 则用于存储该列表目前已被分配的空间大小。 需要注意的是，allocated 和列表的实际空间大小不同，列表实际空间大小，指的是 len(list) 返回的结果，也就是上边代码中注释中的 ob_size，表示该列表总共存储了多少个元素。而在实际情况中，为了优化存储结构，避免每次增加元素都要重新分配内存，列表预分配的空间 allocated 往往会大于 ob_size。 因此 allocated 和 ob_size 的关系是：allocated &gt;= len(list) = ob_size &gt;= 0。 如果当前列表分配的空间已满（即 allocated == len(list)），则会向系统请求更大的内存空间，并把原来的元素全部拷贝过去。 对于 tuple，它是不可变的，意味着元组长度大小固定，且存储元素不可变，所以存储空间也是固定的。 [2] &gt;&gt;&gt;&gt; Tuple 再来看看 Python 中 tuple 的结构： 12345678typedef struct { PyObject_VAR_HEAD PyObject *ob_item[1]; /* ob_item contains space for 'ob_size' elements. * Items must normally not be NULL, except during construction when * the tuple is not yet visible outside the function that builds it. */} PyTupleObject; tuple 和 list 相似，本质也是一个数组，但是空间大小固定。 读者可能会问题，既然列表这么强大，还要元组这种序列类型干什么？!! 对比列表和元组存储方式的差异，可以引申出这样的结论，即元组要比列表更加轻量级，轻量级就意味着性能速度的提升。 我们知道，Python 会在后台，对静态数据做一些资源缓存（传送门）。通常来说，因为垃圾回收机制的存在，如果一些变量不被使用了，Python 就会回收它们所占用的内存，返还给操作系统，以便其他变量或其他应用使用。 但是对于一些静态变量（比如元组），如果它不被使用并且占用空间不大时，Python 会暂时缓存这部分内存。这样的话，当下次再创建同样大小的元组时，Python 就可以不用再向操作系统发出请求去寻找内存，而是可以直接分配之前缓存的内存空间，这样就能大大加快程序的运行速度。 [3] &gt;&gt;&gt;&gt; Tuple VS List 计算初始化一个相同元素的列表和元组分别所需的时间。我们可以看到，元组的初始化速度要比列表快 5 倍： 1234C:\\Users\\xxxxxx&gt;python -m timeit 'x=(1,2,3,4,5,6)'20000000 loops, best of 5: 9.97 nsec per loopC:\\Users\\xxxxxx&gt;python -m timeit 'x=[1,2,3,4,5,6]'5000000 loops, best of 5: 50.1 nsec per loop 当然，如果你想要增加、删减或者改变元素，那么列表显然更优。因为对于元组来说，必须得通过新建一个元组来完成。 元组确实没有列表那么多功能，但是元组依旧是很重要的序列类型之一，元组的不可替代性体现在以下这些场景中： 元组作为很多内置函数和序列类型方法的返回值存在，也就是说，在使用某些函数或者方法时，它的返回值会元组类型，因此你必须对元组进行处理; 元组比列表的访问和处理速度更快，因此，当需要对指定元素进行访问，且不涉及修改元素的操作时，建议使用元组; 元组可以在映射（和集合的成员）中当做“键”使用，而列表不行。 可变和不可变对象前面我们一直在说，元组（tuple）和列表（list）很相似，但元组是可变的，列表不可变。 关于 Python 中的可变和不可不对象内容解读参见：Python 中的可变对象和不可变对象。 当然，如果不理解的话，可以暂时将其当成一个黑箱子，学过集合和字典后再来看会更加顺利。","link":"/2018/01/06/python-shu-ju-jie-gou-zhi-list-and-tuple/"},{"title":"Visual Studio Code (VS Code) 你们都在用吗 ?","text":"Visual Studio Code（VS Code）是由微软推出的，一款同时支持 Windows 、 Linux 和 MacOS 等主流操作系统，且免费开源、功能强大而且非常好用的源代码（文本）编辑器，简称 VS Code。它的插件库中提供了丰富的插件支持，例如：代码 Debug，Git 版本控制，开发环境配置（代码补全、代码片段和代码重构等），远程服务器连接等等。 事实上，不用我安利，很多人都在说 VS Code 是全宇宙最好用的编辑器，无数个大言不惭的攻城狮，一开始尝试就无法“脱坑”。 博主在安装配置使用过程中查阅了网络上很多的相关博文，也遇到过很多问题，为了感谢学习过程中各位大佬的帮助以及分享给更多的新手使用，以作此文。文中如有表述不正确的地方，望各位大佬指正~~~ 更多 VS Code 相关内容，请关注博主 Visual Studio Code 博文系列： 之一 &gt;&gt;&gt; Visual Studio Code (VS Code) 你们都在用吗 ? 之二 &gt;&gt;&gt; 玩转 VSCode 之配置远程开发环境 之三 &gt;&gt;&gt; 玩转 VSCode 之配置 C/C++ 语言开发环境 之四 &gt;&gt;&gt; 玩转 VSCode 之配置 Python 语言开发环境 之五 &gt;&gt;&gt; 使用 VSCode 搭建一个惊人的 Markdown Editor VSCode SetupVisual Studio Code（VS Code）除了具有开源、免费，灵活的自定义配置，强大的调试功能以及丰富的插件扩展等特点之外，还提供良好的跨平台支持（Windows &amp; Linux &amp; Mac）： Visual Studio Code（VScode ）官网 &amp;&amp; Visual Studio Code（VScode ）GitHub 在 2019 年的 Stack Overflow 组织的开发者调研中，VS Code被认为是最受开发者欢迎的开发环境，据调查87317名受访者中有 50.7% 的受访者声称正在使用 VS Code。 话不多说，工欲善其事，必先利其器。你可以直接从 VS Code 官网下载站点（&gt;&gt;&gt; 传送门）获取到不同平台的安装包，界面如下： 这里，先贴出 VS Code 安装成功之后界面效果： 下面，我们分别给出 Windows &amp; Linux 平台下的 VS Code 的安装方法： For WindowsWindows 平台下 VSCode 的安装方法： Download见上文 VS Code 官网下载页面，Windows 下提供了三种可供下载版本： User Installer：会安装在当前计算机帐户目录，意味着如果使用另一个帐号登陆计算机将无法使用别人安装的 VSCode； System Installer：安装在非用户目录，例如 C 盘根目录，任何帐户都可以使用； .zip：免安装版本（主要使用以上两种安装方式）。 VSCode 默认提供的 User Installer 版本，大多数人都是用的这个版本。当然你也可以 System Installer 方式进行安装，过程类似。 SetupVSCode 在 Windows 下的安装非常简单，这里主要留意两点（其它默认即可）： 你可以选择将 VSCode 安装到指定的目录； 安装最后关于：添加到 PATH（重启后生效），默认是勾选上的，不用配置环境变量，可以直接使用。 For Linux接着，我们来看不同 Linux 平台下 VSCode 的安装步骤： For Debian &amp;&amp; Ubuntu对于 Debian &amp;&amp; Ubuntu 系统，VS Code 的安装很简单（推荐通过 .deb 包进行安装）。 Go Start &gt;&gt;&gt;&gt; 1 –&gt; Download DEB Package 例如，我的安装包下载目录为：~/Downloads。可以查看到，下载的安装包如下： 1234$ cd Downloads$ ls# 最新 VS Code “.deb” 包装包名称：code_1.38.1-1568209190_amd64.deb 2 –&gt; Begin To Setup Terminal 下执行如下指令： 12345678910111213$ sudo dpkg -i code_1.38.1-1568209190_amd64.deb# 安装过程中输出信息如下：Selecting previously unselected package code.(Reading database ... 227689 files and directories currently installed.)Preparing to unpack code_1.38.1-1568209190_amd64.deb ...Unpacking code (1.38.1-1568209190) ...Setting up code (1.38.1-1568209190) ...Processing triggers for gnome-menus (3.13.3-6ubuntu3.1) ...Processing triggers for desktop-file-utils (0.22-1ubuntu5.2) ...Processing triggers for bamfdaemon (0.5.3~bzr0+16.04.20180209-0ubuntu1) ...Rebuilding /usr/share/applications/bamf-2.index...Processing triggers for mime-support (3.59ubuntu1) ... 3 –&gt; Startup VSCode 上述安装过程完成后，你可以通过在 Terminal 中执行： 1$ code 即可成功打开 VS Code 编辑器窗口。 同样，你也可以通过在 Dash Home（Super）中搜索：VS ，即可查询到 Visual Studio Code 应用程序。 For Red Hat &amp;&amp; Fedora &amp;&amp; SUSE对于在 Red Hat &amp; Fedora &amp; SUSE（Centos）平台下，VS Code 的安装也非常简单，你可以通过 .rpm 包进行安装。 Go Start &gt;&gt;&gt;&gt; 1 –&gt; Download RPM Package 例如，我的安装包下载目录为：~/Downloads。可以查看到，下载的安装包如下： 12345$ cd Downloads$ ls# 最新 VS Code “.rpm” 包装包名称：code_1.38.1-1568209352.el7.x86_64.rpm 2 –&gt; Begin To Setup Terminal 下执行如下指令： 1234$ sudo yum -ivh install code_1.38.1-1568209352.el7.x86_64.rpm# 安装报错：缺少 libXss.so.1。可以先安装下面的包，再此尝试安装$ sudo yun install libXScrnSaver 3 –&gt; Test VSCode 在命令窗口，输入：“code –version”，查看已安装 VS Code 版本号： 1234$ code --version1.38.1b37e54c98e1a74ba89e03073e5a3761284e3ffb0x64 4 –&gt; Startup VSCode 上述安装过程完成后，你可以通过在 Terminal 中执行： 1$ code 即可成功打开 VS Code 编辑器窗口。 Extensible Plugin严格来说，VS Code 并不是一个 IDE（Integrated Development Environment），它 本质仅仅是一个文本编辑器，直接使用不利于源代码的编辑。 然而，VS Code 提供了丰富的插件扩展支持，而插件的使用也是 VS Code 能如此流行的一个重要原因。插件扩展可以帮我们实现类似于多语言切换、代码拼写检查、代码自动补全、主题等等实用功能。 如何安装插件？VSCode 中，插件的安装方法： 方法一 &gt;&gt; Ctrl + Shift + P 通过快捷键组合 Ctrl + Shift + P 打开 VS Code 命令面板，搜索关键字 extensions，然后选择下面的条目： 1Extensions：install Extensions 界面显示如下： 还有一种更简单的插件安装方法 &gt;&gt;&gt; 方法二 &gt;&gt; Ctrl + Shift + X（推荐） 直接通过快捷键组合 Ctrl + Shift + X 打开插件扩展商店（Extensions Marketplace），然后在搜索栏（Search Extensions in Marketplace）中，根据插件名称直接搜索想要的插件进行安装（如汉化插件：chinese），界面如下： 每个扩展插件的具体功能，都在插件扩展商店中的安装界面有介绍（如上图右侧）。 在如上插件扩展商店中搜索插件 chinese，在未安装 chinese 插件时搜索条目右下角显示 Install，此时表示当前插件未安装。一旦选择安装完成后，Install 会变成设置齿轮图标，你可以通过这里设置是否：启用、关闭，甚至卸载插件（你可以通过 chinese 插件尝试一下）。 | &gt;&gt; ================================== EXTENSIONS Marketplace ================================= &lt;&lt; | | &gt;&gt; 关于 EXTENSIONS Marketplace 工作区介绍： EXTENSIONS，提供如下的列表选项： INSTALLED：列表中包含已下载且安装的功能插件（可关掉，查看时在开启）； RECOMMENDED：列表中包含未安装，但推荐安装的插件； ENABLED：列表中包含已安装并且已启用相应功能插件； DISABLED：列表中包含已安装但未启用相应功能的插件。 插件合集推荐VS Code 官网提供了所有扩展插件的支持列表 &gt;&gt;&gt; 传送门。 下面我会给出一些常见的、基础的可扩展插件列表，所有的插件你都可以在插件扩展商店查看到其详细介绍： 基础配置类插件1 –&gt; Chinese (Simplified) Language Pack for Visual Studio Code 插件名称：中文（简体）语言包 新版 VSCode 的默认语言是英语，你可以通过在插件扩展商店中搜索 Chinese，安装中文（简体）语言包插件来扩展 VSCode 编辑器语言（汉化）： 安装配置好后，VSCode 会提醒你重启以使得配置生效，或者不改变语言（启动但不使用，这是允许的）。 插件安装后，可自由进行语言配置：【Ctrl+Shift+P &gt;&gt;&gt; configure &gt;&gt;&gt; Configure Display Language &gt;&gt;&gt; en(英文) 或 zg-cn(中文)】，这样就可以实现中英文自由切换了。 | &gt;&gt; =================================== 插件生效说明 =============================== &lt;&lt; | 后续我们还要安装一系列的插件， 但注意：一些插件安装好并且配置之后只有重启 VSCode 才会生效，而有些插件则可以立即生效。 万能方法：根据插件功能描述查看一下相应功能是否生效，否则重启 VSCode！！！ 2 –&gt; Code Runner Code Runner 被称为万能语言运行环境（提供数十种语言支持），Code Runner 插件可以让你一键运行各类代码，甚至时代码片段，非常适合学习或测试各种开发语言。 1# 支持的语言有: C, C++, Java, JavaScript, PHP, Python, Perl, Perl 6, Ruby, Go, Lua, Groovy, PowerShell, BAT/CMD, BASH/SH, F# Script, F# (.NET Core), C# Script, C# (.NET Core), VBScript, TypeScript, CoffeeScript, Scala, Swift, Julia, Crystal, OCaml Script, R, AppleScript, Elixir, Visual Basic .NET, Clojure, Haxe, Objective-C, Rust, Racket, Scheme, AutoHotkey, AutoIt, Kotlin, Dart, Free Pascal, Haskell, Nim, D, Lisp, Kit, V, SCSS, Sass, CUDA, Less, Fortran, Ring, 以及一些自定义命令 你可以通过搜索 Code Runner 进行安装： 还支持通过右键（Alt + Ctrl + N）即可编译运行单源码文件，快捷键 Ctrl + Alt + M 可以直接停止代码运行，快捷键 Ctrl + Alt + J 可以直接运行选中代码。 需要注意的是：相应语言的编译器或者解释器还是需要自行安装的，并且把路径添加到系统 PATH 环境变量中。 ================================= Problems Solution ================================= [1] &gt;&gt;&gt; 如何支持输入 &amp;&amp; 已设置 UTF-8 仍输出乱码 通过设置，可以将代码由 OUTPUT 放到 VS Code 内置的 Terminal 中运行，可以同时解决上述两个问题。 Solution：【Ctrl + ,】 &gt;&gt;&gt; 【Extensions】 &gt;&gt;&gt; 【Run Code configuration】 &gt;&gt;&gt; 勾选【Run In Terminal】，即可。 [2] &gt;&gt;&gt; 自定义 Code Runner 运行时逻辑 有些时候，我们希望可以自定义代码的运行逻辑。例如，C++ 的默认编译器用的是 g++，也许你希望使用 Clang，怎么办？？？ Solution：【Ctrl + ,】 &gt;&gt;&gt; 【Extensions】 &gt;&gt;&gt; 【Run Code configuration】 &gt;&gt;&gt; 【Code-runner:Executor Map】 &gt;&gt;&gt; 【Edit in settings.json】 &gt;&gt;&gt; 修改【code-runner.executorMap】属性中关于 c++ 的字段为你期望的自定义运行逻辑。 3 –&gt; Vscode-Icons 一个高效、易用的工作区界面对于编码是需要的，故你需要对一些不明了的显示效果做一些优化。 vscode-icons 插件可以实现 对各种文件类型的文件前的图标进行显示效果优化。这样，你可以直接通过文件的图标就可以快速直观的知道文件类型，而不用去区别文件后缀。 图标显示效果配置方法：【File &gt;&gt;&gt; Preferences &gt;&gt;&gt; File Icon Theme &gt;&gt;&gt; vscode-icons】 或者【[Ctrl + ,] &gt;&gt;&gt; 搜索 Icon Theme &gt;&gt;&gt; 下拉列表中选择 vscode-icons】，可实现项目文件图标显示效果的自由切换。 4 –&gt; KoroFileHeader 优秀的代码除了优秀的性能、规范的格式，注释也是不可或缺的，而且注释也应该有一套标准的注释方法。 KoroFileHeader（Star）能够一键给文件、函数加上注释，提供多种语言支持以及未定义语言的自定义支持等： 文件头部注释快捷键：Ctrl + Win + I，函数注释快捷键：Ctrl + Win + T（当然你可以通过 Ctrl + K + S 重新设置快捷键，但要注意不要冲突）。 文件头部注释 &amp;&amp; 函数注释配置方法 &gt;&gt;&gt;&gt; 打开用户设置【Ctrl + ,】 &gt;&gt;&gt;&gt; 搜索【Fileheader: Config Obj】 &gt;&gt;&gt;&gt; 打开【settings.json】 &gt;&gt;&gt;&gt; 在 &quot;fileheader.configObj&quot; 设置项前添加如下内容： 123456789101112131415161718// 文件头部注释通用格式：&quot;fileheader.customMade&quot;: { &quot;Author&quot;: &quot;git config user.name &amp;&amp; git config user.email&quot;, &quot;Date&quot;: &quot;Do not edit&quot;, &quot;LastEditors&quot;: &quot;git config user.name&quot;, &quot;LastEditTime&quot;: &quot;Do not edit&quot;, &quot;FilePath&quot;: &quot;Do not edit&quot;, &quot;Description&quot;: &quot;&quot;, &quot;custom_string_obkoro1_copyright&quot;: &quot;Copyright (c) ${now_year} by ${git_name} email: ${git_email}, All Rights Reserved. &quot;},// 文件函数注释通用格式：&quot;fileheader.cursorMode&quot;: { &quot;Description&quot;: &quot;&quot;, &quot;function&quot;: &quot;&quot;, &quot;param&quot;: &quot;&quot;, &quot;return&quot;: &quot;&quot;}, 详细设置方法，可参考 &gt;&gt;&gt; 传送门，进行你的自定义配置。 5 –&gt; Code Spell Checker 强烈推荐。对大部分非英语母语又不想写出四不像变量名的程序员来说，正确识记拼写各种单词还是有不小的挑战。 比模棱两可时需要去查在线词典不同的是，这款插件能实时的识别单词拼写是否有误，并给出提示（不少 Bug 都是因为拼写错误导致的）。 6 –&gt; Bracket Pair Colorizer 彩虹花括号插件，能够为圆括号，方括号和大括号提供彩虹色： VSCode 最新已集成彩虹花括号功能 &gt;&gt;&gt;&gt; 目前 VS Code 已经将 Bracket Pair Colorizer 的功能进行了集成，只需要在 settings 中查找 Bracket Pair Colorization 进行勾选即可启动相应功能。 7 –&gt; TabOut VSCode 会自动完成在你打左括号（或左引号）的时候自动完成右括号（或右引号），但在这个编辑状态下，却无法像其他编辑器一样通过按 Tab 自动跳出右括号（或右引号）。 这里提供一种 TabOut 插件，安装启动后自动实现上述功能： 8 –&gt; Indent-Rainbow 缩进显示效果优化 &gt;&gt;&gt;&gt; 用四种不同颜色交替着色文本前面的缩进： 9 –&gt; Filesize 在状态栏左下角中显示当前文件大小，点击后还可以看到详细创建、修改时间的插件： 10 –&gt; Path Intellisense 可自动填充文件名的插件： 11 –&gt; Todo Tree 维护时间稍长的代码仓库免不了会有各种 TODO、FIXME、XXX 之类的特殊注释标记。 Todo Tree 帮助你快速搜索（使用 ripgrep）你的工作区以获取 TODO 和 FIXME 等注释标记，并在资源管理器窗格的树视图中显示它们。 你可以通过单击树中的 TODO 快速打开文件并将光标移动到包含 TODO 的行上。 12 –&gt; Settings Sync 最好用的配置同步插件，没有之一。 Settings Sync 基于 GitHub Gist 实现 VSCode 用户配置、快捷键配置、已安装插件列表等的备份和恢复功能，配置过程有详细精确的操作步骤文档。 最新 VSCode 已提供账号设置同步方式 &gt;&gt;&gt;&gt; 目前 VS Code 已经提供了登录功能（可以替代 Settings Sync 功能），可以使用 Microsoft 或者 Github 账号进行登录，登录账号后提供如下设置同步： 13 –&gt; GitLens GitLens 把 VSCode 结合 Git 的使用体验优化到了极致，能让我们在不离开编辑器，不执行任何命令的情况下知晓光标所在位置代码的修改时间、作者信息等。 14 –&gt; Project Manager Project Manager 对于需要经常切换项目（或者不同语言项目）的场景，可以很容易的实现不同项目之间的快速切换。 15 –&gt; Remote SSH Remote-SSH 允许开发者将容器，远程计算机，或 Windows Subsystem for Linux (WSL) 作为完整的开发环境进行日常开发，调试。 详细使用说明可参见 &gt;&gt;&gt;&gt; 玩转 VSCode 之配置远程开发环境。 主题类插件长时间的编码，暗色调的编码环境更不容易让视力疲劳，可以让你更加专注。 这一小节来推荐几款经典、优美的主题来优化你的 VSCode 编辑器： 1 –&gt; One Dark Pro Atom 标志性的 One Dark Pro 主题，大概是 VS Code安装量最多的主题。你可以通过搜索 One Dark 进行安装： 2 –&gt; Night Owl 一个非常适合夜猫子的 VS Code 主题，为喜欢深夜编码的人精心设计的。你可以通过搜索 Night Owl 进行安装： 优化类插件1 –&gt; Background-cover Background-cover 可以为 VSCode 设置透明背景以及背景图片，提升逼格~~~ 安装好之后，你可以从右下角找到 switch background image 按钮进行图像以及透明度设置，还支持自动轮换背景图片等功能。 2 –&gt; Rainbow Fart Rainbow Fart 提醒您：你的女朋友来了~ 萌妹音彩虹屁，还需要鼓励师作甚？ 在 VSCode 的菜单栏中找到 【查看 –&gt; 命令面板】，或使用快捷键 Ctrl + Shift + P。 在 【命令面板】 中输入 &gt; 【Enable Rainbow Fart】 &gt; 【Enter】。 此时会弹出一个消息通知，点击通知上的 【Open】 按钮。 在打开的页面上点击授权。 安装成功，有着鼓励师优美的声音，代码敲的飞起不是梦！ 3 –&gt; Power Mode Power Mode 插件可以让你编写代码更加炫酷，尝试一下吧~ 4 –&gt; Draw.io Integration 说到在线绘图网站（流程图 &amp;&amp; 思维导图 &amp;&amp; UML …），你可以想到 Draw.io（&gt;&gt;&gt; 备用 传送门） &amp;&amp; ProcessOn。 一位来自德国前端工程师 Henning Dieterichs 成功将 Draw.io 的功能集成进了 VSCode，并打包成了插件（Draw.io Integration）供开发者下载使用，可以让你快速生成需要的图片，尝试一下吧~ 使用方法 &gt;&gt;&gt; 使用时只需要创建以 .drawio 为后缀的文件即可！！！ 多平台配置多重开发环境我们知道，VSCode 事实上只是一个文本编辑器，并不是 IDE（集成开发环境），自身是不含编译器（解释器）以及许多其它集成功能的。但 VSCode 提供丰富的插件扩展支持，通过插件安装可以极大提高你的编程效率，实现一个基于 VSCode 的轻量级 IDE。 故，配置 VSCode 多重开发环境就是组合安装配置多种语言相关插件以及相关语言工具库 的过程。 在开始配置多重开发环境之前，我们先需要了解一下 VS Code 中的项目管理机制（重点！！！）： VSCode 项目管理机制如果你使用过其它 IDE 的话，第一次打开 IDE 往往需要你创建第一个工程，创建完成之后该工程目录下会生成一个特殊的工程配置文件，这个工程文件中记录了 IDE 管理当前工程的元信息，包括这个项目中有哪些文件、项目的相关配置、构建脚本等等。 我们一直在强调，VS Code 仅仅是一个文本编辑器，它选择了一种轻量级的，相对容易理解的管理方式：所有的操作都是基于文件和文件夹。 也就是说，当你打开一个文件（文件夹）时，VSCode 的核心功能就会对这个文件（夹）进行分析，并提供相应的功能。例如，在打开的文件下检测到有 .git 文件，就自动加载 Git 插件来提供版本管理功能；当检测到有 .py 文件时，就会提醒你是否需要安装相应的 Python 语言插件等。 单项目管理和配置上面说了，VS Code 是基于文件（夹）来进行管理的，各个插件也会分析当前打开的文件夹。 你可能会疑惑 &gt;&gt;&gt;&gt; 是不是也意味着 VS Code 其实对项目没有任何管理和配置的能力呢？？？ 其实不然，VS Code 允许我们 创建 几个 跟当前文件夹（或者跟项目）有关的配置文件 保存在当前文件夹或项目目录中子一级 .vscode 文件夹中，但非必须（VS Code 绝大多数功能不需要配置文件也能生效，此时基于默认内置的用户配置文件）。将项目的设置放于 .vscode 文件夹中，便于和团队进行共享，可以将其称为 VSCode 项目自定义配置目录。 ========================================================================= “ .vscode 自定义配置目录” 中主要可包含以下配置文件 &gt;&gt;&gt;&gt; [1] &gt;&gt;&gt;&gt; 文件夹配置文件（settings.json） settings.json 文件的作用和格式，与前面插件配置中涉及到的 VS Code 用户设置几乎完全一样。唯一区别在于相关配置只有在 .vscode 自定义配置目录在 VS Code 中被打开才可以生效，否则使用的是 VSCode 默认的用户设置（User settings.json）。 也就是说，只有当前被打开的项目子一级目录下包含 .vscode 自定义配置文件夹，其 settings.json 配置文件才会生效，否则当前文件夹（项目目录）默认使用的是用户设置（User settings.json）。 区别于用户设置（User settings.json），.vscode\\settings.json 也称为 “文件夹（项目）设置”，只生效于包含了 .vscode 自定义配置文件夹的项目。 使用环境 &gt;&gt;&gt;&gt; 文件夹配置的存在，很好地解决了个人喜好和项目规范之间的冲突。 比如说我们编码时缩减喜欢用空格，而不是制表符，这样的话，在我们的个人设置（用户设置）里面就可以设置为永久使用空格。但是在 VS Code 打开的项目中，团队要求一定要都使用制表符，那我们就可以在 .vscode\\settings.json（文件夹设置） 中将这个配置写进去，而不是粗暴地要求每一位成员都去修改他们各自的配置文件。 [2] &gt;&gt;&gt;&gt; 调试环境配置文件（launch.json）&amp;&amp; 任务设置配置文件（tasks.json） 其中，调试环境配置文件（launch.json），用于配置项目的调试方式。而任务设置配置文件（tasks.json），是关于 VS Code 任务系统的配置文件。 把上述两个配置文件放在文件夹（.vscode）中甚至一并放入到代码仓库中，这样任何使用这个项目的工程师，都不用学习如何配置调试环境和配置任务系统就能运行项目代码了。 ========================================================================= 当然了，肯定也会有人不喜欢在代码仓库中出现编辑器相关的各种配置文件，不过也不用担心，你可以使用版本管理的忽略配置，将 .vscode 这个文件夹剔除在版本管理之外。那么，你就可以自己去控制跟这个项目相关的配置文件了。 多项目工作区管理与配置上面我们提到 VS Code 对于项目是基于文件夹进行管理的。而当用户需要同时操作不同的项目时，经常需要同时对多个文件夹下的代码进行操作。但是 VS Code 关于单个文件夹（单项目）的这种操作模式，要求了用户必须同时打开多个窗口，并不停地在它们之间切换。 多项目（文件夹）工作区 就是为了针对这个问题而实现的解决方案。下面来看如何创建一个可包含多个项目（多文件夹）的工作区： [1] &gt;&gt;&gt;&gt; Add Folder To Workspace 首先，在 VS Code 中打开某个项目文件夹，此时 VS Code 就处于我们上面介绍一个单文件夹的状态。 然后，调出命令面板【Ctrl + Alt + P】 &gt;&gt;&gt;&gt; 搜索【add folder to workspace】 &gt;&gt;&gt;&gt; 选择另一个想要在当前窗口添加的项目（文件夹） &gt;&gt;&gt;&gt; 【添加】。 此时，在资源管理器（Ctrl + Shift + E）的标题栏中，你可以看到【UNTITLED（WORKSPACE）】的标识，表示“无标题工作区”，并且可以看到已经可以同时管理两个项目（文件夹）了。只是现在你还没有保存这个多项目（文件夹）工作区，也没有给它指定一个名字（untitled）。 该命令可以自动的将当前打开的单文件夹，以及其它项目文件夹同时添加到创建的工作区当中。 [2] &gt;&gt;&gt;&gt; Save Workspace As 为 [1] 中创建的工作区进行命名以及存储，需要调出命令面板【Ctrl + Alt + P】 &gt;&gt;&gt;&gt; 搜索【save workspace as】，VS Code 会为工作区创建一个后缀名为 .code-workspace 的工作区文件（Json 格式），你可以将其存储到任意位置（也可以使用一个统一的仓库来管理 VSCode 工作区文件）。 假设我这里命名为：sample.code-workspace，打开后内容如下： 1234567891011{ &quot;folders&quot;: [ { &quot;path&quot;: &quot;FirstDemo&quot; }, { &quot;path&quot;: &quot;HelloPyDemo&quot; } ], &quot;settings&quot;: {}} JSON 文件，默认有两个键（key）。第一个是 folders（文件夹），它里面罗列的是这个多文件夹（项目）工作区里有哪些项目被组织，并且可以看出，项目地址是 sample.code-workspace 文件的相对路径；第二个是 settings（设置），也称为工作区设置，是专属于这个多文件夹工作区的设置，其作用和格式和用户设置以及文件夹设置类似。 注意：想要配置工作区设置（settings 字段）时，直接打开 sample.code-workspace 时会自动打开工作区，无法编辑工作区配置文件。方法一 &gt;&gt;&gt; 你需要通过 【Ctrl + ,】 打开设置 &gt;&gt;&gt; 选择【Workspace】 &gt;&gt;&gt; 任意打开【settings.json】 即可。方法二 &gt;&gt;&gt; 【Ctrl + Shift + P】 &gt;&gt;&gt; 搜索【Preferences: Open Workspace settings(JSON)】 即可。 此外，还提供两个可选的键，分别是：extensions 和 launch（见名知义），相信你可以猜出它是和什么相关的，后续章节用到时会进行介绍。 | ============================================ Split Line ============================================== | 事实上，VS Code 中的工作区是为了让你配置一个工作环境，让你更好地针对不同地环境（如 JAVA，C++，Python 等）设定不同地配置体验更好的 VSCode。同时，针对某一程序设计语言，可以为不同的工作区设置不同的语言版本，例如 Python2.X，Python3.X。 并且，对于同一工作区下的不同项目，你甚至可以分别为不同的项目设置不同的运行环境。例如，某个 Python 多项目工作区下，你可以根据不同的项目需要设置不同的 Python 虚拟环境，而你的工作区的环境可以是某个基础的 Python 解释器环境。 Settings 层级关系上面我们介绍了 3 种 settings.json 配置文件（用户设置，文件夹设置，工作区设置），它们的作用和格式几乎是完全一样的。那么当三者同时存在时，项目会最终使用哪个配置文件呢？？？ 事实上，上述的三种设置具有清晰的层次：用户设置 &gt;&gt;&gt;&gt; 工作区设置 &gt;&gt;&gt;&gt; 文件夹设置。 简言之，后者的设置会覆盖前者的设置，若没有设置某一项，将继续使用前者的设置。 可以这样理解此层次： 用户设置即全局设置，用户更具自身喜好设定好后，每次打开 VSCode 即使用此设定。若某项无设定即使用默认设置； 工作区设置即工作环境设置，可对不同的工作环境使用不同的工作环境。若某项无设定，即使用上一层设置（用户设置）； 文件夹设置即为项目设置，将一个文件夹当成一个项目，对同一个工作环境下的不同项目，使用不同的设置。若某项无设定，即使用上一层设置（工作区设置或用户设置）。 注意，工作区可以不打开，即无“工作区设置”。此时，层次将变为：用户设置 &gt;&gt;&gt;&gt; 文件夹设置。对应前面提到的单文件夹状态。 文件夹设置模拟多项目工作区管理模式事实上，可以通过文件夹设置来实现类似于工作区的多项目管理模式，这是一种常用的、较为简单的管理和配置方案。 上文【单项目管理和配置】中提到过，我们需要将项目的自定义配置目录放于当前项目目录的子一级目录，那么当前项目中的代码文件会采用 .vscode 配置目录中的设置。事实上，VSCode 中打开的 .vscode 自定义配置目录生效范围是和它同级的文件（夹），以及同级文件夹的子目录。 受此启发，我们可以为某个工作环境（例如 Python 开发环境），创建一个统一的目录（文件夹）用来存放所有 Python 开发相关的项目（如：PyProjectsRepo），然后将 .vscode 自定义配置目录存放在 PyProjectsRepo 中，那么 PyProjectsRepo 仓库文件夹下所有的 Python 项目文件夹是否就会遵循文件夹设置（settings.json）了？？？ 事实上，确实如此！！！这样的话，settings.json 配置文件就相当于多文件夹工作区配置文件中的 settings 设置项了。 Project Manager 多项目管理方案在 VS Code 插件介绍部分，我们提到过：Project Manager 对于需要经常切换项目（或者不同语言项目）的场景，可以很容易的实现不同项目之间的快速切换。 注意：这里的项目可以是多个单文件夹，或者是多个工作区（Workspace）。也就是说，Project Manager 可以用来管理工作区的切换。 关于 Project Manager 插件的安装就不介绍了，安装成功之后会在左侧出现 Project Manager 插件的图标。 Project Manager 常用命令 &gt;&gt;&gt;&gt; Project Manager: Save Project：将当前文件夹存储为新项目； Project Manager: Edit Project：编辑项目配置（projects.json）； Project Manager: List Projects to Open：列出所有已保存/检测到的项目并选择一个； Project Manager: List Projects to Open in New Window：列出所有已保存/检测到的项目，然后选择一个在新窗口中打开 Project Manager: Refresh Projects：刷新缓存的项目。 [1] &gt;&gt;&gt;&gt; 如何使用 Manager 管理项目？ 首先你需要打开一个项目（例如：FirstDemo），然后打开命令面板【Ctrl + Alt + P】 &gt;&gt;&gt;&gt; 搜索【Project Manager: Save Projects】 &gt;&gt;&gt;&gt; Enter。 你需要输入一个项目名称，或者采用 Manager 默认的建议名称；随后按下【Enter】键，右下角弹出保存成功提示（Project saved！）。 项目保存成功后，点击 Project Manager 插件图标，可以发现当前项目已出现在项目管理器区域（FAVORITES）。 [2] &gt;&gt;&gt;&gt; 如何添加一个新项目到 Manager ？ 我们可以通过手动编辑管理器的项目配置文件（projects.json），来维护期望的项目列表。 默认 projects.json 文件内容： 123456789[ { &quot;name&quot;: &quot;PyDemo&quot;, &quot;rootPath&quot;: &quot;e:\\\\VSCodeWorkS\\\\PyProjectWSC\\\\FirstDemo&quot;, &quot;paths&quot;: [], &quot;tags&quot;: [], &quot;enabled&quot;: true }] Solution：打开命令面板【Ctrl + Alt + P】 &gt;&gt;&gt;&gt; 搜索【Project Manager: Edit Projects】 &gt;&gt;&gt;&gt; 自动打开【projects.json】配置文件 &gt;&gt;&gt;&gt; 参照第一项配置项，手动添加新的项目（HelloPyDemo）配置 &gt;&gt;&gt;&gt; 内容如下： 1234567891011121314151617[ { &quot;name&quot;: &quot;PyDemo&quot;, &quot;rootPath&quot;: &quot;e:\\\\VSCodeWorkS\\\\PyProjectWSC\\\\FirstDemo&quot;, &quot;paths&quot;: [], &quot;tags&quot;: [], &quot;enabled&quot;: true }, { &quot;name&quot;: &quot;PyDemo1&quot;, &quot;rootPath&quot;: &quot;e:\\\\VSCodeWorkS\\\\PyProjectWSC\\\\HelloPyDemo&quot;, &quot;paths&quot;: [], &quot;tags&quot;: [], &quot;enabled&quot;: true }] 这里，我们仅使用 name 和 rootPath 两个字段，分别指向项目的名称，以及管理项目的绝对路径。当然，你还可以通过给不同的项目打上不同的标签（tag），然后通过标签进行项目过滤，只查看相应标签的项目。 注意：请确保 JSON 文件格式正确。否则，项目管理器将无法打开它，并且会出现类似 Error loading projects.json file. Message: SyntaxError: Unexpected token xxxxx 的错误消息，你可以通过 Open file 修复它。 [3] &gt;&gt;&gt;&gt; 刷新 Manager 中管理项目 打开命令面板【Ctrl + Alt + P】 &gt;&gt;&gt;&gt; 搜索【Project Manager: Refresh Projects】 &gt;&gt;&gt;&gt; 【Enter】。 刷新后，会发现左侧导航栏 “Project Manager” 中已出现添加的新的项目。 [4] &gt;&gt;&gt;&gt; Manager 中切换项目 通过左侧导航栏 “Project Manager” 中相应项目条目，我们可以灵活的在两个项目中自由切换。 注意：切换的是资源管理器中的内容，无法同时查看两个项目中的代码。 [5] &gt;&gt;&gt;&gt; Manager 可用设置 用于设置项目的排序方式： 打开用户设置【Ctrl + ,】 &gt;&gt;&gt;&gt; 搜索【Project Manager Configuration】 &gt;&gt;&gt;&gt; 搜索【Project Manager：Sort list】。 排序方式有：Name &amp;&amp; Saved &amp;&amp; Path &amp;&amp; Recent 四种，具体排序见名知义。 深入了解了 VSCode 的项目管理机制，下面正式来看如何在 VSCode 中配置多重语言开发环境（C/C++ &amp; Python &amp; …）： 配置 C/C++ 语言开发环境由于篇幅原因，关于 VSCode For C/C++ 语言开发环境的配置请参见博文 &gt;&gt;&gt;&gt; 【玩转 VSCode 之配置 C/C++ 语言开发环境】。 配置 Python 语言开发环境开始安装 Python 开发环境之前，如果你已经安装过其它语言开发环境（例如：C/C++），你可以先将其它语言相关插件警用掉（非必须），来保持 VS Code 插件库的清晰，减少不必要的开销。 由于篇幅原因，关于 VSCode For Python 语言开发环境的配置请参见博文 &gt;&gt;&gt;&gt; 【玩转 VSCode 之配置 Python 语言开发环境】。 一个优秀的插件启/警用策略工作区的还有一个重要功能就是：可以针对不同工作区启/警用插件。 安装好的插件有两个选项： 第一个选项“禁用” &gt;&gt;&gt;&gt; 为你的用户设置; 第二个选项“禁用（工作区）” &gt;&gt;&gt;&gt; 为工作区设置。 为当前工作区禁用某个插件后，只应用到当前工作区下，不会影响用户设置和其他工作区的设置，文件夹无此设置。 |&gt;&gt;&gt;&gt; ====================== 插件启/警用策略 ==================== &lt;&lt;&lt;&lt;| 在用户设置（即非打开工作区的情况下）关闭大多数插件，留下常用的、通用的，然后在不同的工作区下再开启。例如默认关闭了 Python 插件，在 Python 工作区下再开启了它。 通过这种方式，将使得安装太多插件下 VSCode 也不会显得很臃肿，占用内存也会相应地减小，还我们一个轻量的 VSCode。","link":"/2017/08/01/visual-studio-code-vs-code-ni-men-du-zai-yong-ma/"},{"title":"一文了解数据科学神器 Anaconda","text":"我们知道：Python 是一种面向对象的解释型计算机程序设计语言，其具有跨平台的特点，可以在 Linux、macOS 以及 Windows 系统中安装环境并使用。也就是说，其编写的代码在不同平台上运行时，几乎不需要做较大的改动，使用者无不受益于它的便捷性。 此外，Python的强大之处在于它的应用领域范围之广，遍及人工智能、科学计算、Web开发、系统运维、大数据及云计算、金融、游戏开发等等。而实现其强大功能的前提，就是 Python 具有数量庞大且功能相对完善的标准库和第三方库。通过对库的引用，能够实现对不同领域业务的开发。 然而正是由于库的数量庞大，对于这些库的管理维护成为既重要但复杂度又高的事情，这对于 Python 开发人员来说是极不友好的。同时 Python 多版本控制也是 Python 开发过程中极其常见的并且难以管理的。此时，Anaconda 粉墨登场… 更多 Python 版本管理以及运行环境相关内容，请关注博主 Git 博文系列： 之一 &gt;&gt;&gt; Python-Vers Management 之二 &gt;&gt;&gt; Pythoner 神器之 virtualenv 之三 &gt;&gt;&gt; 一文了解数据科学神器 Anaconda 之四 &gt;&gt;&gt; Jupyter Tutorial Anaconda 提供一种使用虚拟隔离环境来解决库管理以及维护问题的策略，它通过 conda 工具解决了 Python 开发者的两大痛点： 提供包管理：功能类似于 pip，Windows 平台安装第三方包经常失败的场景得以解决； 提供虚拟环境管理：功能类似于 virtualenv，解决了多版本 Python 并存问题。 话不多说了，下面我们正式开始 Anaconda 的学习： What Is Anaconda？Anaconda 官方地址 &gt;&gt;&gt;&gt; [https://www.anaconda.com/] IntroductionAnaconda 就是可以便捷获取包且对包进行管理，同时对环境进行统一管理的开源的 Python 发行版本。其包含了 Conda、Python 等 180 多个科学包及其依赖项。 由于包含了大量的科学计算包，Anaconda 的下载文件比较大（Linux 约 500 MB），如果只需要某些包，或者需要节省带宽或存储空间，也可以使用 Miniconda 这个较小的发行版（仅包含 conda 和 Python）。 AdvantagesAnaconda 拥有 Conda 包管理器、环境管理器、Conda 科学包、1,000+ 开源库 等等，Anaconda 还具有如下特点： 开源 安装、配置过程简单 高性能使用 Python 和 R 语言 免费的社区支持 Conda vs Pip vs Virtualenv进行 Python 学习、开发过程中，你肯定听说或者使用过 Pip 包管理工具、Virtualenv 虚拟环境管理器，再加上这里我们提到的 Anaconda、conda 工具。下面我们来横向比较一下这些工具的区别: 1 –&gt; Anaconda Anaconda 是一个包含 180+ 的科学包及其依赖项的 Python 发行版本。其包含的科学包包括：conda, numpy, scipy, ipython, jupyter notebook 等等，你可以将其理解为一个 Python 的开发生态圈。 2 –&gt; conda conda 是包管理工具，也是虚拟环境管理以及维护工具； conda 为 Python 项目而创造，但同样也适用于：Python, R, Ruby, Lua, Scala, Java, JavaScript, C/C++, FORTRAN 等语言； 适用平台：Windows &amp;&amp; Mac OS &amp;&amp; Linux； Conda 主要用途： 通过 conda 快速安装、运行和升级包及其依赖项； 使用 conda 可以在计算机中便捷地创建、保存、加载和切换虚拟环境。 前面我们提到过多版本 Pyhton 环境的问题。如果使用 conda ，仅需要几条命令，你就可以创建一个个完全独立的环境来运行不同的 Python 版本，同时你可以继续在系统原生环境中使用你常用的 Python 版本。 3 –&gt; pip pip 是常用的用于安装和管理软件包的 Python 包管理器； pip 编写语言：Python； Python 中 pip 的默认安装： Python 2.7.9 及后续版本：默认安装，命令为 pipPython 3.4 及后续版本：默认安装，命令为 pip3 名称由来：pip 采用的是递归缩写进行命名的。其名字被普遍认为来源于两处： Pip installs Packages（pip 安装包）Pip installs Python（pip 安装 Python） 4 –&gt; Virtualenv virtualenv：用于创建一个独立的 Python 环境的工具； virtualenv 可解决的问题： 当一个程序需要使用 Python 2.7 版本，而另一个程序需要使用 Python 3.6 版本，如何同时使用这两个程序？ 如果将所有程序都安装在系统下的默认路径（如：/usr/lib/python2.7/site-packages），当不小心升级了本不该升级的程序时，将会对其他的程序造成影响。 如果想要安装程序并在程序运行时对其库或库的版本进行修改，都会导致程序的中断。 在共享主机时，无法在全局 site-packages 目录中安装包。 virtualenv 将会为它自定义的虚拟环境创建一个独立的环境，这并不与其他 virtualenv 环境共享库；同时也可以选择性地连接已安装的全局库。 virtualenv 依赖于操作系统级别的 Python 解释器，生成相应版本的虚拟级别 Python 解释器，这相对于 Conda 来说是缺点。 Compare：Conda &amp;&amp; Pip我们已经知道，pip 和 conda 都可以用于安装和管理 Python 相关软件包以及其依赖项。那么它们有什么区别？（5 tips） 1 –&gt; 依赖项检查 pip： 不一定会展示所需其他依赖包； 安装包时或许会直接忽略依赖项而安装，仅在结果中提示错误。 conda： 罗列出所需其他依赖包； 安装包时自动安装其依赖项； 可以便捷地实现安装包的不同版本自由切换（自由安装不同版本的包）。 注意：同样可以使用 conda 虚拟环境中安装的 pip 进行软件包的安装，所以在 conda 封装的独立环境中我们可以同时使用 conda、pip 进行包管理。 2 –&gt; 环境管理 pip：维护多个环境难度较大； conda： 比较方便地在不同环境之间进行切换，环境管理较为简单。 3 –&gt; 对系统自带 Python 的影响 pip：在系统自带 Python 中包的 更新/回退版本/卸载 将影响其他程序； conda：多版本环境实现隔离，不会影响系统自带 Python。 4 –&gt; 适用语言 pip：仅适用于 Python； conda：适用于 Python, R, Ruby, Lua, Scala, Java, JavaScript, C/C++, FORTRAN 等多语言环境。 5 –&gt; conda 与 pip 的关系 你可以认为：conda 结合了 pip 和 virtualenv 的功能，即 conda ≈ pip + virtualenv。 How to setup Anaconda？这一部分我们来看，Anaconda 安装环境要求以及如何快速完成 Anaconda 的安装: Environmental Requirement想要安装 Anaconda，你要需要确保如下： Anaconda 平台支持：Windows、macOS、Linux（x86 / Power8）； 系统位数要求：32 位或 64 位系统均可； 下载文件大小：约 500 MB（建议预留一定空间（至少 3 G），用于存放各种科学包以及 Python 库） Anaconda SetupAnaconda 官方下载地址 &gt;&gt;&gt;&gt; 传送门 检测好安装环境后，下面我们正式开始不同平台下（Windows &amp;&amp; Linux） Anaconda 的安装说明： For Windows1 –&gt; Download Package 前往官方下载页面选择 Windows 下载项。你会发现，有两个版本可供选择：Python 3.7（最新 Python3.X） 和 Python 2.7。你需要选择基于 Python 3.7 下载，还是 Python2.7，这决定了安装好的 Anaconda Base（基础）环境中的 Python 版本，毕竟 Anaconda 也是基于 Python 工作的。 目前，Anaconda 官方站点下载页面只支持 Python3.X 版本系列的 Anaconda 下载。 选择版本之后，根据你的操作系统的情况选择 64-Bit Graphical Installer 或着 32-Bit Graphical Installer 进行相应的安装包下载。 例如，我选择 Python3.7 &amp;&amp; 64bit 的 Anaconda 安装包： Anaconda3-5.2.0-Windows-x86_64.exe。 2 –&gt; Begin To Setup 完成安装包下载之后，双击下载文件，启动安装程序开始安装，【Next】： 3 –&gt; 同意 Anaconda 相关软件使用协议条款 阅读许可证协议条款，然后勾选 I Agree 进行下一步。 4 –&gt; 安装用户选择 选择 Install for: Just me 还是 All Users。假如你的电脑有多个用户（Users），可以选择考虑 All Users，一般选择 Just me 即可。 然后 【Next】： 5 –&gt; 自定义 Anacodna 安装位置 设置自定义 Anaconda 安装位置，默认是安装到 C:\\Users\\XXX\\Anaconda3，【Next】: 6 –&gt; 配置高级选项（Advanced Options） 在 Advanced Options 设置中，不要勾选 Add Anaconda to my PATH environment variable. （“添加 Anaconda 至我的环境变量”）。因为如果勾选，则将会影响其他程序的使用。 如果想要使用 Anaconda，则通过在开始菜单中打开 Anaconda Navigator 或者在开始菜单中的 Anaconda Prompt（类似 DOS）下进行通过命令行使用。 我们推荐不选择 Register Anaconda as my default Python 3.6 。如果你打算在当前系统中默认调用原生的 Python 解释器，而不是使用 Anaconda 对应版本的 Python 解释器，那就不要勾选 Register Anaconda as my default Python 3.6。 然后开始 【Insatll】： Anaconda Base 版本的 Python 解释器和操作系统原生 Python 解释器冲突问题：可以通过修改相应 Python 解释器命名来解决，例如分别改为：python_ana.py &amp;&amp; python3.x.py。更推荐的方法是：设置 Anaconda 环境变量优先级低于系统原生 Python 环境变量（参见【9 –&gt; 手动配置 Anaconda 环境变量】），想要使用 Anaconda Base，可以使用 conda 进行切换。 Anaconda 安装过程还是很漫长的，请耐心等待… 经过漫长的等待，终于安装完成 Installation Complete 了，点击最后一个 【Next】。之后会出现推荐安装 IDE：Microsoft Visual Studio Code 界面： 如果需要安装 Microsoft VSCode，点击 Install Microsoft VSCode，否则我们选择 【Skip】。 7 –&gt; Thanks For Setup 进入 “Thanks for installing Anaconda!” 界面则意味着安装成功，点击 “Finish” 完成安装即可。 注意：如果你不想了解 “Anaconda 云” 和 “Anaconda 支持” ，则可以选择不勾选 Learn more about Anaconda Cloud 和 Learn more about Anaconda Support。 8 –&gt; 安装验证 这里提供两种验证方法，可选用以下任意方法： “开始（Win）–&gt; Anaconda3（64-bit）–&gt; Anaconda Navigator”。若可以成功启动 Anaconda Navigator，进入如下界面，则说明安装成功。 “开始（Win） –&gt; Anaconda3（64-bit）–&gt; 右键点击 Anaconda Prompt –&gt; 以管理员身份运行”，在 Anaconda Prompt 中输入 conda list or conda --version，可以查看已经安装的包名或者 conda 版本号。若结果可以正常显示，则说明安装成功。 9 –&gt; 手动配置 Anaconda 环境变量 可能你不太信任 Anaconda Prompt 或者你更加习惯在 windows DOS 下使用命令行，这时你需要为 Anaconda 配置环境变量的。 操作步骤：【控制面板 –&gt; 系统和安全 –&gt; 系统 –&gt; 高级系统设置 –&gt; 环境变量 –&gt; 用户变量 –&gt;PATH】 中添加如下内容： 12345# 根据个人安装路径不同需要自行调整E:\\anacondaE:\\anaconda\\ScriptsE:\\anaconda\\Library\\binE:\\anaconda\\Library\\mingw-w64（有无都可以） 注意：Anaconda 环境变量和系统原生 Python 解释器的优先级问题，推荐优先级：原生 &gt; Anaconda。即 Anaconda Path 要置于原生 Python 之后！！！ 之后就可以打开 DOS 命令行提示符界面(最好用管理员模式打开) 输入 conda --version 进行验证了。 For Linux1 –&gt; Download Package 前往官方下载页面选择 Linux 下载项。你会发现，有两个版本可供选择：Python 3.7（最新 Python3.X） 和 Python 2.7。你需要选择基于 Python 3.7 下载，还是 Python2.7，这决定了安装好的 Anaconda Base（基础）环境中的 Python 版本，毕竟 Anaconda 也是基于 Python 工作的。 目前，Anaconda 官方站点下载页面只支持 Python3.X 版本系列的 Anaconda 下载。 确定下载版本之后，这里我们提供两种方式用于下载适用于 Linux 的 Anaconda 版本： 官网下载安装包：如果是从官网直接下载安装包，我们需要将下载好的安装包上传到服务器。局域网还好，上传速度一般都比较快。如果服务器是一台阿里云服务器（外网服务器），上传速度是很慢的。 Wget 下载：直接采用 wget 方式直接下载的速度取决于服务器网络带宽。获取下载链接，然后通过 wget 直接下载到服务器。如下（选择用户目录下的 Downloads 目录下载）： 12345# Python 2.7：$ wget -c https://repo.anaconda.com/archive/Anaconda2-5.3.1-Linux-x86_64.sh# Python 3.7：$ wget -c https://repo.anaconda.com/archive/Anaconda3-5.3.1-Linux-x86_64.sh 下载完成后，Centos/ubuntu 系统 ~/Downloads 下会有一个文件：Anaconda3-5.3.1-Linux-x86_64.sh（或：Anaconda2-5.3.1-Linux-x86_64.sh），它就是我们要安装的 anaconda3（anaconda2）的安装包。 下面我以 “Anaconda3 in Linux 的安装以及配置” 为样例介绍 Anaconda 安装过程（Anaconda2 安装过程同理）： 2 –&gt; Anaconda3 in Linux ↓↓↓↓↓↓↓↓ 请一定要注意 ↓↓↓↓↓↓↓↓ 安装前请确认 anaconda3 的安装用户（user），root 用户下已安装的 anaconda 会和普通用户再次安装的 anaconda 产生冲突。一般情况下，安装到普通用户下即可；如果在共享服务器使用的话，需要注意 root 中是否已安装；如果共享服务器中所有用户均使用 anaconda，可以统一安装到 root 用户下，然后 “共享” 给普通用户 ！！！ 共享方法：1）anaconda 安装到普通用户可访问目录；2）普通用户登录时，在 ‘anaconda/bin’ 下执行 conda init bash。具体百度自行解决。 一般，我们会将 anaconda3 的安装包（Anaconda3-5.3.1-Linux-x86_64.sh）下载到当前用户目录下的 Downloads。 假设我们的 anaconda3 安装包存放路径为： ~/Downloads。 [1] 在 ~/Downloads 路径下执行安装指令： 123456789$ bash ~/Downloads/Anaconda3-5.0.1-Linux-x86_64.sh# 命令执行可能会产生如下报错（缺乏解压缩包）:PREFIX=/home/cdh/anaconda3Anaconda3-5.0.1-Linux-x86_64.sh: line 335: bunzip2: command not foundtar: This does not look like a tar archivetar: Exiting with failure status due to previous errors# 安装 bzip2 即可解决:yum install -y bzip2 注意：除非被要求使用 root 权限，否则均选择 Install Anaconda as a user。 [2] “In order to continue the installation …review the license agreement.” 安装过程中，你会看到提示 In order to continue the installation process, please review the license agreement.，提示你：“请浏览许可证协议以便继续安装”，点击 【Enter】 查看 “许可证协议”。 在 “许可证协议” 界面将屏幕滚动至底，输入 yes 表示同意许可证协议内容。然后进行下一步。 [3] 设置安装路径 安装过程中，提示 Press Enter to accept the default install location, CTRL-C to cancel the installation or specify an alternate installation directory.，提示你：“按回车键确认安装路径，按 ‘CTRL-C’ 取消安装或者指定安装目录”。 如果接受默认安装路径，则会显示 PREFIX=/home/{~username}/anaconda&lt;2 or 3&gt; 并且继续安装。安装过程大约需要几分钟的时间。 建议：直接接受默认安装路径。 [4] 设置环境变量 安装过程中最后安装器会询问 Do you wish the installer to prepend the Anaconda&lt;2 or 3&gt; install location to PATH in your /home/{~username}/.bashrc ?，提示你：“你希望安装器添加 Anaconda 安装路径在 【/home/{~username}/.bashrc 】文件中吗？ ”。建议输入 no 不进行自动配置，随后自己手动配置。 注意： 路径 /home/{~username}/.bash_rc 中 “{username}” 即用户目录，取决于安装用户。 如果输入 “no”，则需要手动添加路径，否则 conda 命令将无法运行。 安装结束后，如何手动添加环境变量？ &gt;&gt;&gt; 安装完成后，可以察看 ~/.bashrc 文件末尾是否有追加 anaconda 相关的 export PATH ，如果没有，则执行以下命令： 1$ echo 'export PATH=&quot;~/anaconda3/bin:$PATH&quot;' &gt;&gt; ~/.bashrc [5] Thank you for installing Anaconda&lt;2 or 3&gt;! 当看到 Thank you for installing Anaconda&lt;2 or 3&gt;!，则说明已经成功完成安装。安装完成后，会产生一个 ~/anaconda3 目录，即 Anaconda 安装目录。 [6] 更新 .bashrc 使其生效 关闭终端，然后再打开终端以使安装后的 Anaconda 启动。或者直接在终端中输入以下命令： 1$ source ~/.bashrc [7] 安装验证 可选用以下任意方法: 在终端中输入命令 condal list or conda --version，如果 Anaconda 被成功安装，则会显示 conda 已经安装的包名和版本号。 在终端中输入 python，这条命令将会启动 Python 交互解释器界面。如果 Anaconda 被成功安装并且可以运行，则将会在 Python 版本号的右边显示 Anaconda custom (64-bit)。退出 Python 交互界面则输入 exit() 或 quit() 即可。 提供桌面环境的 Linux 下，在终端中输入 anaconda-navigator。如果 Anaconda 被成功安装，则 Anaconda Navigator 将会被启动。 Conda 包以及虚拟环境管理工具安装好 Anaconda 后，我们就可以用 Anaconda 中的包管理器 Conda 来创建我们一个个独立的 Python 虚拟环境了。 接下来均是以命令行模式进行操作的，Windows 用户请打开 “Anaconda Prompt”（配置 DOS 环境后可以之间在 DOS 下操作），macOS 和 Linux 用户请打开 “Terminal”（“终端”）进行操作。 Conda前面我们提过，Anaconda 下的包管理和环境管理是鉴于 conda 命令行工具得以实现的。我们先来看一下 anaconda 安装之后，如何来快速管理 conda： [1] –&gt; 如何验证 conda 已被安装？ 123$ conda --version / conda -V# 或者$ which conda（Linux) 终端上将会以 conda 版本号的形式显示当前安装 conda 的版本号。如：conda 3.11.0 注意：如果出现错误信息，则需核实是否出现以下情况： 1）使用的用户是否是安装 Anaconda 时的账户；2）是否在安装 Anaconda 之后重启了终端。 [2] –&gt; 如何更新 conda 至最新版本？ 12# 升级 conda：$ conda update conda 执行命令后，conda 将会对版本进行比较并列出可以升级的版本。同时，也会告知用户其他相关包也会升级到相应版本。当较新的版本可以用于升级时，终端会显示 Proceed ([y]/n)?，此时输入 y 即可进行升级。 [3] –&gt; 如何查看 conda 帮助信息？ 123$ conda --help#或$ conda -h [4] –&gt; 如何卸载 conda？ 1）For Linux 或 macOS： 1$ rm -rf ~/anaconda2(anaconda3) 即删除 Anaconda 的安装目录。根据安装的 Anaconda 版本选择相应的卸载命令。 2）For Windows 【控制面板】 → 【添加或删除程序】 –&gt; 选择 【Python X.X (Anaconda)】 –&gt; 点击 【删除程序】 即可。 conda 虚拟环境管理Anaconda Base 环境 &gt;&gt;&gt; Base EnvsWindow 下 activate 命令（Linxu/Mac 下是 source activate）能将我们引入 anaconda 设定的虚拟环境中，如果你后面什么参数都不加那么会进入 anaconda 自带的 base 环境（anaconda 基础运行环境，anaconda 运行也是需要 Pyhton 支持的）。命令行前面也会多一个(base) 说明当前我们处于的是 base 环境下。 安装配置好 anaconda 之后，通过在终端输入 python，我们可以进入 Python 交互式模式（带有 Anaconda custom (64-bit)，已经不是系统原生的 Pyhton 解释器了），这个解释器实质就是 base 环境中的 python 解释器。 我们当然不满足一个 base 环境, 我们更加期望的是更加广阔的天地—可以自由定制的使用多版本虚拟环境。 如何创建新环境？conda 创建虚拟环境的指令如下： 123$ conda create --name &lt;env_name&gt; &lt;lists:package_names&gt;#或$ conda create -n &lt;env_name&gt; &lt;lists:package_names&gt; 命令说明 ⬇⬇⬇⬇⬇ 1）env_name：即创建的环境名。建议以英文命名，且不加空格（名称两边不需要加尖括号 “&lt;&gt;”）。 2）package_names：即安装在环境中的包名（名称两边不加尖括号 “&lt;&gt;”），如：python。 1234567# 如果要安装指定的版本号，则只需要在包名后面以 “=” 和版本号的形式执行。# 例如：conda create --name python2 python=2.7# 释义：创建一个名为 “python2” 的环境，环境中安装版本为 2.7 的 python。 # 如果要在新创建的环境中创建多个包，则直接在 &lt;package_names&gt; 后以空格隔开，添加多个包名即可。# 例如：conda create -n python3 python=3.5 numpy pandas# 释义：创建一个名为 “python3” 的环境，环境中安装版本为 3.5 的 python，同时也安装了 numpy 和 pandas。 如何切换环境？创建好虚拟环境后，如何实现在不同的 conda 虚拟环境进行自由切换呢？？？ [1] –&gt; 激活环境 1）For Linux 或 macOS –&gt; source activate &lt;env_name&gt;，例如： 12# Linux 下激活名为 python3 的虚拟环境： $ source activate python3 2）For Windows –&gt; activate &lt;env_name&gt;，例如： 12# Windows 下激活名为 python3 的虚拟环境： $ activate python3 提示信息 ⬇⬇⬇⬇⬇ –&gt; 如果创建环境后安装 Python 时没有指定 Python 的版本，那么将会安装与 Anaconda 版本相同的 Python 版本。即如果安装 Anaconda 第2版，则会自动安装 Python2.x；如果安装 Anaconda 第3版，则会自动安装 Python 3.x。 –&gt; 当成功切换环境之后，在该行行首将以 “(env_name)” 或 “[env_name]” 开头。其中，“env_name” 为切换到的环境名。 [2] –&gt; 退出已激活环境 1）For Linux 或 macOS 1$ source deactivate 2）For Windows 1$ deactivate 提示信息 ⬇⬇⬇⬇⬇ –&gt; 当执行退出当前环境命令后，原本行首以 “(env_name)” 或 “[env_name]” 开头的字符将不再显示。 如何查看已创建环境？当我们同时管理多个版本环境时，很容易忘记环境名称，那么如何查看 anaconda 中已经创建好的环境呢？ 12345$ conda info --envs或$ conda info -e或$ conda env list 如下显示，星号 “*” 所在行即为当前所在环境： 如何复制已创建环境？如何基于一个已存在的虚拟环境 Copy 出来一份？？？命令格式如下： 1$ conda create --name &lt;new_env_name&gt; --clone &lt;copied_env_name&gt; 命令说明 ⬇⬇⬇⬇⬇ 1）copied_env_name：为被 复制/克隆 的环境名（环境名两边不加尖括号 “&lt;&gt;”）。 2）new_env_name：为复制之后新环境的名称（环境名两边不加尖括号 “&lt;&gt;”）。 12# 例如：conda create --name py2 --clone python2# 释义：克隆名为 “python2” 的环境，克隆后的新环境名为 “py2”。此时，环境中将同时存在 “python2” 和 “py2” 环境，且两个环境的配置相同。 如何删除已创建环境？命令格式如下： 1$ conda remove --name &lt;env_name&gt; --all 命令说明 ⬇⬇⬇⬇⬇ –&gt; env_name：为被删除环境的名称（环境名两边不加尖括号 “&lt;&gt;”）。 ======================================================================== 考虑一下，结合 【复制虚拟环境 &amp;&amp; 删除虚拟环境】 如何为一个虚拟环境进行重命名？？？ 提示信息 ⬇⬇⬇⬇⬇ –&gt; 先拷贝重命名，然后删除原有。 如何导入导出当前环境？如果想要导出当前环境的所有包的信息，以下命令会将包信息存入到 yaml 文件中： 1$ conda env export &gt; environment.yaml 此时，如果需要重新创建一个相同的虚拟环境时可以用（用上述 yaml 配置文件可创建新的虚拟环境）： 1$ conda env create -f environment.yaml Conda&amp;&amp;Pip Channels在介绍 Conda 包管理之前需要介绍一下 Pip &amp;&amp; Conda 中的频道概念，有了 Conda&amp;&amp;Pip Channels 你就可以去相应 Channels 所对应的源（远程服务器）上下载各种使用的包。 何为频道（源）就像家里的电视机，安装 Conda 就相当于买了一台电视机，有了电视不意味着你就能看节目了，你要手动添加频道（信号源）才能看你想看的电视节目。 你可以将 Conda&amp;&amp;Pip 源理解为一个存放了各种 Pip &amp;&amp; Conda 包的远程服务器，而 Channels 是用于访问服务器的链接。 Pip &amp;&amp; Conda 安装好之后，默认使用的是 Pip &amp;&amp; Conda 官方提供的源（Conda –&gt; anaconda.org），这时 Pip &amp;&amp; Conda Channels 设置的是官方源对应的链接，当你使用 Pip &amp;&amp; Conda 进行包的安装、更新操作时，会从官方源中去搜索、下载你需要的包。 而由于 Pip &amp;&amp; Conda 使用的官方源位于外网，网络时好时坏，这可能会导致使用 Pip &amp;&amp; Conda 进行包的安装、更新等操作失败的情况： 123An HTTP error occurred when trying to retrieve this URL.HTTP errors are often intermittent, and a simple retry will get you on your way.ConnectTimeout(MaxRetryError(&quot;HTTPSConnectionPool(host='nanomirrors.tuna.tsinghua.edu.cn', port=443): Max retries exceded with url: /anaconda/cloud/linux-64/repodata.json (Caused by ConnectTimeoutError(&lt;requests.packages.urllib3.connecton.VerifiedHTTPSConnection object at 0x7fb6d340dcc0&gt;, 'Connection to nanomirrors.tuna.tsinghua.edu.cn timed out. (connct timeout=9.15)'))&quot;,),) 这时就需要更换一个稳定、高速的源来提供良好的网络环境。所幸的是，国内镜像源站点提供了 Pip 和 Anaconda 的镜像源，感谢开源~~~ 更换国内源这里来看如何为 Pip &amp;&amp; anaConda 更换稳定、高速的国内源： Conda 换源目前，国内常用 Anaconda 源： 清华大学 –&gt; https://mirrors.tuna.tsinghua.edu.cn/help/anaconda/北京外国语大学 –&gt; https://mirrors.bfsu.edu.cn/help/anaconda/哈尔滨工业大学 –&gt; http://mirrors.hit.edu.cn/#/home南京邮电大学 –&gt; https://mirrors.njupt.edu.cn/ 这里推荐使用清华源（TUNA），来为 Conda 进行换源。提供两种更换清华 Anaconda 源的方法： 1 –&gt; 查看当前源信息 12# 你可以查看当前系统中，conda 源是否是国内源$ conda config --show-sources 2 –&gt; 配置文件 修改或新创建 ~/.condarc 配置文件添加如下内容（最新）： 12345678channels: - defaultsshow_channel_urls: truedefault_channels: - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/r - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/msys2 - https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/ 清华镜像站推荐的配置如下： 123456789101112131415channels: - defaultsshow_channel_urls: truedefault_channels: - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/r - https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/msys2custom_channels: conda-forge: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud msys2: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud bioconda: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud menpo: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud pytorch: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud pytorch-lts: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud simpleitk: https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud 清华大学镜像站推荐的 Anaconda Chanels 设置方法 –&gt; 传送门。 3 –&gt; 命令行 通过命令行运行如下命令，也可以将 Anaconda 默认的镜像源换为 清华TUNA 镜像源： 12345678910111213141516# 查看当前 Conda 源配置信息：$ conda config --showdefault_channels: - https://repo.anaconda.com/pkgs/main - https://repo.anaconda.com/pkgs/r - https://repo.anaconda.com/pkgs/msys2# 添加清华(TUNA) 镜像源:$ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main$ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/r$ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/msys2$ conda config --add channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge/$ conda config --set show_channel_urls yes# 删除错误 Chanels:$ conda config --remove channels https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/r 命令行设置后如何 快速换回默认源 ⬇⬇⬇⬇⬇ 1$ conda config --force --remove-key channels Pip 换源国内常用源 Pip 源： 清华大学 –&gt; https://pypi.tuna.tsinghua.edu.cn/simple阿里云 –&gt; http://mirrors.aliyun.com/pypi/simple/中国科技大学 –&gt; https://pypi.mirrors.ustc.edu.cn/simple/豆瓣 –&gt; http://pypi.douban.com/simple/ 设置前，你可以先查询一下，当前系统中的 pip 源是否是国内源 &gt;&gt;&gt;&gt; 1234# 可以当前我已经设置过了 aliyun 源了：$ pip config listglobal.index-url='http://mirrors.aliyun.com/pypi/simple/'install.trusted-host='mirrors.aliyun.com' 以设置阿里 Pip 源为例（推荐），加速 pip 速度： 123456$ mkdir ~/.pip$ cat &gt; ~/.pip/pip.conf &lt;&lt; EOF&gt;[global]&gt;trusted-host=mirrors.aliyun.com&gt;index-url=http://mirrors.aliyun.com/pypi/simple/&gt;EOF 你可以看到，是在用户目录下生成了一个 pip.conf Pip 配置文件，用于设置 Pip 源。想要恢复 Pip 源，删除 pip.conf 配置文件即可。 conda 包管理conda 除了多虚拟环境管理功能之外，还具有包管理功能（类似于 pip）。 查找可供安装的包版本？如何查找当前 Chanel（Conda 源）中可供安装的软件包版本？？？ 精确查找1$ conda search --full-name &lt;package_full_name&gt; 命令说明 ⬇⬇⬇⬇⬇ –full-name：为精确查找的参数。 package_full_name：是被查找包的全名（包名两边不加尖括号 “&lt;&gt;”）。 例如：conda search --full-name python，即查找全名为 “python” 的包有哪些版本可供安装。 模糊查找1$ conda search &lt;text&gt; 命令说明 ⬇⬇⬇⬇⬇ text：是查找含有此字段的包名（此字段两边不加尖括号 “&lt;&gt;”）。 例如：conda search py，即查找含有 “py” 字段的包，有哪些版本可供安装。 如何获取已安装包信息？查看当前虚拟环境中已安装软件包的信息： 1$ conda list 如何安装第三方包？安装第三方包可分为以下场景： [1] –&gt; 在指定环境中安装包 1$ conda install --name &lt;env_name&gt; &lt;package_name&gt; 命令说明 ⬇⬇⬇⬇⬇ env_name：即将包安装的指定环境名（环境名两边不加尖括号 “&lt;&gt;”）。 package_name：即要安装的包名（包名两边不加尖括号“&lt;&gt;”）。 例如：conda install --name python2 pandas，即在名为 “python2” 的环境中安装 pandas 包。 [2] –&gt; 在当前环境中安装包 1$ conda install &lt;package_name&gt; 命令说明 ⬇⬇⬇⬇⬇ package_name：即要安装的包名(包名两边不加尖括号 “&lt;&gt;”)。 执行命令后在当前环境中安装包。 例如：conda install pandas，即在当前环境中安装 pandas 包。 [3] –&gt; 使用 pip 安装第三方包 –&gt; 使用场景 当使用 conda install 无法进行安装时，可以使用 pip 进行安装。例如：see 包。 –&gt; 命令 1$ pip install &lt;package_name&gt; –&gt; 注意 pip 只是包管理器，无法对环境进行管理。因此如果想在指定环境中使用 pip 进行安装包，则需要先切换到指定环境中，再使用 pip 命令安装包。 pip 无法更新 python，因为 pip 并不将 python 视为包。 pip 可以安装一些 conda 无法安装的包；conda 也可以安装一些 pip 无法安装的包。因此当使用一种命令无法安装包时，可以尝试用另一种命令。 [4] –&gt; 从 Anaconda.org 安装第三方包 Anaconda.org 官方网址 –&gt; 传送门。 –&gt; 使用场景 当使用 conda install 无法进行安装时，可以考虑从 Anaconda.org 中获取安装包的命令，并进行安装。 –&gt; 注意 从 Anaconda.org 安装包时，无需注册； 在当前环境中安装来自于 Anaconda.org 的包时，需要通过输入要安装的包在 Anaconda.org 中的路径作为获取途径（channel）。 查询路径的方式如下 &gt;&gt;&gt;&gt;&gt; 进入 Anaconda Cloud 官方网址，在页面 “Anaconda Cloud” 的上方搜索框中输入要安装的包名，–&gt; search。 搜索结果中有数以千计的包可供选择，此时点击 “Downloads” 可根据下载量进行排序，最上面的为下载最多的包,（图中以搜索 pymysql 包为例）。选择满足需求的包或下载量最多的包，点击包名： 复制 To install this package with conda run:下方的命令，并粘贴在终端中执行即可完成安装： 如何卸载已安装第三方包？[1] –&gt; 卸载指定环境中的包 1$ conda remove --name &lt;env_name&gt; &lt;package_name&gt; 命令说明 ⬇⬇⬇⬇⬇ env_name：即卸载包所在指定环境的名称（环境名两边不加尖括号 “&lt;&gt;”）。 package_name：即要卸载包的名称（包名两边不加尖括号 “&lt;&gt;”）。 例如：conda remove --name python2 pandas，即可卸载名为 “python2” 中的 pandas 包。 [2] –&gt; 卸载当前环境中的包 1$ conda remove &lt;package_name&gt; 命令说明 ⬇⬇⬇⬇⬇ package_name：即要卸载包的名称（包名两边不加尖括号“&lt;&gt;”）。 执行命令后即在当前环境中卸载指定包。 例如：conda remove pandas，即可在当前环境中卸载 pandas 包。 如何更新已安装第三方包？[1] –&gt; 更新所有包 123$ conda update --all#或$ conda upgrade --all 建议：在安装 Anaconda 之后执行上述命令更新 Anaconda 中的所有包至最新版本，便于使用。 [2] –&gt; 更新指定包 123$ conda update &lt;package_name&gt;#或$ conda upgrade &lt;package_name&gt; 注意 ⬇⬇⬇⬇⬇ package_name：为指定更新的包名（包名两边不加尖括号 “&lt;&gt;”）。 更新多个指定包，则包名以空格隔开，向后排列。 例如：conda update pandas numpy matplotlib，即可更新 pandas、numpy、matplotlib 等包。 深入了解 Anaconda了解了以上内容，或许你会觉得奇怪为啥 Anaconda 能做这些事, 他的原理到底是什么？ 首先，我们来看看 Anaconda in Windows 的安装目录： 这里只截取了一部分，其实这里就是我们前面介绍的 base 环境。里面有着一个基本的 python 解释器（你可以找找 python.exe），Lib 里面也有 base 环境下的各种包文件。 那我们自己创建的环境去哪了呢, 我们可以看见一个 envs, 这里就是我们自己创建的各种虚拟环境的入口, 点进去看看： 可以发现我们之前创建的所有虚拟环境目录就在下面, 再点进去： 哎？！！这不就是一个标准的 Python 环境目录吗？ 这么一看, Anaconda 所谓的创建虚拟环境其实就是安装了一个真实的 Python 环境, 只不过我们可以通过 activate，conda 等命令去随意的切换我们当前的 Python 环境, 用不同版本的解释器和不同的包环境去运行 Python 脚本，很巧妙啊~~~ Anaconda 生态环境初体验至此，你已经掌握了 Anaconda 的日常使用方法。下面我会补充一部分内容用于提升使用体验（推荐阅读）： Conda In JetBrains PyCharm在工作环境中我们会选择在集成开发环境（IDE）去编码,正如我们前面推荐的 PyCharm, 而 PyCharm 也能很方便的配置和 anaconda 的虚拟环境结合使用。 在 【File】 –&gt; 【Settings】 –&gt; 【Project:XXX】 –&gt; 【Project Interpreter】 里面修改 Project Interpreter，点击齿轮标志再点击 【Add Local】 为你某个环境的 python.exe 解释器就行了： 比如你要在 DeepLearning 环境中编写程序, 那么就修改为 E:\\\\Anaconda3\\envs\\DeepLearning\\python.exe。同时可以看到这时候下面的依赖包也变成了 DeepLearning 环境中的包了。接下来我们就可以在 Pycharm 中愉快的编码了。 Anaconda In WindowsWindows 环境下，按下 【Win】，调出 Windows 开始菜单。可以看到 “最近添加” 的：Anaconda3(64-bit) 文件夹。 Anaconda3（64-bit）中包含：Anaconda Navigator、Anaconda Prompt、Jupyter Notebook 以及 Spyder 等菜单项。下面我们来看如何使用这些功能项： Anaconda Prompt打开 Anaconda Prompt，这个窗口和 DOS 窗口一样的，输入命令就可以控制和管理 Python 环境。可以将其看作一个 Anaconda 内嵌的用于执行 conda 命令行指令的工具。最常用的是 conda 命令，前面我们介绍的所有 conda 命令此软件都集成了，你可以直接用。点开的话如下图： 进入后你会发现我们处于 Anaconda 的 base 环境中。 同时，安装完 anaconda，就相当于默认安装了 Python、IPython、集成开发环境 Spyder、部分包等等。你可以在 Windows 下的 cmd 下启动相应组件。以启动 IPython 为例： Anaconda Navigator从其名称（Anaconda 导航员）即可看出，它应该是一个用于帮助用户快速使用 Anaconda 的工具。确实，Anaconda Navigator 是用于管理工具包和环境的图形用户界面。 同时支持快速启动 Anaconda 内嵌的一些工具：JupyterLab、Jupyter Notebook、IPython、Spyder 等。 Jupyter NotebookJupyter Notebook 是基于 web 的交互式计算环境。支持富文本，可以编辑易于人们阅读的文档。所以常用于展示数据分析的过程（强烈推荐使用）。 我们还可以为远程服务器配置 Jupyter Notebook 服务后，实现远程调用（一方面可以在图形化界面进行开发编程；另一方面免除了需要在本地搭建搭建一套和服务器相同开发环境的问题），体验度极高！！！ JupyterLab你可以认为 Jupyter Lab 是 Jupyter Notebook 的升级版，为用户提供了更多的功能，JupyterLab 最终将取代经典的 Jupyter Notebook。 打开 JupyterLab 会在默认浏览器打开 http://localhost:8888/lab 这样一个东东，这里可以打开 Jupyter Notebook、Python 解释器以及 终端（Terminal）等等…. 我们可以打开 【Anaconda Navigator】 -&gt; 【Launch jupyterlab】 ，也可以直接在浏览器输入 http://localhost:8888/lab （可以保存为书签）。如果是布置在云端，可以输入服务器域名（IP），是不是很爽？ SpyderSpyder 一个使用 Python 语言、跨平台的、科学运算集成开发环境（Anaconda 内嵌的一款 IDE）。点击 Anaconda Navigator &gt;&gt;&gt; Spyder，第一次启用，会初始化，耐心等待一段时间……加载完成，界面如图: Spyder 编辑器，没有安装 IDE 的同学可以直接选用这款编辑器来编写代码，它最大的优点就是模仿 MATLAB 的“工作空间”。spyder.exe 放在安装目录下的 Scripts 里面，可以将其发送到桌面快捷方式进行使用。并且 Spider 支持远程服务器链接。 Orange3交互式数据可视化，通过巧妙的数据可视化执行简单的数据分析。探索统计分布，箱形图和散点图，或深入了解决策树，层次聚类，热图，MDS和线性投影。即使您的多维数据也可以在 2D 中变得合理，特别是在智能属性排名和选择方面。 据说：老师和学生都喜欢它。在教授数据挖掘时，我们喜欢说明而不是仅仅解释。而橙色很棒。Orange 在世界各地的学校，大学和专业培训课程中使用，支持数据科学概念的实践培训和视觉插图。甚至还有专门为教学设计的小部件。 附加组件扩展功能。使用 Orange 中可用的各种附加组件从外部数据源挖掘数据，执行自然语言处理和文本挖掘，进行网络分析，推断频繁项目集并执行关联规则挖掘。此外，生物信息学家和分子生物学家可以使用Orange通过差异表达对基因进行排序并进行富集分析。","link":"/2018/01/03/yi-wen-liao-jie-shu-ju-ke-xue-shen-qi-anaconda/"},{"title":"一文学会 Hexo 轻量级框架的博客搭建【持续更新】","text":"HEXO 是一个快速、简洁且高效的博客框架。支持 GitHub Flavored Markdown 解析文章。并且通过 Node.js 所带来的超快生成速度，可利用靓丽的主题在几秒内瞬间完成静态网页渲染。 写在前面–&gt; 在开始 Hexo 轻量级博客框架搭建之前，首先说明本文所作目的： 其一：本文作为基于 Hexo Frame 搭建个人博客过程记录，方便日后回顾使用； 其二：由于在搭建过程中受益于博客上分享过 Hexo 环境搭建的前辈们（致敬~），故作此以分享给更多的 Hexo 新手小白们。 如文中有表述不恰当的地方，欢迎各位在留言区进行指正，若有转载请注明出处！ 更多 Hexo 博客框架内容，请关注博主 Hexo 博文系列： 一文学会 Hexo 轻量级框架的博客搭建【持续更新】 Hexo 预安装环境部署之 Node.js Git 使用指南之初识 Hello, Hexo World 打造沉浸式写作体验，你需要试试-Markdown-Editor 基于图床的博客图片存储解决方案 稳定快速、高效免费的图床方案-Github-jsDelivr-PicGo Hexo 博客多设备协同管理问题【持续更新】 Getting Started with HexoHexo 是一个快速、简洁且高效的博客框架。支持 GitHub Flavored Markdown 解析文章。并且通过 Node.js 所带来的超快生成速度，可利用靓丽的主题在几秒内瞬间完成静态网页渲染。 注意，在正式开始 Hexo 博客安装以及搭建之前，我们需要预先准备 Hexo 安装环境依赖（预安装环境），这是必须的！否则会影响到后续 Hexo 的安装、搭建过程。所以下面我们需要先来 部署 Hexo 预安装环境： 安装 Node.js前面提过，Hexo 博客需要 Node.js 来进行渲染，才可以完成最终博客静态页面的显示。关于 Node.js 的详细下载以及安装过程说明请参见：Hexo 预安装环境搭建之 Node.js ，这里提供了不同平台下 Node.js 的安装过程。 –&gt;&gt;&gt; 到这里，相信你已经完成了 Node.js 的安装。 安装 Git关于 Git，你可以理解为 Hexo + Git 的搭配方案才可以让互联网内的其他用户可以正常访问我们的博客站点（否者只能本地访问），甚至博客的多平台协同管理（家&amp;公司&amp;学校…多环境博客创作）也要靠 Git 来支持。 Git 的详细下载以及安装过程说明请参见：Git 使用指南之初识 ，这里不仅提供了不同平台下 Git 的安装记录，还包含了 Git 快速入门指南 来帮助你快速了解 Git。 –&gt;&gt;&gt; 到这里，相信你已经完成了 Git 的安装。 维护一个 Github 远程仓库首先通过 Github 官网 ，注册一个 Github 账号并完成登陆。 在 Github 上新建一个 Repository（远程仓库），显示如下： 注意：Repository 名称最好是 Github 账号名（保证唯一，这里我的 Github 账户名是：TheNightIsYoung），并且一定要加 .github.io，所以最终我所创建的 Github 仓库名称为：TheNightIsYoung.github.io。 接着，我们还需要为 Github 和 本地 Git 配置 SSH Key，具体配置过程可以参见 Git 使用指南之远程仓库 中 “GitHub 配置 SSH Key” 章节内容。 维护一个 Gitee 远程仓库首先通过 Gitee 官网 ，注册一个 Citee（码云）账号并完成登陆。 当然，你还可以选择其它 国内远程仓库，这里配置另外一个远程仓库的目的主要是为了解决 Github 的访问速度较慢的问题（不要深究，后续会进行说明）。 例如：如果你是使用过 Coding（腾讯云开发者平台是由腾讯云与 CODING 共同开发的）的用户，非必须使用 Gitee 平台远程仓库，可以直接使用 Coding 平台。两者在使用上几乎没有差异（但这里博主推荐使用 Gitee，一些原因博主感觉 Coding 越来越不友好了….越来越开始向钱看齐了）。 以 Gitee 平台为例，新建一个项目（Repository），如下： 这里注意：和 Github 一样，Repository 名称也要和账户名称一致。同样，我们需要为 Gitee 配置 SSH Key，在账户 Settings 中点击 SSH keys，添加一个 SSH KEY，将之前公钥的内容添加进去。然后测试是否成功连接： 123456C:\\Users\\Jie Guo&gt;ssh -T git@gitee.comThe authenticity of host 'gitee.com (212.64.62.183)' can't be established.ECDSA key fingerprint is SHA256:FQGC9Kn/eye1W8icdBgrQp+KkGYoFgbVr17bmjey0Wc.Are you sure you want to continue connecting (yes/no)? yesWarning: Permanently added 'gitee.com,212.64.62.183' (ECDSA) to the list of known hosts.Hi TheNightIsYoung! You've successfully authenticated, but GITEE.COM does not provide shell access. 预安装环境部署至此就完成了~~~ 下面我们正式开始 Hexo 博客的搭建： Hexo 安装以及初始化NPM 安装 Hexo使用 NPM 管理工具安装 Hexo ↓↓↓↓↓↓ 在预安装环境部署中我们已经成功安装 Node.js，这里无需单独安装 npm（Node.js 中已包含了 npm），打开 Git Bash（桌面点击鼠标右键）运行以下命令安装 Hexo： 1$ npm install -g hexo-cli 回车之后，日志信息输出中可能会出现 WARN 的警告语句，不要担心，等着即可…。过一段时间如果出现hexo 版本号信息输出的语句就代表安装成功了。如下： 123456npm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@1.2.4 (node_modules\\fsevents):npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@1.2.4: wanted {&quot;os&quot;:&quot;darwin&quot;,&quot;arch&quot;:&quot;any&quot;} (current: {&quot;os&quot;:&quot;win32&quot;,&quot;arch&quot;:&quot;x64&quot;})+hexo-cli: 1.1.0audited 4700 packages in 5.05sfound 0 vulnerabilities –&gt; npm install 很慢很慢的问题，请参见博文 1.4 常见问题。 安装完后输入 hexo -v 验证是否安装成功： 123456789101112131415161718$ hexo -vhexo: 3.8.0hexo-cli: 1.1.0os: Windows_NT 10.0.17134 win32 x64http_parser: 2.8.0node: 10.15.0v8: 6.8.275.32-node.45uv: 1.23.2zlib: 1.2.11ares: 1.15.0modules: 64nghttp2: 1.34.0napi: 3openssl: 1.1.0jicu: 62.1unicode: 11.0cldr: 33.1tz: 2018e 初始化 Hexo 博客目录首先在任意一个位置新建一个文件夹，用于存放 Hexo 初始化博客文件，这里我选择 F:/HexoBlogProject ： 12$ cd F:$ mkdir HexoBlogProject 然后在 Git Bash 中依次运行以下命令来 初始化 Hexo 项目： 123$ hexo init &lt;floder&gt;$ cd &lt;floder&gt;$ npm install 实际环境测试如下： 123456789101112131415161718192021222324252627282930313233343536373839$ hexo init HexoBlogProject/INFO Cloning hexo-starter to F:\\HexoBlogProjectCloning into 'F:\\HexoBlogProject'...remote: Enumerating objects: 68, done.remote: Total 68 (delta 0), reused 0 (delta 0), pack-reused 68Unpacking objects: 100% (68/68), done.Submodule 'themes/landscape' (https://github.com/hexojs/hexo-theme-landscape.git) registered for path 'themes/landscape'Cloning into 'F:/HexoBlogProject/themes/landscape'...remote: Enumerating objects: 1, done.remote: Counting objects: 100% (1/1), done.remote: Total 867 (delta 0), reused 0 (delta 0), pack-reused 866Receiving objects: 100% (867/867), 2.55 MiB | 1.64 MiB/s, done.Resolving deltas: 100% (459/459), done.Submodule path 'themes/landscape': checked out '73a23c51f8487cfcd7c6deec96ccc7543960d350'INFO Install dependenciesnpm WARN deprecated titlecase@1.1.2: no longer maintainednpm WARN deprecated postinstall-build@5.0.3: postinstall-build's behavior is now built into npm! You should migrate off of postinstall-build and use the new `prepare` lifecycle script with npm 5.0.0 or greater.&gt; nunjucks@3.1.6 postinstall F:\\HexoBlogProject\\node_modules\\nunjucks&gt; node postinstall-build.js srcnpm notice created a lockfile as package-lock.json. You should commit this file.npm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@1.2.4 (node_modules\\fsevents):npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@1.2.4: wanted {&quot;os&quot;:&quot;darwin&quot;,&quot;arch&quot;:&quot;any&quot;} (current: {&quot;os&quot;:&quot;win32&quot;,&quot;arch&quot;:&quot;x64&quot;})added 422 packages from 501 contributors and audited 4700 packages in 23.449sfound 0 vulnerabilitiesINFO Start blogging with Hexo!$ cd HexoBlogProject/$ npm installnpm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@1.2.4 (node_modules\\fsevents):npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@1.2.4: wanted {&quot;os&quot;:&quot;darwin&quot;,&quot;arch&quot;:&quot;any&quot;} (current: {&quot;os&quot;:&quot;win32&quot;,&quot;arch&quot;:&quot;x64&quot;})audited 4700 packages in 5.05sfound 0 vulnerabilities 看到 INFO Start blogging with Hexo！ 是不很激动！！！此时我们来看一下 Hexo 初始化目录 HexoBlogProject 结构，如下： 123456789HexoBlogProject.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes HexoBlogProject 站点目录说明这一小节我们简要介绍一下站点目录结构，这将有助于我们进一步了解 Hexo 博客框架的工作原理。 1）package.json：hexo 框架的参数和所依赖插件： 12345678910111213141516171819{ &quot;name&quot;: &quot;hexo-site&quot;, &quot;version&quot;: &quot;0.0.0&quot;, &quot;private&quot;: true, &quot;hexo&quot;: { &quot;version&quot;: &quot;3.8.0&quot; }, &quot;dependencies&quot;: { &quot;hexo&quot;: &quot;^3.7.0&quot;, &quot;hexo-generator-archive&quot;: &quot;^0.1.5&quot;, &quot;hexo-generator-category&quot;: &quot;^0.1.3&quot;, &quot;hexo-generator-index&quot;: &quot;^0.2.1&quot;, &quot;hexo-generator-tag&quot;: &quot;^0.2.0&quot;, &quot;hexo-renderer-ejs&quot;: &quot;^0.3.1&quot;, &quot;hexo-renderer-stylus&quot;: &quot;^0.3.3&quot;, &quot;hexo-renderer-marked&quot;: &quot;^0.3.2&quot;, &quot;hexo-server&quot;: &quot;^0.3.1&quot; }} 2）scaffolds —&gt; 脚手架、骨架 当我们想要新建一篇文章的时候，hexo 是根据这个目录下的文件进行构建的，基本不用关心。 3）source —&gt; 博文目录 source 目录下包含一个 _posts 目录 ：需要新建的博文都放在 _posts 目录下。 _posts 目录下是一个个 MarkDown 文件。默认情况下有一个 hello-world.md 的文件，博文就在这个文件中编辑。 _posts 目录下的 MarkDown 文件，最终会被编译成 html 文件，放到 public（此文件夹现在应该没有，因为 Blog 项目初始化之后还没有编译过）文件夹下。 4）themes —&gt; 主题目录 themes 为博客网站主题目录，Hexo 有非常好的主题拓展，支持的主题也很丰富，通过更换主题会使得你的博客更加酷炫，后面的博文会教你如何更换 Hexo 主题。 \\themes 目录下每一个子目录就是一个主题，默认情况下子目录如下： 123themes.|-- landscape // 默认主题 当然我们可以下载自己满意的主题到该目录下，hexo主题传送门。 5）_config.yml —&gt; 站点配置文件： 博客站点的很多信息都在这里配置：诸如网站名称、副标题、描述、作者、语言、主题等等参数。这里我们给出 _config.yml 文件中的内容，以及主要参数说明 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Sitetitle: Hexo # 网站标题subtitle: # 网站副标题description: # 网站描述keywords:author: John Doe # 作者language: # 语言timezone: # 网站时区：Hexo 默认使用当前电脑的时区。时区列表，比如说：America/New_York, Japan, 和 UTC 。# URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: http://yoursite.com # 站点的 Urlroot: / # 站点的根目录permalink: :year/:month/:day/:title/ # 文章的“永久链接”格式 permalink_defaults: # 永久链接中各部分的默认值# Directorysource_dir: source # 资源文件夹：用来存放 hexo 内容public_dir: public # 公共文件夹：这个文件夹用于存放生成的站点文件。tag_dir: tags # 标签文件夹archive_dir: archives # 归档文件夹category_dir: categories # 分类文件夹code_dir: downloads/code # Include code 文件夹i18n_dir: :lang # 国际化（i18n）文件夹skip_render: # 跳过指定文件的渲染：可使用 glob 表达式来匹配路径# Writingnew_post_name: :title.md # File name of new posts # 新文章的文件名称default_layout: post # 预设布局titlecase: false # Transform title into titlecase # 把标题转换为 title caseexternal_link: true # Open external links in new tab # 在新标签中打开链接filename_case: 0 # 把文件名称转换为 ‘1’ 小写或 ‘2’ 大写render_drafts: false # 是否显示草稿post_asset_folder: false # 是否启动 Asset 文件夹relative_link: false # 把链接改为与根目录的相对位址 future: true # 显示未来的文章highlight: # 内容中代码块的设置 enable: true line_number: true auto_detect: false tab_replace: # Home page setting# path: Root path for your blogs index page. (default = '')# per_page: Posts displayed per page. (0 = disable pagination)# order_by: Posts order. (Order by date descending by default)index_generator: path: '' per_page: 10 order_by: -date # Category &amp; Tagdefault_category: uncategorizedcategory_map: # 分类别名tag_map: # 标签别名# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DD # 日期格式time_format: HH:mm:ss # 时间格式# Pagination## Set per_page to 0 to disable paginationper_page: 10 # 分页数量pagination_dir: page# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: landscape # 主题名称# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: # 部署部分的设置 type: # 类型：常用的是 Git 关于 HexoBlogProject 站点目录配置以及使用，后续我们进行博客配置时会具体说明，这里不再赘述。 Hexo 本地博客上面我们已经完成了 Hexo 本地博客的安装以及搭建，注意只是 本地博客（只可以在你本地运行，其他人在互联网上是看不到的）。现在我们来启动 Hexo 本地服务，进行本地博客预览测试。Git Bash 中运行以下命令： 123$ hexo server （或 hexo s）INFO Start processingINFO Hexo is running at http://localhost:4000 . Press Ctrl+C to stop. 此时，通过浏览器访问 http://localhost:4000/ ，就可以看到 Hexo 的原始博客内容，页面如下所示： 至此，我们已经可以在本地使用 Hexo 博客了。 但其实我们更加关注的是如何将 Hexo 博客发布到 Internet 上供其他人分享交流，下面我将会给出一个解决方案——将我们搭建好的本地 Hexo 博客项目推送到公共代码仓库（远程仓库）以提供公共访问。 Hexo 个人博客实施方案实施方案一：Github·PageGithub·Page 方法是将本地 Hexo 博客推送至 GithubPages 以实现公共访问： 1）首先，安装 hexo-deployer-git 插件，Git bash 下运行下面命令： 12345678910$ npm install hexo-deployer-git --savenpm WARN deprecated swig@1.4.2: This package is no longer maintainednpm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@1.2.4 (node_modules\\fsevents):npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@1.2.4: wanted {&quot;os&quot;:&quot;darwin&quot;,&quot;arch&quot;:&quot;any&quot;} (current: {&quot;os&quot;:&quot;win32&quot;,&quot;arch&quot;:&quot;x64&quot;})+ hexo-deployer-git@0.3.1added 31 packages from 36 contributors and audited 5870 packages in 11.225sfound 1 low severity vulnerability run `npm audit fix` to fix them, or `npm audit` for details 2）然后，修改站点目录下 _config.yml（站点配置文件）。修改文件末尾为： 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: git@github.com:&lt;Your github account name&gt;/&lt;Your github account name&gt;.github.io.git branch: master 实际环境测试： 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: git@github.com:TheNightIsYoung/TheNightIsYoung.github.io.git branch: master 这里，我的 Github account name（Github 账户名称）为：TheNightIsYoung。 注意：仓库地址最好使用 SSH 访问，不要填写 Http 地址。 3）将本地 Hexo 博客推送至 GithubPages，Git Bash 输入以下命令， 返回 INFO Deploy done: git 即表示成功推送： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182# 生成静态页面：$ hexo generate （或：hexo g）INFO Start processingINFO Files loaded in 272 msINFO Generated: index.htmlINFO Generated: archives/index.htmlINFO Generated: fancybox/blank.gifINFO Generated: fancybox/jquery.fancybox.cssINFO Generated: fancybox/fancybox_loading@2x.gifINFO Generated: fancybox/fancybox_loading.gifINFO Generated: archives/2019/index.htmlINFO Generated: fancybox/fancybox_sprite.pngINFO Generated: fancybox/fancybox_sprite@2x.pngINFO Generated: fancybox/fancybox_overlay.pngINFO Generated: archives/2019/01/index.htmlINFO Generated: js/script.jsINFO Generated: fancybox/helpers/jquery.fancybox-buttons.cssINFO Generated: css/fonts/FontAwesome.otfINFO Generated: fancybox/jquery.fancybox.pack.jsINFO Generated: fancybox/helpers/jquery.fancybox-buttons.jsINFO Generated: css/style.cssINFO Generated: css/fonts/fontawesome-webfont.woffINFO Generated: fancybox/helpers/jquery.fancybox-media.jsINFO Generated: fancybox/helpers/jquery.fancybox-thumbs.jsINFO Generated: fancybox/helpers/fancybox_buttons.pngINFO Generated: css/fonts/fontawesome-webfont.eotINFO Generated: fancybox/helpers/jquery.fancybox-thumbs.cssINFO Generated: css/fonts/fontawesome-webfont.svgINFO Generated: css/fonts/fontawesome-webfont.ttfINFO Generated: 2019/01/07/hello-world/index.htmlINFO Generated: fancybox/jquery.fancybox.jsINFO Generated: css/images/banner.jpgINFO 28 files generated in 650 ms# 部署至 GithubPages：$ hexo deploy （或：hexo d）INFO Deploying: gitINFO Setting up Git deployment...Initialized empty Git repository in F:/HexoBlogProject/.deploy_git/.git/[master (root-commit) 6d469d7] First commit 1 file changed, 0 insertions(+), 0 deletions(-) create mode 100644 placeholderINFO Clearing .deploy_git folder...INFO Copying files from public folder...INFO Copying files from extend dirs...[master c71b7a5] Site updated: 2019-01-08 12:03:08 29 files changed, 5777 insertions(+) create mode 100644 2019/01/07/hello-world/index.html create mode 100644 archives/2019/01/index.html create mode 100644 archives/2019/index.html create mode 100644 archives/index.html create mode 100644 css/fonts/FontAwesome.otf create mode 100644 css/fonts/fontawesome-webfont.eot create mode 100644 css/fonts/fontawesome-webfont.svg create mode 100644 css/fonts/fontawesome-webfont.ttf create mode 100644 css/fonts/fontawesome-webfont.woff create mode 100644 css/images/banner.jpg create mode 100644 css/style.css create mode 100644 fancybox/blank.gif create mode 100644 fancybox/fancybox_loading.gif create mode 100644 fancybox/fancybox_loading@2x.gif create mode 100644 fancybox/fancybox_overlay.png create mode 100644 fancybox/fancybox_sprite.png create mode 100644 fancybox/fancybox_sprite@2x.png create mode 100644 fancybox/helpers/fancybox_buttons.png create mode 100644 fancybox/helpers/jquery.fancybox-buttons.css create mode 100644 fancybox/helpers/jquery.fancybox-buttons.js create mode 100644 fancybox/helpers/jquery.fancybox-media.js create mode 100644 fancybox/helpers/jquery.fancybox-thumbs.css create mode 100644 fancybox/helpers/jquery.fancybox-thumbs.js create mode 100644 fancybox/jquery.fancybox.css create mode 100644 fancybox/jquery.fancybox.js create mode 100644 fancybox/jquery.fancybox.pack.js create mode 100644 index.html create mode 100644 js/script.js delete mode 100644 placeholderBranch 'master' set up to track remote branch 'master' from 'git@github.com:TheNightIsYoung/TheNightIsYoung.github.io.git'.To github.com:TheNightIsYoung/TheNightIsYoung.github.io.git * [new branch] HEAD -&gt; masterINFO Deploy done: git 4）通过浏览器访问网址： https://&lt;Your github account name&gt;.github.io 就可以看到和本地 hexo 博客相同页面。 ================================================= 对比 Hexo 站点目录，观察一下被推送到远程仓库的文件，你是否发现： 远程仓库中的资源文件，其实就是我们的 .../&lt;Hexo 站点目录&gt;/public 目录下的内容（博客静态页面）。简单来说，执行 hexo d 命令会将站点目录下 ：public 目录下的内容推送到远程仓库，而 Hexo 博客项目的配置文件、主题、scaffolds 等等，仍在我们本地储存维护…. 实施方案二：Github·Page + Gitee·Page使用过 Github 都知道，Github 有时候在国内访问较慢，而 Gitee 国内访问较快。故除了添加 Github 仓库外，我们可以在第一种实施方案的基础上配置 Citee·Page。 1）hexo-deployer-git 插件已经安装过，这里可以直接跳过； 2）修改站点目录下 _config.yml（站点配置文件）。修改文件末尾为： 123456789# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy:- type: git repo: git@github.com:&lt;Your github account name&gt;/&lt;Your github account name&gt;.github.io.git branch: master- type: git repo: git@gitee.com:&lt;Your coding account name&gt;/&lt;Your coding account name&gt;.git branch: master 实际环境测试： 123456789# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy:- type: git repo: git@github.com:TheNightIsYoung/TheNightIsYoung.github.io.git branch: master- type: git repo: git@gitee.com:thenightisyoung/thenightisyoung.git branch: master 这里，我的 gitee account name（Gitee 账户名称）为：thenightisyoung。 3）将本地 Hexo 博客推送至 GiteePages，Git Bash 输入以下命令， 返回 INFO Deploy done: git 即表示成功推送： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657$ hexo g$ hexo dINFO Deploying: gitINFO Setting up Git deployment...Initialized empty Git repository in F:/HexoBlogProject/.deploy_git/.git/[master (root-commit) c9fcced] First commit 1 file changed, 0 insertions(+), 0 deletions(-) create mode 100644 placeholderINFO Clearing .deploy_git folder...INFO Copying files from public folder...INFO Copying files from extend dirs...[master 498e47c] Site updated: 2019-01-08 13:55:57 29 files changed, 5777 insertions(+) create mode 100644 2019/01/07/hello-world/index.html create mode 100644 archives/2019/01/index.html create mode 100644 archives/2019/index.html create mode 100644 archives/index.html create mode 100644 css/fonts/FontAwesome.otf create mode 100644 css/fonts/fontawesome-webfont.eot create mode 100644 css/fonts/fontawesome-webfont.svg create mode 100644 css/fonts/fontawesome-webfont.ttf create mode 100644 css/fonts/fontawesome-webfont.woff create mode 100644 css/images/banner.jpg create mode 100644 css/style.css create mode 100644 fancybox/blank.gif create mode 100644 fancybox/fancybox_loading.gif create mode 100644 fancybox/fancybox_loading@2x.gif create mode 100644 fancybox/fancybox_overlay.png create mode 100644 fancybox/fancybox_sprite.png create mode 100644 fancybox/fancybox_sprite@2x.png create mode 100644 fancybox/helpers/fancybox_buttons.png create mode 100644 fancybox/helpers/jquery.fancybox-buttons.css create mode 100644 fancybox/helpers/jquery.fancybox-buttons.js create mode 100644 fancybox/helpers/jquery.fancybox-media.js create mode 100644 fancybox/helpers/jquery.fancybox-thumbs.css create mode 100644 fancybox/helpers/jquery.fancybox-thumbs.js create mode 100644 fancybox/jquery.fancybox.css create mode 100644 fancybox/jquery.fancybox.js create mode 100644 fancybox/jquery.fancybox.pack.js create mode 100644 index.html create mode 100644 js/script.js delete mode 100644 placeholderBranch 'master' set up to track remote branch 'master' from 'git@gitee.com:TheNightIsYoung/TheNightIsYoung.github.io.git'.git@gitee.com:TheNightIsYoung/TheNightIsYoung.github.io.git + c425509...498e47c HEAD -&gt; master (forced update)INFO Deploy done: gitINFO Deploying: gitINFO Clearing .deploy_git folder...INFO Copying files from public folder...INFO Copying files from extend dirs...On branch masternothing to commit, working tree cleanBranch 'master' set up to track remote branch 'master' from 'git@gitee.com:TheMusicIsLoud/TheMusicIsLoud.git'.To git.dev.tencent.com:TheMusicIsLoud/TheMusicIsLoud.git * [new branch] HEAD -&gt; masterINFO Deploy done: git ４）Gitee 还需要通过 Gitee Pages 服务 ，才能开启静态 Pages 应用（Service –&gt; Gitee Pages）。如下页面显示： 开启成功后界面如下： 5）通过浏览器访问网址： https://&lt;Your coding account name&gt;.gitee.io/ 同样也可以访问到 hexo 博客页面 12# 我的访问链接如下：https://thenightisyoung.gitee.io 实施方案三：Github·Page + Gitee·Page + domain name上面我们已经将 Hexo 个人博客远程托管到 Gihub &amp; Gitee上了。 还能不能再继续优化一下方案？？？ 问题：一方面每一次进行访问时，我们都需要通过 https://&lt;Your coding account name&gt;.coding.me 或者 https://&lt;Your github account name&gt;.gitee.io 一长串的域名来进行访问，显得非常繁琐；另一方面我们有一个闲置的域名，单纯想做域名映射，以达到通过域名即可访问我们的个人博客。 前提：你有一个闲置的自定义域名。这里你可以为 Github·Page 或者 Gitee·Page 配置域名映射，二选其一。Gitee 域名绑定目前只面向企业用户（难受），所以这里我们会将自定义域名绑定到 Github Page（Github 支持 CDN 加速快速访问）。 1）配置 Github·Page 的域名映射 1 –&gt; 域名解析（使用域名的前提）参数： 添加一条 CNAME 记录指向 &lt;Your github account name&gt;.github.io： 12345# 记录类型：选择为 CNAME# 主机记录（即域名前缀）：选择为 www# 解析线路：默认选项即可# 记录值：&lt;Your github account name&gt;.github.io# TTL：默认选项即可 注意：要确认你的域名的解析状态为正常状态！ 2 –&gt; 博客 Github 仓库设置： 首先打开博客仓库设置：https://github.com/&lt;Your github account name&gt;/&lt;Your github account name&gt;.github.io/settings 找到 Custom domain，填写好自定义域名（例如：www.xxxxxx.com），点击 save。 –&gt; 启用 Github Page HTTPS ： 自 2018 年 5 月 1 日，Github 支持自定义域名的 HTTPS 请求了，直接在 Custom domain 下勾选 Enforce HTTPS 即可开启。 配置也相当简单，只需要更新 DNS 配置里的 A 记录，将其指向以下4个 IP 地址中的至少一个。 1234185.199.108.153185.199.109.153185.199.110.153185.199.111.153 HTTPS 让你的网站和网站访客更安全，并且 Github 提供的这些 IP 地址自动将你的站点加入了 CDN，提高了访问速度（真香~）。 3 –&gt; 在 Hexo 站点目录中的 public 目录下创建 CNAME 文件，内容如下： www.xxxxxx.com 部署： 1$ hexo d 4 –&gt; 等待一段时间（域名生效时间，10分钟左右）后，我们发现已经可以通过我们的域名访问到个人博客了。 2）配置 Gitee·Page 的域名映射（Gitee Page Pro） 当前 Gitee Page Pro 是支持自定义域名版本的 Gitee Page，留一个小期待吧，希望码农后续可以支持普通用户的 Gitee·Pages 绑定自定义域名，持续关注 。 未来可期，配置相同 –&gt; 在上述 配置 Github·Page 的域名映射 基础上进行如下设置，即可将域名指向 &lt;Your gitee account name&gt;.gitee.io： 1 –&gt; 域名解析（使用域名的前提）参数： 添加一条 CNAME 记录指向 &lt;Your gitee account name&gt;.gitee.io： 12345# 记录类型：选择为 CNAME# 主机记录（即域名前缀）：选择为 www# 解析线路：默认选项即可# 记录值：&lt;Your gitee account name&gt;.gitee.io# TTL：默认选项即可 注意：要确认域名解析状态为正常状态！ 2 –&gt; 打开 Pages 服务, 进行域名绑定即可。 至此，你就可以通过你的自定义域名进行 Hexo 博客的访问了。 Problem &amp;&amp; Solution1）Github·Page 配置域名绑定问题 问题描述：Github·Page 项目成功绑定了自定义域名之后，可以正常通过域名进行站点访问了。但发现一个现象，在部署上传新的文章后，访问又双叒变成了 404 ？？？ WTF！？在我打算再次重新配置 Github·Page 的时候，我突然发现仓库 Settings 页面绑定域名的那一栏变成空了，是谁动了我的奶酪？？？ 度娘上查到，在为 Github·Page 配置域名绑定之后，会在当前仓库中自动生成一个 CNAME 文件（你可以重新 Save 域名试一下），查看 CNAME 文件内容： 12# 只有一行语句，就是你的域名your domain name 而我们在 hexo d 重新部署之后，发现 CNAME 文件不见了。 你很容易可以想到，hexo d 时，Hexo 会将 public 目录中的文件和目录推送至远端仓库指定分支中，并且完全覆盖该分支下的已有内容。 也即是说，前面我们在 “实施方案一：Github·Page” 配置过程中，由于 public 文件下没有 CNAME 文件，导致远程仓库中的域名绑定相关的 CNAME 文件 被覆盖掉了，≧ ﹏ ≦ 知道了原因，下面我们给出解决方法： 我们知道，站点目录下 public 中的文件是由 source 文件夹的内容生成的。我们尝试一下在 source 目录下添加一个 Github·Page 需要的 CNAME 文件 ，内容如下； 12# 我的域名www.orangeshare.cn 然后执行如下命令，清除以及重新生成静态页面内容： 12$ hexo clean$ hexo g 可以观察到，重新生成的 public 目录下，已经包含 CNAME 文件 了，有点小激动啊~ 再次 hexo d 推送试一下。成功了 O(∩_∩)O 2）Gitee·Page 推送问题 问题描述：Gitee·Page 配置成功之后，可以正常通过 https://&lt;Your coding account name&gt;.gitee.io 进行站点访问了。但发现一个现象，在部署推送新的文章后，访问 Gitee·Page 页面时新推送博文内容没有更新？？？ 这时，你需要进入 Gitee Pages 服务设置页面，重新刷新部署页面（Update），如下（黄色 Update 按钮）： 等待大概 30s 左右部署完成，重新访问页面发现：Gitee·Page 页面已可以查看到新推送的博文~~~","link":"/2017/09/20/yi-wen-xue-hui-hexo-qing-liang-ji-kuang-jia-de-bo-ke-da-jian-chi-xu-geng-xin/"},{"title":"使用 VSCode 搭建一个惊人的 Markdown Editor","text":"本文使用 Visual Studio Code 构建了一个出色的，不逊色于其它任何一款的 Markdown 编辑器 环境。 本环境中实现了最基本的实时 Markdown 效果预览（所见即所得），语法规范（Markdown linting）以及基于 Md 原文档快速生成 Html、Docx 和 PDF 文档的能力，并具有生成许多其他格式文档（jpeg、png）的潜力。当然你也可以基于此环境，并且结合个人需要进行适当的功能或插件扩展。 博主在安装配置使用过程中查阅了网络上很多的相关博文，也遇到过很多的问题，为了感谢学习过程中各位大佬的帮助以及分享给更多的新手使用，以作此文。文中如有表述不正确的地方，望各位大佬不吝指正~~~ 话不多说，下面正式开始基于 VS Code 的 MarkDown 编译器环境搭建 &gt;&gt;&gt; Pre-installed Preparation开始本博文学习之前，你需要有 必要的 VS Code &amp;&amp; MarkDown 基础概念储备。其中， 更多 VS Code 相关内容，请关注博主 Visual Studio Code 博文系列 ↓↓↓↓↓↓↓↓ 之一 &gt;&gt;&gt; Visual Studio Code (VS Code) 你们都在用吗 ? 之二 &gt;&gt;&gt; 玩转 VSCode 之配置远程开发环境 之三 &gt;&gt;&gt; 玩转 VSCode 之配置 C/C++ 语言开发环境 之四 &gt;&gt;&gt; 玩转 VSCode 之配置 Python 语言开发环境 更多 MarkDown 相关内容，请关注博主 Hexo 博文系列 ↓↓↓↓↓↓↓↓ &gt;&gt;&gt; 打造沉浸式写作体验，你需要试试-Markdown-Editor 相信通过对上述内容的学习：你已经拥有了一个 VS Code 编辑器，并且已经掌握了基础的 MarkDown 语法规范。 熟悉 VS Code 开箱即用的 MarkDown 功能VS Code 系统中内置了许多基本的，开箱即用的 MarkDown 功能，你无需安装任何插件就可以使用。 下面，让我们来探索一下这些作为你成为 MarkDown 专家的第一步。 编辑 MarkDown 项目我们知道：VScode 中所有操作都是基于文件和文件夹的，但我们更多强调的是 VSCode 以文件夹的形式来组织管理工程项目（当然，你可以仅仅操作一个 md 文件）。 故，首先你可以创建一个单独用来存储所有 Markdown 文档的文件夹，这里我的为：MarkDownWSC。你可以将其看作是 Markdown 文档的一个存储仓库，不只是单个文件的编辑，这对于一次性创建和编辑给定的许多文档都非常方便。 接下来，在 VS Code 中以打开文件夹（Ctrl + K + O）的方式，打开 MarkDownWSC 文件夹。 然后创建一个 HelloWorld.md 的 Markdown 文件，并依据 Markdown 语法规范编辑以下内容： 1234567# Head 1## Head 2### Head 2Hello, welcome to markdown world!We will learn how to operate MarkDown in vscode. 也就是说，和普通文本编辑器一样，VS Code 也支持 Markdown 文档的编辑。 同时，你可以借鉴前面我们在 VSCode 项目管理机制 中提到过的 单项目管理和配置，VS Code 也允许我们 创建 几个 跟当前文件夹或者跟 Markdown 项目有关的配置文件。在这些配置文件中，你可以进行和 Markdown 编辑、渲染、插件使用等有关的所有配置（使用文件夹设置 .vscode\\settings.json）。 尝试 Markdown 预览器和普通文本编辑器不同的是，VS Code 系统还内置了一个 Markdown 的预览器，这可以帮助我们一边编辑 Markdown 文档内容，一边实时地预览效果。 VS Code 中，提供了两种预览方式： [1] &gt;&gt;&gt;&gt; 通过快捷键 [Ctrl + Shift + V]，单独打开一个 HTML 风格的 MarkDown 代码预览窗口，进行效果查看。 [2] &gt;&gt;&gt;&gt; 通过快捷键 [Ctrl + K V]，来打开一个位于右侧的，侧边预览窗口。额外的，你可以在左侧窗格的 Markdown 文档中添加文本，并在右侧的 HTML 预览窗格中查看这些更改（推荐）。 Config User Snippets For MarkDown对于编辑 Markdown 文档而言，User Snippets（代码片段）的使用可以极大的提高你的创作效率。 VS Code 中，你可以通过 &gt;&gt;&gt;&gt; 打开命令面板 [Ctrl + Shift + P] &gt;&gt;&gt;&gt; 选择 [Snippets: Configure User Snippets] &gt;&gt;&gt;&gt; 选择打开 [markdown.json (Markdown)] 文件，默认配置文件内容如下： 123456789101112131415{ // Place your snippets for markdown here. Each snippet is defined under a snippet name and has a prefix, body and // description. The prefix is what is used to trigger the snippet and the body will be expanded and inserted. Possible variables are: // $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. Placeholders with the // same ids are connected. // Example: // &quot;Print to console&quot;: { // &quot;prefix&quot;: &quot;log&quot;, // &quot;body&quot;: [ // &quot;console.log('$1');&quot;, // &quot;$2&quot; // ], // &quot;description&quot;: &quot;Log output to console&quot; // }} 同时，你需要在项目组织目录 MarkDownWSC/.vscode 下的配置文件 settings.json 中开启 User Snippets 开关： 123456789{&quot;[markdown]&quot;: { &quot;editor.quickSuggestions&quot;: { &quot;comments&quot;: &quot;off&quot;, &quot;strings&quot;: &quot;off&quot;, &quot;other&quot;: &quot;on&quot; }}} 配置完成之后，如何自定义我们需要的 Snippets 呢？！！！事实上，在 markdown.json 上面有一大段注释的代码，提供了一个 Example 例子： 1234# &quot;Print to console&quot; &gt;&gt;&gt;&gt; 快捷语句的标题# &quot;prefix&quot; &gt;&gt;&gt;&gt; 快捷语句触发的关键字# &quot;body&quot; &gt;&gt;&gt;&gt; 快捷语句触发后的代码，使用 `$1`，`$2` 等指定光标位置。这些数字指定了光标跳转的顺序。特别地，`$0` 表示最终光标位置# &quot;description&quot; &gt;&gt;&gt;&gt; 快捷语句的功能描述 你可以取消掉 Example 注释，通过 log 触发一下。 这里，我自己写了一些比较常用的 Markdown 片段供你参考： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990&quot;Print to ```shell```&quot;:{ &quot;prefix&quot;: &quot;```shell&quot;, &quot;body&quot;: [ &quot;```shell&quot;, &quot;$1&quot;, &quot;```&quot; ], &quot;description&quot;: &quot;build code snippets of [shell]&quot;},&quot;Print to ```bash```&quot;:{ &quot;prefix&quot;: &quot;```bash&quot;, &quot;body&quot;: [ &quot;```bash&quot;, &quot;$1&quot;, &quot;```&quot; ], &quot;description&quot;: &quot;build code snippets of [bash]&quot;},&quot;Print to ```javascript```&quot;:{ &quot;prefix&quot;: &quot;```javascript&quot;, &quot;body&quot;: [ &quot;```javascript&quot;, &quot;$1&quot;, &quot;```&quot; ], &quot;description&quot;: &quot;build code snippets of [javascript]&quot;},&quot;Print to ```css```&quot;:{ &quot;prefix&quot;: &quot;```css&quot;, &quot;body&quot;: [ &quot;```css&quot;, &quot;$1&quot;, &quot;```&quot; ], &quot;description&quot;: &quot;build code snippets of [css]&quot;},&quot;Print to ```html```&quot;:{ &quot;prefix&quot;: &quot;```html&quot;, &quot;body&quot;: [ &quot;```html&quot;, &quot;$1&quot;, &quot;```&quot; ], &quot;description&quot;: &quot;build code snippets of [html]&quot;},&quot;Print to ```python```&quot;:{ &quot;prefix&quot;: &quot;```python&quot;, &quot;body&quot;: [ &quot;```python&quot;, &quot;$1&quot;, &quot;```&quot; ], &quot;description&quot;: &quot;build code snippets of [python]&quot;},&quot;Print to ```java```&quot;:{ &quot;prefix&quot;: &quot;```java&quot;, &quot;body&quot;: [ &quot;```java&quot;, &quot;$1&quot;, &quot;```&quot; ], &quot;description&quot;: &quot;build code snippets of [java]&quot;},&quot;Print to ```yaml```&quot;:{ &quot;prefix&quot;: &quot;```yaml&quot;, &quot;body&quot;: [ &quot;```yaml&quot;, &quot;$1&quot;, &quot;```&quot; ], &quot;description&quot;: &quot;build code snippets of [yaml]&quot;},&quot;Print to ```text```&quot;:{ &quot;prefix&quot;: &quot;```text&quot;, &quot;body&quot;: [ &quot;```text&quot;, &quot;$1&quot;, &quot;```&quot; ], &quot;description&quot;: &quot;build code snippets of [text]&quot;},&quot;Print to ```json```&quot;:{ &quot;prefix&quot;: &quot;```json&quot;, &quot;body&quot;: [ &quot;```json&quot;, &quot;$1&quot;, &quot;```&quot; ], &quot;description&quot;: &quot;build code snippets of [json]&quot;} 除了 VSCode 开箱即用的功能外，为了创建更好的 MarkDown 编辑环境，我们需要借助其它插件来为 VSCode 添加额外的 MarkDown 功能。 事实上，这和基于 VSCode 搭建各种语言（Python、C、C++）开发环境类似，配置 MarkDown 编辑环境就是 &gt;&gt;&gt;&gt; 组合安装、配置多种 MarkDown 相关插件的过程。 Description Of Optional Extensions你在查阅资料的过程中，可能了解到很多的插件推荐安装博文。 这里，首先我会对网络上主流的 MarkDown 插件功能进行简单介绍，然后通过完成对不同插件的主要功能测试，结合使用效果，给出本文所采用的插件搭配推荐方案。 希望这一小节学习后，你可以自主决定 &gt;&gt;&gt;&gt; 你个人的 MarkDown（In VSCode）环境插件搭配方案 &lt;&lt;&lt;&lt; （这里更重要的是为你提供一种插件选择搭配的参考思路） 需要说明的，下文关于【插件评价】仅代表我个人的观点，是根据我个人的认知以及使用习惯来进行推荐的，不代表所有！！！ 目前，网络上推荐安装的主流的 Markdown 插件有： Markdown All in OneExtensions search &gt;&gt;&gt;&gt; Markdown All in One [Yu Zhang] &gt;&gt;&gt;&gt; 该插件功能如其名，集成了编辑 Markdown 文档时所需要的大部分功能（All in One）。 其主要功能包括： Markdown 样式快捷键支持 目录支持 列表自动化处理和表格的自动格式化 数学公式支持（KaTeX） 自动补全 可以看出，日常使用已经足够了，这也是伴随无数人在 VS Code 中最早体验的 Markdown 扩展了。 插件评价 &gt;&gt;&gt;&gt; 可作为 Markdown 环境基础插件（可选，功能较多，效果一般），搭配其它提供额外功能的 专用功能插件 使用。 Markdown LintExtensions search &gt;&gt;&gt;&gt; markdownlint [David Anson] &gt;&gt;&gt;&gt; Markdown 代码检查工具，用于规范编辑时的 Markdown 语法。 Markdown 默认的语法格式相当的宽泛，你可以下载并遵循这个插件的规范，极大程度上可以帮助你编辑出具有统一规范格式的 Markdown 文档。为 Markdown 开发提供便利，同时又大幅节省了自己制定语法规范的成本。 这里，我们给出 Markdown Lint 语法规范的 &gt;&gt;&gt;&gt; 警告信息表 &lt;&lt;&lt;&lt; 以便查询解决 ↓↓↓↓↓ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128# MD001 - Heading levels should only increment by one level at a timeDescription &gt;&gt;&gt;&gt; 标题级数只能依次创建，不能隔级创建，必须 h1-h2-h3... 这样# MD002 - First heading should be a top level headingDescription &gt;&gt;&gt;&gt; 文档的第一个标题必须是最高级的标题，也就是 h1# MD003 - Heading styleDescription &gt;&gt;&gt;&gt; 整篇文档的标题格式要采取统一的，例如保持：`### XXX ###`# MD004 - Unordered list styleDescription &gt;&gt;&gt;&gt; 整篇文档的无序列表的格式要一致# MD005 - Inconsistent indentation for list items at the same levelDescription &gt;&gt;&gt;&gt; 同一个等级的列表的缩进要一致# MD006 - Consider starting bulleted lists at the beginning of the lineDescription &gt;&gt;&gt;&gt; 一级标题不能够缩进# MD007 - Unordered list indentationDescription &gt;&gt;&gt;&gt; 无序列表嵌套的时，默认采取两个空格的缩进方式# MD009 - Trailing spaces [Expected: 0 or 2; Actual: 1]Description &gt;&gt;&gt;&gt; 行尾空格数为 0 或 2，为 1 或超出 2 之后会有警告，其中两个空格表示换行# MD010 - Hard tabsDescription &gt;&gt;&gt;&gt; 不能使用 tab 来进行缩进，要使用空格# MD011 - Reversed link syntaxDescription &gt;&gt;&gt;&gt; 内联形式的链接和创建方式是否错误，中括号和圆括号是否使用正确# MD012 - Multiple consecutive blank linesDescription &gt;&gt;&gt;&gt; 文档中不能有连续的空行，在代码块中这个规则不会生效# MD013 - Line lengthDescription &gt;&gt;&gt;&gt; 默认行的最大长度是 80，对表格代码块标题都起效果# MD014 - Dollar signs used before commands without showing outputDescription &gt;&gt;&gt;&gt; 在代码块中，终端命令前面不需要有美元符号，如果如果代码块中既有终端命令，也有命令的输出，则终端命令前可以有美元符号($)# MD018 - No space after hash on atx style headingDescription &gt;&gt;&gt;&gt; 标题格式如果是 &quot;atx&quot; 的话，在 # 号和文字之间需要一个空格隔开# MD019 - Multiple spaces after hash on atx style headingDescription &gt;&gt;&gt;&gt; 标题格式如果是 &quot;atx&quot; 的话，在 # 号和文字之间只需要一个空格隔开，不需要多个# MD020 - No space inside hashes on closed atx style headingDescription &gt;&gt;&gt;&gt; 在 closed_atx 格式的标题中，文字和前后的 # 号之间都需要一个空格隔开# MD021 - Multiple spaces inside hashes on closed atx style headingDescription &gt;&gt;&gt;&gt; 在 closed_atx 格式的标题中，文字和前后的 # 号之间只需要一个空格隔开，不能有多余的# MD022 - Headings should be surrounded by blank linesDescription &gt;&gt;&gt;&gt; 标题的上下行必须都是空格# MD023 - Headings must start at the beginning of the lineDescription &gt;&gt;&gt;&gt; 标题行不能缩进# MD024 - Multiple headings with the same contentDescription &gt;&gt;&gt;&gt; 在文档中不能有重复性的标题# MD025 - Multiple top level headings in the same documentDescription &gt;&gt;&gt;&gt; 同一个文档中，只能有一个最高级的标题，即默认只能有一个一级标题 # XX #；文档开头处的 Front Matter 中的 title，可作为文档的最高级（一级）标题# MD026 - Trailing punctuation in headingDescription &gt;&gt;&gt;&gt; 标题的末尾不能有 &quot;. , ; : ! ?&quot; 这些符号# MD027 - Multiple spaces after blockquote symbolDescription &gt;&gt;&gt;&gt; 在创建引用块的时候，右尖号与文字之间必须有且只有一个空格# MD028 - Blank line inside blockquoteDescription &gt;&gt;&gt;&gt; 两个引用区块间不能仅用一个空行隔开，或者说同一引用区块中不能有空行；如果一行中没有内容，则这一行也要用 &gt; 开头# MD029 - Ordered list item prefixDescription &gt;&gt;&gt;&gt; 有序列表的前缀序号格式必须只用1或者从1开始的加1递增数字# MD030 - Spaces after list markersDescription &gt;&gt;&gt;&gt; 列表（有序、无序）的前缀符号和文字之间用 1 个空格隔开；在列表嵌套或者同一列表项中有多个段落时，无序列表缩进两个空格，有序列表缩进 3 个空格# MD031 - Fenced code blocks should be surrounded by blank linesDescription &gt;&gt;&gt;&gt; 单独的代码块前后需要用空行隔开（除非是在文档开头或末尾），否则有些解释器不会解释为代码块# MD032 - Lists should be surrounded by blank linesDescription &gt;&gt;&gt;&gt; 列表（有序、无序）前后需要用空行隔开，否则有些解释器不会解释为列表；列表的缩进必须一致，否则会警告# MD033 - Inline HTMLDescription &gt;&gt;&gt;&gt; 文档中不允许使用 html 语句# MD034 - Bare URL usedDescription &gt;&gt;&gt;&gt; 单纯的链接地址需要用尖括号 &lt;&gt; 包裹，否则有些解释器不会解释为链接# MD035 - Horizontal rule styleDescription &gt;&gt;&gt;&gt; 创建水平线时整篇文档要统一，要和文档中第一次创建水平线使用的符号一致# MD036 - Emphasis used instead of a headingDescription &gt;&gt;&gt;&gt; 不能用强调来代替标题 **xxx**# MD037 - Spaces inside emphasis markersDescription &gt;&gt;&gt;&gt; 强调的符号和文字之间不能有空格# MD038 - Spaces inside code span elementsDescription &gt;&gt;&gt;&gt; 当用单反引号创建代码段的时候，单反引号和它们之间的代码不能有空格；如果要把单反引号嵌入到代码段的首尾，创建代码段的单反引号和嵌入的单反引号间要有一个空格隔开# MD039 - Spaces inside link textDescription &gt;&gt;&gt;&gt; 链接名和包围它的中括号之间不能有空格，但链接名中间可以有空格# MD040 - Fenced code blocks should have a language specifiedDescription &gt;&gt;&gt;&gt; 单独的代码块（此处是指上下用三个反引号包围的代码块）应该指定代码块的编程语言，这一点有助于解释器对代码进行代码高亮# MD041 - First line in file should be a top level headingDescription &gt;&gt;&gt;&gt; 文档的第一个非空行应该是文档最高级的标题，默认是 1 级标题# MD042 - No empty linksDescription &gt;&gt;&gt;&gt; 链接的地址不能为空# MD043 - Required heading structureDescription &gt;&gt;&gt;&gt; 要求标题遵循一定的结构，默认是没有规定的结构# MD044 - Proper names should have the correct capitalizationDescription &gt;&gt;&gt;&gt; 指定一些名称，会检查它是否有正确的大写，例如（names 参数）指定：JavaScript，写成 javaScript &amp;&amp; javascript 会被检测# MD045 - Images should have alternate text (alt text)Description &gt;&gt;&gt;&gt; 图片链接必须包含描述文本 all text# MD046 - Code block styleDescription &gt;&gt;&gt;&gt; 整篇文档采用一致的代码格式# MD047 - Files should end with a single newline characterDescription &gt;&gt;&gt;&gt; 文档末尾需要一个空行结尾 事实上，有时候我们想要屏蔽 Markdown Lint 对某些警告信息的检测，你可以在用户配置文件（settings.json）中添加如下配置： 1234567&quot;markdownlint.config&quot;: { &quot;default&quot;: true, &quot;MD014&quot;: false, // 警用 代码内美元符号限制 警告 &quot;MD033&quot;: false, // 警用 HTML 标签使用 警告 &quot;MD036&quot;: false, // 警用 强调来代替标题 检测警告 &quot;MD045&quot;: false // 警用 图片链接必须包含描述文本 警告} | ================================== Split Line ===================================== | 插件评价 &gt;&gt;&gt;&gt; 必备插件（必选），以提供 Markdown 代码检查功能。 Markdown ShortcutsExtensions search &gt;&gt;&gt;&gt; Markdown Shortcuts [Mdickin] &gt;&gt;&gt;&gt; 提供编写 Markdown 的高效快捷键支持，可以极大的帮助你提高 Markdown 编辑的效率。 通过特定的快捷键，你可以实现一键加粗、插入代码块、插入引用、添加不同等级标题等等 …….实现类似于 MarkdownPad、Typora、Aton 中的快捷操作，提高你的创作效率。 该功能和插件 Markdown All in One 子功能有重叠，其中少部分快捷键可能与 Markdown All in One 冲突，实际测试时以该插件为高优先级。当然了，你也可以自行修改快捷键设置来解决冲突。 但是需要考虑到的一个问题就是 &gt;&gt;&gt;&gt; 为了保证插件快捷键符合 “大众” 习惯，并且和 VS Code 系统自身快捷键兼容，快捷键设置成本增加 &gt;&gt;&gt;&gt; 快捷键记忆成本大幅度增加。 插件评价 &gt;&gt;&gt;&gt; 一般插件（可选），我个人更倾向于使用 Markdown 自身语法格式（可配合 User Snippets 使用）。 Markdown+MathExtensions search &gt;&gt;&gt;&gt; Markdown+Math [Goessner] &gt;&gt;&gt;&gt; 使用 KaTeX 引擎，提供数学公式渲染（用于 Markdown 对公式进行正常显示）。 虽然和 Markdown All in One 子功能（Math）都是使用 KaTeX 引擎，但渲染效果更好。使用时需要将 Markdown All in One 的 math.enabled 取消掉。 插件评价 &gt;&gt;&gt;&gt; 一般插件（可选），更多的是在不支持数学公式的 Markdown 环境中作为补充插件或增强公式渲染使用。 Markdown Preview Github StylingExtensions search &gt;&gt;&gt;&gt; Markdown Preview Github Styling [Matt Bierner] &gt;&gt;&gt;&gt; 提供 Github 样式的 Markdown 文档预览。 VS Code 开箱即用的 Markdown 预览器预览效果一般，该插件可以将其修改为 Github 风格的预览样式。 插件评价 &gt;&gt;&gt;&gt; 一般插件（可选），可在不支持更好预览模式的环境中提供 Github 样式的 Markdown 文档预览。 Markdown PDF &amp;&amp; Pandoc写好的 Markdown 文档是为了分享给其他人查看的，而其结果的展示需要使用专用编译器，或者安装特定的查看扩展。 那么，VS Code 中有没有相关的插件，可以将撰写好的 Markdown 文档转化为常见的 PDF、Docx 文件，甚至是可在浏览器查看的 HTML 文档？？？这就能够结合 Markdown 编译的简便性和 PDF 等文档的通用性，使得文档编写和修改过程效率更高。 当然是有的，这里提供两种方法，你可以根据个人需求选择适合自己的方法： 1. Markdown PDF2. VSCode-Pandoc + Pandoc 事实上，任何可以将 Markdown 文档输出为 HTML 格式的插件（例如：Markdown All In One &amp;&amp; Markdown+Math）均可以实现 PDF 的导出（浏览器打开 HTML 格式页面后，选择存储为 PDF 即可）。但考虑到转化效果以及其它格式的转化，需要更进一步了解上面的两种方法。 下面分别来看两种方法的介绍、安装以及配置过程： Markdown PDFExtensions search &gt;&gt;&gt;&gt; Markdown PDF [Yzane] &gt;&gt;&gt;&gt; Convert Markdown to PDF（HTML &amp;&amp; PNG &amp;&amp; JPEG）。 尽管好多人都说，Markdown PDF 插件不支持 LaTex，导出效果不好，要弃坑云云….之类的。 但我仍然将其列为一个一般（可选）插件，这是出于相对于其它插件复杂的安装、配置以及对 VS Code 的性能影响，通过简单配置的 Markdown PDF 插件对于 Markdown 文档构建一个表现较好的 PDF（HTML &amp;&amp; PNG &amp;&amp; JPEG）已足够满足日常需要了。 1] &gt;&gt;&gt;&gt; 安装问题 Markdown PDF 插件专门用来为 Markdown 文档导出其 PDF 格式，需要搭配 Chrome 浏览器（实际上基于 Chromium 内核的浏览器都可以）。插件安装成功后，等待 Chromium 自动安装（可在右下角消息中心关注其下载状态）。 若下载失败，可以通过项目配置文件夹 MarkDownWSC/.vscode 下创建 settings.json 配置文件，来指定 Chrome 程序路径： 123{&quot;markdown-pdf.executablePath&quot;: &quot;C:\\\\.....&quot;,} 2] &gt;&gt;&gt;&gt; 导出 PDF 在 Md 文档中，点击右键，出现如下选项（根据需要选择）： 123456markdown-pdf: Export (settings.json)markdown-pdf: Export (pdf)markdown-pdf: Export (html)markdown-pdf: Export (png)markdown-pdf: Export (jpeg)markdown-pdf: Export (all: pdf, html, png, jpeg) 3] &gt;&gt;&gt;&gt; 导出优化 针对 “导出 PDF 格式不好” &amp;&amp; “不支持公式显示” 的问题，做如下配置： | &gt;&gt;&gt;&gt; 3.1 自定义 CSS 文件，优化导出 PDF 样式 Markdown PDF 插件直接导出 PDF 格式并不够美观，中文字体显示有很大问题。可以采用自定义 CSS 样式来美化导出 PDF。 你不会自定义 CSS 样式也没关系，你可从网络上下载大佬们写好的、非常漂亮的 CSS 格式文件（或直接复制内容到本地） &gt;&gt;&gt;&gt; Markdown CSS Theme，你可以先从仓库里面的 markdownX.css 文档系列中随意 Copy 一份，在项目文件夹 MarkDownWSC 下创建 css/markdownX.css 作为你个人的 CSS 样式文件。 然后，通过项目配置文件夹 MarkDownWSC/.vscode 下的 settings.json 配置 CSS 样式文件，内容如下： 1&quot;markdown-pdf.styles&quot;: [&quot;css/markdownX.css&quot;] 配置好后，你可以和默认导出 PDF 格式对比一下设置自定义 CSS 样式后的效果（不满意还可以使用其它 CSS，或真正的自定义你的 CSS 样式表）。 | &gt;&gt;&gt;&gt; 3.2. 数学公式显示优化 仅仅通过在 Markdown 文档中任意位置，引入 MathJax 标签 就可以正常显示了。标签内容如下： 12&lt;script type=&quot;text/javascript&quot; src=&quot;http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/x-mathjax-config&quot;&gt; MathJax.Hub.Config({ tex2jax: {inlineMath: [['$', '$']]}, messageStyle: &quot;none&quot; });&lt;/script&gt; 重新生成 PDF 文件，可以发现文档中公式已经可以正常显示了。 | =========================== Split Line =========================== | 插件评价 &gt;&gt;&gt;&gt; 可选插件，通过简单安装、配置以实现一个具有良好表现（取决于自定义 CSS 样式表）的日常 [Markdown &gt;&gt; PDF] 转换工具。 VSCode-Pandoc + PandocExtensions search &gt;&gt;&gt;&gt; vscode-pandoc [DougFinke] &gt;&gt;&gt;&gt; Renders markdown through pandoc。 如上，插件 vscode-pandoc 的功能是，仅仅是使用 Pandoc 工具来渲染 Markdown 文档。因此你还需要在当前操作系统中下载以及安装 Pandoc 文档转换工具。 Pandoc 不依赖 VS Code 编辑器，适用于多款支持 Pandoc 的编辑器（如：Typora 等）。它可以将文档 Markdown、LaTeX、HTML、Word docx 等多种标记格式之间相互转换，并支持输出 PDF、EPUB、HTML 幻灯片等多种格式。 1] &gt;&gt;&gt;&gt; Pandoc 安装 首先，你需要按照 Pandoc 安装页面 上的说明安装 Pandoc，这里提供了不同平台下 Pandoc 安装方法。 事实上，如果条件允许的话，你还可以使用 conda 或者 pip 进行 Pandoc 进行安装。 安装完成之后，可以在 DOS || Bash 中，使用 pandoc --version 命令来检查 Pandoc 是否可用。如果输出如下信息表示已安装配置成功；否者你需要在添加 [环境变量] 之后再进行尝试： 1234567pandoc.exe 2.12Compiled with pandoc-types 1.22, texmath 0.12.1.1, skylighting 0.10.4,citeproc 0.3.0.8, ipynb 0.1.0.1User data directory: C:\\Users\\XXXXXXX\\AppData\\Roaming\\pandocCopyright (C) 2006-2021 John MacFarlane. Web: https://pandoc.orgThis is free software; see the source for copying conditions. There is nowarranty, not even for merchantability or fitness for a particular purpose. 2] &gt;&gt;&gt;&gt; 导出 HTML &amp;&amp; Docx &amp;&amp; PDF | &gt;&gt;&gt;&gt; 2.1. DOS（Bash） Demo Pandoc 安装完成之后就可以在命令行下正常使用了（不考虑 VSCode），我们先来看如何导出 &gt;&gt;&gt;&gt; HTML &amp;&amp; Docx ： 12345678910111213# 1. Markdown &gt;&gt;&gt;&gt; HTML$ pandoc -s -f gfm -t html5 --css=css/markdownPad-github.css test.md -o test.html# 参数说明：# -s &gt;&gt;&gt;&gt; 表示使用标准模板输出# -f &gt;&gt;&gt;&gt; 显示指定输入格式；-t &gt;&gt;&gt;&gt; 显示指定输出格式# -f gfm -t html5 &gt;&gt;&gt;&gt; 表示：用 GFM 引擎来解析，从 Github Flavored MarkDown 到 HTML5# --css=xxx &gt;&gt;&gt;&gt; 表示：自定义 CSS 样式表，xxx 表示样式表路径# test.md -o test.html &gt;&gt;&gt;&gt; 表示：把 `test.md` 这个 MarkDown 文件输出成同名的 `test.html` 文件# 2. Markdown &gt;&gt;&gt;&gt; Docx$ pandoc test.md -o test.docx 来看如何导出 &gt;&gt;&gt;&gt; PDF ： 123456789101112131415# 2. Markdown &gt;&gt;&gt;&gt; PDF$ pandoc test.md -o test.pdf# 报错了：Error producing PDF.! Package inputenc Error: Unicode character 安 (U+5B89)(inputenc) not set up for use with LaTeX.See the inputenc package documentation for explanation.Type H &lt;return&gt; for immediate help. ...l.94 ...��}\\label{jorek-ux5b89ux88c5ux624bux518c}}Try running pandoc with --pdf-engine=xelatex. 这是由于 Pandoc 生成 PDF 文件需要使用 PDF 排版工具或引擎（--pdf-engine=xelatex），网络上推荐安装什么 MikTex、TexLive、CTex，这有啥区别啊？！！事实上，他们都是 TeX 排版系统的发行版，都内置了常用的文档编译器（编译引擎）：xelatex、lualatex、pdflatex。我们需要确认的是： LaTeX 是安装在原生 Windows 里还是 WSL 里？ 安装 TeXLive 还是 MiKTeX？ 平时编译的时候使用哪个编译器？（XeLaTeX or LuaLaTeX or pdfLaTeX） 网络上一个大佬进行了相关的测试（传送门），可以作为我们选择的依据： 12345# LaTeX配置安装大对比：TeXLive/MiKTeX、Windows/WSL；xelatex/lualatex/pdflatex 编译器的速度性能详细对比1. WSL &gt; Windows 原生2. TeXLive ≈ MiKTeX（个人推荐：MiKTeX For Windows；TeXLive For WSL）3. pdfLaTeX &gt; XeLaTeX &gt; LuaLaTeX TeXLive &amp;&amp; MiKTeX 安装问题 &gt;&gt;&gt;&gt; 会涉及到宏包（.sty）安装 &gt;&gt;&gt;&gt; MikTex 支持在编译（文档渲染）过程中提示哪个 sty（宏包） 文件缺失，提示你下载，解决了所有宏包缺失后，才可以编译导出最终的 PDF 文档；而 TexLive 不支持在编译过程中下载缺失宏包，安装时就会把所有 sty 都下载下来。 MikTex 下载完成后，需要更新 MikTex Console（Win Search），更新后如果命令执行仍有错误信息，可以定位日志文件将其中错误的 log 都删除掉即可。安装成功后，你可以在 MiKTeX\\miktex\\bin\\x64 目录下找到 xelatex、lualatex、pdflatex 渲染工具。 再来看如何导出 &gt;&gt;&gt;&gt; PDF ： 123# 指定渲染引擎：--pdf-engine=xelatex# 很多博客上仍使用的是 `--latex-engin` 参数（已被移除），使用会报错：`latex-engine has been removed. Use --pdf-engine instead.`$ pandoc --pdf-engine=xelatex test.md -o test.pdf 如果 Markdown（test.md）文档中包含中文，虽然编译（渲染）过程中不再出现错误，但是会显示如下警告，并且编译好的 PDF 文件中并没有中文。 12[WARNING] Missing character: There is no 安 (U+5B89) in font [lmroman12-bold]:mapping=tex-text;![WARNING] Missing character: There is no 装 (U+88C5) in font [lmroman12-bold]:mapping=tex-text;! 这是由于 xelatex 引擎默认字体不支持中文字符，添加字体设置参数：-V CJKmainfont=\\&quot;Microsoft YaHei\\&quot; -V geometry:margin=2.5cm，然后再次尝试编译文档就 OK 了！！！ 12# Markdown &gt;&gt;&gt;&gt; PDF$ pandoc --pdf-engine=xelatex -V CJKmainfont=\\&quot;Microsoft YaHei\\&quot; -V geometry:margin=2.5cm test.md -o test.pdf | &gt;&gt;&gt;&gt; 2.2. VSCode Demo 再来看，如何在 VS Code 中使用 vscode-pandoc 插件来管理 Pandoc 工具进行文档编译的。 我们整理【1. DOS（Bash） Demo】中进行过的配置，先在项目配置文件夹 MarkDownWSC/.vscode 下的 settings.json 中配置如下内容： 12345{&quot;pandoc.docxOptString&quot;: &quot;&quot;,&quot;pandoc.pdfOptString&quot;: &quot;--pdf-engine=lualatex -V CJKmainfont=\\&quot;Microsoft YaHei\\&quot; -V geometry:margin=2.5cm&quot;,&quot;pandoc.htmlOptString&quot;: &quot;-s -f gfm -t html5 --css=css/mdPreviewPlus.css&quot;,} 配置完成后，你可以通过在需要编译（渲染、或转换）的 Markdown 文档中的任意位置 &gt;&gt;&gt;&gt; 点击快捷键 [Ctrl + K P] &gt;&gt;&gt;&gt; 系统会提示如下： 123pdf Render as pdf documentdocx Render as word documenthtml Render as html document 你可以根据你的需要，选择想要导出的类型（PDF &amp;&amp; Docx &amp;&amp; HTML）。 3] &gt;&gt;&gt;&gt; 导出优化 针对 “导出 PDF 格式不好” &amp;&amp; “导出 HTML 报警 nonempty &lt;title&gt;” 的问题，做如下说明： | &gt;&gt;&gt;&gt; 3.1 空标题问题 标准输出时，你需要和标准文档一样正确设置一个标题，即 Markdown 文档中添加 YAML 格式的 front matter，如下： 123---title: &quot;Pandoc&quot;--- 设置后，再次生成就不再产生 stderr:[WARNING] This document format requires a nonempty &lt;title&gt;... 警告了！！！ | &gt;&gt;&gt;&gt; 3.2 导出 PDF 格式不好 有这个问题，是由于我在使用时没有深入了解 Pandoc 工具如何自定义 PDF 的样式（对我来说，Markdown PDF 就完全够了），只是测试的话我采取了曲线救国的方式 &gt;&gt;&gt;&gt; 导出 HTML，然后浏览器中 Print 成 PDF（没有使用到 Pandoc 的精髓）。 导出 HTML 公式无法显示的问题，你可以参考：【[1] &gt;&gt;&gt;&gt; Markdown PDF】 &gt;&gt;&gt;&gt; 【1.3.2. 数学公式显示优化】。 事实上，你甚至可以使用 Pandoc 工具导出一个符合论文要求格式的 PDF 文档，功能非常强大！！！ | =========================== Split Line =========================== | 插件评价 &gt;&gt;&gt;&gt; 可选插件，功能强大的格式转换工具，可以渲染出具有严格格式要求的文档（例如：论文…），可以满足你所有的转换需要，但安装、配置过程比较复杂，使用以及学习成本较高，日常简单使用的话不推荐。 Markdown Preview Enhanced（MPE）Extensions search &gt;&gt;&gt;&gt; Markdown Preview Enhanced [Yiyi Wang] &gt;&gt;&gt;&gt; 是一款为 Atom 以及 Visual Studio Code 编辑器编写的 超级强大的 Markdown 插件。 这款插件意在让你拥有飘逸的 Markdown 写作体验。 相信你在查阅资料过程中，肯定被安利过 MPE（Markdown Preview Enhanced），它凭借其丰富的特性支持，提供了编辑 Markdown 文档时可能用到的几乎所有功能： 123456789101112131415161718192021自动编辑器及预览滑动同步导入外部文件Code ChunkPandocPrinceebook（电子书）幻灯片可扩展性LaTeX 数学导出 PDF, PNG, 以及 JPEG 凭借 Puppeteer导出漂亮的 HTML（移动端支持）编译到 GitHub Flavored Markdown自定义预览 CSSTOC 生成流程图 / 时序图 以及各种其他种类的图形嵌入 LaTeX, 渲染 TikZ, Chemfig 等图形Task List (Github Flavored)Image Helper（图片助手）脚注Front Matter以及更多。。。 关于 MPE 详细使用说明，你可以参考 &gt;&gt;&gt;&gt; Markdown Preview Enhanced 中文说明文档。 插件评价 &gt;&gt;&gt;&gt; 可选插件，功能丰富，支持编辑 Markdown 文档时可能用到的几乎所有功能。但灵活的定制带来使用复杂度的提升，某些功能（例如：Pandoc、ebook）的使用需要单独安装相应的工具，并且相对于其它专用插件需要消耗更多的性能。 插件选用方案结合上一小节的插件说明以及评价，你可以综合考虑个人的使用需要，选择符合你个人使用习惯的插件搭配方案，以构建一个合理的 VSCode Markdown 创作环境。 这里有一些推荐方案： [1] &gt;&gt;&gt;&gt; 方案：Markdown Lint &amp;&amp; MPE 如果你想在安装 VS Code 之后快速开始 Markdown 的创作，避免令人烦躁的插件选择、下载、安装、配置过程，此时，你仅仅需要一个 MPE（Markdown Preview Enhanced） 插件就可以满足你的日常使用了。 例如：MPE 开箱即用的目录（TOC）生成、不同风格的预览主题（Atom &amp;&amp; Github &amp;&amp; Vue…）、快速导出 PDF（HTML &amp;&amp; PNG &amp;&amp; JPEG）等等。 同时，你可以配合下载 Markdown Lint 扩展，以支持 Markdown 语法规范。 [2] &gt;&gt;&gt;&gt; 推荐方案：Markdown Lint &amp;&amp; Markdown Preview Github Styling &amp;&amp; Markdown PDF（Pandoc）&amp;&amp; PicGo 对我个人而言，MPE 对于性能的影响我难以接受，并且 MPE 丰富的特性于我而言不是刚需。作为一个重度强迫症，我无法忍受 MPE 预览菜单中的无效操作条目（某些功能只有安装相应工具才可以使用）。 很多时候并不是功能越多越好，适合你自己的才是最好的！！！事实上，我个人日常使用的编辑要求仅仅如下： Markdown 代码检查（Markdown Lint） 良好的侧栏预览风格（Markdown Preview Github Styling） 支持导出 PDF &amp;&amp; HTML &amp;&amp; Word 等格式的文档（Markdown PDF（Pandoc）） 图像上传工具（PicGo） 通过一些精简的、小型的、专用替代插件，就可以在 VS Code 中帮助我们实现一个高效、惊人、影响较小的 Markdown 编辑器了。","link":"/2017/09/22/shi-yong-vscode-da-jian-yi-ge-liang-ren-de-markdown-editor/"},{"title":"Python 中的函数","text":"程序语言中的，编写代码要不断追求简洁和易读。换句话说，我们要尽量避免写重复的代码，少复制粘贴，也就是所谓的 DRY 原则（Don’t Repeat Yourself）。而 函数 的作用就是用来 提高程序的模块性，和代码的重复利用率。接下来我们详细解读 Python 中函数的使用。 引言 &gt;&gt;&gt;&gt; 事实上，前面我们在介绍 Python 基本数据结构时，就已经学习过 Python 中提供的许多内建（内置）函数： 1# input() print() len() type() id() str() ... 对于 Python 支持的内建函数，可以直接从 Python 的官方网站查看更详细的文档说明 –&gt; Python 内置函数（v3.10.3）。 当然，根据我们的任务需要自由、灵活、快速的定制我们自己的函数（自定义函数）也是必要的！！！ Python 支持自定义函数（Function），即将一段有规律的、可重复使用的代码封装成函数，从而达到一次编写、多次调用的目的。 不难理解，函数的本质 &gt;&gt;&gt;&gt; 是一段有特定功能、可以重复使用的代码，这段代码已经被提前编写好了，并且为其起一个“好听”的名字。在后续编写程序过程中，如果需要同样的功能，直接通过起好的名字就可以调用这段代码。 那么，Python 中如何定义一个函数呢 ↓↓↓↓↓ 函数定义当我们需要定制一个特定功能的函数时，Python 中需要用 def 关键字实现，具体的语法格式如下： 1234def 函数名 (参数列表): ''' 函数说明文档：函数功能说明 ''' 函数体 [return [返回值]] 此格式中，各部分参数的含义如下： 函数名：一个符合 Python 语法的标识符，但不建议使用 a、b、c 这类简单的标识符作为函数名，函数名最好能够体现出该函数的功能； 形参列表：设置该函数可以接收多少个参数，多个参数之间用逗号（ , ）分隔； 函数说明文档：函数的第一行语句可以选择性地使用文档字符串用于函数功能说明，非必须（推荐）； 函数体：实现特定功能的多行代码； return [返回值]：返回可选，可返回值也可返回表达式，函数一旦执行到 return 时，就执行完毕，并将表达式结果返回。如果没有 return 语句或不带表达式的 return，结果相都当于返回 None。 注意，在创建函数时，即使函数不需要参数，也必须保留一对空的 ()，否则 Python 解释器将提示 invaild syntax 错误。 给出一个用于计算矩形面积的函数定义实例： 1234def area(width, height): &quot;&quot;&quot; Fun: Calculate the area of ​​a rectangle &quot;&quot;&quot; print(&quot;width: %d, height: %d&quot; % (width, height)) return width * height 空函数沙发要实现一个功能，我还没想好怎么做，先占个沙发以待后续补充开发（借助 pass 函数）: 123def nop(): #TODO balabala pass 这样可以保证代码结构完整性，让代码能运行起来。如果不加会报错： 123456&gt;&gt;&gt; def nop():...... File &quot;&lt;stdin&gt;&quot;, line 3 ^IndentationError: expected an indented block 函数文档说明支持函数的说明文档，本质就是放于函数内的一段字符串注释。 只不过作为说明文档，字符串的放置位置是有讲究的，函数的说明文档通常位于函数内部、所有代码的最前面 –&gt; 见函数语法规则中的函数说明文档。 这样的话，你可以通过 Python 的 help() 内置函数或者 funName.__doc__ 进行查看： 1234567def area(width, height): &quot;&quot;&quot; Fun: Calculate the area of ​​a rectangle &quot;&quot;&quot; print(&quot;width: %d, height: %d&quot; % (width, height)) return width * heighthelp(area)print(area.__doc__) 输出如下信息： 123456Help on function area in module __main__:area(width, height) Fun: Calculate the area of ​​a rectangle Fun: Calculate the area of ​​a rectangle 函数调用不管是 Python 中提供的内建函数，亦或是上面自定义的函数，只是将特定的功能代码封装了起来，一切都是为了等待调用的。 这就像是神奇宝贝里的精灵球安静地待着，只有听见你的召唤时才会出场，为你所用。 Python 中函数的调用规则都是一样，要想调用一个函数，需要知道函数的名称和需要的参数（出来吧，皮卡丘~）: 1[返回值] = 函数名([形参值]) 其中，函数名即指的是要调用的函数的名称；形参值指的是当初创建函数时要求传入的各个形参的值。如果该函数有返回值，我们可以通过一个变量来接收该值，当然也可以不接受。 以上面定义好的面积函数来说明 Python 中的函数调用： 1234567891011graph_width = 10graph_height = 5graph_area = area(graph_width, graph_height)print(&quot;The area of graph is &quot;,graph_area)# Output: The area of graph is 50# 既可以传递数值，也可以将变量作为参数进行传递area1 = area(10,50)print(area1)# Output: 500 需要注意的是，创建函数有多少个形参，那么调用时就需要传入多少个值；并且默认情况下，调用函数时传入的参数（实参列表）和参数列表（形参列表）会按函数声明中定义的顺序匹配起来（故，形参也被称为 位置参数）。即便该函数没有参数，函数名后的小括号也不能省略。 深入理解函数名称以我们熟悉的， Python 内置的求绝对值的函数 abs() 为例： 12&gt;&gt;&gt; abs(-10)10 你需要使用 abs() 的形式进行函数调用。但你想过没有，如果只写 abs 呢？ 12&gt;&gt;&gt; abs&lt;built-in function abs&gt; 输出信息显示：abs 是一个内置函数。可见，abs() 是函数调用，而 abs 是函数本身。 [1] &gt;&gt;&gt;&gt; 函数别名 由变量可以指向函数调用的返回值，很自然的可以想到，如果把函数本身（函数名）赋值给变量是什么情况？ 123&gt;&gt;&gt; fun_test = abs&gt;&gt;&gt; fun_test&lt;built-in function abs&gt; 哎！把函数名赋值给变量后（变量指向函数本身），好像给这个函数起了一个 “别名”。 同理的话，验证一下 &gt;&gt;&gt;&gt; 是否可以通过该变量来调用这个函数 123&gt;&gt;&gt; fun_test = abs&gt;&gt;&gt; fun_test(-10)10 成功！直接调用 abs() 函数和调用 fun_test() 完全相同。突然又有了个想法： 12345&gt;&gt;&gt; id(fun_test)3038282253312&gt;&gt;&gt; id(abs)3038282253312&gt;&gt;&gt; abs 哦哦~~~经过小心验证，你可以大胆猜测了 &gt;&gt;&gt;&gt; 函数名其实就是指向一个函数对象的引用 [2] &gt;&gt;&gt;&gt; 函数名是指向函数对象的一个引用 所以，上面完全可以把函数名赋给一个变量，让它们指向同一个函数对象引用，这相当于给这个函数起了一个“别名”，但一般禁止这么使用，容易混淆。 又来了个奇怪的想法，既然函数名是一个引用，不就相当于一个变量吗？如果把 abs 指向其他对象，会有什么情况发生？ 12345678&gt;&gt;&gt; abs = &quot;test&quot;&gt;&gt;&gt; abs(-10)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: 'str' object is not callable&gt;&gt;&gt; abs'test' 果然，和猜想的差不多！abs 已经不再是指向求绝对值函数对象的引用了，而是变为一个普通的变量了！ 当然实际代码绝对不能这么写，这里是为了对比函数调用（abs()）和函数名（abs）的区别。要恢复 abs 函数，请重启 Python 交互环境。 形参（位置参数） &amp;&amp; 实参函数调用中有提到，实参列表、形参列表，以及位置参数的说法，到底怎么区分： 形式参数（形参） &gt;&gt;&gt;&gt; 定义函数时，函数名后面括号中的参数就是形式参数（形式上要求的）。 实际参数（实参） &gt;&gt;&gt;&gt; 调用函数时，函数名后面括号中的参数就是形式参数（实际使用时传入的）。 调用函数时，传入的实参列表和函数的形参列表，会按函数声明中定义的顺序匹配起来，故形参也被称为位置参数。 参数检查机制函数调用时，Python 会自动检查传入参数数量是否正确？传入参数类型是否正确？你需要检查传入参数的顺序是否和形成一致？ [1] &gt;&gt;&gt;&gt; 参数个数检查 调用函数时，必须保证实参和形参数量必须一致。如果参数个数不对，Python 解释器会自动检查出来，并抛出TypeError： 123456789&gt;&gt;&gt; area(2,3,5)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: area() takes 2 positional arguments but 3 were given&gt;&gt;&gt; area(2)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: area() missing 1 required positional argument: 'height' 可以看到，提示你多出/缺少必要的位置参数。 [2] &gt;&gt;&gt;&gt; 参数位置检查 调用函数时，必须确保实参位置和形式位置顺序一一对应，否则会产生以下 2 种结果： 1）–&gt; 位置一致，但传入实参类型和形参不匹配，抛出 TypeError 123456789&gt;&gt;&gt; area(&quot;Google&quot;, 12)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; File &quot;&lt;stdin&gt;&quot;, line 2, in areaTypeError: %d format: a number is required, not str&gt;&gt;&gt; abs(&quot;A&quot;)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: bad operand type for abs(): 'str' 2）–&gt; 传入实参类型和形参类型一致，位置不一致，导致函数计算结果和预期不符 这是由于实参和形参会函数声明中定义的顺序进行匹配，此时实参类型和形参类型一致，无法检查出错误，但会导致运行结果和预期不符： 例如，设计一个求梯形面积的函数，并利用此函数求上底为 4cm，下底为 3cm，高为 5cm 的梯形的面积。但如果交互高和下低参数的传入位置，计算结果将导致错误： 1234def area(upper_base,lower_bottom,height): return (upper_base + lower_bottom)*height/2print(&quot;正确结果为：&quot;, area(4,3,5))print(&quot;错误结果为：&quot;, area(4,5,3)) 也就是说，参数个数以及参数类型 Python 解释器自动会帮你检查，但参数位置需要你自己确保！！！ [3] &gt;&gt;&gt;&gt; 自定义函数参数类型检查 自定义函数时，可以设置对传入参数的类型进行强制检查，只允许符合我们要求的参数传入，这可以防止其他人调用我们自定义的函数时引发类型异常，增强代码的健壮性。 假如只允许整数的参数。数据类型检查可以用内置函数 isinstance() 实现： 1234567&gt;&gt;&gt; def area(width, height):... if not isinstance(width, int) or not isinstance(height,int):... raise TypeError(&quot;bad operand type for area(int，int)&quot;)... print(&quot;width: %d, height: %d&quot; % (width, height))... return width * height...&gt;&gt;&gt; 添加了参数检查后，如果传入错误的参数类型，函数就可以抛出一个错误： 12345&gt;&gt;&gt; area(12.0,10)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; File &quot;&lt;stdin&gt;&quot;, line 3, in areaTypeError: bad operand type for area(int，int) 关于错误和异常处理将在后续讲到，这里不用深究。 参数传递机制大多数的编程语言中，说到函数中的参数传递，就会谈到值传递 &amp;&amp; 引用传递，关于 Python 中的参数传递机制也是众说纷纭，但主流有两种想法： [1] &gt;&gt;&gt;&gt; 值传递和引用（地址）传递 值传递：适用于实参类型为不可变类型（字符串、数字、元组）； 引用（地址）传递：适用于实参类型为可变类型（列表，字典）。 值传递和引用传递理解和 C/C++、Java 类似，函数参数进行值传递后，若形参的值发生改变，不会影响实参的值；而函数参数继续引用传递后，改变形参的值，实参的值也会一同改变。 [2] &gt;&gt;&gt;&gt; 引用传递（个人理解） 基本数据类型时就提过，Python 中一切皆对象，变量是没有类型的，类型属于对象（变量所指向的内存数据）。例如： 12test = [1,2,3]test = &quot;HelloPython&quot; 以上代码中，[1,2,3] 是 List 类型，&quot;HelloPython&quot; 是 String 类型，而变量 test 是没有类型，它仅仅是一个对象的引用（一个指针），可以是指向 List 类型对象，也可以是指向 String 类型对象。 所以，变量参数传递时，就是引用的传递，不同的是，由于指向内存单元数据对象类型（可变与不可变对象）的不同导致不同的结果： 可变对象：由于引用指向列表，字典，集合等可变对象，故改变形参的值，实参的值也会一同改变； 不可变对象：由于引用指向字符串、数字、元组等可变对象，故改变形参的值，实参的值不受影响。 实例印证： 传递不可变对象实例 &gt;&gt;&gt;&gt; 1234567&gt;&gt;&gt; def ChangeInt(test):... test = 10...&gt;&gt;&gt; test = 2&gt;&gt;&gt; ChangeInt(test)&gt;&gt;&gt; print(test)2 传递可变对象实例 &gt;&gt;&gt;&gt; 1234567891011&gt;&gt;&gt; def changeme( mylist ):... &quot;修改传入的列表&quot;... mylist.append([1,2,3,4])... print (&quot;函数内取值: &quot;, mylist)... return...&gt;&gt;&gt; mylist = [10,20,30]&gt;&gt;&gt; changeme( mylist )函数内取值: [10, 20, 30, [1, 2, 3, 4]]&gt;&gt;&gt; print (&quot;函数外取值: &quot;, mylist)函数外取值: [10, 20, 30, [1, 2, 3, 4]] return [表达式]我们知道，当程序执行到 return [表达式] 时标志函数执行完成，用于将表达式结果（任意数据类型）进行返回。 需要注意的是，return 语句在同一函数中可以出现多次，但只要有一个得到执行，就会直接结束函数的执行。 [1] &gt;&gt;&gt;&gt; return None 隐含机制 如果函数中没有 return [表达式] 语句或者单独的 return 或者 return None，函数都返回是一个 None。 也就说没有返回值语句时，Python 解释器会自动帮你返回 None。 –&gt; 思考，函数可以返回多个值吗？答案是肯定的。 [2] &gt;&gt;&gt;&gt; return 返回多个值 实现 Python 函数返回多个值，有以下 2 种方式： 在函数中，提前将要返回的多个值存储到一个列表或元组中，然后函数返回该列表或元组； 函数直接返回多个值，之间用逗号（ , ）分隔，Python 会自动将多个值封装到一个元组中，其返回值仍是一个元组。 程序演示： 123456789101112def retu_list(): add = [&quot;Python&quot;, &quot;C/C++&quot;, &quot;Java&quot;] return addprint(&quot;retu_list: &quot;, retu_list())def retu_tuple(): return &quot;Python&quot;, &quot;C/C++&quot;, &quot;Java&quot;print(&quot;retu_tuple: &quot;, retu_tuple())# Output# retu_list: ['Python', 'C/C++', 'Java']# retu_tuple: ('Python', 'C/C++', 'Java') 序列解包方式接收多个返回值 &gt;&gt;&gt;&gt; 可以直接使用序列元素个数对应数量的变量，接收函数返回列表或元组中的多个值： 12345def retu_tuple(): return &quot;Python&quot;, &quot;C/C++&quot;, &quot;Java&quot;p,c,j = retu_tuple()print(&quot;retu_tuple: ( %s, %s, %s&quot; % (p,c,j), &quot;)&quot;) 函数参数列表详解Python 的函数定义非常简单，但由于参数列表的多种定义方式，灵活度却非常大。参数列表支持的参数类型定义： 位置参数 关键字参数 默认参数 不定长参数 这些参数形式的引入，使得不仅能处理比较复杂的参数使用场景，还可以极大的简化调用者的代码。 位置参数位置参数详细说明可见 【形参（位置参数） &amp;&amp; 实参】 和 【参数检查机制】 小节说明。 目前，我们调用函数时所用的参数都是位置参数，即传入函数的实际参数必须与形式参数的数量和位置必须一一对应（需要人为参与）。 不知道你有没有这种感觉，按顺序给参数传入数值总是感觉不太靠谱，一旦疏忽搞错怎么办？ &gt;&gt;&gt;&gt; 关键字参数。 关键字参数关键字参数，是指使用形式列表中参数的名字来 “绑定” 实参列表中输入的参数值。 通过此方式指定函数实参时，不再需要与形参的位置完全一致，只要将参数名写正确即可。 [1] 使用关键字参数传参 &gt;&gt;&gt;&gt; 12345678&gt;&gt;&gt; def move(start_x, start_y, step):... end_x = start_x + step... end_y = start_y + step... return end_x, end_y...&gt;&gt;&gt; move(start_x=2, start_y=3, step=2)(4, 5) [2] 使用位置 &amp;&amp; 关键字参数混合传参 &gt;&gt;&gt;&gt; 你还可以使用位置参数和关键字参数混合传参的方式： 123456&gt;&gt;&gt; move(2,3, step=2)(4, 5)# 这样是不允许的：（move(2,1, start_y=3)）# 认为你传入了两个 start_y 需要注意，混合传参时 关键字参数必须位于所有的位置参数之后 。否则，会产生错误： 1SyntaxError: positional argument follows keyword argument 默认参数如果函数参数列表中的某个参数的值很少发生变化，为了避免每次都传同样的值，可以使用默认参数（函数定义时给出参数默认值），以达到简化函数调用的目的。语法规则如下： 12def 函数名(...，形参名，形参名=默认值)： 代码块 注意，使用此格式定义函数时，指定有默认值的形式参数必须在所有没默认值参数的最后，否则会产生语法错误。 以下实例中，step 为默认参数，调用时如果没有传入 step 参数，则使用默默认值： 1234567&gt;&gt;&gt; def move(start_x, start_y, step=1):... end_x = start_x + step... end_y = start_y + step... return end_x, end_y...&gt;&gt;&gt; move(2,3)(3, 4) 这样，当我们调用 move(2, 3) 时，相当于调用了 move(2, 3，1)。 使用默认参数时，也要符合位置参数 &amp;&amp; 关键字参数规则： 1234567891011&gt;&gt;&gt; move(2,3)&gt;&gt;&gt;&gt; move(2,1,start_y=3) # 这是不允许的Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: move() got multiple values for argument 'start_y'&gt;&gt;&gt; move(start_x=2,start_y=3,step=1)(3, 4)&gt;&gt;&gt; move(2,3,step=1)&gt;(3, 4) 默认参数设置原则使用默认参数时，要注意： 有默认值的形式参数必须在所有没默认值参数的最后，否则会产生语法错误； 当函数有多个参数时，把变化大的参数放前面，变化小的参数放后面。变化小的参数就可以作为默认参数。 来看一个运用实例： 写个北京市一年级小学生注册的函数，需要传入名字和性别两个参数： 123def enroll(name, gender): print('name:', name) print('gender:', gender) 如果要继续传入年龄、城市等信息怎么办？这样会使得调用函数的复杂度大大增加。此时，我们可以把年龄和城市设为默认参数（变化小）： 12345def enroll(name, gender, age=8, city='Beijing'): print('name:', name) print('gender:', gender) print('age:', age) print('city:', city) 这样，大多数学生注册时不需要提供年龄和城市，只提供必须的两个参数： 12345&gt;&gt;&gt; enroll('Sarah', 'F')name: Sarahgender: Fage: 8city: Beijing 只有与默认参数不符（飞北京，不是 8 岁入学）的学生才需要提供额外的信息： 123enroll('Bob', 'M', 7)enroll('Adam', 'M', city='Tianjin')enroll('Adam', 'M', 9, city='Tianjin') 可见，默认参数降低了函数调用的难度，而一旦需要更复杂的调用时，又可以传递更多的参数来实现。无论是简单调用还是复杂调用，函数只需要定义一个。 默认参数必须指向不可变对象默认参数的很有用，但使用不当，也会掉坑里….默认参数有个最大的坑 先定义一个带有默认参数空 list 的函数，调用方法会添加一个 END 再返回: 123def add_end(L=[]): L.append('END') return L 当你正常调用时，结果似乎不错： 1234&gt;&gt;&gt; add_end([1, 2, 3])[1, 2, 3, 'END']&gt;&gt;&gt; add_end(['x', 'y', 'z'])['x', 'y', 'z', 'END'] 当你使用默认参数调用时，一开始结果也是对的： 12&gt;&gt;&gt; add_end()['END'] 但是，再次调用add_end()时，结果就不对了： 1234&gt;&gt;&gt; add_end()['END', 'END']&gt;&gt;&gt; add_end()['END', 'END', 'END'] 很多初学者很疑惑，默认参数是[]，但是函数似乎每次都“记住了”上次添加了 'END' 后的 list。还记得我们前面在参数传递中说过的可变类型对象的传递么？原因正在这里。 定义默认参数要牢记一点：默认参数必须指向不变对象！要修改上面的例子，我们可以用 None 这个不变对象来实现： 12345def add_end(L=None): if L is None: L = [] L.append('END') return L 现在，无论调用多少次，都不会有问题： 1234&gt;&gt;&gt; add_end()['END']&gt;&gt;&gt; add_end()['END'] 不定长参数有些时候，你可能需要一个函数能够处理比当初声明时更多的参数，也就是说，定义时我们无法明确参数的个数。 以一个计算 a1 + a2 + a3 + …… +a_n（n 个数的和）的样例来说明： 要定义出这个函数，按照之前的规则，我们必须确定输入的参数。但由于参数个数不确定（不知道具体要算几个数的和），所以我们首先想到可以把 a1，a2，a3…… 作为一个 list 或 tuple 传进来，这样，函数可以定义如下： 12345def calc(numbers): sum = 0 for n in numbers: sum = sum + n * n return sum 这种方法，调用的时候，我们需要先组装出一个 list 或 tuple，然后传入 calc 函数，比较麻烦以及浪费资源的。 在 Python 中，支持定义可变参数（不定长参数）的函数，即传入函数中的实际参数可以是任意多个。 Python 定义不定长，有以下 2 种形式（名字自己起的哈）: 元组型不定长非关键字实参； 字典型不定长关键字实参。 元组型不定长非关键字实参此种形式的语法格式如下所示： 1*args *args 表示创建一个名为 args 的空元组，该元组可接受任意多个（不定长）外界传入的非关键字实参。 程序演示了如何定义一个参数可变的函数： 123456def calc(arg1, *numbers): sum = 0 for n in numbers: sum = sum + n * n print(arg1) return sum 上面程序中，calc() 函数的最后一个参数就是 numbers 元组，这样在调用该函数时，除了前面位置参数接收对应位置的实参外，其它非关键字参数都会由 numbers 元组接收。 当然，可变参数并不一定必须为最后一个函数参数，例如修改 calc() 函数为： 123456def calc(*numbers, arg1): sum = 0 for n in numbers: sum = sum + n * n print(arg1) return sum numbers 可变参数作为 calc() 函数的第一个参数。需要注意的是，在调用该函数时，必须以关键字参数的形式给普通参数传值，否则 Python 解释器会把所有参数都优先传给可变参数，如果普通参数没有默认值，就会报错。 | &gt;&gt;&gt;&gt; ======================================================= 重新认识 print() 函数，查看 print() 函数文档： 1print(*objects, sep = ' ', end = '\\n', file = sys.stdout, flush = False) 可以看到第一个参数 objects 带了 * 号，为不定长参数 –&gt; 这也是为什么 print() 函数可以传递任意数量的参数。其余四个为默认参数，我们可以通过修改默认值来改变参数： 1print('金枪鱼', '三文鱼', '鲷鱼', sep = '+', end = '=?') 字典型不定长关键字实参此种形式的语法格式如下所示： 1**kwargs **kwargs 表示创建一个名为 kwargs 的空字典，该字典可接受任意多个（不定长）外界传入以关键字参数赋值的实参。 这种方法允许你传入 0 个或任意个含参数名的参数，这些关键字参数在函数内部自动组装为一个 dict。请看示例： 123&gt;&gt;&gt; def person(name, age, **vardict):... print('name:', name, 'age:', age, 'other:', vardict)... 函数 person 除了位置参数 name 和 age 外，还接受关键字参数 vardict。在调用该函数时，可以只传入位置参数： 12&gt;&gt;&gt; person(&quot;Opera&quot;,35)name: Opera age: 35 other: {} 也可以同时传入任意个数的关键字实参： 12&gt;&gt;&gt; person(&quot;Google&quot;,23,city=&quot;Beijing&quot;,job=&quot;IT&quot;)name: Google age: 23 other: {'city': 'Beijing', 'job': 'IT'} 参数混合在 Python 中定义函数，可以使用位置参数、默认参数、、关键字参数、不定长参数，并且这 4 种参数都可以组合使用，例如如下代码： 123456789101112# 定义了支持参数收集的函数def dis_str(home,*str,**course) : print(home) print(str) print(course)#调用函数dis_str(&quot;home_test&quot;,\\ &quot;str_1&quot;,\\ &quot;str_2&quot;,\\ shell=&quot;course_1&quot;,\\ go=&quot;course_2&quot;,\\ java=&quot;course_1&quot;) 程序输出结果为： 123home_test('str_1', 'str_2'){'shell': 'course_1', 'go': 'course_2', 'java': 'course_1'} 序列支持向函数传参我们知道，Python 支持定义具有可变参数的函数，即该函数可以接收任意多个参数，其中非关键字参数会集中存储到元组参数（*args）中，而关键字参数则集中存储到字典参数（**kwargs）中，这个过程可称为参数收集。 不仅如此，Python 还支持逆向参数收集，即直接将列表、元组、字典作为函数参数，Python 会将其进行拆分，把其中存储的元素按照次序分给函数中的各个形参。 在以逆向参数收集的方式向函数参数传值时，Pyhon 语法规定，当传入列表或元组时，其名称前要带一个 * 号，当传入字典时，其名称前要带有 2 个 * 号。 [1] &gt;&gt;&gt;&gt; 向定长形参列表传参 举个例子： 12345678910def dis_str(name,add) : print(&quot;name:&quot;,name) print(&quot;add&quot;,add)data = [&quot;Python教程&quot;,&quot;http://c.biancheng.net/python/&quot;]# 使用逆向参数收集方式传值dis_str(*data)# Output:# name: Python教程# add http://c.biancheng.net/python/ [2] &gt;&gt;&gt;&gt; 向不定长形参列表传参 以逆向参数收集的方式，还可以给拥有可变参数的函数传参，例如： 123456789101112def dis_str(name,*add) : print(&quot;name:&quot;,name) print(&quot;add:&quot;,add)data = [&quot;http://c.biancheng.net/python/&quot;,\\ &quot;http://c.biancheng.net/shell/&quot;,\\ &quot;http://c.biancheng.net/golang/&quot;]#使用逆向参数收集方式传值dis_str(&quot;Python教程&quot;,*data)# Output:# name: Python教程# add: ('http://c.biancheng.net/python/', 'http://c.biancheng.net/shell/', 'http://c.biancheng.net/golang/') 同样的，你可以执行下面代码，可上述输出一样（比较一下差别）： 12345678910111213def dis_str(name,*add) : print(&quot;name:&quot;,name) print(&quot;add:&quot;,add)data = [&quot;Python教程&quot;,\\ &quot;http://c.biancheng.net/python/&quot;,\\ &quot;http://c.biancheng.net/shell/&quot;,\\ &quot;http://c.biancheng.net/golang/&quot;]#使用逆向参数收集方式传值dis_str(*data)# Output:# name: Python教程# add: ('http://c.biancheng.net/python/', 'http://c.biancheng.net/shell/', 'http://c.biancheng.net/golang/') | &gt;&gt;&gt;&gt; ====================================================== 使用逆向参数收集的方式，必须注意 * 号的添加。以逆向收集列表列表为例，如果传参时其列表名前不带 * 号，则 Python 解释器会将整个列表作为参数传递给一个参数。 123456789101112def dis_str(name,*add) : print(&quot;name:&quot;,name) print(&quot;add:&quot;,add)data = [&quot;Python教程&quot;,\\ &quot;http://c.biancheng.net/python/&quot;,\\ &quot;http://c.biancheng.net/shell/&quot;,\\ &quot;http://c.biancheng.net/golang/&quot;]dis_str(data)# 输出# name: ['Python教程', 'http://c.biancheng.net/python/', 'http://c.biancheng.net/shell/', 'http://c.biancheng.net/golang/']# add: () 函数间协作上面，我们使用函数来封装具有独立功能的代码模块，实际编程时，一个程序往往是通过多个函数的配合来实现的。 浅析变量作用域当多个函数同时运行时，就涉及函数中一个非常重要的概念 —— 变量作用域（Vars Scope）。 全局变量 &amp;&amp; 局部变量先来看一个例子： 月底了，身为老板的你要核算成本来调整经营策略，假设餐馆的成本是由固定成本（租金）和变动成本（水电费 + 食材成本）构成的。 那么我们可以分别编写一个计算变动成本的函数和一个计算总成本的函数： 1234567891011121314rent = 3000def cost(): utilities = int(input('请输入本月的水电费用')) food_cost = int(input('请输入本月的食材费用')) variable_cost = utilities + food_cost print('本月的变动成本费用是' + str(variable_cost))def sum_cost(): sum = rent + variable_cost print('本月的总成本是' + str(sum))cost()sum_cost() 乍一看代码好像没有什么问题，但是一旦运行，终端就会报错： 123line 10, in sum_cost sum = rent + variable_costNameError: name 'variable_cost' is not defined 可以发现，第一个函数 cost() 运行没有问题，报错信息指出问题出在 sum_cost() 函数内的变量 variable_cost 没有被定义。 这就涉及一个变量作用域的问题 &gt;&gt;&gt;&gt; 程序中的变量并不是在哪个位置都可以被使用的，它是有作用域。 变量的作用域指的是变量的有效范围，就是变量可以在哪个范围以内使用。它由变量的定义位置决定，在不同位置定义的变量，它的作用域是不一样的。 目前我们只需要掌握下面两点即可： 一个在函数内部赋值的变量仅能在该函数内部使用（局部作用域），它们被称作 局部变量，如 cost() 函数里的 variable_cost； 在所有函数之外赋值的变量，可以在程序的任何位置使用（全局作用域），它们被称作 全局变量，如程序第一行定义的变量 rent=3000。 上述例子中，变量 rent 是在函数外被赋值的，所以它是全局变量，能被 sum_cost() 函数直接使用。而变量 variable_cost 是在 cost() 函数内定义的，属于局部变量，其余函数内部如 sum_cost() 无法访问。 事实上，当 cost() 函数调用执行完毕，在这个函数内定义的变量都会”消失”。 函数中局部变量是调用生成，调用结束后释放的 &gt;&gt;&gt;&gt; def 语句后的代码块只是封装了函数的功能，如果没有被调用，那么 def 语句后面的代码永远不会被执行。当函数被调用时，Python 会为其分配一块临时的存储空间，所有在函数内部定义的变量，都会存储在这块空间中。而在函数执行完毕后，这块临时存储空间随即会被释放并回收，该空间中存储的变量自然也就无法再被使用。 获取指定作用域范围中的变量在一些特定场景中，我们可能需要获取某个作用域内（全局范围内或者局部范围内）所有的变量，Python 提供了以下 3 种方式： [1] &gt;&gt;&gt;&gt; globals() globals() 函数为 Python 的内置函数，它可以返回一个包含全局范围内所有变量的字典，该字典中的每个键值对，键为变量名，值为该变量的值。 举个例子： 123456789101112# 全局变量Pyname = &quot;Python 教程&quot;Pyadd = &quot;http://orangeshare.cn/python&quot;def text(): # 局部变量 Shename = &quot;shell 教程&quot; Sheadd= &quot;http://orangeshare.cn/shell&quot;print(globals())# Output：# { ...... , 'Pyname': 'Python 教程', 'Pyadd': 'http://orangeshare.cn/python', ......} 注意，globals() 函数返回的字典中，会默认包含有很多变量，这些都是 Python 主程序内置的，读者暂时不用理会它们。 并且，通过该字典，我们还可以访问指定变量，甚至如果需要，还可以修改它的值。例如，在上面程序的基础上，添加如下语句： 123print(globals()['Pyname'])globals()['Pyname'] = &quot;Python 入门教程&quot;print(Pyname) [2] &gt;&gt;&gt;&gt; locals() locals() 函数也是 Python 内置函数之一，通过调用该函数，我们可以得到一个包含当前作用域内所有变量的字典。 这里所谓的 【当前作用域】 指的是，在函数内部调用 locals() 函数，会获得包含所有局部变量的字典；而在全局范文内调用 locals() 函数，其功能和 globals() 函数相同。 举个例子： 123456789101112131415161718# 全局变量Pyname = &quot;Python 教程&quot;Pyadd = &quot;http://orangeshare.cn/python&quot;def text(): #局部变量 Shename = &quot;shell 教程&quot; Sheadd= &quot;http://orangeshare.cn/shell/&quot; print(&quot;函数内部的 locals:&quot;) print(locals())text()print(&quot;函数外部的 locals:&quot;)print(locals())# Output：# 函数内部的 locals:# {'Sheadd': 'http://orangeshare.cn/shell/', 'Shename': 'shell 教程'}# 函数外部的 locals:# {...... , 'Pyname': 'Python 教程', 'Pyadd': 'http://orangeshare.cn/python/', ...... } 当使用 locals() 函数获取所有全局变量时，和 globals() 函数一样，其返回的字典中会默认包含有很多变量，这些都是 Python 主程序内置的，读者暂时不用理会它们。 注意，当使用 locals() 函数获得所有局部变量组成的字典时，可以向 globals() 函数那样，通过指定键访问对应的变量值，但无法对变量值做修改。 [3] &gt;&gt;&gt;&gt; vars(object) vars() 函数也是 Python 内置函数，其功能是返回一个指定 object 对象范围内所有变量组成的字典。如果不传入object 参数，vars() 和 locals() 的作用完全相同。 由于目前读者还未学习 Python 类和对象，因此初学者可先跳过该函数的学习，等学完 Python 类和对象之后，再回过头来学习该函数。 12345678910111213141516# 全局变量Pyname = &quot;Python 教程&quot;Pyadd = &quot;http://orangeshare.cn/python/&quot;class Demo: name = &quot;Python 教程&quot; add = &quot;http://orangeshare.cn/python/&quot;print(&quot;有 object：&quot;)print(vars(Demo))print(&quot;无 object：&quot;)print(vars())# Output:# 有 object：# {...... , 'name': 'Python 教程', 'add': 'http://c.biancheng.net/python/', ......}# 无 object：# {...... , 'Pyname': 'Python教程', 'Pyadd': 'http://c.biancheng.net/python/', ...... } 函数中使用同名全局变量当函数内部的局部变量和函数外部的全局变量同名时，在函数内部，局部变量会“遮蔽”同名的全局变量。 这时，无论是访问还是修改该同名变量，操作的都是局部变量，而不再是全局变量。 这里举个实例： 12345678name = &quot;Python 教程&quot;def demo (): # 访问全局变量 print(name)demo()# Output:# Python 教程 上面程序中，print(name) 直接访问 name 变量，这是允许的。在上面程序的基础上，在函数内部添加一行代码，如下所示： 123456name = &quot;Python教程&quot;def demo (): # 访问全局变量 print(name) name = &quot;shell教程&quot;demo() 执行此程序，Python 解释器报如下错误： 1UnboundLocalError: local variable 'name' referenced before assignment 发生什么了？！！ &gt;&gt;&gt;&gt; 由于函数中局部变量名和全局变量名 name 同名（触发屏蔽机制），局部 name 变量就会“遮蔽”全局 name 变量，再加上局部变量 name 在 print(name) 后才被初始化，违反了“先定义后使用”的原则，因此程序会报错。 如果就是想在函数中访问甚至修改被“遮蔽”的变量，怎么办呢？ 这时候 global 语句就能派上用场了，它可以将局部变量声明为全局变量，作如下修改： 12345678910111213name = &quot;Python 教程&quot;def demo (): global name # 访问全局name变量 print(name) # 修改全局 name 变量的值 name = &quot;shell 教程&quot;demo()print(name)# Output:# Python 教程# shell 教程 增加了 global name 声明之后，程序会把 name 变量当成全局变量，这意味着 demo() 函数后面对 name 赋值的语句只是对全局变量赋值，而不是重新定义局部变量。 局部函数我们知道，Python 函数内部可以定义变量，这样就产生了局部变量，有读者可能会问，Python 函数内部能定义函数吗？答案是肯定的。 Python 支持在函数内部定义函数，此类函数又称为 局部函数。 和局部变量一样，默认情况下局部函数只能在其所在函数的作用域内使用。 举个例子： 1234567891011121314#全局函数def outdef (): # 局部函数 def indef(): print(&quot;http://orangeshare.cn/python/&quot;) # 调用局部函数（该函数只在当前作用域可见） indef()# indef() 不能直接调用，内部函数在当前作用域内不可见# 调用全局函数outdef()# Output:# http://orangeshare.cn/python/ 可以看到，indef 函数定义于 outdef 函数中，所以其作用域就是 outdef 函数内。想要执行局部函数，只能在其作用域（outdef 函数）中进行调用。 [1] &gt;&gt;&gt;&gt; 局部函数变量同名“遮蔽”问题 需要注意，如果局部函数中定义有和所在函数中变量同名的变量，也会发生“遮蔽”的问题。 例如： 12345678910# 全局函数def outdef (): name = &quot;所在函数中定义的 name 变量&quot; # 局部函数 def indef(): print(name) name = &quot;局部函数中定义的 name 变量&quot; indef()# 调用全局函数outdef() 执行此程序，Python 解释器会报如下错误： 1UnboundLocalError: local variable 'name' referenced before assignment 怎么办？！！ 由于这里的 name 变量是局部变量，globals 关键字，并不适用于解决此问题。 这里可以使用 Python 提供的 nonlocal 关键字。例如，修改上面程序为： 123456789101112131415# 全局函数def outdef (): name = &quot;所在函数中定义的 name 变量&quot; # 局部函数 def indef(): nonlocal name print(name) # 修改 name 变量的值 name = &quot;局部函数中定义的 name 变量&quot; indef()# 调用全局函数outdef()# Output:# 所在函数中定义的 name 变量 [2] &gt;&gt;&gt;&gt; 函数作为返回值，扩大局部函数作用域 就如同全局函数返回其局部变量，就可以扩大该变量的作用域一样；通过将局部函数作为所在函数的返回值，也可以扩大局部函数的使用范围。例如，修改上面程序为： 12345678910111213141516171819# 全局函数def outdef (): name = &quot;局部函数所在外部函数中定义的 name 变量&quot; # 局部函数 def indef(): nonlocal name print(name) # 调用局部函数 return indef# 调用全局函数new_indef = outdef()# 调用全局函数中的局部函数new_indef()# Output:# 调用局部函数 也就是说：如果所在函数没有返回局部函数，则局部函数的可用范围仅限于所在函数内部；反之，如果所在函数将局部函数作为返回值，则局部函数的作用域就会扩大，既可以在所在函数内部使用，也可以在所在函数的作用域中使用。 哎？连续调用了两回？怎么理解在全局作用域中调用局部函数？ 这是由于 outdef() 外部函数返回的是一个其内部函数的引用，还记得前面关于函数名称的解读么？所以调用 outdef() 外部函数其返回值相当于其内部函数（局部函数）的一个别名，然后就可以全局作用域中调用局部函数。 带来的好处 &gt;&gt;&gt;&gt; 我们知道，只有当函数被调用时，Python 才会为其分配一块临时的存储空间，所有在函数内部定义的变量，都会存储在这块空间中。而在函数执行完毕后，这块临时存储空间随即会被释放并回收，该空间中存储的变量自然也就无法再被使用。 而以使用其局部函数作为返回值的外部函数，当外部函数结束时，其局部函数中使用到的外部函数相关联变量会被绑定到内部函数，这样你就可以使得这些变量始终保存在内存中，不会随外部函数的结束而清除（变量状态保存）。 其实，上面介绍到的就是 Python 中闭包的概念，更多请参加：Python 中的函数升阶。 函数内部调用Python 中在一个函数的内部，也是支持调用其它函数的。看如下样例： 1234567891011121314151617rent = 3000def cost(): global variable_cost utilities = int(input('请输入本月的水电费用')) food_cost = int(input('请输入本月的食材费用')) variable_cost = utilities + food_cost print('本月的变动成本是' + str(variable_cost))def sum_cost(): cost() sum = rent + variable_cost print('本月的总成本是' + str(sum))sum_cost() 需要注意的是，语句对函数调用，必须在函数调用之后，包括直接调用的函数调用的其他函数也必须在调用语句之前，否则报错。 然而，更多的是不再定义全局变量，而是将函数的预期执行结果作为当前函数的返回值： 1234567891011121314151617rent = 3000def cost(): utilities = int(input('请输入本月的水电费用')) food_cost = int(input('请输入本月的食材费用')) variable_cost = utilities + food_cost print('本月的变动成本是' + str(variable_cost)) return variable_costdef sum_cost(): sum = rent + cost() print('本月的总成本是' + str(sum))sum_cost() 这应该才是最合理的使用方法。 递归函数Python 中函数内部是支持调用其它函数的，那么，如果一个函数在内部是否可以调用自身本身呢？ 可以的！！！这个函数就被称为递归函数。 来看一个实例，我们来计算阶乘 n! = 1 x 2 x 3 x ... x n，用函数 fact(n) 表示，可以看出： fact(n) = n! = 1 x 2 x 3 x ... x (n-1) x n = (n-1)! x n = fact(n-1) x n 所以，fact(n) 可以表示为 n x fact(n-1)，只有 n=1 时需要特殊处理。 于是，fact(n) 用递归的方式写出来就是： 1234567891011&gt;&gt;&gt; def fact(n):... if n==1:... return 1... return n * fact(n - 1)...&gt;&gt;&gt; fact(1)1&gt;&gt;&gt; fact(2)2&gt;&gt;&gt; fact(5)120 如果我们计算fact(5)，可以根据函数定义看到计算过程如下： 12345678910===&gt; fact(5)===&gt; 5 * fact(4)===&gt; 5 * (4 * fact(3))===&gt; 5 * (4 * (3 * fact(2)))===&gt; 5 * (4 * (3 * (2 * fact(1))))===&gt; 5 * (4 * (3 * (2 * 1)))===&gt; 5 * (4 * (3 * 2))===&gt; 5 * (4 * 6)===&gt; 5 * 24===&gt; 120 递归函数的优点是定义简单，逻辑清晰。理论上，所有的递归函数都可以写成循环的方式，但循环的逻辑不如递归清晰。 执行递归函数将反复调用其自身，每调用一次就进入新的一层，当最内层的函数执行完毕后，再一层一层地由里到外退出。 当一个函数不断地调用它自身时，必须在某个时刻函数的返回值是确定的，即不再调用它自身：否则，这种递归就变成了无穷递归，类似于死循环。因此，在定义递归函数时有一条最重要的规定： 递归一定要向已知方向进行。 [1] &gt;&gt;&gt;&gt; 递归中的栈溢出问题 使用递归函数需要注意防止栈溢出。在计算机中，函数调用是通过栈（stack）这种数据结构实现的，每当进入一个函数调用，栈就会加一层栈帧，每当函数返回，栈就会减一层栈帧。 由于栈的大小不是无限的，所以递归调用的次数过多，会导致栈溢出。可以试试 fact(1000)： 123456789&gt;&gt;&gt; fact(1000)Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt; File &quot;&lt;stdin&gt;&quot;, line 4, in fact File &quot;&lt;stdin&gt;&quot;, line 4, in fact File &quot;&lt;stdin&gt;&quot;, line 4, in fact [Previous line repeated 995 more times] File &quot;&lt;stdin&gt;&quot;, line 2, in factRecursionError: maximum recursion depth exceeded in comparison [2] &gt;&gt;&gt;&gt; 尾递归解决栈溢出 解决递归调用栈溢出的方法是进行 尾递归 优化 &gt;&gt;&gt;&gt; 普通的递归，每一次递归都需要调用函数，会创建新的栈，生成一大堆中间变量；而尾递归不会保存中间变量，每一级调用直接返回函数的返回值更新调用栈，而不用创建新的调用栈。 如何实现尾递归 &gt;&gt;&gt;&gt; 在函数返回的时候，调用其自身，并且 return 语句不能包含表达式。 上面的 fact(n) 函数由于 return n * fact(n - 1) 引入了乘法表达式，所以就不是尾递归了。要改成尾递归方式，需要多一点代码，主要是要把每一步的乘积传入到递归函数中： 1234567def fact(n): return fact_iter(n, 1)def fact_iter(num, product): if num == 1: return product return fact_iter(num - 1, num * product) 可以看到，return fact_iter(num - 1, num * product) 仅返回递归函数本身，num - 1 和 num * product 在函数调用前就会被计算，不影响函数调用。fact(5) 对应的 fact_iter(5, 1) 的调用如下： 123456===&gt; fact_iter(5, 1)===&gt; fact_iter(4, 5*1)===&gt; fact_iter(3, 5*1*4)===&gt; fact_iter(2, 5*1*4*3)===&gt; fact_iter(1, 5*1*4*3*2)===&gt; 120 尾递归调用时，如果做了优化，栈不会增长，因此，无论多少次调用也不会导致栈溢出。 遗憾的是，某些编程语言没有针对尾递归做优化，Python 解释器就是其中之一，所以，即使把上面的 fact(n) 函数改成尾递归方式，也会导致栈溢出。 能人无数啊！！！网上有大佬用装饰器实现了 Python 的尾递归，试运行下面代码验证： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#!/usr/bin/env python3# This program shows off a python decorator(# which implements tail call optimization. It# does this by throwing an exception if it is # it's own grandparent, and catching such # exceptions to recall the stack.import sysclass TailRecurseException(BaseException): def __init__(self, args, kwargs): self.args = args self.kwargs = kwargsdef tail_call_optimized(g): &quot;&quot;&quot; This function decorates a function with tail call optimization. It does this by throwing an exception if it is it's own grandparent, and catching such exceptions to fake the tail call optimization. This function fails if the decorated function recurses in a non-tail context. &quot;&quot;&quot; def func(*args, **kwargs): f = sys._getframe() if f.f_back and f.f_back.f_back \\ and f.f_back.f_back.f_code == f.f_code: raise TailRecurseException(args, kwargs) else: while 1: try: return g(*args, **kwargs) except TailRecurseException as e: args = e.args kwargs = e.kwargs func.__doc__ = g.__doc__ return func@tail_call_optimizeddef factorial(n, acc=1): &quot;calculate a factorial&quot; if n == 0: return acc return factorial(n-1, n*acc)print(factorial(10000)) # prints a big, big number,# but doesn't hit the recursion limit.@tail_call_optimizeddef fib(i, current = 0, next = 1): if i == 0: return current else: return fib(i - 1, next, current + next)print(fib(10000)) # also prints a big number,# but doesn't hit the recursion limit.","link":"/2018/01/10/python-zhong-de-han-shu/"},{"title":"玩转 VSCode 之配置 C&#x2F;C++ 语言开发环境","text":"Linux &amp;&amp; Windows 平台下配置 VS Code + C/C++ 语言学习、开发环境。 我们知道，配置 VSCode 多重开发环境，就是组合安装配置多种语言相关插件以及相关语言工具库 的过程。 下面正式开始在 VS Code 中配置 C/C++ 开发、调试环境（For Windows &amp;&amp; Linux）： Extensions Setup首先，需要安装 VSCode 中 C/C++ 开发过程中可能会用到的插件 &gt;&gt;&gt;&gt; 1 –&gt; 必须安装的扩展： C/C++：实际上就是指 cpptools，提供 C/C++ 语言支持，包括智能提示和调试功能等。 推荐 安装插件：C/C++ Extension Pack –&gt; Popular extensions for C++ development in Visual Studio Code（插件合集包，包含了所有 C/C++ 开发中可能用到的流行插件）。 2 –&gt; 其他可选扩展： Include Autocomplete：提供 C/C++ 头文件名字的补全功能； C/C++ Snippets：提供 C/C++ 重用代码块（Snippets）支持，最新 VSCode 中已集成有 Snippets 支持。 3 –&gt; 不建议/不需要装的扩展： GBKtoUTF8：把 GBK 编码的文档转换成 UTF8 编码的。此扩展可能有严重的 Bug； C++ Intellisense：使用全局 GUN 工具为 C/C++ 提供智能提示； 创建 C/C++ 工程文件夹我们知道，VScode 是以文件夹的形式来组织管理工程项目的。 故，首先你需要创建一个用来存放整个工程代码的文件夹也被称为 【工作目录】，这里我的为：CppProjectWSC。 注意：工作目录路径中不能含有中文和空格和引号。 然后通过 VSCode 打开该文件夹【File –&gt; Open Folder 或使用快捷键 Ctrl + K + O】，选择刚才创建的那个文件夹即可。 事实上，此时你就可以将 VSCode 作为编辑器进行 C/C++ 源码学习和编写了。 Reffs Configuration打起精神，重点来了…. 如果你只是将 VSCode 作为一个编辑器使用，那么上述就够了，当然这不是我们的目的。 再一次重申：VS Code 只是一个编辑器，并不是 IDE。 我们的目的是：想要在 VSCode 中直接使用 Code Runner 进行 C/C++ 代码的编写测试或者完成代码的 Debug（断点测试）功能，那么你还需要进行额外的配置。 需要配置那些？？？ 配置一个 C/C++ 编译器：你需要确定当前系统环境下确保有一个可以用来编译 C/C++ 的编译器； 配置工程文件夹：你需要使用 VSCode 设置规则在工程文件夹中进行一些配置，以可以帮助我们完成一键构建（编译、链接等）、运行…… 但由于编译器以及 VSCode 中的配置，在不同平台（Windows &amp; Linux）下的具体细节存在一定的差异，下面将分为两部分内容分别介绍： For Windows For Linux 你可以直接选择你关注平台的配置，这两部分内容是独立完整的。 For Windows先进行 Windows 平台下 C/C++ 编译器的选择，安装以及配置： 配置 C/C++ 编译器：MinGW-w64MinGW-w64 的全称是：Minimalist GNU on Windows-win64bit，是 GCC 的 Windows 64bit 版本，可以编译生成 64bit 或 32bit 可执行程序。并且 MinGW-w64 是稳定可靠的、持续更新的 C/C++ 编译器，值得信赖！ 所以，这里选择安装以及配置 MinGW-w64 作为 Window 平台下 C/C++ 的编译器。当然，你也选择配置其它 C/C++ 编译器，如：Clang 等。 1.1 –&gt; Download Package 这里先给出 MinGW-w64 的托管网站，通过这里 &gt;&gt;&gt;&gt; 传送门 你可以获得其安装包。 这里提供两种安装方式： 在线安装器方式安装：MinGW-W64 Online Installer 某版本的现成安装包方式安装：例如，x86_64-posix-seh，版本选择可参看下文 1.2.1 中版本选择说明。 下载过程中可能由于网络问题导致安装包无法下载，例如，下载页面已经跳转但没有跳出下载安装包保存窗口，这时你可以尝试： 等待网络变好后，重新刷新网页； 寻找 【mirror】 或者 【Problems Downloading？】 选择一个较近的镜像网站，可能会获得较高（无法保证）的下载速度； 基于上述两种尝试，两种安装方式对应的安装链接都尝试下 1.2 –&gt; Begin To Setup 分别来看两种安装方式： 1.2.1 –&gt; 在线安装器方式进行安装 安装选项： 选项说明： 名称 解释 可选项 说明 选择建议 Version 版本号 无需求选择最新 Architecture 架构 i686, x86_64 64位系统选择 x86_64, 32位系统选择 i686 x86_64 Threads 线程模式 posix, win32 Windows 平台选 win32, 其它选 posix win32 Exception 异常处理 x86_64:sjlj,seh; i686:sjlj,dwarf sjlj同时支持32bit &amp; 64bit，稳定性好；seh 和 dwarf 只分别支持 64bit，32bit，但性能好 seh Build revision 构建版本号 0 【Next】 之后，你可以自定义 MinGW-w64 的安装目录。 下面来看第二种安装方式 &gt;&gt;&gt;&gt; 1.2.2 –&gt; 某版本的现成安装包方式安装 下载相应的安装包，具体版本选择可参考上表，选择合适位置解压（保证路径中没有空格的目录）即可。 1.3 –&gt; Config Envs-Vars MinGW-w64 安装好之后，需要检查是否已添加环境变量。 你可以尝试如下命令判断是否已经自动添加了环境变量（DOS）： 1$ g++ --version 如果没有 g++ 的版本输出信息，说明需要添加环境变量： 将 MinGW-w64 安装包目录下的 bin 文件夹添加至系统环境变 PATH 中 ↓↓↓↓↓↓ 添加后查看（g++ &amp;&amp; gcc）： 1234567891011&gt; g++ --versiong++ (x86_64-posix-seh-rev0, Built by MinGW-W64 project) 8.1.0Copyright (C) 2018 Free Software Foundation, Inc.This is free software; see the source for copying conditions. There is NOwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&gt; gcc --versiongcc (x86_64-posix-seh-rev0, Built by MinGW-W64 project) 8.1.0Copyright (C) 2018 Free Software Foundation, Inc.This is free software; see the source for copying conditions. There is NOwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 至此，C/C++ 编译器：MinGW-w64 的安装以及配置已经完成了~~~ 解决了编译器的问题后，接着看如何完成后续的 VSCode 配置： &gt;&gt;&gt;&gt; 配置工程文件夹前面提到过，需要使用 VSCode 设置规则在工程文件夹中进行一些配置，以可以帮助我们完成一键构建（编译、链接等）、运行…… 事实上，这总共会涉及到 4 个配置文件： 1234567891011# launch.json# tasks.json# settings.json# c_cpp_properties.json&gt;&gt;&gt; 注意：# VSCode 单次运行一个脚本视为一个 task，相应任务的配置文件为 tasks.json；# settings.json 为上面我们创建的工程文件夹（工作区，CppProjectWSC）的配置文件；# launch.json 是调试环境的配置文件；# c_cpp_properties.json 主要是用来配置 C/C++ 引用库路径的。 在开始 【launch.json &amp; tasks.json &amp; settings.json &amp; c_cpp_properties.json】 配置之前，你应该知道： 你可以选择直接在当前工程文件夹（CppProjectWSC）下创建一个 .vscode 文件夹，作为工程文件夹的环境配置目录，随后直接创建空白的上述四个文件，然后贴入你的配置内容，这是允许的。 但我们 不建议采用这种直接创建的方式，VSCode 直接提供了自动生成的方法，自动生成后你只需要修改或者添加一些你需要的配置就可以了。 2.1 –&gt; Go Start 我们将从 VSCode 中的 Debug（爬虫）功能入手，来完成整个配置过程。并且熟悉 VSCode 中 C/C++ 代码的编译、运行以及断点调试。 首先，点击“爬虫”按钮（或 Ctrl + Shift + D），打开 VSCode 中的 Debug（C/C++ 编译调试）界面观察一下： 下面正式开始配置 gcc 和 g++ 分别用于编译 C 和 C++: 2.1.1 –&gt; C 语言配置 开始配置之前，先给出一个 C 的实例代码方便后续的配置以及环境测试。在工程文件夹 CppProjectWSC 下创建一个名为 cTest.c 的 C 源码文件，内容为: 1234567891011121314151617181920212223/* * @Description: * @Author: TheNightIsYoung * @E-Mail: guojie0213_iit@163.com * @Date: 2017-09-26 11:07:21 * @LastEditors: TheNightIsYoung * @LastEditTime: 2019-09-26 11:20:28 */#include &lt;stdio.h&gt;int main(int argc, char const *argv[]){ /** * @Description: * @Func: VS Code Test * @Param: * @return: */ printf(&quot;Welcome to use VS Code.\\n&quot;); printf(&quot;This is a debug test.\\n&quot;); return 0;} 此时由于安装配置了编译器的原因，其实已经可以使用 Code Runner （Ctrl + Alt + N）运行 C 的代码了： 123[Running] cd &quot;e:\\VSCodeWorkS\\CPPProjectWSC\\&quot; &amp;&amp; gcc cTest.c -o cTest &amp;&amp; &quot;e:\\VSCodeWorkS\\CPPProjectWSC\\&quot;cTestWelcome to use VS Code.[Done] exited with code=0 in 0.684 seconds 完美~~~ 继续 ↓↓↓↓↓ 2.1.1-1 –&gt; 配置调试设置 【Ctrl + Shift + D】 –&gt; F5（启动 Debug 调试功能），跳转出一个小命令框选择 【C++ (GDB/LLDB)】，然后你可以看到： 然后，我们选择：【gcc build and debug active file】，此时 VSCode 会自动在工作区中创建 .vscode，并且在 .vscode 目录下生成配置文件：launch.json，用来配置调试的相关信息。内容如下： 注意：使用较新版本的 C/C++ 插件时，可能无法生成 launch.json 配置文件。此时，你可以插件的设置按钮选择【Install Another Version】，这里可以选择 1.8.4。 123456789101112131415161718192021222324252627282930313233343536{ // Use IntelliSense to learn about possible attributes. // Hover to view descriptions of existing attributes. // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387 &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ /* ------ GCC Launch For C ------ */ { &quot;name&quot;: &quot;(gdb) Launch&quot;, &quot;type&quot;: &quot;cppdbg&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;program&quot;: &quot;${fileDirname}\\\\${fileBasenameNoExtension}.exe&quot;, &quot;args&quot;: [], &quot;stopAtEntry&quot;: false, &quot;cwd&quot;: &quot;${workspaceFolder}&quot;, &quot;environment&quot;: [], &quot;externalConsole&quot;: false, &quot;MIMode&quot;: &quot;gdb&quot;, &quot;miDebuggerPath&quot;: &quot;F:\\\\MinWG64\\\\mingw64\\\\bin\\\\gdb.exe&quot;, &quot;setupCommands&quot;: [ { &quot;description&quot;: &quot;Enable pretty-printing for gdb&quot;, &quot;text&quot;: &quot;-enable-pretty-printing&quot;, &quot;ignoreFailures&quot;: true }, { &quot;description&quot;: &quot;Set Disassembly Flavor to Intel&quot;, &quot;text&quot;: &quot;-gdb-set disassembly-flavor intel&quot;, &quot;ignoreFailures&quot;: true } ], &quot;preLaunchTask&quot;: &quot;gcc build active file&quot; } ]} 可以检查默认生成 launch.json 内容是否和上述一样，否则新手需要保证一致（当然，miDebuggerPath 需要配置你自己的 gdb.exe 路径）。 配置好 launch.json 文件后（用来启动调试任务），此时你可以查看 .vscode 目录下是否生成 tasks.json ？ 如果有 tasks.json 文件，直接跳过这里开始后续配置，否则重新 –&gt; F5（启动 Debug 调试功能）此时可能会弹出窗口显示（很大可能）： 1Could not find the task 'gcc build active file' 提示你找不到 task gcc build active file，这时因为 task.json 文件不存在。 2.1.1-2 –&gt; 配置构建任务 此时菜单栏选择 【Terminal –&gt; Configure Task –&gt; Create task.json file from template –&gt; others】 便会自动完成 tasks.json 的创建，默认内容如下： 123456789101112{ // See https://go.microsoft.com/fwlink/?LinkId=733558 // for the documentation about the tasks.json format &quot;version&quot;: &quot;2.0.0&quot;, &quot;tasks&quot;: [ { &quot;label&quot;: &quot;echo&quot;, &quot;type&quot;: &quot;shell&quot;, &quot;command&quot;: &quot;echo Hello&quot; } ]} 此时需要我们来重新配置 tasks.json 文件，配置内容如下： 注意 command 要修改为你本地的 gcc.exe 路径；【options -&gt; cwd】 也需要修改为你本地的 MinWG64/bin 路径。 123456789101112131415161718192021222324252627282930{ // See https://go.microsoft.com/fwlink/?LinkId=733558 // for the documentation about the tasks.json format &quot;version&quot;: &quot;2.0.0&quot;, &quot;tasks&quot;: [ /* ------ Configure GCC Compiler For C ------ */ { &quot;label&quot;: &quot;gcc build active file&quot;, &quot;type&quot;: &quot;cppbuild&quot;, &quot;command&quot;: &quot;F:\\\\MinWG64\\\\mingw64\\\\bin\\\\gcc.exe&quot;, &quot;args&quot;: [ &quot;-g&quot;, &quot;${file}&quot;, &quot;-o&quot;, &quot;${fileDirname}\\\\${fileBasenameNoExtension}.exe&quot; ], &quot;options&quot;: { &quot;cwd&quot;: &quot;F:\\\\MinWG64\\\\mingw64\\\\bin&quot; }, &quot;problemMatcher&quot;:[ &quot;$gcc&quot; ], &quot;group&quot;: { &quot;kind&quot;: &quot;build&quot;, &quot;isDefault&quot;: true } } ]} 对于 tasks.json 文件，是为了方便在 VScode 里编译 C/C++ 代码，可以将类似 g++ -g main.cpp 等 gcc/g++ 命令写入 VScode 的任务系统。 ======================================================================== 再来总结一下： launch.json 用来启动断点调试程序，其中有一个 ”preLaunchTask“=”gcc build active file&quot; ，也就是添加一个 launch（启动）的任务，任务名为 gcc build active file，这 gcc build active file 就是我们在 tasks.json 中设置的 lable（个人理解：也就是说 launch 通过 preLaunchTask 去 tasks.json 查找具体的编译任务，然后完成编译，链接，运行….）。 ======================================================================== 事实上，如果你仅仅编写 C 语言，到此 VS Code 已经能够满足你的要求。你可以尝试一下对上述给出的 C 源码进行断点调试（F5）。调试的两个快捷键与 Visual Studio 相同，F10 逐过程，F11 逐语句。 2.1.2 —&gt; C++ 语言配置 我们再来创建一个 C++ 源码文件（c++Test.py）用于完成后续 C++ 语言的配置与测试： 12345678910111213141516171819202122232425/* * @Description: * @Author: TheNightIsYoung * @E-Mail: * @Date: 2017-09-20 13:26:01 * @LastEditors: TheNightIsYoung * @LastEditTime: 2019-09-20 13:29:54 */#include &lt;iostream&gt;using namespace std;int main(int argc, char const *argv[]){ /** * @Description: * @Func: VSCode Test * @Param: * @return: */ cout &lt;&lt; &quot;Welcome to use VS Code.&quot; &lt;&lt; endl; return 0;} 此时由于安装配置了编译器的原因，其实已经可以使用 Code Runner （Ctrl + Alt + N）运行 C++ 的代码了： 1234[Running] cd &quot;e:\\VSCodeWorkS\\CPPProjectWSC\\&quot; &amp;&amp; g++ c++Test.cpp -o c++Test &amp;&amp; &quot;e:\\VSCodeWorkS\\CPPProjectWSC\\&quot;c++TestWelcome to use VS Code.[Done] exited with code=0 in 0.515 seconds 完美~~~ 继续 ↓↓↓↓↓ 2.1.2-1 –&gt; 配置调试设置 继续配置 C++ 的断点调试，参照前面已经生成的 C 的配置： 先来打开之前配置 C 语言的 launch.json，点击页面右下角的【Add Configuration】，选择【（gdb）launch】，可以看到为我们生成的一个新的调试方式: 123456789101112131415161718192021222324252627&quot;configurations&quot;: [ { &quot;name&quot;: &quot;(gdb) Launch&quot;, &quot;type&quot;: &quot;cppdbg&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;program&quot;: &quot;enter program name, for example ${workspaceFolder}/a.exe&quot;, &quot;args&quot;: [], &quot;stopAtEntry&quot;: false, &quot;cwd&quot;: &quot;${fileDirname}&quot;, &quot;environment&quot;: [], &quot;externalConsole&quot;: false, &quot;MIMode&quot;: &quot;gdb&quot;, &quot;miDebuggerPath&quot;: &quot;/path/to/gdb&quot;, &quot;setupCommands&quot;: [ { &quot;description&quot;: &quot;Enable pretty-printing for gdb&quot;, &quot;text&quot;: &quot;-enable-pretty-printing&quot;, &quot;ignoreFailures&quot;: true }, { &quot;description&quot;: &quot;Set Disassembly Flavor to Intel&quot;, &quot;text&quot;: &quot;-gdb-set disassembly-flavor intel&quot;, &quot;ignoreFailures&quot;: true } ] }, 对比着之前的 gcc 调试方式，我们需要修改一点细节，从之前生成的信息复制过来修改 launch.json，主要修改这几个选项： –&gt; 1] program 1${fileDirname}\\\\${fileBasenameNoExtension}.exe –&gt; 2] miDebuggerPath 1复制之前的路径 –&gt; 3] stopAtEntry 1true // 非必须 –&gt; 4] 添加 preLaunchTask 1&quot;preLaunchTask&quot;: &quot;g++ build active file&quot; // 注意上个设置项结尾的逗号 然后，修改一下两个启动器名称（name 重复了），完成后的 launch.json 变为如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980{ // Use IntelliSense to learn about possible attributes. // Hover to view descriptions of existing attributes. // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387 &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ /* ------ G++ Launch For C/C++ ------ */ { &quot;name&quot;: &quot;(G++) Launch&quot;, // 配置名称：将会在启动配置的下拉菜单中显示; &quot;type&quot;: &quot;cppdbg&quot;, // 配置类型: 使用 GDB 或 LLDB 时只能是 cppdbg； &quot;request&quot;: &quot;launch&quot;, // 请求配置类型: 可以设置为 launch（启动）或 attach（附加）； &quot;program&quot;: &quot;${fileDirname}/${fileBasenameNoExtension}.exe&quot;, // 设置将要进行调试的程序的路径； &quot;args&quot;: [], // 程序调试时传递给程序的命令行参数，一般设为空即可； &quot;stopAtEntry&quot;: false, // 设为 true 时，程序将暂停在程序入口处，一般设置为 false； &quot;cwd&quot;: &quot;${workspaceFolder}&quot;, // 调试程序时的工作目录：一般设置为 ${workspaceRoot}，即代码所在目录（工作区）； &quot;environment&quot;: [], // 设置调试时添加到程序环境中的环境变量，例如: [ { &quot;name&quot;: &quot;squid&quot;, &quot;value&quot;: &quot;clam&quot; } ]； &quot;externalConsole&quot;: false, // 调试时是否显示控制台窗口：一般设置为 true，显示控制台； &quot;windows&quot;: { // For Windows &quot;MIMode&quot;: &quot;gdb&quot;, // 指定连接的调试器：可以为 gdb 或 lldb（但目前 lldb 在 Windows下没有预编译好的版本）； &quot;miDebuggerPath&quot;: &quot;F:/MinWG64/mingw64/bin/gdb.exe&quot; // 调试器（miDebugger）路径，注意 Windows 下这里要与 MinGw 的路径对应； }, &quot;linux&quot;: { // For Linux &quot;MIMode&quot;: &quot;gdb&quot;, // 指定连接的调试器：可以为 gdb 或 lldb（但目前 lldb 在 Windows下没有预编译好的版本）； &quot;miDebuggerPath&quot;: &quot;/usr/bin/gdb&quot; // 调试器（miDebugger）路径，注意 Windows 下这里要与 MinGw 的路径对应； }, &quot;setupCommands&quot;: [ // 执行下面的命令数组以设置 GDB 或 LLDB { &quot;description&quot;: &quot;Enable pretty-printing for gdb&quot;, &quot;text&quot;: &quot;-enable-pretty-printing&quot;, &quot;ignoreFailures&quot;: true }, { &quot;description&quot;: &quot;Set Disassembly Flavor to Intel&quot;, &quot;text&quot;: &quot;-gdb-set disassembly-flavor intel&quot;, &quot;ignoreFailures&quot;: true } ], &quot;logging&quot;: { // 用于设置：将哪些类型的消息记录到调试控制台。 &quot;exceptions&quot;: true, // 是否应将异常消息记录到调试控制台,默认为 true； &quot;moduleLoad&quot;: true, // 是否应将模块加载事件记录到调试控制台，默认为 true； &quot;programOutput&quot;: true, // 是否应将程序输出记录到调试控制台的可选标志，默认为 true； &quot;engineLogging&quot;: false, // 是否应将诊断引擎日志记录到调试控制台，默认为 false； &quot;trace&quot;: false, // 是否将诊断适配器命令跟踪记录到调试控制台，默认为 false； &quot;traceResponse&quot;: false // 是否将诊断适配器命令和响应跟踪记录到调试控制台，默认为 false。 }, &quot;preLaunchTask&quot;: &quot;g++ build active file&quot; // 设置调试会话开始前将执行的任务：一般为编译程序（例如 C++：g++.exe, C：gcc.exe），与 tasks.json 的 label 相对应; }, /* ------ GCC Launch For C ------ */ { &quot;name&quot;: &quot;(GCC) Launch&quot;, &quot;type&quot;: &quot;cppdbg&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;program&quot;: &quot;${fileDirname}/${fileBasenameNoExtension}.exe&quot;, &quot;args&quot;: [], &quot;stopAtEntry&quot;: true, &quot;cwd&quot;: &quot;${workspaceFolder}&quot;, &quot;environment&quot;: [], &quot;externalConsole&quot;: false, &quot;MIMode&quot;: &quot;gdb&quot;, &quot;miDebuggerPath&quot;: &quot;F:/MinWG64/mingw64/bin/gdb.exe&quot;, &quot;setupCommands&quot;: [ { &quot;description&quot;: &quot;Enable pretty-printing for gdb&quot;, &quot;text&quot;: &quot;-enable-pretty-printing&quot;, &quot;ignoreFailures&quot;: true }, { &quot;description&quot;: &quot;Set Disassembly Flavor to Intel&quot;, &quot;text&quot;: &quot;-gdb-set disassembly-flavor intel&quot;, &quot;ignoreFailures&quot;: true } ], &quot;preLaunchTask&quot;: &quot;gcc build active file&quot; } ]} 2.1.2-2 –&gt; 配置构建任务 然后我们打开 task.json，按照之前生成的 gcc 编译命令，添加 g++ 编译命令。只需将之前的复制过来一份更改以下项目就行: –&gt; 1] label 1将 gcc build active file 改为：g++ build active file –&gt; 2] command 1将之前的调试编译器由 &quot;gcc&quot; 改为：&quot;g++&quot; 完成后的 task.json 配置文件： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253{ // See https://go.microsoft.com/fwlink/?LinkId=733558 // for the documentation about the tasks.json format &quot;version&quot;: &quot;2.0.0&quot;, &quot;tasks&quot;: [ /* ------ Configure G++ Compiler For C/C++ ------ */ { &quot;label&quot;: &quot;g++ build active file&quot;, // 任务名称：被启动器 Launch 调用，与 launch.json 的 preLaunchTask 设置项相对应； &quot;type&quot;: &quot;shell&quot;, // { shell | process } &quot;command&quot;: &quot;F:/MinWG64/mingw64/bin/g++.exe&quot;, // 设置调试时使用的编译器： 这里设置为 G++，用于编译 C++ 语言； &quot;args&quot;: [ &quot;-g&quot;, // 生成和调试有关的信息; &quot;${file}&quot;, &quot;-o&quot;, // 设置编译后输出的文件名：默认输出 a.exe; &quot;${fileDirname}/${fileBasenameNoExtension}.exe&quot; ], &quot;options&quot;: { &quot;cwd&quot;: &quot;F:/MinWG64/mingw64/bin&quot; }, &quot;problemMatcher&quot;:[ &quot;$gcc&quot; ], &quot;group&quot;: { // 用于定义此任务属于的执行组 &quot;kind&quot;: &quot;build&quot;, // { build | test } &quot;isDefault&quot;: true // { true | false } } }, /* ------ Configure GCC Compiler For C ------ */ { &quot;label&quot;: &quot;gcc build active file&quot;, &quot;type&quot;: &quot;shell&quot;, &quot;command&quot;: &quot;F:/MinWG64/mingw64/bin/gcc.exe&quot;, &quot;args&quot;: [ &quot;-g&quot;, &quot;${file}&quot;, &quot;-o&quot;, &quot;${fileDirname}/${fileBasenameNoExtension}.exe&quot; ], &quot;options&quot;: { &quot;cwd&quot;: &quot;F:/MinWG64/mingw64/bin&quot; }, &quot;problemMatcher&quot;:[ &quot;$gcc&quot; ], &quot;group&quot;: { &quot;kind&quot;: &quot;build&quot;, &quot;isDefault&quot;: true } } ]} 至此，回到我们的调试界面（Debug），已经可以看到启动条目里面具有 g++/gcc 调试选项，你可以再尝试一下对上述给出的 C++ 源码进行断点调试（F5）。 好了，你的 VS Code（Windows）已经可以同时编译调试 C/C++ ~ 你应该还没忘了之前说过的有 4 个文件进行配置吧？余下的两个配置文件与 C/C++（库引用、C 标准等）以及一些项目自定义设置相关。 话不多说，开始配置： 2.1.2-3 –&gt; 配置单文件夹工作区设置（settings.json） VSCode 可以通过 用户（User） 和 文件夹 设置来实现高度可配置化。用户设置是全局的，但单文件夹的工作区的设置（.vscode/settings.json）是针对当前项目进行独立设置的，它会覆盖用户设置，你可以在其中进行当前项目的个性化设置。 换句话说，你可以在 settings.json 中针对当前工程项目类别（C++ or Java？）进行远超符合你代码书写习惯的设置，例如配置 Tab 空格数、自动保存、自动格式化等等。 如何自动生成 settings.json 文件？？？ &gt;&gt;&gt;&gt;&gt; 打开 VSCode 设置页面（Ctrl + ,），切换到 Workspace，在配置项中随便找一个 Edit in settings.json 打开，即可在 .vscode 下自动生成 settings.json 文件。如果你已经针对工作区进行过配置，settings.json 是不为空的，否则应该是一个空白的文件。 这里给一个样例配置（你可以根据个人需要进行设置）： 1234567891011121314151617181920212223242526272829303132{ &quot;files.autoSave&quot;: &quot;onWindowChange&quot;, // 文件自动保存选项；参数说明：onFocusChange =&gt; 当前文件失去焦点后自动保存; onWindowChange =&gt; 需要当前 VScode 窗口失去焦点才会自动保存 &quot;files.autoSaveDelay&quot;: 3000, // 间隔多少毫秒自动保存，默认「1000毫秒」;如果配置了保存格式化代码，这个配置下自动保存不会格式化代码 &quot;editor.tabSize&quot;: 4, // 配置 Tab 空格数 &quot;editor.formatOnSave&quot;: false, // 保存自动格式化代码 &quot;editor.formatOnPaste&quot;: true, // 粘贴自动格式化 &quot;code-runner.runInTerminal&quot;: false, // 设置成 false 会在 “output” 中进行输出，无法输入； &quot;code-runner.executorMap&quot;: { &quot;c&quot;: &quot;cd $dir &amp;&amp; gcc $fileName -o $fileNameWithoutExt &amp;&amp; $dir$fileNameWithoutExt&quot;, &quot;cpp&quot;: &quot;cd $dir &amp;&amp; g++ $fileName -o $fileNameWithoutExt &amp;&amp; $dir$fileNameWithoutExt&quot; }, &quot;code-runner.saveFileBeforeRun&quot;: true, // Run Code 前保存； &quot;code-runner.preserveFocus&quot;: true, // 若为 false，Run code 后光标会聚焦到终端上。如果需要频繁输入数据可设为 false； &quot;code-runner.clearPreviousOutput&quot;: true, // 每次 Run code 前清空终端中属于之前 Code runner 的日志消息； &quot;C_Cpp.clang_format_sortIncludes&quot;: true, // 格式化时调整 include 的顺序（按字母排序）; &quot;C_Cpp.intelliSenseEngine&quot;: &quot;Default&quot;, // 可以为 Default 或 Tag Parser，后者较老，功能较简单。具体差别参考 cpptools 扩展文档； &quot;C_Cpp.errorSquiggles&quot;: &quot;Disabled&quot;, &quot;C_Cpp.autocomplete&quot;: &quot;Default&quot;, &quot;files.associations&quot;: { // 将某文件扩展名视为某种语言，可用通配符模式以及文档中的已知语言字符串进行关联。 &quot;iostream&quot;: &quot;cpp&quot;, &quot;exit-thread.h&quot;: &quot;c&quot;, &quot;ldsodefs.h&quot;: &quot;c&quot;, &quot;random&quot;: &quot;cpp&quot;, &quot;tls.h&quot;: &quot;c&quot;, &quot;dl-osinfo.h&quot;: &quot;c&quot;, &quot;stdio.h&quot;: &quot;c&quot; }} 2.1.2-4 –&gt; 配置 C/C++ 引用库路径（c_cpp_properties.json） Ctrl + Shift + P 调出命令控制窗口，再输入 edit 或者 configuration，选择 &quot;C/C++:Edit Configurations(JSON)&quot;，然后这个文件就出来了，默认配置如下： 1234567891011121314151617181920{ &quot;configurations&quot;: [ { &quot;name&quot;: &quot;Win32&quot;, &quot;includePath&quot;: [ &quot;${workspaceFolder}/**&quot; ], &quot;defines&quot;: [ &quot;_DEBUG&quot;, &quot;UNICODE&quot;, &quot;_UNICODE&quot; ], &quot;compilerPath&quot;: &quot;F:\\\\MinWG64\\\\mingw64\\\\bin\\\\gcc.exe&quot;, &quot;cStandard&quot;: &quot;gnu17&quot;, &quot;cppStandard&quot;: &quot;gnu++14&quot;, &quot;intelliSenseMode&quot;: &quot;windows-gcc-x64&quot; } ], &quot;version&quot;: 4} 注意，该配置文件中不允许有注释!!! 你需要将 C/C++ 开发可能用到的引用库路径设置进来，添加到 includePath 选项中即可。 支持自动查询，includePath 中需要添加的路径获取方法：cmd ——&gt; gcc -v -E -x c++ -，搜索结果如下： 给出 c_cpp_properties.json 最终的配置内容（注意 brower 选项）: 123456789101112131415161718192021222324252627282930313233343536373839404142{ &quot;configurations&quot;: [ { &quot;name&quot;: &quot;Win32&quot;, &quot;includePath&quot;: [ &quot;${workspaceFolder}/**&quot;, &quot;F:/MinWG64/mingw64/include&quot;, &quot;F:/MinWG64/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++&quot;, &quot;F:/MinWG64/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/x86_64-w64-mingw32&quot;, &quot;F:/MinWG64/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/backward&quot;, &quot;F:/MinWG64/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/8.1.0/include&quot;, &quot;F:/MinWG64/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/8.1.0/include-fixed&quot;, &quot;F:/MinWG64/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/8.1.0/../../../../x86_64-w64-mingw32/include&quot; ], &quot;defines&quot;: [ &quot;_DEBUG&quot;, &quot;UNICODE&quot;, &quot;_UNICODE&quot; ], &quot;compilerPath&quot;: &quot;F:\\\\MinWG64\\\\mingw64\\\\bin\\\\gcc.exe&quot;, &quot;cStandard&quot;: &quot;gnu17&quot;, &quot;cppStandard&quot;: &quot;gnu++14&quot;, &quot;intelliSenseMode&quot;: &quot;windows-gcc-x64&quot;, &quot;browse&quot;: { &quot;limitSymbolsToIncludedHeaders&quot;: true, &quot;databaseFilename&quot;: &quot;&quot;, &quot;path&quot;: [ &quot;${workspaceFolder}/**&quot;, &quot;F:/MinWG64/mingw64/include&quot;, &quot;F:/MinWG64/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++&quot;, &quot;F:/MinWG64/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/x86_64-w64-mingw32&quot;, &quot;F:/MinWG64/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/backward&quot;, &quot;F:/MinWG64/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/8.1.0/include&quot;, &quot;F:/MinWG64/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/8.1.0/include-fixed&quot;, &quot;F:/MinWG64/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/8.1.0/../../../../x86_64-w64-mingw32/include&quot; ] } } ], &quot;version&quot;: 4} 其中，browse 字段（重要）说明 &gt;&gt;&gt;&gt; 如果只是将需要包含的头文件放在 includePath 字段中,那么 include 的问题解决了，但是 defines 的问题还没有解决，这将会出现一大堆的提示。 这些提示大部分都是因为缺少相应的宏定义引起的，而 browse 可以搜索相应 browse.path 字段中所有的宏定义，并把缺少的宏定义补全，让 Definition/Declaration 操作可以无障碍。 For Linux接下来，来看 Linux 平台下 C/C++ 编译器的选择，安装以及配置（大同小异）： 配置 C/C++ 编译器：GCC &amp;&amp; G++对于 Centos（ Centos7.2）而言，安装后可能是没有 C 语言和 C++ 编译环境的，故需要手动安装（yum）GCC/g++（安装前你可以通过 gcc/g++ --version 测试一下是否已安装过）： 1234# GCC$ yum -y install gcc# g++$ yum -y install gcc-c++ 而对于 Ubuntu（ Ubuntu16.04 Check），系统中默认已安装有 GCC/g++，你可以查看当前版本： 1234567891011deeplearning@ThinkCentre-M910s-N000:~/DeepLearning$ gcc --versiongcc (Ubuntu 5.4.0-6ubuntu1~16.04.11) 5.4.0 20160609Copyright (C) 2015 Free Software Foundation, Inc.This is free software; see the source for copying conditions. There is NOwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.deeplearning@ThinkCentre-M910s-N000:~/DeepLearning$ g++ --versiong++ (Ubuntu 5.4.0-6ubuntu1~16.04.11) 5.4.0 20160609Copyright (C) 2015 Free Software Foundation, Inc.This is free software; see the source for copying conditions. There is NOwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 解决了编译器的问题后，接着看如何完成后续的 VSCode 配置： &gt;&gt;&gt;&gt; 配置工程文件夹前面提到过，需要使用 VSCode 设置规则在工程文件夹中进行一些配置，以可以帮助我们完成一键构建（编译、链接等）、运行…… 事实上，这总共会涉及到 4 个配置文件： 1234567891011# launch.json# tasks.json# settings.json# c_cpp_properties.json&gt;&gt;&gt; 注意：# VSCode 单次运行一个脚本视为一个 task，相应任务的配置文件为 tasks.json；# settings.json 为上面我们创建的工程文件夹（工作区，CppProjectWSC）的配置文件；# launch.json 是调试环境的配置文件；# c_cpp_properties.json 主要是用来配置 C/C++ 引用库路径的。 在开始 【launch.json &amp; tasks.json &amp; settings.json &amp; c_cpp_properties.json】 配置之前，你应该知道： 你可以选择直接在当前工程文件夹（CppProjectWSC）下创建一个 .vscode 文件夹，作为工程文件夹的环境配置目录，随后直接创建空白的上述四个文件，然后贴入你的配置内容，这是允许的。 但我们 不建议采用这种直接创建的方式，VSCode 直接提供了自动生成的方法，自动生成后你只需要修改或者添加一些你需要的配置就可以了。 2.1 –&gt; Go Start 我们将从 VSCode 中的 Debug（爬虫）功能入手，来完成整个配置过程。并且熟悉 VSCode 中 C/C++ 代码的编译、运行以及断点调试。 首先，点击“爬虫”按钮（或 Ctrl + Shift + D），打开 VSCode 中的 Debug（C/C++ 编译调试）界面观察一下： 下面正式开始配置 gcc 和 g++ 分别用于编译 C 和 C++: 2.1.1 –&gt; C 语言配置 开始配置之前，先给出一个 C 的实例代码方便后续的配置以及环境测试。在工程文件夹 CppProjectWSC 下创建一个名为 cTest.c 的 C 源码文件，内容为: 1234567891011121314151617181920212223/* * @Description: * @Author: TheNightIsYoung * @E-Mail: guojie0213_iit@163.com * @Date: 2017-09-26 11:07:21 * @LastEditors: TheNightIsYoung * @LastEditTime: 2019-09-26 11:20:28 */#include &lt;stdio.h&gt;int main(int argc, char const *argv[]){ /** * @Description: * @Func: VS Code Test * @Param: * @return: */ printf(&quot;Welcome to use VS Code.\\n&quot;); printf(&quot;This is a debug test.\\n&quot;); return 0;} 此时由于安装配置了编译器的原因，其实已经可以使用 Code Runner （Ctrl + Alt + N）运行 C 的代码了： 1Welcome to use VS Code. 完美~~~ 继续 ↓↓↓↓↓ 2.1.1-1 –&gt; 配置调试设置 【Ctrl + Shift + D】 –&gt; F5（启动 Debug 调试功能），跳转出一个小命令框选择 【C++ (GDB/LLDB)】，然后你可以看到： 然后，我们选择：【gcc build and debug active file】，此时 VSCode 会自动在工作区中创建 .vscode，并且在 .vscode 目录下生成配置文件：launch.json，用来配置调试的相关信息。内容如下： 注意：使用较新版本的 C/C++ 插件时，可能无法生成 launch.json 配置文件。此时，你可以插件的设置按钮选择【Install Another Version】，这里可以选择 1.8.4。 123456789101112131415161718192021222324252627282930{ // Use IntelliSense to learn about possible attributes. // Hover to view descriptions of existing attributes. // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387 &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ /* ------ GCC Launch For C ------ */ { &quot;name&quot;: &quot;gcc build and debug active file&quot;, &quot;type&quot;: &quot;cppdbg&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;program&quot;: &quot;${fileDirname}/${fileBasenameNoExtension}.out&quot;, &quot;args&quot;: [], &quot;stopAtEntry&quot;: true, &quot;cwd&quot;: &quot;${workspaceFolder}&quot;, &quot;environment&quot;: [], &quot;externalConsole&quot;: false, &quot;MIMode&quot;: &quot;gdb&quot;, &quot;setupCommands&quot;: [ { &quot;description&quot;: &quot;Enable pretty-printing for gdb&quot;, &quot;text&quot;: &quot;-enable-pretty-printing&quot;, &quot;ignoreFailures&quot;: true } ], &quot;preLaunchTask&quot;: &quot;gcc build active file&quot;, &quot;miDebuggerPath&quot;: &quot;/usr/bin/gdb&quot; } ]} 可以检查默认生成 launch.json 内容是否和上述一样，否则新手需要保证一致（当然，miDebuggerPath 需要配置你自己的 gdb 路径）。 配置好 launch.json 文件后（用来启动调试任务），此时你可以查看 .vscode 目录下是否生成 tasks.json？ 如果有 tasks.json，直接跳过这里开始后续配置，否则重新 –&gt; F5（启动 Debug 调试功能）此时可能会弹出窗口显示（很大可能）： 1Could not find the task 'gcc build active file' 提示你找不到 task gcc build active file，这时因为 task.json 文件不存在。 2.1.1-2 –&gt; 配置构建任务 此时菜单栏选择 【Terminal –&gt; Configure Task –&gt; Create task.json file from template –&gt; others】 便会自动完成 tasks.json 的创建，默认内容如下： 123456789101112{ // See https://go.microsoft.com/fwlink/?LinkId=733558 // for the documentation about the tasks.json format &quot;version&quot;: &quot;2.0.0&quot;, &quot;tasks&quot;: [ { &quot;label&quot;: &quot;echo&quot;, &quot;type&quot;: &quot;shell&quot;, &quot;command&quot;: &quot;echo Hello&quot; } ]} 此时需要我们来重新配置 tasks.json 文件，配置内容如下： 注意 command 要修改为你本地的 gcc 路径；【options -&gt; cwd】 也需要修改为你本地的 gcc/bin 路径。 123456789101112131415161718192021222324{ &quot;tasks&quot;: [ /* ------ Configure GCC Compiler For C ------ */ { &quot;type&quot;: &quot;shell&quot;, &quot;label&quot;: &quot;gcc build active file&quot;, &quot;command&quot;: &quot;/usr/bin/gcc&quot;, &quot;args&quot;: [ &quot;-g&quot;, &quot;${file}&quot;, &quot;-o&quot;, &quot;${fileDirname}/${fileBasenameNoExtension}.out&quot; ], &quot;options&quot;: { &quot;cwd&quot;: &quot;/usr/bin&quot; }, &quot;group&quot;: { &quot;kind&quot;: &quot;build&quot;, &quot;isDefault&quot;: true } } ], &quot;version&quot;: &quot;2.0.0&quot;} 对于 tasks.json 文件，是为了方便在 VScode 里编译 C/C++ 代码，可以将类似 g++ -g main.cpp 等 gcc/g++ 命令写入 VScode 的任务系统。 ======================================================================== 再来总结一下： launch.json 用来启动断点调试程序，其中有一个 ”preLaunchTask“=”gcc build active file&quot; ，也就是添加一个 launch（启动）的任务，任务名为 gcc build active file，这 gcc build active file 就是我们在 tasks.json 中设置的 lable（个人理解：也就是说 launch 通过 preLaunchTask 去 tasks.json 查找具体的编译任务，然后完成编译，链接，运行….）。 ======================================================================== 事实上，如果你仅仅编写 C 语言，到此 VS Code 已经能够满足你的要求。你可以尝试一下对上述给出的 C 源码进行断点调试（F5）。调试的两个快捷键与 Visual Studio 相同，F10 逐过程，F11 逐语句。 2.1.2 —&gt; C++ 语言配置 我们再来创建一个 C++ 源码文件（c++Test.py）用于完成后续 C++ 语言的配置与测试： 12345678910111213141516171819202122232425/* * @Description: * @Author: TheNightIsYoung * @E-Mail: * @Date: 2017-09-20 13:26:01 * @LastEditors: TheNightIsYoung * @LastEditTime: 2019-09-20 13:29:54 */#include &lt;iostream&gt;using namespace std;int main(int argc, char const *argv[]){ /** * @Description: * @Func: VSCode Test * @Param: * @return: */ cout &lt;&lt; &quot;Welcome to use VS Code.&quot; &lt;&lt; endl; return 0;} 此时由于安装配置了编译器的原因，其实已经可以使用 Code Runner （Ctrl + Alt + N）运行 C++ 的代码了： 1Welcome to use VS Code. 完美~~~ 继续 ↓↓↓↓↓ 2.1.2-1 –&gt; 配置调试设置 继续配置 C++ 的断点调试，参照前面已经生成的 C 的配置： 先来打开之前配置 C 语言的 launch.json，点击页面右下角的【Add Configuration】，选择【（gdb）launch】，可以看到为我们生成的一个新的调试方式: 1234567891011121314151617181920&quot;configurations&quot;: [ { &quot;name&quot;: &quot;(gdb) Launch&quot;, &quot;type&quot;: &quot;cppdbg&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;program&quot;: &quot;enter program name, for example ${workspaceFolder}/a.out&quot;, &quot;args&quot;: [], &quot;stopAtEntry&quot;: false, &quot;cwd&quot;: &quot;${workspaceFolder}&quot;, &quot;environment&quot;: [], &quot;externalConsole&quot;: false, &quot;MIMode&quot;: &quot;gdb&quot;, &quot;setupCommands&quot;: [ { &quot;description&quot;: &quot;Enable pretty-printing for gdb&quot;, &quot;text&quot;: &quot;-enable-pretty-printing&quot;, &quot;ignoreFailures&quot;: true } ] } 对比着之前的 gcc 调试方式，我们需要修改一点细节，从之前生成的信息复制过来修改 launch.json，主要修改这几个选项： –&gt; 1] program 1${fileDirname}/${fileBasenameNoExtension}.o –&gt; 2] miDebuggerPath 1复制之前的路径 –&gt; 3] stopAtEntry 1true // 非必须 –&gt; 4] 添加 preLaunchTask 1&quot;preLaunchTask&quot;: &quot;g++ build active file&quot; // 注意上个设置项结尾的逗号 然后，修改一下两个启动器名称（name 重复了），完成后的 launch.json 变为如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970{ // Use IntelliSense to learn about possible attributes. // Hover to view descriptions of existing attributes. // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387 &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ /* ------ G++ Launch For C/C++ ------ */ { &quot;name&quot;: &quot;(G++) Launch&quot;, // 配置名称：将会在启动配置的下拉菜单中显示; &quot;type&quot;: &quot;cppdbg&quot;, // 配置类型: 使用 GDB 或 LLDB 时只能是 cppdbg； &quot;request&quot;: &quot;launch&quot;, // 请求配置类型: 可以设置为 launch（启动）或 attach（附加）； &quot;program&quot;: &quot;${fileDirname}/${fileBasenameNoExtension}.out&quot;, // 设置将要进行调试的程序的路径； &quot;args&quot;: [], // 程序调试时传递给程序的命令行参数，一般设为空即可； &quot;stopAtEntry&quot;: true, // 设为 true 时，程序将暂停在程序入口处，一般设置为 false； &quot;cwd&quot;: &quot;${workspaceFolder}&quot;, // 调试程序时的工作目录：一般设置为 ${workspaceRoot}，即代码所在目录（工作区）； &quot;environment&quot;: [], // 设置调试时添加到程序环境中的环境变量，例如: [ { &quot;name&quot;: &quot;squid&quot;, &quot;value&quot;: &quot;clam&quot; } ]； &quot;externalConsole&quot;: false, // 调试时是否显示控制台窗口：一般设置为 true，显示控制台； &quot;windows&quot;: { // For Windows &quot;MIMode&quot;: &quot;gdb&quot;, // 指定连接的调试器：可以为 gdb 或 lldb（但目前 lldb 在 Windows下没有预编译好的版本）； &quot;miDebuggerPath&quot;: &quot;D:\\\\...&quot;, // 调试器（miDebugger）路径，注意 Windows 下这里要与 MinGw 的路径对应； }, &quot;linux&quot;: { // For Linux &quot;MIMode&quot;: &quot;gdb&quot;, // 指定连接的调试器：可以为 gdb 或 lldb（但目前 lldb 在 Windows下没有预编译好的版本）； &quot;miDebuggerPath&quot;: &quot;/usr/bin/gdb&quot;, // 调试器（miDebugger）路径，注意 Windows 下这里要与 MinGw 的路径对应； }, &quot;setupCommands&quot;: [ // 执行下面的命令数组以设置 GDB 或 LLDB { &quot;description&quot;: &quot;Enable pretty-printing for gdb&quot;, &quot;text&quot;: &quot;-enable-pretty-printing&quot;, &quot;ignoreFailures&quot;: true } ], &quot;logging&quot;: { // 用于设置：将哪些类型的消息记录到调试控制台。 &quot;exceptions&quot;: true, // 是否应将异常消息记录到调试控制台,默认为 true； &quot;moduleLoad&quot;: false, // 是否应将模块加载事件记录到调试控制台，默认为 true； &quot;programOutput&quot;: true, // 是否应将程序输出记录到调试控制台的可选标志，默认为 true； &quot;engineLogging&quot;: false, // 是否应将诊断引擎日志记录到调试控制台，默认为 false； &quot;trace&quot;: false, // 是否将诊断适配器命令跟踪记录到调试控制台，默认为 false； &quot;traceResponse&quot;: false // 是否将诊断适配器命令和响应跟踪记录到调试控制台，默认为 false。 }, &quot;preLaunchTask&quot;: &quot;g++ build active file&quot; // 设置调试会话开始前将执行的任务：一般为编译程序（例如 C++：g++.exe, C：gcc.exe），与 tasks.json 的 label 相对应; }, /* ------ GCC Launch For C ------ */ { &quot;name&quot;: &quot;(GCC) Launch&quot;, &quot;type&quot;: &quot;cppdbg&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;program&quot;: &quot;${fileDirname}/${fileBasenameNoExtension}.out&quot;, &quot;args&quot;: [], &quot;stopAtEntry&quot;: true, &quot;cwd&quot;: &quot;${workspaceFolder}&quot;, &quot;environment&quot;: [], &quot;externalConsole&quot;: false, &quot;MIMode&quot;: &quot;gdb&quot;, &quot;setupCommands&quot;: [ { &quot;description&quot;: &quot;Enable pretty-printing for gdb&quot;, &quot;text&quot;: &quot;-enable-pretty-printing&quot;, &quot;ignoreFailures&quot;: true } ], &quot;preLaunchTask&quot;: &quot;gcc build active file&quot;, &quot;miDebuggerPath&quot;: &quot;/usr/bin/gdb&quot; } ]} 2.1.1-2 –&gt; 配置构建任务 然后我们打开 task.json，按照之前生成的 gcc 编译命令，添加 g++ 编译命令。只需将之前的复制过来一份更改以下项目就行: –&gt; 1] label 1将 gcc build active file 改为：g++ build active file –&gt; 2] command 1将之前的调试编译器由 &quot;gcc&quot; 改为：&quot;g++&quot; 完成后的 task.json 配置文件： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647{ &quot;tasks&quot;: [ /* ------ Configure G++ Compiler For C/C++ ------ */ { &quot;type&quot;: &quot;shell&quot;, // { shell | process } &quot;label&quot;: &quot;g++ build active file&quot;, // 任务名称：被启动器 Launch 调用，与 launch.json 的 preLaunchTask 设置项相对应； &quot;command&quot;: &quot;/usr/bin/g++&quot;, // 设置调试时使用的编译器： 这里设置为 GCC，用于编译 C 语言； /**编译命令参数设置：*/ &quot;args&quot;: [ &quot;-g&quot;, // 生成和调试有关的信息; &quot;${file}&quot;, &quot;-o&quot;, // 设置编译后输出的文件名：默认输出 a.o; &quot;${fileDirname}/${fileBasenameNoExtension}.out&quot; ], &quot;options&quot;: { &quot;cwd&quot;: &quot;/usr/bin&quot; }, &quot;group&quot;: { // 用于定义此任务属于的执行组 &quot;kind&quot;: &quot;build&quot;, // { build | test } &quot;isDefault&quot;: true // { true | false } } }, /* ------ Configure GCC Compiler For C ------ */ { &quot;type&quot;: &quot;shell&quot;, &quot;label&quot;: &quot;gcc build active file&quot;, &quot;command&quot;: &quot;/usr/bin/gcc&quot;, &quot;args&quot;: [ &quot;-g&quot;, &quot;${file}&quot;, &quot;-o&quot;, &quot;${fileDirname}/${fileBasenameNoExtension}.out&quot; ], &quot;options&quot;: { &quot;cwd&quot;: &quot;/usr/bin&quot; }, &quot;group&quot;: { &quot;kind&quot;: &quot;build&quot;, &quot;isDefault&quot;: true } } ], &quot;version&quot;: &quot;2.0.0&quot;} 至此，回到我们的调试界面（Debug），已经可以看到启动条目里面具有 g++/gcc 调试选项，你可以再尝试一下对上述给出的 C++ 源码进行断点调试（F5）。 好了，你的 VS Code（Linux）已经可以同时编译调试 C/C++ ~ 你应该还没忘了之前说过的有 4 个文件进行配置吧？余下的两个配置文件与 C/C++（库引用、C 标准等）以及一些工作区设置相关。 话不多说，开始配置： 2.1.2-3 –&gt; 配置单文件夹工作区设置（settings.json） VSCode 可以通过 用户（User） 和 文件夹 设置来实现高度可配置化。用户设置是全局的，但单文件夹的工作区的设置（.vscode/settings.json）是针对当前项目进行独立设置的，它会覆盖用户设置，你可以在其中进行当前项目的个性化设置。 换句话说，你可以在 settings.json 中针对当前工程项目类别（C++ or Java？）进行远超符合你代码书写习惯的设置，例如配置 Tab 空格数、自动保存、自动格式化等等。 如何自动生成 settings.json 文件？？？ &gt;&gt;&gt;&gt;&gt; 打开 VSCode 设置页面（Ctrl + ,），切换到 Workspace，在配置项中随便找一个 Edit in settings.json 打开，即可在 .vscode 下自动生成 settings.json 文件。如果你已经针对工作区进行过配置，settings.json 是不为空的，否则应该是一个空白的文件。 这里给一个样例配置（你可以根据个人需要进行设置）： 1234567891011121314151617181920212223242526272829303132{ &quot;files.autoSave&quot;: &quot;onWindowChange&quot;, // 文件自动保存选项；参数说明：onFocusChange =&gt; 当前文件失去焦点后自动保存; onWindowChange =&gt; 需要当前 VScode 窗口失去焦点才会自动保存 &quot;files.autoSaveDelay&quot;: 3000, // 间隔多少毫秒自动保存，默认「1000毫秒」;如果配置了保存格式化代码，这个配置下自动保存不会格式化代码 &quot;editor.tabSize&quot;: 4, // 配置 Tab 空格数 &quot;editor.formatOnSave&quot;: false, // 保存自动格式化代码 &quot;editor.formatOnPaste&quot;: true, // 粘贴自动格式化 &quot;code-runner.runInTerminal&quot;: false, // 设置成 false 会在 “output” 中进行输出，无法输入； &quot;code-runner.executorMap&quot;: { &quot;c&quot;: &quot;cd $dir &amp;&amp; gcc $fileName -o $fileNameWithoutExt &amp;&amp; $dir$fileNameWithoutExt&quot;, &quot;cpp&quot;: &quot;cd $dir &amp;&amp; g++ $fileName -o $fileNameWithoutExt &amp;&amp; $dir$fileNameWithoutExt&quot; }, &quot;code-runner.saveFileBeforeRun&quot;: true, // Run Code 前保存； &quot;code-runner.preserveFocus&quot;: true, // 若为 false，Run code 后光标会聚焦到终端上。如果需要频繁输入数据可设为 false； &quot;code-runner.clearPreviousOutput&quot;: true, // 每次 Run code 前清空终端中属于之前 Code runner 的日志消息； &quot;C_Cpp.clang_format_sortIncludes&quot;: true, // 格式化时调整 include 的顺序（按字母排序）; &quot;C_Cpp.intelliSenseEngine&quot;: &quot;Default&quot;, // 可以为 Default 或 Tag Parser，后者较老，功能较简单。具体差别参考 cpptools 扩展文档； &quot;C_Cpp.errorSquiggles&quot;: &quot;Disabled&quot;, &quot;C_Cpp.autocomplete&quot;: &quot;Default&quot;, &quot;files.associations&quot;: { // 将某文件扩展名视为某种语言，可用通配符模式以及文档中的已知语言字符串进行关联。 &quot;iostream&quot;: &quot;cpp&quot;, &quot;exit-thread.h&quot;: &quot;c&quot;, &quot;ldsodefs.h&quot;: &quot;c&quot;, &quot;random&quot;: &quot;cpp&quot;, &quot;tls.h&quot;: &quot;c&quot;, &quot;dl-osinfo.h&quot;: &quot;c&quot;, &quot;stdio.h&quot;: &quot;c&quot; }} 2.1.2-4 –&gt; 配置 C/C++ 引用库路径（c_cpp_properties.json） Ctrl + Shift + P 调出命令控制窗口，再输入 edit 或者 configuration，选择 &quot;C/C++:Edit Configurations(JSON)&quot;，然后这个文件就出来了，默认配置如下： 12345678910111213141516{ &quot;configurations&quot;: [ { &quot;name&quot;: &quot;Linux&quot;, &quot;includePath&quot;: [ &quot;${workspaceFolder}/**&quot; ], &quot;defines&quot;: [], &quot;compilerPath&quot;: &quot;/usr/bin/gcc&quot;, &quot;cStandard&quot;: &quot;c11&quot;, &quot;cppStandard&quot;: &quot;c++17&quot;, &quot;intelliSenseMode&quot;: &quot;clang-x64&quot; } ], &quot;version&quot;: 4} 注意，该配置文件中不允许有注释!!! 你需要将 C/C++ 开发可能用到的引用库路径设置进来，添加到 includePath 选项中即可。 支持自动查询，includePath 中需要添加的路径获取方法：cmd ——&gt; gcc -v -E -x c++ -，搜索结果如下： 给出 c_cpp_properties.json 最终的配置内容（注意 Browser 选项）: 12345678910111213141516171819202122232425262728293031323334{ &quot;configurations&quot;: [ { &quot;name&quot;: &quot;Linux&quot;, &quot;includePath&quot;: [ &quot;${workspaceFolder}/**&quot;, &quot;/usr/include&quot; ], &quot;defines&quot;: [ &quot;_DEBUG&quot;, &quot;UNICODE&quot;, &quot;_UNICODE&quot; ], &quot;compilerPath&quot;: &quot;/usr/bin/gcc&quot;, &quot;cStandard&quot;: &quot;c11&quot;, &quot;cppStandard&quot;: &quot;c++17&quot;, &quot;intelliSenseMode&quot;: &quot;clang-x64&quot;, &quot;browse&quot;: { &quot;limitSymbolsToIncludedHeaders&quot;: true, &quot;databaseFilename&quot;: &quot;&quot;, &quot;path&quot;: [ &quot;${workspaceFolder}/**&quot;, &quot;/usr/include&quot; ] } } ], &quot;version&quot;: 4} 其中，browse 字段（重要）说明 &gt;&gt;&gt;&gt; 如果只是将需要包含的头文件放在 includePath 字段中,那么 include 的问题解决了，但是 defines 的问题还没有解决，这将会出现一大堆的提示。 这些提示大部分都是因为缺少相应的宏定义引起的，而 browse 可以搜索相应 browse.path 字段中所有的宏定义，并把缺少的宏定义补全，让 Definition/Declaration 操作可以无障碍。 ProblemsFile not found (/build/…/glibc-2.2X)Ubuntu16.04 中遇到一个问题（Error: File not found (/build/glibc-LK5gWL/glibc-2.23），具体如下:: 1234567Unable to open 'memcpy-avx-unaligned.S': Unable to read file (Error: File not found (/build/glibc-LK5gWL/glibc-2.23/sysdeps/x86_64/multiarch/memcpy-avx-unaligned.S)).Unable to open 'libc-start.c': Unable to read file (Error: File not found (/build/glibc-LK5gWL/glibc-2.23/csu/libc-start.c)).Unable to open 'ioputs.c': Unable to read file (Error: File not found (/build/glibc-LK5gWL/glibc-2.23/libio/ioputs.c)).... 看起来是系统中缺少 glibc-2.23 库，解决方法如下： 123456789$cd /$sudo mkdir build$cd build$sudo mkdir glibc-LK5gWL# 下载相应版本的 glibc：$sudo wget -c http://ftp.gnu.org/gnu/glibc/glibc-2.23.tar.gz$sudo tar –zxvf glibc-2.23.tar.gz 上述 /build/glibc-LK5gWL/glibc-2.2X 库安装成功后，需要将其引用路径添加到：c_cpp_properties.json 中： 1234567&quot;includePath&quot;: [ &quot;${workspaceFolder}/**&quot; &quot;/usr/include&quot;, &quot;/build/glibc-LK5gWL/glibc-2.23/include&quot;, &quot;/build/glibc-LK5gWL/glibc-2.23/**&quot; ], 不修改的话，跳转到的源文件可能有很多报错（红色波浪线），但不影响使用。","link":"/2017/08/02/wan-zhuan-vscode-zhi-pei-zhi-c-c-yu-yan-kai-fa-huan-jing/"},{"title":"Python 面向对象编程之类和对象","text":"前面我们提到过，我们知道 面向对象的编程概述。面向过程是具体化的，流程化的，解决一个问题，你需要一步一步的分析，一步一步的实现，这就是面向过程的设计。而面向对象呢？其实，面向对象是模型化的，你只需抽象出一个类，这是一个封闭的盒子，在这里你拥有数据也拥有解决问题的方法。 一切皆对象，面向对象的程序设计把计算机程序视为一组对象的集合，而每个对象都可以接收其他对象发过来的消息，并处理这些消息，计算机程序的执行就是一系列消息在各个对象之间传递。 面向对象初识Python 从设计之初就已经是一门面向对象的语言，在 Python 中所有数据类型都可以视为对象，当然也可以支持自定义对象。自定义的对象数据类型就是面向对象中的类（Class）的概念。 我们以一个例子来说明面向过程和面向对象在程序流程上的不同之处： 假设我们要处理学生的成绩表 &gt;&gt;&gt;&gt; –&gt; 面向过程: 为了表示一个学生的成绩，面向过程的程序可以用一个 dict 表示： 12std1 = { 'name': 'Michael', 'score': 98 }std2 = { 'name': 'Bob', 'score': 81 } 而处理学生成绩可以通过函数实现，比如打印学生的成绩： 12def print_score(std): print('%s: %s' % (std['name'], std['score'])) –&gt; 面向对象： 而如果采用面向对象的设计思想，我们首选思考的不是程序的执行流程，而是 Student 这种数据类型应该被视为一个对象，这个对象拥有 name 和 score 这两个属性（Property）。如果要打印一个学生的成绩，首先必须创建出这个学生对应的对象，然后，给对象发一个 print_score 消息，让对象自己把自己的数据打印出来。 12345678class Student(object): def __init__(self, name, score): self.name = name self.score = score def print_score(self): print('%s: %s' % (self.name, self.score)) 注意，以上代码仅是为了演示面向对象的编程思想，暂时先不需要深究。 给对象发消息实际上就是调用对象对应的关联函数，我们称之为对象的方法（Method）。面向对象的程序写出来就像这样： 1234bart = Student('Bart Simpson', 59)lisa = Student('Lisa Simpson', 87)bart.print_score()lisa.print_score() 上面，我们定义了 Class——Student，是指学生这个概念；而实例（Instance）则是一个个具体的 Student，比如：Bart Simpson 和 Lisa Simpson 是两个具体的 Student。 类和实例面向对象最重要的概念就是类（Class）和实例（Instance）。 必须牢记类是抽象的模板，类仅仅充当图纸的作用，本身并不能直接拿来用，而只有根据图纸造出的实际物品（对象）才能直接使用。 比如 Student 类，实例（张三、李四）是根据类实例化出来的一个个具体的 “对象”，每个对象都拥有相同的方法（打印成绩），但各自的数据可能不同（姓名、成绩）。 因此，Python 程序中类的使用顺序是这样的： 创建（定义）类，也就是制作图纸的过程； 创建类的实例对象（根据图纸造出实际的物品），通过实例对象实现特定的功能。 类Python 中，定义类是通过 class 关键字，其基本语法格式如下： 123class 类名(object)： 多个（≥0）类属性... 多个（≥0）类方法... 说明： 类名：符合标识符命名规范，推荐使用代表该类功能的单词组合（首字母大写，其它字母小写）； 继承：(object) 表示该类是从哪个类继承下来的，通常，如果没有合适的继承类，就使用 object 类，这是所有类最终都会继承的类（也称为顶级父类）； 冒号：表示告诉 Python 解释器，下面要开始设计类的内部功能了，也就是编写类属性和类方法 类属性/类方法：无论是类属性还是类方法，对于类来说，它们都不是必需的，可以有也可以没有。另外，Python 类中属性和方法所在的位置是任意的，即它们之间并没有固定的前后次序。 关于继承，这里先不要深究~~~这里给出是为了保证类定义的完整性。 以 Student 类为例： 123456789class Student(object): '类的帮助信息' add = &quot;This is my first class&quot; def __init__(self): print(&quot;这是类的构造函数&quot;) def print_score(self): print(&quot;print student`s score.&quot;) 和函数一样，我们也可以为类定义说明文档，其要放到类头之后，类体之前的位置。 其次，可以看到，学生类（Student）中包含了一个名为 add 的类属性。注意，根据定义属性位置的不同，在各个类方法之外定义的变量称为类属性或类变量（如 add 属性），而在类方法中定义的属性称为实例属性（或实例变量），区别和用法后面会进行说明。 同时，学生类（Student）中还包含一个 __init__() 类方法和一个 print_score 方法。 [1] &gt;&gt;&gt;&gt; 空类 Python 中支持创建一个没有任何类属性和类方法的空类： 12class Empty: pass 但在实际应用中，很少会创建空类，因为空类没有任何实际意义。 [2] &gt;&gt;&gt;&gt; 类的构造方法 上面定义的 Student 类中，我们手动添加过一个 __init__(self) 方法，事实上，该方法是一个特殊的类方法，称为类的构造方法（构造函数）。 特殊在哪里？？？ &gt;&gt;&gt;&gt; 构造方法是用于后续创建类的对象（类实例化为对象）时使用的，每当创建一个类的实例对象时，Python 解释器都会自动调用它。 1）–&gt; 隐式构造函数 事实上，定义类时，即使不手动为类添加任何构造方法，Python 也会自动为类添加一个仅包含 self 参数的构造方法（默认构造方法）。并且，在创建类对象（类实例化为对象）时，会自动调用默认构造方法。 2）–&gt; 显示创建构造函数 手动（显示）添加构造方法的语法格式如下： 12def __init__(self,...): 代码块 构造函数说明： 此方法的方法名中，开头和结尾各有 2 个下划线，且中间不能有空格。前面已经说过，Python 中很多这种以双下划线开头、双下划线结尾的方法，都具有特殊的意义； __init__() 方法可以包含多个参数，但必须包含一个名为 self 的参数，且必须作为第一个参数。 再贴出包含手动创建构造函数的类定义，重新认识一下： 123456789class Student(object): '类的帮助信息' add = &quot;This is my first class&quot; def __init__(self): print(&quot;这是类的构造函数&quot;) def print_score(self): print(&quot;print student`s score.&quot;) 验证 &gt;&gt;&gt;&gt; 创建类的实例对象时，是否会自动调用构造函数： 1234567891011class Student(object): '类的帮助信息' add = &quot;This is my first class&quot; def __init__(self): print(&quot;类的构造函数被调用了！&quot;) def print_score(self): print(&quot;print student`s score.&quot;)zhang_san = Student() # 创建一个学生对象 &gt;&gt;&gt; 张三（zhang_san） 运行代码可看到如下结果： 1类的构造函数被调用了！ 可以发现，创建类的实例对象时，确实隐式调用了我们手动创建的 __init__() 构造方法。 3）–&gt; 多参数显示构造方法 在 __init__() 构造方法中，除了 self 参数外，还可以自定义一些参数，如下： 123456789class Student(object): '类的帮助信息' add = &quot;This is my first class&quot; def __init__(self, name, score): print(name, &quot;Score: &quot;, score) def print_score(self): print(&quot;print student`s score.&quot;) 由于在创建对象时会隐式调用类的构造方法，如果构造函数中又定义有多个参数时，必须手动传递参数。但注意，self 不需要手动传递参数： 1zhang_san = Student(&quot;zhangsan&quot;, 100) # 创建一个学生对象 &gt;&gt;&gt; 张三（zhang_san） 输出如下： 1zhangsan Score: 100 self 方法参数不知道你发现没有，在前面类中定义方法的过程中，无论是定义类的构造方法，还是在类中定义一般方法，都要求将 self 参数作为方法的第一个参数。你可以返回去 Check 一下前面定义好的 Student 类。 那么，self 到底在其中扮演着什么样的角色呢？ [1] &gt;&gt;&gt;&gt; self 由来 事实上，Python 类中关于方法的定义规范是，无论是构造方法还是实例方法，最少要包含一个参数，但并没有规定该参数的具体名称。 也就是说，无论是定义构造方法还是实例方法中，都至少要包含一个参数，该参数名称是任意的（符合标识符命名）。 之所以将其命名为 self，只是程序员之间约定俗成的一种习惯，遵守这个约定，可以使我们编写的代码具有更好的可读性，大家一看到 self 参数，就知道它的作用。 那么 &gt;&gt;&gt;&gt; 为什么要至少包含一个参数，self 参数到底有什么作用呢？ [2] &gt;&gt;&gt;&gt; 方法中第一个参数 self 的作用 我们把类比作是造房子的图纸，那么类实例化后的对象对应的是根据图纸建成的真正可以住的房子（对象创建）。 思考一下 &gt;&gt;&gt;&gt; 根据一张图纸（类），我们可以设计出成千上万的房子（类对象），每个房子长相都是类似的（都有相同的类变量和类方法），但它们都有各自的主人，那么如何对它们进行区分呢？ self 参数来了，它就相当于每个房子的门钥匙（对象的引用），可以保证每个房子的主人在使用房子时仅能进入自己的房子（每个类对象只能调用自己的类变量和类方法）。 类比到 Python 实际场景 &gt;&gt;&gt;&gt; Python 中，同一个类可以实例化多个类对象，当使用某个对象调用类的方法时，该对象会自动把自身的引用作为第一个参数传给该方法，这样 Python 解释器就明白当前正在调用的类方法属于哪一个对象了。也就是说，对象调用类方法时，Python 会自动绑定类方法的第一个参数使其指向调用该方法的对象。 你可以简单为 &gt;&gt;&gt;&gt; Python 解释器为了区分不同对象对构造方法或实例方法的拥有权，会自动绑定这些方法的第一个 self 参数到当前调用对象，self 就是一个指向当前调用对象的引用。 这样，你就可以理解上面为什么在调用实例方法和构造方法时，不需要手动为第一个 self 参数传值了。 最后给出一个示例来理解上述说明： 1234567891011121314151617181920212223class Student(object): '类的帮助信息' add = &quot;This is my first class&quot; def __init__(self): print(self, &quot;正在执行构造方法&quot;) def study(self): print(self, &quot;正在学习 Python&quot;)zhang_san = Student()print(&quot;Where zhang_san:&quot;, zhang_san)zhang_san.study()# &lt;__main__.Student object at 0x7f2e3521dcf8&gt; 正在执行构造方法# Where zhang_san: &lt;__main__.Student object at 0x7f2e3521dcf8&gt;# &lt;__main__.Student object at 0x7f2e3521dcf8&gt; 正在学习 Pythonli_si = Student()print(&quot;Where li_si:&quot;, li_si)li_si.study()# &lt;__main__.Student object at 0x7f2e3521dd68&gt; 正在执行构造方法# Where li_si: &lt;__main__.Student object at 0x7f2e3521dd68&gt;# &lt;__main__.Student object at 0x7f2e3521dd68&gt; 正在学习 Python 好了，我们已经学会如何定义一个类，但要 想使用定义好的类，必须创建该类的实例对象。 类的对象创建类实例对象的过程，又称为类的实例化过程，可以将类实例化成一个个具体的对象。 其语法格式如下： 1类名(参数) 说明：定义类时，如果没有手动添加 __init__() 构造方法，又或者添加的 __init__() 中仅有一个 self 参数，则创建类对象时的参数可以省略不写。 创建了名为 Language 的类，并对其进行了实例化： 123456789101112131415161718class Language : # 下面定义了 2 个类变量 name = &quot;Python&quot; add = &quot;Python is a OOP language.&quot; def __init__(self, name, add): # 下面定义 2 个实例变量 self.name = name self.add = add print(name, &quot;Production：&quot;, add) # 下面定义了一个 say 实例方法 def say(self, content): print(content)# 将该 Language 对象赋给 language 变量language = Language(&quot;Python&quot;,&quot;Python is a OOP language.&quot;)# Python Production： Python is a OOP language. 上面的程序中，由于构造方法除 self 参数外，还包含 2 个参数，且这 2 个参数没有设置默认参数，因此在实例化类对象时，需要传入相应的 name 值和 add 值（self 参数是特殊参数，不需要手动传值，Python 会自动传给它值）。 类实例化对象的使用 &gt;&gt;&gt;&gt; 一般情况下，类的使用，实际上是对类实例化后对象的使用。 上面我们已经完成了类的实例化，即获得了一个个的具体的对象。实例化后的类对象可以执行以下两种操作： 访问或修改类对象具有的实例变量，甚至可以添加新的实例变量或者删除已有的实例变量； 访问类对象的方法，包括调用现有的方法，甚至给类对象动态添加方法。 1）–&gt; 访问类对象的变量或方法 使用已实例化好的类对象，访问类中实例变量（方法）的语法格式如下： 1类对象名.变量名(方法名) 给出代码演示，如何通过上面 language 对象调用类中的实例变量和实例方法： 1234567891011121314151617# 将该 Language 对象赋给 language 变量language = Language(&quot;Python&quot;,&quot;Python is a OOP language.&quot;)# Python Production： Python is a OOP language.# 访问 name &amp;&amp; add 实例变量的值print(language.name, language.add)# Python Python is a OOP language.# 修改实例变量的值language.name = &quot;Python Lesson&quot;language.add = &quot;http://c.biancheng.net/python&quot;print(language.name, language.add)# Python Lesson http://c.biancheng.net/python# 访问（调用）language 的 say()方法language.say(&quot;人生苦短，我用 Python&quot;)# 人生苦短，我用 Python 2）–&gt; 为类对象动态增加或删除实例变量 12345678910111213# 为 language 对象增加一个 money 实例变量language.money= 159.9print(language.money)# 159.9# 删除新添加的 money 实例变量del language.money# 再次尝试输出 money，此时会报错：AttributeErrorprint(language.money)# Traceback (most recent call last):# File &quot;.code.tio&quot;, line 38, in # print(language.money)# AttributeError: 'Language' object has no attribute 'money' 3）–&gt; 为类对象动态增加实例方法 以本节开头的 Language 类为例，由于其内部只包含一个 say() 方法，因此该类实例化出的 language 对象也只包含一个 say() 方法。Python 中允许为类对象动态增加方法，我们还可以为 language 对象动态添加其它方法。 需要注意的是，为 language 对象动态增加的方法，Python 不会自动将调用者自动绑定到第一个参数（即使将第一个参数命名为 self 也没用），函数调用是需要手动绑定。例如如下代码： 1234567891011121314# 先定义一个函数def info(self): print(&quot;---info函数---&quot;, self)# 将方法 info 动态绑定给 language 对象language.foo = info# 需要手动将 info 方法的 self 参数绑定到 language 对象language.foo(language)# ---info函数--- &lt;__main__.Language object at 0x7f281a544d30&gt;# 使用 lambda 表达式为 language 对象动态绑定方法 barlanguage.bar = lambda self: print('--lambda表达式--', self)language.bar(language)# --lambda表达式-- &lt;__main__.Language object at 0x7f281a544d30&gt; 有没有不用手动给 self 传值的动态增加方法呢？ &gt;&gt;&gt;&gt; 需要借助 types 模块下的 MethodType： 12345678def study(self,content): print(&quot;正在学习：%s&quot; % content)from types import MethodTypelanguage.study = MethodType(study, language)# 第一个参数已经绑定了，无需传入，可直接进行函数调用了language.study(&quot;Python&quot;)# 正在学习：Python 由于使用 MethodType 包装 study() 函数时，已经将该函数的 self 参数绑定为 language，因此后续再使用 study() 函数时，就不用再给 self 参数绑定值了。 类属性和类方法详解对于前面提到的类属性和类方法，看官老爷可能会有一种疑惑：怎么一会儿叫实例属性和实例方法，一会儿叫类属性和类方法，到底是不是一回事儿？？？ 至少可以达成一个共识 &gt;&gt;&gt;&gt; 无论是类属性还是类方法，都无法像普通变量或者函数那样，在类的外部直接使用它们。我们可以将类看做一个独立的空间，则类属性其实就是在类体中定义的变量，类方法是在类体中定义的函数。 关于上述差别，和前面函数部分讲解的变量作用域是类似的，Python 中根据类体中变量定义的位置，以及变量和方法定义方式的不同，类属性和类方法的叫法以及使用也是有差别的。 类属性 &amp;&amp; 实例属性在类体中，根据变量定义位置以及方式的不同，类属性可细分为以下 3 种类型： 类体中、所有函数之外：此范围定义的变量，称为 类属性或类变量； 类体中，所有函数内部：以 self.varName 的方式定义的变量，称为 实例属性或实例变量； 类体中，所有函数内部：以 varName = VarName 的方式定义的变量，称为 局部变量。 那么，类变量、实例变量以及局部变量之间有哪些不同呢？ [1] &gt;&gt;&gt;&gt; 类变量（类属性） 类变量指的是在类中，但在各个类方法外定义的变量。实例如下： 12345678class Language : # 下面定义了 2 个类变量 name = &quot;Python&quot; add = &quot;Python is a OOP language.&quot; # 下面定义了一个 say 实例方法 def say(self, content): print(content) 上面代码中，name 和 add 就属于类变量。 1）–&gt; 类变量访问方式 类变量的访问方式有 2 种，既可以使用类名直接访问，也可以使用类的实例化对象访问。 类名访问示例（可访问，可修改） &gt;&gt;&gt;&gt; 12345678910111213# 使用类名直接访问print(Language.name)print(Language.add)# Python# Python is a OOP language.# 修改类变量的值Language.name = &quot;Python3.X&quot;Language.add = &quot;Python3.X is a OOP language.&quot;print(Language.name)print(Language.add)# Python3.X# Python3.X is a OOP language. 类对象访问示例（可访问，不可修改） &gt;&gt;&gt;&gt; 不推荐！！！后续会说明 12345lang = Language()print(lang.name)print(lang.add)# Python3.X# Python3.X is a OOP language. 需要注意的是，通过类对象对类变量进行赋值，其本质将不再是修改类变量的值，而是在给该对象动态增加新的实例变量。 2）–&gt; 类变量在所有类的实例化对象中作为公用资源存在 注意，类变量（类属性）为所有实例化对象共有，通过类名修改类变量的值，会影响所有的实例化对象。 3）–&gt; 动态增加和删除类变量 类似于类对象中动态增加和删除实例变量操作，可以通过类名为类和类对象动态增加或删除类变量： 123456789101112Language.test = 10.2print(Language.test)print(lang.test)# 10.2# 10.2del Language.testprint(Language.test)# Traceback (most recent call last):# File &quot;.code.tio&quot;, line 28, in # print(Language.test)# AttributeError: type object 'Language' has no attribute 'test' 总结：使用类名的方式进行类变量（类属性）的访问、修改以及删除，并且类变量（类属性）为所有实例化对象共有。 [2] &gt;&gt;&gt;&gt; 实例变量（实例属性） 实例变量指的是在任意类方法内部，以 self.变量名 的方式定义的变量，其特点是只作用于调用方法的对象。 另外，实例变量只能通过对象名访问，无法通过类名访问。 示例如下： 12345678910111213141516171819202122232425262728293031class Language : def __init__(self): self.name = &quot;Python&quot; self.add = &quot;Python is a OOP language.&quot; # 下面定义了一个 say 实例方法 def say(self): self.catalog = 1999 lang = Language()print(lang.name)print(lang.add)# Python# Python is a OOP language.lang2 = Language()print(lang2.name)print(lang2.add)# Python# Python is a OOP language.# 只有调用 say()，才会拥有 catalog 实例变量lang2.say()print(lang2.catalog)# 1999# 由于 lang 对象未调用 say() 方法，因此其没有 catalog 变量，下面这行代码会报错print(lang.catalog)# Traceback (most recent call last):# File &quot;.code.tio&quot;, line 22, in # print(lang.catalog)# AttributeError: 'Language' object has no attribute 'catalog' 说明：Language 类中，name、add 以及 catalog 都是实例变量。其中，由于 __init__() 函数在创建类对象时会自动调用，而 say() 方法需要类对象手动调用。因此，Language 类的类对象都会包含 name 和 add 实例变量，而只有调用了 say() 方法的类对象，才包含 catalog 实例变量。 通过 __init__() 构造函数中实例变量（属性）的特性，你应该受到启发 &gt;&gt;&gt;&gt; 1）–&gt; 实例变量为所有类的实例化对象绑定通用属性 有些人可能会问，既然是通用属性，那将这些通用属性定义为类变量（类属性）不就行了？ 你没有考虑到的是，一旦通用属性被定义为类变量后，即被所有类的实例化对象所共享，导致该通用属性在所有对象中的取值都相同，这就失去其意义了。 也就是说，实例变量为类的实例化对象所独占。通过某个对象修改实例变量的值，不会影响类的其它实例化对象。 2）–&gt; 动态增加和删除实例变量 前面讲过，通过类对象可以访问类变量，但无法修改类变量的值。这是因为，通过类对象修改类变量的值，不是在给“类变量赋值”，而是定义新的实例变量。 示例如下： 1234567891011121314151617181920212223242526272829class Language : name = &quot;Python&quot; add = &quot;Python is a OOP language.&quot; # 下面定义了一个 say 实例方法 def say(self): self.catalog = 1999lang = Language()# lang 访问类变量print(lang.name)print(lang.add)# Python# Python is a OOP language.lang.name = &quot;Python3.X&quot;lang.add = &quot;Python3.X is a OOP language.&quot;# lang 实例变量的值print(lang.name)print(lang.add)# Python3.X# Python3.X is a OOP language.# 类变量的值print(Language.name)print(Language.add)# Python# Python is a OOP language. 3）–&gt; 实例变量和类变量同名问题 类中，实例变量和类变量可以同名，但这种情况下使用类对象将无法调用类变量，它会首选实例变量！！！ 明白前面说的：为什么不推荐 “类变量使用对象名调用” 的原因了吧。 [3] &gt;&gt;&gt;&gt; 局部变量 除了实例变量，类方法中还可以定义局部变量。和前者不同，局部变量直接以 变量名=值 的方式进行定义，例如： 123456789class Book: def count(self,money): sale = 0.8 * money print(&quot;优惠后的价格为：&quot;, sale)ibook = Book()ibook.count(100)# 优惠后的价格为： 80.0 通常情况下，定义局部变量是为了所在类方法功能的实现。需要注意的一点是，局部变量只能用于所在函数中，函数执行完成后，局部变量也会被销毁。 类方法 &amp;&amp; 静态方法 &amp;&amp; 实例方法和类属性一样，类方法也可以进行更细致的划分，具体可分为类方法、实例方法和静态方法： 类方法：采用 @classmethod 修饰的方法； 静态方法：采用 @staticmethod 修饰的方法； 实例方法：不用任何修饰的方法。 其中 @classmethod 和 @staticmethod 都是函数装饰器，后续章节会对其做详细介绍。 [1] &gt;&gt;&gt;&gt; 实例方法 通常情况下，在类中定义的方法默认都是实例方法，无需使用任何方法修饰符（使用最多）。 前面章节中，我们定义的类方法均为实例方法。甚至，类的构造方法（函数）理论上也属于实例方法，只不过它比较特殊。 123456789class Language : # 类构造函数，也属于实例方法 def __init__(self): self.name = &quot;Python&quot; self.add = &quot;Python is a OOP language.&quot; # 下面定义了一个 say 实例方法 def say(self): self.catalog = 1999 实例方法最大的特点就是，它最少也要包含一个 self 参数，用于绑定调用此方法的实例对象（Python 会自动完成绑定）。 并且，实例方法支持如下两种调用方式： 类对象调用（绑定方法调用）； 类名调用（非绑定方法调用）。 两种方式的 调用差别在于：和前面使用类对象调用实例方法不同，通过类名直接调用实例方法时，Python 并不会自动给 self 参数传值（需要手动传递 self 对象引用）。 也就是说如果想用类调用实例方法，不能像如下这样： 1234567class Language : # 下面定义了一个 info 实例方法 def info(self): print(&quot;I am learning python.&quot;) Language.info() 如上使用（不为 self 传入对象引用），会报出如下错误： 123456Traceback (most recent call last): File &quot;.code.tio&quot;, line 7, in Language.info()TypeError: info() missing 1 required positional argument: 'self'# 报错提示：调用 info() 类方式时缺少给 self 参数传参。 考虑一下，这也是合理的。self 参数需要的是方法的实际调用者（是类对象），而这里只提供了类名，当然无法自动传值。 故，采用类名调用实例方法时，必须手动为 self 参数传值： 123456789class Language : # 下面定义了一个 info 实例方法 def info(self): print(&quot;I am learning python.&quot;)lang = Language() Language.info(lang)# I am learning python. 需要注意的是，上面的报错信息只是让我们手动为 self 参数传值，但并没有规定必须传一个该类的对象，其实完全可以任意传入一个参数，例如： 12345678class Language : # 下面定义了一个 info 实例方法 def info(self): print(self, &quot;am learning python.&quot;) Language.info(&quot;zhang_san&quot;)# zhang_san am learning python. 可见，&quot;zhang_san&quot; 这个字符串传给了 info() 方法的 self 参数，但这样的使用会引发程序异常，需要注意。 [2] &gt;&gt;&gt;&gt; 类方法 Python 类方法和实例方法相似，它最少也要包含一个参数，只不过类方法中通常将其命名为 cls，Python 会自动将 类本身绑定给 cls 参数。也就是说，在调用类方法时，无需显式为 cls 参数传参。 和 self 一样，cls 参数的命名也不是规定的（可以随意命名），只是 Python 程序员约定俗称的习惯而已。 和实例方法最大的不同在于，类方法需要使用 ＠classmethod 修饰符进行修饰，例如： 12345678910class Language : # 类构造函数，也属于实例方法 def __init__(self): self.name = &quot;Python&quot; self.add = &quot;Python is a OOP language.&quot; # 下面定义了一个 info 类方法 @classmethod def info(cls): print(&quot;Calling Class Method&quot;, cls) 需要注意的是，如果没有 ＠classmethod，则 Python 解释器会将 info() 方法认定为实例方法，而不是类方法。 类方法调用 &gt;&gt;&gt;&gt; 类方法推荐使用类名直接调用，当然也可以使用实例对象来调用（不推荐）: 12345678# 使用类名直接调用： Language.info()# Calling Class Method # 使用类对象调用： lang = Language()lang.info()# Calling Class Method [3] &gt;&gt;&gt;&gt; 静态方法 静态方法，其实就是前面学习的函数，和函数唯一的区别是，静态方法定义在类这个空间（类命名空间）中，而函数则定义在程序所在的空间（全局命名空间）中。 静态方法没有类似 self、cls 这样的特殊参数，因此 Python 解释器不会对它包含的参数做任何类或对象的绑定。也正因为如此，类的静态方法中无法调用任何类属性和类方法。 静态方法需要使用 ＠staticmethod 修饰，例如： 12345678910class Language : # 下面定义了一个 info 类方法 @classmethod def info(cls): print(&quot;Calling Class Method&quot;, cls) @staticmethod def test(name, add): # info() # 这是错误的 print(name, add) 静态方法的调用 &gt;&gt;&gt;&gt; 既可以使用类名，也可以使用类对象进行静态方法的调用，例如： 123456# 使用类名直接调用： Language.test(&quot;Python&quot;, &quot;is a OOP language.&quot;) # 使用类对象调用： lang = Language()lang.test(&quot;Python&quot;, &quot;is a OOP language.&quot;) 在实际编程中，几乎不会用到类方法和静态方法，因为我们完全可以使用函数代替它们实现想要的功能，但在一些特殊的场景中（例如工厂模式中），使用类方法和静态方法也是很不错的选择。 类命名空间前面提到过，Python 类体中的代码位于独立的命名空间（称为类命名空间）中。换句话说，所有用 class 关键字修饰的代码块，都可以看做是位于独立的命名空间中。 和类命名空间相对的是 全局命名空间，即整个 Python 程序默认都位于全局命名空间中。而类体则独立位于 类命名空间中。 事实上，类是由多个类属性和类方法构成，而类属性其实就是定义在类这个独立空间中的变量，而类方法其实就是定义在类空间中的函数，和定义在全局命名空间中的变量和函数相比，并没有明显的不同。 程序实例： 123456789101112131415161718192021222324# 全局空间定义变量name = &quot;Python&quot;add = &quot;Python is a OOP language.&quot;# 全局空间定义函数def say (): print(&quot;Python Global Method&quot;)class Language: # 定义 Language 空间的类变量 name1 = &quot;Python3.X&quot; add = &quot;Python3.X is a OOP language.&quot; # 定义 Language 空间的 say def say(): print(&quot;Python Method in Class&quot;)# 调用全局的变量和函数print(name,add)say()# 调用类独立空间的变量和函数print(Language.name1, Language.add)Language.say() 类命名空间中编写可执行程序 &gt;&gt;&gt;&gt; Python 还允许直接在类命名空间中编写可执行程序（例如输出语句、分支语句、循环等等），例如： 12345class Language: #直接编写可执行代码 print('正在执行类空间中的代码') for i in range(5): print(i) 运行结果为： 123456正在执行类空间中的代码01234 类的封装特性（访问限制）这一小节，我们来看面向对象四大特性之一的：封装。 我们知道，类（Class）的内部可以定义类属性和类方法，而外部代码可以直接通过 “类对象.属性名” 或 “类对象.方法名(参数)” 的方式来操作相应数据和类内部方法（看作是一个简单封装）。 1234567891011121314class Student(object): def __init__(self, name, score): self.name = name self.score = score def print_score(self): print('%s: %s' % (self.name, self.score))bart = Student('Bart Simpson', 59)print(bart.name, &quot;Score: &quot;, bart.score)bart.score = 99print(bart.score)bart.print_score() 事实上，更多时候对于设计一个良好封装的类时，我们需要刻意地将一些属性和方法隐藏在类的内部，这样在使用此类时，将无法直接以 “类对象.属性名”（或 “类对象.方法名(参数)” 的形式调用这些属性（或方法）。 那么，如何将不想直接暴露给用户的属性和方法隐藏在类的内部呢？！！ &gt;&gt;&gt;&gt; Python 中的访问限制和其它面向对象的编程语言（如 C++、Java）不同，Python 类中的变量和函数，不是公有的（类似 public 属性），就是私有的（类似 private），这两种属性的区别如下： public：公有属性的类变量和类函数，在类的外部、类内部以及子类中，都可以正常访问； private：私有属性的类变量和类函数，只能在本类内部使用，类的外部以及子类都无法使用。 但是，Python 并没有提供 public、private 这些修饰符。为了实现类的封装，Python 采取了下面的方法： 默认情况下，Python 类中的变量和方法都是公有（public）的，它们的名称前都没有下划线 (_)； 如果类中的变量和函数，其名称以双下划线 (__) 开头，则该变量（函数）为私有变量（私有函数），其属性等同于 private。 所以，我们把 Student 类改一改： 12345678class Student(object): def __init__(self, name, score): self.__name = name self.__score = score def __print_score(self): print('%s: %s' % (self.__name, self.__score)) 改完之后，对于外部代码来说，没什么变动，但是已经无法从外部访问 实例变量.__name &amp;&amp; 实例变量.__score &amp;&amp; 实例变量.__print_score 了： 123456789bart = Student('Bart Simpson', 59)print(bart.__name, &quot;Score: &quot;, bart.__score)# Traceback (most recent call last):# File &quot;.code.tio&quot;, line 12, in # print(bart.__name, &quot;Score: &quot;, bart.__score)# AttributeError: 'Student' object has no attribute '__name'bart.__print_score()# AttributeError: 'Student' object has no attribute '__print_score' 私有变量或方法命名问题 除此之外，还可以定义以单下划线 (_) 开头的类属性或者类方法（例如 _name、_display(self)），这种类属性和类方法通常也被视为私有属性和私有方法。虽然它们也能通过类对象正常访问，但是按照约定俗成的规定，当你看到这样的变量或方法时，意思就是，“虽然我可以被访问，但是，请把我视为私有，不要随意访问”。 注意，Python 类中还有以双下划线 (__) 开头和结尾的类方法（例如类的构造函数 __init__(self)），这些都是 Python 内部定义的，用于 Python 内部调用。我们自己定义类属性或者类方法时，不要使用这种格式。· 这样就确保了外部代码不能随意修改对象内部的状态，这种通过访问限制的保护，会使得代码更加健壮。 那么，如何访问这些被规定了访问限制的私有属性呢 &gt;&gt;&gt;&gt; 你需要使用 Python 中的描述符协议，或者使用类定义时暴露出来的 未隐藏的类方法 来间接操作这些隐藏的属性和方法（本质上都是通过 get &amp;&amp; set 方法进行访问）。 Python 中的描述符先来认识一下 Python 中描述符的概念： 本质上，描述符就是一个类，只不过它定义了另一个类中属性的访问方式。换句话说，一个类可以将属性管理全权委托给描述符类。 描述符是 Python 中复杂属性访问的基础，它在内部被用于实现 property、@property 装饰器 和 super 类型等。这里先不容深究这些概念~~~后文会给出相关说明。 描述符类基于以下 3 个特殊方法（换句话说，这 3 个方法组成了描述符协议）： __get__(self, obj, value)：在读取属性时将调用这一方法（本节后续用 getter 表示）； __set__(self, obj, type=None)：在设置属性时将调用这一方法（本节后续用 setter 表示）； __delete__(self, obj)：对属性调用 del 时将调用这一方法。 其中，实现了 setter 和 getter 方法的描述符类被称为 数据描述符；反之，如果只实现了 getter 方法，则称为 非数据描述符。 实际上，在每次进行属性访问时，描述符协议中的方法都由类对象的特殊方法 __getattribute__() 调用（注意不要和 __getattr__() 弄混）。也就是说，每次使用 类对象.属性（或者 getattr(类对象，属性值)）的调用方式时，都会隐式地调用 __getattribute__()，它会按照下列顺序查找该属性： 验证该属性是否为类实例对象的数据描述符； 如果不是，就查看该属性是否能在类实例对象的 __dict__ 中找到； 最后，查看该属性是否为类实例对象的非数据描述符。 为了表达清楚，这里举个例子： 12345678910111213141516171819202122232425262728293031# 描述符类class revealAccess: def __init__(self, initval = None, name = 'var'): self.val = initval self.name = name # getter def __get__(self, obj, objtype): print(&quot;Retrieving&quot;,self.name) return self.val # setter def __set__(self, obj, val): print(&quot;updating&quot;,self.name) self.val = valclass myClass: x = revealAccess(10, 'var &quot;x&quot;') y = 5m = myClass()print(m.x)# Retrieving var &quot;x&quot;# 10m.x = 20# updating var &quot;x&quot;print(m.x)print(m.y)# Retrieving var &quot;x&quot;# 20# 5 可以看出，如果一个类的某个属性有数据描述符，那么每次查找这个属性时，都会调用描述符的 __get__() 方法，并返回它的值；同样，每次在对该属性赋值时，也会调用 __set__() 方法。 注意，虽然上面例子中没有使用 __del__() 方法，但也很容易理解，当每次使用 del 类对象.属性（或者 delattr(类对象，属性)） 语句时，都会调用该方法。 除了使用描述符类来对类属性进行封装外，还可以使用 property()函数 或者 @property 装饰器： Python property() 函数前面，我们一直在用 类对象.属性 的方式访问类中定义的属性，其实这种做法是欠妥的，因为它破坏了类的封装原则。正常情况下，类包含的属性应该是隐藏的，只允许通过类提供的公共方法（未隐藏的类方法）来间接实现对类属性的访问和操作。 因此，在不破坏类封装原则的基础上，为了能够有效操作类中的属性，类中应定义用于读（或写）类属性的多个 getter &amp;&amp; setter 方法，这样就可以通过这些暴露出来的公共方法来操作隐藏的类属性了。 例如，上面的 Student 类中，如果外部代码要访问、修改以及删除 name 怎么办？方法如下： 12345678910111213141516171819202122232425262728class Student(object): def __init__(self, name, score): self.__name = name self.__score = score # 设置 name 属性值的函数 def setname(self,name): self.__name = name # 访问 name 属性值的函数 def getname(self): return self.__name # 删除 name 属性值的函数 def delname(self): self.__name = &quot;xxxx&quot;bart = Student('Bart Simpson', 99)# 获取 name 属性值print(bart.getname())# Bart Simpson# 设置 name 属性值bart.setname(&quot;Bart Valli&quot;)print(bart.getname())# Bart Valli# 删除 name 属性值bart.delname()print(bart.getname())# xxxx 看官老爷可能会觉得，这种操作类属性的方式比较麻烦，更习惯使用 类对象.属性 这种方式。 property() 函数登场 &gt;&gt;&gt;&gt; 庆幸的是，Python 中提供了 property() 函数，让开发者依旧使用 类对象.属性 的方式操作类中的属性。其语法格式如下： 1属性名 = property(fget=None, fset=None, fdel=None, doc=None) 说明，fget 参数用于指定获取该属性值的类方法，fset 参数用于指定设置该属性值的方法，fdel 参数用于指定删除该属性值的方法，最后的 doc 是一个文档字符串，用于说明此函数的作用。 注意，在使用 property() 函数时，以上 4 个参数可以仅指定第 1 个、或者前 2 个、或者前 3 个，当前也可以全部指定。也就是说，property() 函数中参数的指定并不是完全随意的。 例如，修改上面的程序，为 name 属性配置 property() 函数： 123456789101112131415161718192021222324252627282930313233343536373839class Student(object): def __init__(self, name, score): self.__name = name self.__score = score # 设置 name 属性值的函数 def setname(self,name): self.__name = name # 访问 name 属性值的函数 def getname(self): return self.__name # 删除 name 属性值的函数 def delname(self): self.__name = &quot;xxxx&quot; # 为 name 属性配置 property 函数 name = property(getname, setname, delname, &quot;Name Getter &amp;&amp; Setter &amp;&amp; deleter&quot;)# 调取说明文档的 2 种方式print(Student.name.__doc__)# Name Getter &amp;&amp; Setter &amp;&amp; Delhelp(Student.name)# Help on property:# # Name Getter &amp;&amp; Setter &amp;&amp; Del bart = Student('Bart Simpson', 99)# 获取 name property 函数print(bart.name)# Bart Simpson# 设置 name property 函数bart.name = &quot;Bart Valli&quot;print(bart.name)# Bart Valli# 删除 name 属性值del bart.nameprint(bart.name)# xxxx 注意，由于 getname() 方法中需要返回 name 属性，如果使用 self.name 的话，其本身又被调用 getname()，这将会先入无限死循环。 当然，property() 函数也可以少传入几个参数。以上面的程序为例，我们可以修改 property() 函数如下所示： 1name = property(getname, setname) 这意味着，name 是一个可读写的属性，但不能删除。因为 property() 函数中并没有为 name 配置用于函数该属性的方法。也就是说，即便 Student 类中设计有 delname() 函数，这种情况下也不能用来删除 name 属性。但你仍然可以使用 delname 函数。 Python @property 装饰器Python 中，既要保护类的封装特性，又要让开发者可以使用 对象.属性 的方式操作操作类属性，除了使用 property() 函数，Python 还提供了 @property 装饰器。 通过 @property 装饰器，可以直接通过方法名来访问方法，不需要在方法名后添加一对 () 小括号。 @property 的语法格式如下： 123@propertydef 方法名(self) 代码块 例如，定义一个矩形类，并定义用 @property 修饰的方法操作类中的 area 私有属性，代码如下： 12345678910class Rect: def __init__(self,area): self.__area = area @property def area(self): return self.__arearect = Rect(30)print(&quot;矩形的面积是：&quot;, rect.area)# 矩形的面积是： 30 上面程序中，使用 ＠property 修饰了 area() 方法，这样就使得该方法变成了 area 私有属性的 getter 方法。 你可以将其简单看作是为 area 私有属性添加一个不带下划线的同名 getter 方法，以提供 对象.属性 方式进行私有属性的读取。如果只包含该方法，area 私有属性只具有读属性。 也就是说，在使用 Rect 类时，无法对 area 属性重新赋值，即运行如下代码会报错： 123456rect.area = 90print(&quot;修改后的面积：&quot;, rect.area)# Traceback (most recent call last):# File &quot;.code.tio&quot;, line 12, in # rect.area = 90# AttributeError: can't set attribute 如果想要为 area 私有属性添加修改以及删除操作，就需要使用 setter 装饰器 &amp;&amp; deleter 装饰器 添加不带下划线的同名 getter &amp;&amp; deleter 方法: 123456@area.setterdef area(self, value): self.__area = value@area.deleterdef area(self): self.__area = 0 完整代码样例如下： 123456789101112131415161718192021222324class Rect: def __init__(self,area): self.__area = area @property def area(self): return self.__area @area.setter def area(self, value): self.__area = value @area.deleter def area(self): self.__area = 0rect = Rect(30)print(&quot;矩形的面积是：&quot;, rect.area)# 矩形的面积是： 30rect.area = 90print(&quot;修改后的面积：&quot;, rect.area)# 修改后的面积： 90del rect.areaprint(&quot;删除后的 area 值为：&quot;, rect.area)# 删除后的 area 值为： 0 这样 area 私有属性就有了 getter &amp;&amp; setter &amp;&amp; deleter 方法，该属性就变成了具有读、写、删除功能的属性了。 访问限制优点使用上述的封装机制，保证了类内部数据结构的完整性。因为使用类的用户无法直接看到类中的数据结构，只能使用类允许公开的数据和方法，很好地避免了外部对内部数据的影响，提高了程序的可维护性。 并且由于用户只能借助暴露出来的类方法来访问数据，这时只需要在这些暴露的方法中加入适当的控制逻辑，即可轻松避免用户对类中属性或方法的不合理操作，有助于提高程序的健壮性。 例如，你可以通过下面形式来提高程序的健壮性： 12345678class Student(object): ... def set_score(self, score): if 0 &lt;= score &lt;= 100: self.__score = score else: raise ValueError('bad score') 深入了解访问限制底层原理事实上，Python 封装特性的实现纯属“投机取巧”，之所以类对象无法直接调用以双下划线开头命名的类属性和类方法，是因为其底层实现时，Python 偷偷改变了它们的名称。 我们定义了一个 Student 类，定义如下： 12345678class Student(object): def __init__(self, name, score): self.__name = name self.__score = score def __print_score(self): print('%s: %s' % (self.__name, self.__print_score)) 在这个类中，有一个 __print_score() 方法，由于其是私有方法，且该类没有提供任何调用该方法的“接口”，因此在目前看来，此方法根本无法在类外部调用。也就是说，如下调用 __print_score() 方法是不可行的： 123456zhangsan = Student(&quot;zhang_san&quot;, 99)zhang_san.__print_score()# Traceback (most recent call last):# File &quot;.code.tio&quot;, line 11, in # zhangsan.__print_score()# AttributeError: 'Student' object has no attribute '__print_score' 那么，是不是类似 __print_score() 这种的私有方法，真的没有方法调用吗？ 事实上，对于以双下划线开头命名的类属性或类方法，Python 在底层实现时，将它们的名称都偷偷改成了 _类名__属性（方法）名 的格式。 以 Student 类中的 __print_score() 为例，Python 在底层将其方法名偷偷改成了_Student__print_score 。例如在 Student 类的基础上，执行如下代码： 123456789101112class Student(object): def __init__(self, name, score): self.__name = name self.__score = score def __print_score(self): print('%s: %s' % (self.__name, self.__score))zhangsan = Student(&quot;zhang_san&quot;, 99)zhangsan._Student__print_score()# zhang_san: 99 原来如此~~~，再尝试一下私有的类属性的访问： 12345678print(zhangsan._Student__name)print(zhangsan._Student__score)# zhang_san# 99zhangsan._Student__score = 69print(zhangsan._Student__score)# 69 类的继承特性继承特性，经常用于创建和现有类功能类似的新类，又或是新类只需要在现有类基础上添加一些成员（属性和方法），但又不想直接将现有类代码复制给新类。也就是说，通过使用继承这种机制，可以轻松实现类的重复使用，提高其复用性。 在 OOP 程序设计中，当我们定义一个 class 的时候，可以从某个现有的 class 继承，新的 class 称为 子类（Subclass），而被继承的 class 称为 基类、父类或超类（Base class、Super class）。有读者可能还听说过 “派生” 这个词汇，它和继承是一个意思，只是观察角度不同而已。换句话说，继承是相对子类来说的，即子类继承自父类；而派生是相对于父类来说的，即父类派生出子类。 子类继承父类时，只需在定义子类时，将父类（可以是多个）放在子类之后的圆括号里即可。语法格式如下： 12class 类名(父类1, 父类2, ...)： #类定义部分 注意，如果类中没有显式指定继承自哪个类，则默认继承 object 类（object 类是 Python 中所有类的父类，顶级父类）。另外，Python 的继承是多继承机制（和 C++ 一样），即一个子类可以同时拥有多个直接父类。 假设已经编写了一个名为 Animal 的类，定义有一个 run() 实例方法可以直接打印： 123class Animal(object): def run(self): print('Animal is running...') 当我们需要编写 Dog 和 Cat 类时，要求新类不仅具有 run() 方法，还具有叫声方法 call()。此时，笨方法是将 run() 方法直接复制到新类中并且添加表示叫声的方法 call()，这样就没有复用之前已经定义好的 Animal 类。 事实上，更简单的方法，就是使用类的继承机制。此时可以直接从 Animal 类继承： 1234567891011class Animal(object): def run(self): print('Animal is running...')class Dog(Animal): def call(): print(&quot;Dog is calling:&quot;, &quot;Wangwangwang....&quot;)class Cat(Animal): def call(): print(&quot;Cat is calling:&quot;, &quot;Miaomiaomiao....&quot;) 对于 Dog 来说，Animal 就是它的父类，对于 Animal 来说，Dog 就是它的子类。Cat 和 Dog 类似。 [1] &gt;&gt;&gt;&gt; 子类继承父类所有的属性以及方法 继承有什么好处？？？ 继承最大的好处是子类获得了父类的全部功能，即具有父类全部的属性和方法（即便该属性或方法是私有（private）的）。 上面由于 Animial 类中已经实现了 run() 方法，因此 Dog 和 Cat 作为它的子类，即使什么事也没干，但自动拥有了 run() 方法： 12345678910111213141516class Animal(object): name = &quot;This is a Animal&quot; def run(self): print('Animal is running...')class Dog(Animal): passclass Cat(Animal): passjinmao = Dog()print(jinmao.name)# This is a Animaljinmao.run()# Animal is running... [2] &gt;&gt;&gt;&gt; 子类重写（覆盖）父类中方法 继承第二个好处是在子类中可以重写父类中方法。 我们知道，子类继承了父类，那么子类就拥有了父类所有的类属性和类方法。通常情况下，子类会在此基础上，扩展一些新的类属性和类方法。 能会遇到这样一种情况，即子类从父类继承得来的类方法中，大部分是适合子类使用的，但有个别的类方法，并不能直接照搬父类的，如果不对这部分类方法进行修改，子类对象无法使用。针对这种情况，我们就需要在子类中重复父类的方法。 上面 Animal 的例子，无论是 Dog 还是 Cat，它们 run() 的时候，显示的都是 Animal is running...，然而符合逻辑的做法是分别显示 Dog is running... 和 Cat is running...，因此： 1234567891011121314151617181920class Animal(object): name = &quot;This is a Animal&quot; def run(self): print('Animal is running...')class Dog(Animal): def run(self): print('Dog is running...')class Cat(Animal): def run(self): print('Cat is running...')jinmao = Dog()jinmao.run()# Dog is running...xianluo = Cat()xianluo.run()# Cat is running... 事实上，如果我们在子类中重写（覆盖）了从父类继承来的类方法，那么当在类的外部通过子类对象调用该方法时，Python 总是会执行子类中重写的方法。 子类中调用父类中被重写的方法 &gt;&gt;&gt;&gt; 这就产生一个新的问题，即如果想调用父类中被重写的这个方法，该怎么办呢？ 我们知道，Python 中的类可以看做是一个独立空间，而类方法其实就是出于该空间中的一个函数。而如果想要全局空间或者其它类的独立空间中，调用类空间中的函数，只需要通过类名调用该函数即可（要注意此时为未绑定方法调用，注意给 self 传参）。 [3] &gt;&gt;&gt;&gt; Python 中的多继承 大部分面向对象的编程语言，都只支持单继承，即子类有且只能有一个父类。而 Python 却支持多继承（C++也支持多继承）。和单继承相比，多继承容易让代码逻辑复杂、思路混乱，一直备受争议，中小型项目中较少使用，后来的 Java、C#、PHP 等干脆取消了多继承。 使用多继承经常需要面临的问题是，多个父类中包含同名的类方法。 对于这种情况，Python 的处置措施是：根据子类继承多个父类时这些父类的前后次序决定，即排在前面父类中的类方法会覆盖排在后面父类中的同名类方法。 举个样例： 12345678910111213141516171819202122232425class People: def __init__(self): self.name = People def say(self): print(&quot;People 类: &quot;, self.name)class Animal: def __init__(self): self.name = Animal def say(self): print(&quot;Animal 类: &quot;,self.name) # People中的 name 属性和 say() 会遮蔽 Animal 类中的class Person(People, Animal): passclass Dog(Animal, People): passzhangsan = Person()zhangsan.name = &quot;Zhang San&quot;zhangsan.say()jinmao = Dog()jinmao.name = &quot;Jin Mao&quot;jinmao.say() 推荐：尽管 Python 在语法上支持多继承，但逼不得已，建议大家不要使用多继承。 深入理解 Python 中的 MRO我们知道，Python 类是支持（多）继承的，一个类的方法和属性可能定义在当前类，也可能定义在基类。当调用类方法或类属性时，就需要对当前类以及它的基类进行搜索，以确定方法或属性的位置，而搜索的顺序就称为方法解析顺序（MRO）。 方法解析顺序（Method Resolution Order，MRO）。对于 只支持单继承的编程语言来说，MRO 很简单，就是从当前类开始，逐个搜索它的父类（思考一下上面说到的 “子类重写（覆盖）父类中方法”）；而对于 Python，它支持多继承，MRO 相对会复杂一些。 实际上，Python 发展至今，经历了以下 3 种 MRO 算法，分别是： 从左往右，采用深度优先搜索（Deep-first search, DFS）的算法，称为旧式类的 MRO； 自 Python 2.2 版本开始，新式类 MRO 在采用深度优先搜索算法的基础上，对其做了优化； 自 Python 2.3 版本，对新式类采用了 C3 算法。由于 Python3.X 仅支持新式类，所以我们只使用 C3 算法。 为什么 MRO 弃用了前两种算法，而选择最终的 C3 算法呢？？？ &gt;&gt;&gt;&gt; 前两种算法都存在一定的问题。 旧式类 MRO 算法在使用旧式类的 MRO 算法时，以 【程序一】 为例: 123456789101112class A: def method(self): print(&quot;CommonA&quot;)class B(A): passclass C(A): def method(self): print(&quot;CommonC&quot;)class D(B, C): passD().method() 通过分析可以想到，此程序中的 4 个类是一个“菱形”继承的关系，当使用 D 类对象访问 method() 方法时，根据 深度优先算法，搜索顺序为 D-&gt;B-&gt;A-&gt;C-&gt;A。 因此，使用旧式类的 MRO 算法最先搜索得到的是基类 A 中的 method() 方法，即在 Python&lt;2.2 版本中，此程序的运行结果为： 1CommonA 但是，这个结果显然不是想要的，我们希望搜索到的是 C 类中的 method() 方法。 新式类 MRO 算法Python 2.2 版本中推出了新的计算新式类 MRO 的方法，它仍然采用从左至右的 深度优先遍历，但是如果遍历中出现重复的类，只保留最后一个。 【程序一】 中，通过深度优先遍历，其搜索顺序为 D-&gt;B-&gt;A-&gt;C-&gt;A，由于此顺序中有两个 A，因此仅保留后一个，简化后得到最终的搜索顺序为 D-&gt;B-&gt;C-&gt;A。 新式类可以直接通过 类名.__mro__ 的方式获取类的 MRO，也可以通过 类名.mro() 的形式，旧式类是没有 __mro__ 属性和 mro() 方法的。 可以看到，这种 MRO 方式已经能够解决“菱形”继承的问题，但是可能会违反单调性原则。单调性原则是指在类存在多继承时，子类不能改变基类的 MRO 搜索顺序，否则会导致程序发生异常。 例如，分析如下程序 【程序二】： 12345678910class X(object): passclass Y(object): passclass A(X,Y): passclass B(Y,X): passclass C(A, B): pass 通过进行深度遍历，得到搜索顺序为 C-&gt;A-&gt;X-&gt;object-&gt;Y-&gt;object-&gt;B-&gt;Y-&gt;object-&gt;X-&gt;object，再进行简化（相同取后者），得到 C-&gt;A-&gt;B-&gt;Y-&gt;X-&gt;object。 下面来分析这样的搜索顺序是否合理，我们来看下各个类中的 MRO： 对于 A，其搜索顺序为 A-&gt;X-&gt;Y-&gt;object； 对于 B，其搜索顺序为 B-&gt;Y-&gt;X-&gt;object； 对于 C，其搜索顺序为 C-&gt;A-&gt;B-&gt;Y-&gt;X-&gt;object。 可以看到，A 和 C 中，X、Y 的搜索顺序是相反的，也就是说，当 A 被继承时，它本身的搜索顺序发生了改变，这违反了单调性原则。 MRO C3为解决 Python 2.2 中 MRO 所存在的问题，Python 2.3 采用了 C3 方法来确定方法解析顺序。多数情况下，如果某人提到 Python 中的 MRO，指的都是 C3 算法。 在 Python 2.3 及后续版本中，运行 【程序一】，得到如下结果： 1CommonC 运行 【程序二】，会产生如下异常： 1234Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;TypeError: Cannot create a consistent method resolutionorder (MRO) for bases X, Y 由此可见，C3 可以有效解决前面 2 种算法的问题。 那么，C3 算法是怎样实现的呢？？？ C3 实现方法 &gt;&gt;&gt;&gt; 以 【程序一】 为主： 12345678910class A: def method(self): print(&quot;CommonA&quot;)class B(A): passclass C(A): def method(self): print(&quot;CommonC&quot;)class D(B, C): pass C3 把各个类的 MRO 记为如下等式： 类 A：L[A] = merge(A , object) 类 B：L[B] = [B] + merge(L[A] , [A]) 类 C：L[C] = [C] + merge(L[A] , [A]) 类 D：L[D] = [D] + merge(L[B] , L[C] , [B] , [C]) 注意，以类 A 等式为例，其中 merge 包含的 A 称为 L[A] 的头，剩余元素（这里仅有一个 object）称为尾。对于类 B 等式，其中包含两个列表，L[A] &amp;&amp; [A]，分别有头和尾。 这里的关键在于 merge，它的运算方式如下： 检查第一个列表的头元素（如 L[A] 的头），记作 H; 若 H 未出现在 merge 中其它列表的尾部，则将其输出，并将其从所有列表中删除，然后回到步骤 1；否则，取出下一个列表的头部记作 H，继续该步骤。 重复上述步骤，直至列表为空或者不能再找出可以输出的元素。如果是前一种情况，则算法结束；如果是后一种情况，Python 会抛出异常。 由此，可以计算出类 A &amp;&amp; B &amp;&amp; C &amp;&amp; D 的 MRO，其计算过程为： 1234567891011121314151617L[A] = merge(A , object) = [A] + merge(object) = [A, object]L[B] = [B] + merge(L[A], [A]) = [B] + merge([A, object], [A]) = [B, A] + merge([object]) = [B, A, object]L[C] = [C, A, object]L[D] = [D] + merge(L[B], L[C], [B], [C]) = [D] + merge([B, A, object], [C, A, object], [B], [C]) = [D, B] + merge([A, object], [C, A, object], [C]) = [D, B, C] + merge([A, object], [A, object]) = [D, B, C, A] + merge([object], [object]) = [D, B, C, A, object] 你可以在 Python 交互式环境下通过 类名.mro() 验证一下如上推理： 12345678&gt;&gt;&gt; A.mro()[&lt;class '__main__.A'&gt;, &lt;class 'object'&gt;]&gt;&gt;&gt; B.mro()[&lt;class '__main__.B'&gt;, &lt;class '__main__.A'&gt;, &lt;class 'object'&gt;]&gt;&gt;&gt; C.mro()[&lt;class '__main__.C'&gt;, &lt;class '__main__.A'&gt;, &lt;class 'object'&gt;]&gt;&gt;&gt; D.mro()[&lt;class '__main__.D'&gt;, &lt;class '__main__.B'&gt;, &lt;class '__main__.C'&gt;, &lt;class '__main__.A'&gt;, &lt;class 'object'&gt;] 继承升阶我们知道，Python 中内置有一个 object 类，它是所有内置类型的共同祖先，也是所有没有显式指定父类的类（包括用户自定义的）的共同祖先。 因此在实际编程过程中，如果想实现与某个 Python 内置类型具有类似行为的类时，最好的方法就是将这个内置类型子类化。 内置类型子类化，其实就是自定义一个新类，使其继承有类似行为的内置类，通过重定义这个新类实现指定的功能。 举个例子，如下所示创建了一个名为 newDict 的类，其中 newDictError 是自定义的异常类： 1234567891011121314151617181920class newDictError(ValueError): &quot;&quot;&quot;如果向 newDict 添加重复值，则引发此异常&quot;&quot;&quot;class newDict(dict): &quot;&quot;&quot;不接受重复值的字典&quot;&quot;&quot; def __setitem__(self,key,value): if value in self.values(): if ((key in self and self[key]!=value) or (key not in self)): raise newDictError(&quot;这个值已经存在，并对应不同的键&quot;) super().__setitem__(key,value)demoDict = newDict()demoDict['key']='value'demoDict['other_key']='value2'print(demoDict)demoDict['other_key']='value'print(demoDict) 可以看到，newDict 是 Python 中 dict 类型的子类，所以其大部分行为都和 dict 内置类相同。唯一不同之处在于，newDict 不允许字典中多个键对应相同的值。如果用户试图添加具有相同值的新元素，则会引发 newDictError 异常，并给出提示信息。 由于目前尚未学习如何处理异常，因此这里没有 newDictError 做任何处理，异常处理会在后续章节做详细讲解。 另外，如果查看现有代码你会发现，其实很多类都是对 Python 内置类的部分实现，它们作为子类的速度更快，代码更整洁。 其实，除了 Python 中常用的基本内置类型，collections 模块中还额外提供了很多有用的容器，这些容器可以满足大部分情况。 Super() 使用我们知道，Python 中子类会继承父类所有的类属性和类方法。严格来说，类的构造方法其实就是实例方法，因此毫无疑问，父类的构造方法，子类同样会继承。 但我们知道，Python 是一门支持多继承的面向对象编程语言，如果子类继承的多个父类中包含同名的类实例方法，则子类对象在调用该方法时，会优先选择排在最前面的父类中的实例方法。显然，构造方法也是如此。 12345678910111213141516171819class People: def __init__(self,name): self.name = name def say(self): print(&quot;我是人，名字为：&quot;, self.name)class Animal: def __init__(self,food): self.food = food def display(self): print(&quot;我是动物,我吃&quot;, self.food)# People中的 name 属性和 say() 会遮蔽 Animal 类中的class Person(People, Animal): passper = Person(&quot;zhang_san&quot;)per.say()# per.display() Person 类同时继承 People 和 Animal，其中 People 在前。这意味着，在创建 per 对象时，其将会调用从 People 继承来的构造函数。因此我们看到，上面程序在创建 per 对象的同时，还要给 name 属性进行赋值。 场景引入但如果去掉上述代码中最后一行的注释符，运行此行代码，Python 解释器会报如下错误： 123456Traceback (most recent call last): File &quot;.code.tio&quot;, line 19, in per.display() File &quot;.code.tio&quot;, line 11, in display print(&quot;我是动物,我吃&quot;, self.food)AttributeError: 'Person' object has no attribute 'food' 这是因为，从 Animal 类中继承的 display() 方法中，需要用到 food 属性的值，但由于 People 类的构造方法“遮蔽”了Animal 类的构造方法，使得在创建 per 对象时，Animal 类的构造方法未得到执行，所以程序出错。 反过来也是如此，如果将代码改为如下形式： 1class Person(Animal, People) 则在创建 per 对象时，会给 food 属性传值。这意味着，per.display() 能顺序执行，但 per.say() 将会报错。 怎么办？？？ 针对这种情况，正确的做法是定义 Person 类自己的构造方法（等同于重写第一个直接父类的构造方法）。 但需要注意，如果在子类中定义构造方法，则必须在该方法中调用父类的构造方法。 子类中调用父类构造函数也就是说，当某个类具有多继承时，为了保证可以正常使用继承至其父类中的各种方法，一般需要在子类中定义构造方法，并且必须在该方法中调用父类的构造方法。 在子类中的构造方法中，调用父类构造方法的方式有两种，分别是： 类可以看做一个独立空间，在类的外部调用其中的实例方法，可以向调用普通函数那样，只不过需要使用非绑定方式进行调用 类名.方法名(参数)。同理前面子类中调用父类中被重写的方法说明； 使用 super() 函数，但注意如果涉及多继承时，该函数只能调用第一个直接父类的构造方法。 也就是说，涉及到多继承时，在子类构造函数中，调用第一个父类构造方法的方式有以上 2 种（super() 函数有使用限制），而调用其它父类构造方法的方式只能使用未绑定方法。 super() 函数的使用语法格式如下： 12345# Python 2.X &amp;&amp; Python 3.Xsuper(Class, obj).__init__(self,...)# Python 3.X（推荐使用！！！）super().__init__(self,...) 例如，对于上面的程序可以尝试如下修改： 12345678910111213141516171819202122232425class People: def __init__(self,name): self.name = name def say(self): print(&quot;我是人, 名字为：&quot;, self.name)class Animal: def __init__(self,food): self.food = food def display(self): print(&quot;我是动物, 我吃&quot;, self.food)class Person(People, Animal): #自定义构造方法 def __init__(self, name, food): #调用 People 类的构造方法 super().__init__(name) # super(Person, self).__init__(name) #执行效果和上一行相同 # People.__init__(self, name) # 使用未绑定方法调用 People 类构造方法 # 调用其它父类的构造方法，需手动给 self 传值 Animal.__init__(self, food)per = Person(&quot;zhang_san&quot;, &quot;Meats&quot;)per.say()per.display() 可以看到，Person 类自定义的构造方法中，调用 People 类构造方法，可以使用 super() 函数，也可以使用未绑定方法。但是调用 Animal 类的构造方法，只能使用未绑定方法。 注意，这里 super() 方法不仅可以调用第一个直接父类中的构造函数，还可以调用其第一个父类中的重写方法（或其它方法），例如： 12345678910111213class Person(People, Animal): #自定义构造方法 def __init__(self, name, food): #调用 People 类的构造方法 super().__init__(name) # super(Person,self).__init__(name) #执行效果和上一行相同 # People.__init__(self, name) # 使用未绑定方法调用 People 类构造方法 # 调用其它父类的构造方法，需手动给 self 传值 Animal.__init__(self, food) def say(self): super().say() # 调用父类 say() 方法 print(&quot;我是&quot;, self.name) Super 注意事项Python 中，由于基类不会在子类 __init__() 中被隐式地调用，需要程序员显式调用它们。这种情况下，当程序中包含多重继承的类层次结构时，使用 super 是非常危险的，往往会在类的初始化过程中出现问题。 [1] &gt;&gt;&gt;&gt; 混用 super 与显式类调用 分析如下程序，C 类使用了 __init__() 方法调用它的基类，会造成 B 类被调用了 2 次： 12345678910111213141516171819class A: def __init__(self): print(&quot;A&quot;,end=&quot; &quot;) super().__init__()class B: def __init__(self): print(&quot;B&quot;,end=&quot; &quot;) super().__init__()class C(A,B): def __init__(self): print(&quot;C&quot;,end=&quot; &quot;) A.__init__(self) # super().__init__(self) B.__init__(self) print(&quot;MRO:&quot;,[x.__name__ for x in C.__mro__])C()# MRO: ['C', 'A', 'B', 'object']# C A B B 出现以上这种情况的原因在于，C 的实例调用 A.__init__(self)，使得 super(A,self).__init__() 调用了 B.__init__() 方法。换句话说，super 应该被用到整个类的层次结构中。 但是，有时这种层次结构的一部分位于第三方代码中，我们无法确定外部包的这些代码中是否使用 super()，因此，当需要对某个第三方类进行子类化时，最好查看其内部代码以及 MRO 中其他类的内部代码。 [2] &gt;&gt;&gt;&gt; 不同种类参数 使用 super 的另一个问题是初始化过程中的参数传递。如果没有相同的签名（参数），一个类怎么能调用其基类的 __init__() 代码呢？这会导致下列问题： 12345678910111213141516171819202122class commonBase: def __init__(self): print(&quot;commonBase&quot;) super().__init__()class base1(commonBase): def __init__(self): print(&quot;base1&quot;) super().__init__()class base2(commonBase): def __init__(self, name): print(&quot;base2&quot;) super().__init__()class myClass(base1,base2): def __init__(self,arg): print(&quot;my base&quot;) super().__init__(arg) # 形式一 # super().__init__() # 形式二myClass(10) 可以看到，base1 &amp;&amp; base2 需要不同的参数传入，使用形式一还是形式二传入呢？都是会导致问题的！！！ 一种解决方法是使用 *args 和 **kwargs 包装的参数和关键字参数，这样即使不使用它们，所有的构造函数也会传递所有参数，如下所示： 1234567891011121314151617class commonBase: def __init__(self,*args,**kwargs): print(&quot;commonBase&quot;) super().__init__()class base1(commonBase): def __init__(self,*args,**kwargs): print(&quot;base1&quot;) super().__init__(*args,**kwargs)class base2(commonBase): def __init__(self,*args,**kwargs): print(&quot;base2&quot;) super().__init__(*args,**kwargs)class myClass(base1,base2): def __init__(self,arg): print(&quot;my base&quot;) super().__init__(arg)myClass(10) 不过，这是一种很糟糕的解决方法，由于任何参数都可以传入，所有构造函数都可以接受任何类型的参数，这会导致代码变得脆弱。另一种解决方法是在 MyClass 中显式地使用特定类的 __init__() 调用，但这无疑会导致第一种错误。 如果想要避免程序中出现以上的这些问题，这里给出几点建议： 尽可能避免使用多继承，可以使用一些设计模式来替代它； super 的使用必须一致，即在类的层次结构中，要么全部使用 super，要么全不用。混用 super 和传统调用是一种混乱的写法； 如果代码需要兼容 Python 2.x，在 Python 3.x 中应该显式地继承自 object。在 Python 2.x 中，没有指定任何祖先地类都被认定为旧式类。 调用父类时应提前查看类的层次结构，也就是使用类的 __mro__ 属性或者 mro() 方法查看有关类的 MRO。 前面，我们介绍了类的封装和继承特性，下面来看其多态性： 类的多态特性我们都知道，Python 是弱类型语言，其最明显的特征是在使用变量时，无需为其指定具体的数据类型。这会导致一种情况，即同一变量可能会被先后赋值不同的类对象，例如： 12345678910111213class Language: def say(self): print(&quot;赋值的是 Language 类的实例对象&quot;)class IPython: def say(self): print(&quot;赋值的是 IPython 类的实例对象&quot;)a = Language()a.say()# 赋值的是 Language 类的实例对象a = IPython()a.say()# 赋值的是 IPython 类的实例对象 可以看到，a 可以被先后赋值为 Language 类和 IPython 类的对象，但这并不是多态。 类的多态特性，需要满足以下两个前提条件： 继承：多态一定是发生在子类和父类之间； 重写：子类重写了父类的方法。 对上面代码的改写： 123456789101112131415161718192021class CLanguage: def say(self): print(&quot;调用的是 Clanguage 类的 say 方法&quot;)class CPython(CLanguage): def say(self): print(&quot;调用的是 CPython 类的 say 方法&quot;)class CLinux(CLanguage): def say(self): print(&quot;调用的是 CLinux 类的 say 方法&quot;) a = CLanguage()a.say()# 调用的是 Clanguage 类的 say 方法a = CPython()a.say()# 调用的是 CPython 类的 say 方法a = CLinux()a.say()# 调用的是 CLinux 类的 say 方法 CPython 和 CLinux 都继承自 CLanguage 类，且各自都重写了父类的 say() 方法。从运行结果可以看出，同一变量 a 在执行同一个 say() 方法时，由于 a 实际表示不同的类实例对象，因此 a.say() 调用的并不是同一个类中的 say() 方法，这就是多态。 要理解多态的好处，我们还需要再编写一个函数，这个函数接受一个 CLanguage 类型的变量： 1234567891011121314151617181920212223class WhoSay: def say(self,cLanguage): cLanguage.say()class CLanguage: def say(self): print(&quot;调用的是 Clanguage 类的say方法&quot;)class CPython(CLanguage): def say(self): print(&quot;调用的是 CPython 类的say方法&quot;)class CLinux(CLanguage): def say(self): print(&quot;调用的是 CLinux 类的say方法&quot;)a = WhoSay()# 调用 CLanguage 类的 say() 方法a.say(CLanguage())# 调用 CPython 类的 say() 方法a.say(CPython())# 调用 CLinux 类的 say() 方法a.say(CLinux()) 此程序中，通过给 WhoSay 类中的 say() 函数添加一个 cLanguage 参数，其内部利用传入的 cLanguage 调用 say() 方法。这意味着，当调用 WhoSay 类中的 say() 方法时，我们传给 cLanguage 参数的是哪个类的实例对象，它就会调用那个类中的 say() 方法。 开闭原则 &gt;&gt;&gt;&gt; 对于一个变量，我们只需要知道它是 cLanguage 类型，无需确切地知道它的子类型，就可以放心地调用 say() 方法，而具体调用的 say() 方法是作用在 CLanguage、CPython 还是 CLinux 对象上，由运行时该对象的确切类型决定，这就是多态真正的威力。 这样，调用方只管调用，不管细节，而当我们新增一种 CLanguage 的子类时，只要确保 say() 方法编写正确，不用管原来的代码是如何调用的。这就是著名的“开闭”原则： 对扩展开放：允许新增 CLanguage 子类； 对修改封闭：不需要修改依赖 CLanguage 类型的 say() 等函数。 静态语言 vs 动态语言对于静态语言（例如 Java）来说，如果需要传入 CLanguage 类型，则传入的对象必须是 CLanguage 类型或者它的子类，否则，将无法调用 say() 方法。 对于 Python 这样的动态语言来说，则不一定需要传入 CLanguage 类型。我们只需要保证传入的对象有一个 say() 方法就可以了： 123class Timer(object): def say(self): print('Start...') 例如，Python 的 file-like object 类型。对真正的文件对象，它有一个 read() 方法，返回其内容。 但是对于许多对象，只要有 read() 方法，都被视为 file-like object。许多函数接收的参数就是 file-like object，你不一定要传入真正的文件对象，完全可以传入任何实现了 read() 方法的对象。 枚举类一些具有特殊含义的类，其实例化对象的个数往往是固定的，比如用一个类表示月份，则该类的实例对象最多有 12 个；再比如用一个类表示季节，则该类的实例化对象最多有 4 个。 针对这种特殊的类，Python 3.4 中新增加了 Enum 枚举类。 也就是说，对于这些实例化对象个数固定的类，可以用枚举类来定义。 [1] &gt;&gt;&gt;&gt; 枚举类的定义和属性访问 例如，下面程序演示了如何定义一个枚举类： 1234567from enum import Enumclass Color(Enum): # 为序列值指定 value 值 red = 1 green = 2 blue = 3 如果想将一个类定义为枚举类，只需要令其继承自 enum 模块中的 Enum 类即可。例如在上面程序中，Color 类继承自 Enum 类，则证明这是一个枚举类。 在 Color 枚举类中，red、green、blue 都是该类的成员（可以理解为是类变量）。注意，枚举类的每个成员都由 2 部分组成，分别为 name 和 value，其中 name 属性值为该枚举值的变量名（如 red），value 代表该枚举值的序号（序号通常从 1 开始）。 和普通类的用法不同，枚举类不能用来实例化对象，但这并不妨碍我们访问枚举类中的成员。访问枚举类成员的方式有多种，例如以 Color 枚举类为例，在其基础上添加如下代码： 123456789101112131415161718192021from enum import Enumclass Color(Enum): # 为序列值指定 value 值 red = 1 green = 2 blue = 3# 调用枚举成员的 3 种方式print(Color.red)# Color.redprint(Color['red'])# Color.redprint(Color(1))# Color.red# 调取枚举成员中的 value 和 nameprint(Color.red.value)# 1print(Color.red.name)# red [2] &gt;&gt;&gt;&gt; 枚举类不支持外部修改 枚举类中各个成员的值，不能在类的外部做任何修改，也就是说，下面语法的做法是错误的： 1234567Color.red = 4# Traceback (most recent call last):# File &quot;.code.tio&quot;, line 18, in # Color.red = 4# File &quot;/usr/lib64/python3.6/enum.py&quot;, line 361, in __setattr__# raise AttributeError('Cannot reassign members.')# AttributeError: Cannot reassign members. [3] &gt;&gt;&gt;&gt; 枚举类成员比较 枚举类成员之间不支持比较大小，但可以用 == 或者 is 进行比较是否相等，例如： 1234567891011121314print(Color.red == Color.green)# Falseprint(Color.red.name is Color.green.name)# False# print(Color.red &gt; Color.green)# Traceback (most recent call last):# File &quot;.code.tio&quot;, line 20, in # print(Color.red &gt; Color.green)# TypeError: '&gt;' not supported between instances of 'Color' and 'Color'# 支持比较相应值大小：print(Color.red.value &lt; Color.green.value)# True [4] &gt;&gt;&gt;&gt; 枚举类成员遍历 遍历枚举类中所有成员的支持两种方式： 12345for color in Color: print(color, color.value)# Color.red 1# Color.green 2# Color.blue 3 除此之外，该枚举类还提供了一个 __members__ 属性，该属性是一个包含枚举类中所有成员的字典，通过遍历该属性，也可以访问枚举类中的各个成员。例如： 12345for name,member in Color.__members__.items(): print(name, &quot;-&gt;&quot;, member, &quot; -&gt; value: &quot;, member.value)# red -&gt; Color.red -&gt; value: 1# green -&gt; Color.green -&gt; value: 2# blue -&gt; Color.blue -&gt; value: 3 [5] &gt;&gt;&gt;&gt; @unique 装饰器 Python 枚举类中各个成员必须保证 name 互不相同（唯一Key），但 value 可以相同，举个例子： 123456789from enum import Enumclass Color(Enum): # 为序列值指定 value 值 red = 1 green = 1 blue = 3print(Color['green'])# Color.red 可以看到，Color 枚举类中 red 和 green 具有相同的值（都是 1），Python 允许这种情况的发生，它会将 green 当做是 red 的别名，因此当访问 green 成员时，最终输出的是 red。 在实际编程过程中，如果想避免发生这种情况，可以借助 @unique 装饰器，这样当枚举类中出现相同值的成员时，程序会报 ValueError 错误。例如： 12345678910111213141516from enum import Enum,unique@uniqueclass Color(Enum): # 为序列值指定 value 值 red = 1 green = 1 blue = 3print(Color['green'])# Traceback (most recent call last):# File &quot;.code.tio&quot;, line 4, in # class Color(Enum):# File &quot;/usr/lib64/python3.6/enum.py&quot;, line 834, in unique# (enumeration, alias_details))# ValueError: duplicate values found in : green -&gt; red [6] &gt;&gt;&gt;&gt; Enum() 函数创建枚举类 除了通过继承 Enum 类的方法创建枚举类，还可以使用 Enum() 函数快速创建枚举类。例如： 123456789101112131415161718from enum import Enum#创建一个枚举类Color = Enum(&quot;Color&quot;,('red','green','blue'))# 调用枚举成员的 3 种方式print(Color.red)print(Color['red'])print(Color(1))# 调取枚举成员中的 value 和 nameprint(Color.red.value)print(Color.red.name)# 遍历枚举类中所有成员的 2 种方式for color in Color: print(color, color.value)for name,member in Color.__members__.items(): print(name, &quot;-&gt;&quot;, member, &quot; -&gt; value: &quot;, member.value) 实战搜索引擎要想实现一个搜索引擎，首先要了解什么是搜索引擎。 简单地理解，搜索引擎是一个系统，它可以帮助用户去互联网上搜集与其检索内容相关的信息。 通常，一个搜索引擎由搜索器、索引器、检索器以及用户接口组成，其中各个部分的含义如下： 搜索器：其实就是我们常说的爬虫、它能够从互联网中搜集大量的信息，并将之传递给索引器； 索引器：理解搜索器搜索到的信息，并从中抽取出索引项，存储到内部的数据库中，等待检索； 检索器：根据用户查询的内容，在已经建立好的索引库中快速检索出与之相关的信息，并做相关度评价，以此进行排序； 用户接口：其作用就是提供给用户输入查询内容的窗口（例如百度、谷歌的搜索框），并将检索好的内容反馈给用户。 由于爬虫知识不是重点，这里不再做深入介绍，我们假设搜索样本就存在于本地磁盘中的文件。为了方便，这里只提供五个用于检索的文件，各文件存放的内容分别如下： 1234567891011121314# 1.txtPython 官方文档# 2.txthttps://docs.python.org/zh-cn/3/# 3.txt「Python 官方文档」是一个在线学习 Python 的网站，在这里你可以查找到 Python 的最新变化以及历史信息。# 4.txtPython 官方文档有 Python 官方开发团队提供，致力于发布 Python 最新变化以及历史信息，以供开发人员学习使用。# 5.txt抛开喧嚣，卸下繁华，只为一纸清凉，遇到更好的自己。 下面，根据以上知识，我们先实现一个最基本的搜索引擎： 1234567891011121314151617181920212223242526272829class SearchEngineBase: def __init__(self): pass # 搜索器 def crawl_corpus(self, file_path): with open(file_path, 'rb') as fin: text = fin.read().decode('utf-8') self.process_corpus(file_path, text) # 索引器 def process_corpus(self, id, text): raise Exception('process_corpus not implemented.') # 检索器 def searcher(self, query): raise Exception('searcher not implemented.')# 用户接口def main(search_engine): for file_path in ['1.txt', '2.txt', '3.txt', '4.txt', '5.txt']: search_engine.crawl_corpus(file_path) while True: query = input() results = search_engine.searcher(query) print('found {} result(s):'.format(len(results))) for result in results: print(result) 以上代码仅是建立了搜索引擎的一个基本框架，它可以作为基类被其他类继承，那么继承自此类的类将分别代表不同的搜索引擎，它们应该各自实现基类中的 process_corpus() 和 searcher() 方法。 整个代码的运行过程是这样的，首先将各个检索文件中包含的内容连同该文件所在的路径一起传递给索引器，索引器会以该文件的路径建立索引，等待用户检索。 在 SearchEngineBase 类的基础上，下面实现了一个基本可以工作的搜索引擎： 1234567891011121314151617181920class SimpleEngine(SearchEngineBase): def __init__(self): super().__init__() # 建立索引时使用 self.__id_to_texts = {} def process_corpus(self, id, text): # 以文件路径为键，文件内容为值，形成键值对，存储在字典中，由此建立索引 self.__id_to_texts[id] = text def searcher(self, query): results = [] # 依次检索字典中的键值对，如果文件内容中包含用户要搜索的信息，则将此文件的文件路径存储在 results 列表中 for id, text in self.__id_to_texts.items(): if query in text: results.append(id) return resultssearch_engine = SimpleEngine()main(search_engine) 运行结果如下： 12345C语言中文网found 3 result(s):1.txt3.txt4.txt 可以看到，用户搜索与 “Python 官方文档” 有关的内容，最终检索到了 1.txt、3.txt和 4.txt 文件中包含与之相关的内容。由此，只需要短短十来行代码就可以实现一个基础的搜索引擎。","link":"/2018/01/12/python-mian-xiang-dui-xiang-bian-cheng-zhi-lei-he-dui-xiang/"},{"title":"Python 面向对象编程之类的特殊属性和方法","text":"Python 类中，凡是以双下划线 __ 开头和结尾命名的成员（属性和方法），都被称为类的特殊成员（特殊属性和特殊方法），例如类的 __init__(self) 构造方法。此外，Python 类中还包含很多其它的特殊成员，包括 __del__(self)、__new__(self) 等等，这里会一一进行详解。 类常用特殊成员整理我们知道，Python 类中的特殊成员，其特殊性类似 C++ 类的 private 私有成员，即不能在类的外部直接调用，但允许借助类中的普通方法调用甚至修改它们（封装）。如果需要，还可以对类的特殊方法进行重写，从而实现一些特殊的功能。 这一小节，将会详解 Python 顶级父类 object 中常用特殊成员的使用： Method: __new____new__() 是一种用来创建类实例的静态方法，它无需使用 @staticmethod 装饰器修饰，且该方法会优先 __init__() 初始化方法被调用。 [1] &gt;&gt;&gt;&gt; __new__() 返回当前类实例 一般情况下，重写 __new__() 的实现需要使用合适的参数调用其超类的 super().__new__()，并在返回之前修改实例。 实例如下： 123456789101112131415161718192021222324class demoClass: instances_created = 0 def __new__(cls,*args,**kwargs): print(&quot;__new__():&quot;,cls,args,kwargs) instance = super().__new__(cls) instance.number = cls.instances_created cls.instances_created += 1 return instance def __init__(self,attribute): print(&quot;__init__():&quot;,self,attribute) self.attribute = attributetest1 = demoClass(&quot;abc&quot;)# __new__(): ('abc',) {}# __init__(): &lt;__main__.demoClass object at 0x7efd9982fcc0&gt; abctest2 = demoClass(&quot;xyz&quot;)# __new__(): ('xyz',) {}# __init__(): &lt;__main__.demoClass object at 0x7efd9982fcf8&gt; xyzprint(test1.number, test1.instances_created)# 0 2print(test2.number, test2.instances_created)# 1 2 [2] &gt;&gt;&gt;&gt; __new__() 返回其它类实例 __new__() 通常会返回该类的一个实例，但有时也可能会返回其他类的实例，如果发生了这种情况，则会跳过对 __init__() 方法的调用。 而在某些情况下（比如需要修改不可变类实例（Python 的某些内置类型）的创建行为），利用这一点会事半功倍。比如： 12345678910111213141516class nonZero(int): def __new__(cls,value): print(&quot;__new__()&quot;) return super().__new__(cls,value) if value != 0 else None def __init__(self,skipped_value): # 此例中会跳过此方法 print(&quot;__init__()&quot;) super().__init__()print(type(nonZero(-12)))# __new__()# __init__()print(type(nonZero(0)))# __new__() [3] &gt;&gt;&gt;&gt; 何时使用 __new__()？ 很简单，在 __init__() 不够用的时候。 例如，前面例子中对 Python 不可变的内置类型（如 int、str、float 等）进行了子类化，这是因为一旦创建了这样不可变的对象实例，就无法在 __init__() 方法中对其进行修改。 有些读者可能会认为，__new__() 对执行重要的对象初始化很有用，如果用户忘记使用 super()，可能会漏掉这一初始化。虽然这听上去很合理，但有一个主要的缺点，即如果使用这样的方法，那么即便初始化过程已经是预期的行为，程序员明确跳过初始化步骤也会变得更加困难。不仅如此，它还破坏了 __init__() 中执行所有初始化工作 的潜规则。 并且，由于 __new__() 不限于返回同一个类的实例，所以很容易被滥用，不负责任地使用这种方法可能会对代码有害，所以要谨慎使用。 一般来说，对于特定问题，最好搜索其他可用的解决方案，最好不要影响对象的创建过程，使其违背程序员的预期。比如说，前面提到的覆写不可变类型初始化的例子，完全可以用工厂方法（一种设计模式）来替代。 Method: __repr__我们经常会直接输出类的实例化对象，例如： 123456class Language: passlangs = Language()print(langs)# &lt;__main__.Language object at 0x7fe399c6a710&gt; 通常情况下，直接输出某个实例化对象，本意往往是想了解该对象的基本信息，例如该对象有哪些属性，它们的值各是多少等等。但默认情况下，我们得到的信息只会是 class name + object at + &lt;memory address&gt;，对我们了解该实例化对象帮助不大。 那么，有没有可能自定义输出实例化对象时的信息呢？？？答案是肯定，通过重写类的 __repr__() 方法即可。 重写 __repr__() 方法输出实例化对象时的信息 &gt;&gt;&gt;&gt; 事实上，当我们输出某个实例化对象时，其调用的就是该对象的 __repr__() 方法，输出的是该方法的返回值。 以本节开头的程序为例，执行 print(clangs) 等同于执行 print(clangs.__repr__())，程序的输出结果是一样的（输出的内存地址可能不同）。 和 __init__(self) 的性质一样，Python 中的每个类都包含 __repr__() 方法，这是因为 object 类包含 __reper__() 方法，而 Python 中所有的类都直接或间接继承自 object 类。因此，你可以通过在类中重写这个方法，从而实现当输出实例化对象时，输出我们想要的信息。 实例演示： 1234567891011class Language: def __init__(self): self.name = &quot;Python&quot; self.add = &quot;Python is a OOP programing.&quot; def __repr__(self): return &quot;Language [name = &quot; + self.name +&quot;, add = &quot; + self.add + &quot; ]&quot;langs = Language()print(langs)# Language [name = Python, add = Python is a OOP programing. ] 由此可见，__repr__() 方法是类的实例化对象用来做“自我介绍”的方法，默认情况下，它会返回当前对象的 class name + object at + &lt;memory address&gt;，而如果对该方法进行重写，可以为其制作自定义的自我描述信息。 Method: __del__我们知道，Python 中通过调用 __init__() 构造方法来创建当前类的实例化对象；__del__() 方法，功能正好和 __init__() 相反，其用来销毁实例化对象。 事实上在编写程序时，如果之前创建的类实例化对象后续不再使用，最好在适当位置手动将其销毁，释放其占用的内存空间（垃圾回收，GC）。 大多数情况下，Python 开发者不需要手动进行垃圾回收，因为 Python 有自动的垃圾回收机制，能自动将不需要使用的实例对象进行销毁。 但注意，无论是手动销毁，还是 Python 自动帮我们销毁，都会调用 __del__() 方法。实例演示： 1234567891011class Language: def __init__(self): print(&quot;调用 __init__() 方法构造对象&quot;) def __del__(self): print(&quot;调用 __del__() 销毁对象，释放其空间&quot;)langs = Language()# 调用 __init__() 方法构造对象del langs# 调用 __del__() 销毁对象，释放其空间 [1] &gt;&gt;&gt;&gt; 类的自动回收机制 千万不要误认为，只要为该实例对象调用 __del__() 方法，该对象所占用的内存空间就会被释放。举个例子： 12345678910111213class Language: def __init__(self): print(&quot;调用 __init__() 方法构造对象&quot;) def __del__(self): print(&quot;调用 __del__() 销毁对象，释放其空间&quot;)langs = Language()# 添加一个引用 langs 对象的实例对象cl = langsdel langsprint(&quot;**** Program End ****&quot;) 运行结果如下： 123调用 __init__() 方法构造对象**** Program End ****调用 __del__() 销毁对象，释放其空间 可以看到，当程序中有其它变量（比如这里的 cl）引用该实例对象时，即便手动调用 __del__() 方法，该方法也不会立即执行，而是等待程序执行完成之后才会释放。这就和 Python 的垃圾回收机制有关。 以上面程序中的 langs 为例，实际上构建 langs 实例对象的过程分为两步： 先使用 Language() 调用该类中的 __init__() 方法构造出一个该类的对象（将其称为 C，计数器为 0），并立即用 langs 这个变量作为所建实例对象的引用（ C 的计数器值 + 1）。 在此基础上，又有一个 cl 变量引用 langs（其实相当于引用 Language()，此时 C 的计数器再 +1 ），这时如果调用 del langs 语句，只会导致 C 的计数器减 1（值变为 1），因为 C 的计数器值不为 0，因此 C 不会被销毁（不会执行 __del__() 方法）。 [2] &gt;&gt;&gt;&gt; 重写时需显式调用父类 __del__() 方法 需要额外说明的是，如果我们重写子类的 __del__() 方法（父类为非 object 的类），则必须显式调用父类的 __del__() 方法，这样才能保证在回收子类对象时，其占用的资源（可能包含继承自父类的部分资源）能被彻底释放。 为了说明这一点，这里举一个反例： 123456789101112class Language: def __del__(self): print(&quot;调用父类 __del__() 方法&quot;) class cl(Language): def __del__(self): # super().__del__() # 需要显示调用父类 __del__() 方法 print(&quot;调用子类 __del__() 方法&quot;) c = cl()del c# 调用子类 __del__() 方法 Method: __dir__在 Python 内置函数中，提到过 dir() 函数，通过此函数可以某个对象拥有的所有的属性名和方法名，该函数会返回一个包含有所有属性名和方法名的有序列表。 实例如下： 1234567891011class Language: def __init__ (self,): self.name = &quot;C语言中文网&quot; self.add = &quot;http://c.biancheng.net&quot; def say(): passlangs = Language()print(dir(langs))# ['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__', 'add', 'name', 'say'] 可以看到，不仅仅输出本类中新添加的属性名和方法（最后 3 个），还会输出从父类（这里为 object 类）继承得到的属性名和方法名。 值得一提的是，dir() 函数的内部实现，其实是在调用参数对象 __dir__() 方法的基础上，对该方法返回的属性名和方法名做了排序。 所以，你完全可以自行调用该对象具有的 __dir__() 方法来查看某个对象拥有的所有的属性名和方法名： 1234567891011class Language: def __init__ (self,): self.name = &quot;C语言中文网&quot; self.add = &quot;http://c.biancheng.net&quot; def say(): passlangs = Language()print(langs.__dir__())['name', 'add', '__module__', '__init__', 'say', '__dict__', '__weakref__', '__doc__', '__repr__', '__hash__', '__str__', '__getattribute__', '__setattr__', '__delattr__', '__lt__', '__le__', '__eq__', '__ne__', '__gt__', '__ge__', '__new__', '__reduce_ex__', '__reduce__', '__subclasshook__', '__init_subclass__', '__format__', '__sizeof__', '__dir__', '__class__'] 显然，使用 __dir__() 方法和 dir() 函数输出的数据是相同，仅仅顺序不同。 Method: __dict__事实上，在 Python 类的内部，无论是类属性还是实例属性，都是以字典的形式进行存储的，其中属性名作为键，而值作为该键对应的值。 为了方便用户查看类中包含哪些属性，Python 类提供了 __dict__ 属性。 需要注意是，该属性可以用类名或者类的实例对象来调用： 使用类名直接调用 __dict__，会输出该由类中所有类属性组成的字典； 使用类的实例对象调用 __dict__，会输出由类中所有实例属性组成的字典。 实例演示： 123456789101112131415161718192021class Language: a = 1 b = 2 def __init__ (self): self.name = &quot;Python&quot; self.add = &quot;Python is a OOP Programing&quot; def info(self): print(&quot;Instance Method&quot;) @classmethod def say(cls): print(&quot;Class Method&quot;)# 通过类名调用__dict__print(Language.__dict__)# {'__module__': '__main__', 'a': 1, 'b': 2, '__init__': , 'info': , 'say': , '__dict__': , '__weakref__': , '__doc__': None}# 通过类实例对象调用 __dict__langs = Language()print(langs.__dict__)# {'name': 'Python', 'add': 'Python is a OOP Programing'} 不仅如此，对于具有继承关系的父类和子类来说，父类有自己的 __dict__，同样子类也有自己的 __dict__，它不会包含父类的 __dict__。例如： 1234567891011121314151617181920212223242526272829class Language: a = 1 b = 2 def __init__ (self): self.name = &quot;Python&quot; self.add = &quot;Python is a OOP Programing&quot; class CL(Language): c = 1 d = 2 def __init__ (self): self.na = &quot;Python3.X&quot; self.ad = &quot;Python3.X is a OOP Programing&quot;# 父类名调用__dict__print(Language.__dict__)# {'__module__': '__main__', 'a': 1, 'b': 2, '__init__': , '__dict__': , '__weakref__': , '__doc__': None}# 子类名调用__dict__print(CL.__dict__)# {'__module__': '__main__', 'c': 1, 'd': 2, '__init__': , '__doc__': None}# 父类实例对象调用 __dict__langs = Language()print(langs.__dict__)# {'name': 'Python', 'add': 'Python is a OOP Programing'}# 子类实例对象调用 __dict__cl = CL()print(cl.__dict__)# {'na': 'Python3.X', 'ad': 'Python3.X is a OOP Programing'} 可见，通过子类直接调用的 __dict__ 中，并没有包含父类中的 a 和 b 类属性；同样，通过子类对象调用的 __dict__，也没有包含父类对象拥有的 name 和 add 实例属性。 总结一下： 实例的 __dict__ 仅存储与该实例相关的实例属性; 类的 __dict__ 存储所有实例共享的变量和函数(类属性，方法等)，类的 __dict__ 并不包含其父类的属性。 [1] &gt;&gt;&gt;&gt; 修改类实例属性值 借助由类实例对象调用 __dict__ 属性获取的字典，可以使用字典的方式对其中实例属性的值进行修改，例如： 1234567891011121314class Language: a = 1 b = 2 def __init__ (self): self.name = &quot;Python&quot; self.add = &quot;Python is a OOP Programing&quot;#通过类实例对象调用 __dict__langs = Language()print(langs.__dict__)# {'name': 'Python', 'add': 'Python is a OOP Programing'}langs.__dict__['name'] = &quot;Python3.X&quot;print(langs.name)# Python3.X [2] &gt;&gt;&gt;&gt; __dict__ 魔法操作 我们知道，__dict__ 是用来存储对象属性的一个字典，其键为属性名，值为属性的值。 既然 __dict__ 是个字典那么我们就可以用字典的属性了。我们通过使用 dir() 属性来看看 __dict__ 都有哪些属性: 1['__class__', '__contains__', '__delattr__', '__delitem__', '__dir__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__', '__getitem__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__iter__', '__le__', '__len__', '__lt__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__reversed__', '__setattr__', '__setitem__', '__sizeof__', '__str__', '__subclasshook__', 'clear', 'copy', 'fromkeys', 'get', 'items', 'keys', 'pop', 'popitem', 'setdefault', 'update', 'values'] 我们看一段代码内含注释: 123456789101112131415161718192021class A(): def __init__(self): self.name=&quot;liming&quot; def save_data(self,dicts): self.__dict__.update(dicts)#添加字典元素 if isinstance(self.__dict__,dict): print(True) # 获取字典独有的属性 print(set(dir(self.__dict__))-set(dir(self))) return self.__dict__if __name__ == '__main__': dicts={&quot;a&quot;:1, &quot;b&quot;:2, &quot;c&quot;:3} a=A() print(a.save_data(dicts))# Output:# True# {'pop', 'items', '__contains__', 'get', '__len__', '__delitem__', 'setdefault', 'values', '__iter__', 'clear', 'keys', 'update', 'popitem', '__getitem__', '__setitem__', 'fromkeys', 'copy'}# {'name': 'liming', 'a': 1, 'b': 2, 'c': 3} 可以看到，__dict__ 也提供了一个 update 方法，用于使用一个新的字典所包含的键值对来更新己有的字典。 这对于给对象的属性赋值的时候，非常 pythonic： 123456789class A(): def __init__(self,dicts): self.name=dicts[&quot;name&quot;] self.age=dicts[&quot;age&quot;] self.sex=dicts[&quot;sex&quot;] self.hobby=dicts[&quot;hobby&quot;]if __name__ == '__main__': dicts={&quot;name&quot;:&quot;lisa&quot;,&quot;age&quot;:23,&quot;sex&quot;:&quot;women&quot;,&quot;hobby&quot;:&quot;hardstyle&quot;} a=A(dicts) 想象一下如果我们传入的字典有 100 个键….如何还是这样一个一个赋值不敢想不敢想？！！ 你可以使用如下方法： 12345678class A(): def __init__(self,dicts): self.__dict__.update(dicts) print(self.__dict__)if __name__ == '__main__': dicts={&quot;name&quot;:&quot;lisa&quot;,&quot;age&quot;:23,&quot;sex&quot;:&quot;women&quot;,&quot;hobby&quot;:&quot;hardstyle&quot;} a=A(dicts) common Method这一小节我们来看几个类以及对象相关的常用函数： setattr &amp;&amp; getattr &amp;&amp; hasattr[1] &gt;&gt;&gt;&gt; hasattr() 函数 hasattr() 函数用来判断某个类实例对象是否包含指定名称的属性或方法。该函数的语法格式如下： 1hasattr(obj, name) 说明：obj 指的是某个类的实例对象，name 表示指定的属性名或方法名。同时，该函数会将判断的结果（True or False）作为返回值反馈回来。 实例演示： 123456789101112131415class Language: def __init__ (self): self.name = &quot;Python&quot; self.add = &quot;Python is a OOP Programing.&quot; def say(self): print(&quot;I am learning Python.&quot;)langs = Language()print(hasattr(langs,&quot;name&quot;))# Trueprint(hasattr(langs,&quot;add&quot;))# Trueprint(hasattr(langs,&quot;say&quot;))# True 显然，无论是属性名还是方法名，都在 hasattr() 函数的匹配范围内。 需要注意的是，我们只能通过该函数判断实例对象是否包含该名称的属性或方法，但不能精确判断，该名称代表的是属性还是方法。 [2] &gt;&gt;&gt;&gt; getattr() 函数 getattr() 函数获取某个类实例对象中指定属性的值。和 hasattr() 函数不同，该函数只会从类对象包含的所有属性中进行查找。其语法格式如下： 1getattr(obj, name[, default]) 其中，obj 表示指定的类实例对象；name 表示指定的属性名；而 default 是可选参数，用于设定该函数的默认返回值，即当函数查找失败时；如果不指定 default 参数，则程序将直接报 AttributeError 错误，反之该函数将返回 default 指定的值。 1234567891011121314151617181920class Language: def __init__ (self): self.name = &quot;Python&quot; self.add = &quot;Python is a OOP Programing.&quot; def say(self): print(&quot;I am learning Python.&quot;)langs = Language()print(getattr(langs,&quot;name&quot;))print(getattr(langs,&quot;add&quot;))print(getattr(langs,&quot;say&quot;))print(getattr(langs,&quot;display&quot;,'nodisplay'))# Output:# Python# Python is a OOP Programing.# &lt;bound method Language.say of &lt;__main__.CLanguage object at 0x000001FC2F2E3245&gt;&gt;# nodisplay 可以看到，对于类中已有的属性，getattr() 会返回它们的值，而如果该名称为方法名，则返回该方法的状态信息；反之，如果该明白不为类对象所有，要么返回默认的参数，要么程序报 AttributeError 错误。 [3] &gt;&gt;&gt;&gt; setattr() 函数 setattr() 函数的功能相对比较复杂，它最基础的功能是修改类实例对象中的属性值。其次，它还可以实现为实例对象动态添加属性或者方法。其语法格式如下： 1setattr(obj, name, value) 1）–&gt; 修改类实例对象中的属性值 实例演示： 1234567891011121314151617181920212223class Language: def __init__ (self): self.name = &quot;Python&quot; self.add = &quot;Python is a OOP Programing.&quot; def say(self): print(&quot;I am learning Python.&quot;)langs = Language()print(langs.name)print(langs.add)setattr(langs,&quot;name&quot;,&quot;Python3.X&quot;)setattr(langs,&quot;add&quot;,&quot;Python3.X is a OOP Programing.&quot;)print(langs.name)print(langs.add)# Output:# Python# Python is a OOP Programing.# Python3.X# Python3.X is a OOP Programing. 2）–&gt; 别名用法 setattr() 函数，还可以将类属性修改为一个类方法，同样也可以将类方法修改成一个类属性。 实例演示： 12345678910111213141516171819def say(): print(&quot;I am learning Python.&quot;)class Language: def __init__ (self): self.name = &quot;Python&quot; self.add = &quot;Python is a OOP Programing&quot;langs = Language()print(langs.name)print(langs.add)setattr(langs, &quot;name&quot;, say)langs.name()# Output:# Python# Python is a OOP Programing# I am learning Python. 显然，通过修改 name 属性的值为 say（全局函数），原来的 name 属性就变成了一个 name() 方法。 3）–&gt; 动态添加实例属性和方法 使用 setattr() 函数对实例对象中执行名称的属性或方法进行修改时，如果该名称查找失败，Python 解释器不会报错，而是会给该实例对象动态添加一个指定名称的属性或方法。 实例演示： 12345678910111213141516def say(): print(&quot;I am learning Python.&quot;)class Language: passlangs = Language()setattr(langs,&quot;name&quot;,&quot;Python&quot;)setattr(langs,&quot;say&quot;, say)print(langs.name)langs.say()# Output:# Python# I am learning Python. 可以看到，虽然 Language 为空类，但通过 setattr() 函数，我们为 langs 对象动态添加了一个 name 属性和一个 say() 方法。 issubclass &amp;&amp; isinstancePython 中提供了如下两个函数来进行类型检查： issubclass(cls, class_or_tuple)：检查 cls 是否为后一个类或元组包含的多个类中任意类的子类； isinstance(obj, class_or_tuple)：检查 obj 是否为后一个类或元组包含的多个类中任意类的对象。 通过使用上面两个函数，程序可以方便地先执行检查，然后才调用方法，这样可以保证程序不会出现意外情况。 类型检查实例： 123456789101112131415# 定义一个字符串hello = &quot;Hello&quot;;print('[&quot;Hello&quot; 是否是 str 类的实例?] --&gt;', isinstance(hello, str))print('[&quot;Hello&quot; 是否是 object 类的实例?] --&gt;', isinstance(hello, object))print('[ str 是否是 object 类的子类?] --&gt;', issubclass(str, object))print('[&quot;Hello&quot; 是否是 tuple 类的实例?] --&gt;', isinstance(hello, tuple))print('[ str 是否是 tuple 类的子类?] --&gt;', issubclass(str, tuple), '\\n')# 定义一个列表my_list = [2, 4]print('{ [2, 4] 是否是 list 类的实例?} --&gt;', isinstance(my_list, list))print('{ [2, 4] 是否是 object 类及其子类的实例?} --&gt;', isinstance(my_list, object))print('{ list 是否是 object 类的子类?} --&gt;', issubclass(list, object))print('{ [2, 4] 是否是 tuple 类及其子类的实例?} --&gt;', isinstance([2, 4], tuple))print('{ list 是否是 tuple 类的子类?} --&gt;', issubclass(list, tuple)) 通过上面程序可以看出，issubclass() 和 isinstance() 两个函数的用法差不多，区别只是 issubclass() 的第一个参数是类名，而 isinstance() 的第一个参数是变量，这也与两个函数的意义对应：issubclass 用于判断是否为子类，而 isinstance() 用于判断是否为该类或子类的实例。 [1] &gt;&gt;&gt;&gt; 元组参数 issubclass() 和 isinstance() 两个函数的第二个参数都可使用元组。 实例演示： 1234data = (20, 'fkit')print('[ data 是否为列表或元组? ] -&gt;', isinstance(data, (list, tuple))) # Trueprint('[ str 是否为 list 或 tuple 的 子类? ] -&gt;', issubclass(str, (list, tuple)))print('[ str 是否为 list 或 tuple 或 object 的子类? ] -&gt;', issubclass(str, (list, tuple, object))) [2] &gt;&gt;&gt;&gt; __bases__ 属性参看直接父类 Python 为所有类都提供了一个 __bases__ 属性，通过该属性可以查看该类的所有直接父类，该属性返回所有直接父类组成的元组。 实例演示： 12345678910111213class A: passclass B: passclass C(A, B): passprint('类 A 的所有父类:', A.__bases__)print('类 B 的所有父类:', B.__bases__)print('类 C 的所有父类:', C.__bases__)# 类 A 的所有父类: (&lt;class 'object'&gt;,)# 类 B 的所有父类: (&lt;class 'object'&gt;,)# 类 C 的所有父类: (&lt;class '__main__.A'&gt;, &lt;class '__main__.B'&gt;) 可以看出，如果在定义类时没有显式指定它的父类，则这些类默认的父类是 object 类。 [3] &gt;&gt;&gt;&gt; __subclasses__() 方法参看直接父类 Python 还为所有类都提供了一个 __subclasses__() 方法，通过该方法可以查看该类的所有直接子类，该方法返回该类的所有子类组成的列表。 实例演示： 1234567891011class A: passclass B: passclass C(A, B): passprint('类 A 的所有子类:', A.__subclasses__())print('类 B 的所有子类:', B.__subclasses__())# 类 A 的所有子类: [&lt;class '__main__.C'&gt;]# 类 B 的所有子类: [&lt;class '__main__.C'&gt;] Method: __call____call__ 是 Python 类中一个非常特殊的实例方法。功能类似于在类中重载 () 运算符，使得类实例对象可以像调用普通函数那样，以 对象名() 的形式使用。 举个例子： 123456789class Language: # 定义__call__方法 def __call__(self,name,add): print(&quot;调用__call__()方法&quot;, name, add) langs = Language()langs(&quot;Python&quot;, &quot;Python is a OOP Programing.&quot;)# 调用__call__()方法 Python Python is a OOP Programing. 可以看到，通过在 Language 类中实现 __call__() 方法，使的 langs 实例对象变为了可调用对象。 Python 中，凡是可以将 () 直接应用到自身并执行，都称为可调用对象。可调用对象包括自定义的函数、Python 内置函数以及本节所讲的类实例对象。 对于可调用对象，实际上 名称() 可以理解为是 名称.__call__() 的简写。如下： 12langs.__call__(&quot;Python&quot;, &quot;Python is a OOP Programing.&quot;)# 调用__call__()方法 Python Python is a OOP Programing. 再来看一个自定义函数的例子，例如： 1234567def say(): print(&quot;Python is a OOP Programing.&quot;)say()say.__call__()# Python is a OOP Programing.# Python is a OOP Programing. 不仅如此，类中的实例方法也有以上 2 种调用方式，这里不再举例，有兴趣的读者可自行编写代码尝试。 用 __call__() 弥补 hasattr() 函数的短板 &gt;&gt;&gt;&gt; 前面我们提到，hasattr() 函数查找类的实例对象中是否包含指定名称的属性或者方法，但该函数有一个缺陷，即它无法判断该指定的名称，到底是类属性还是类方法。 要解决这个问题，我们可以借助可调用对象的概念。要知道，类实例对象包含的方法，其实也属于可调用对象，但类属性却不是。举个例子： 1234567891011121314151617class CLanguage: def __init__ (self): self.name = &quot;Python&quot; self.add = &quot;Python is a OOP Programing.&quot; def say(self): print(&quot;I am learning Python.&quot;)clangs = CLanguage()if hasattr(clangs,&quot;name&quot;): print(hasattr(clangs.name,&quot;__call__&quot;))if hasattr(clangs,&quot;say&quot;): print(hasattr(clangs.say,&quot;__call__&quot;))# Output:# False# True 可以看到，由于 name 是类属性，它没有以 __call__ 为名的 __call__() 方法；而 say 是类方法，它是可调用对象，因此它有 __call__() 方法。 Python 中的运算符重载前面我们学习了各种序列类型，每个类型都有其独特的操作方法。例如列表类型支持直接做加法操作实现添加元素的功能，字符串类型支持直接做加法实现字符串的拼接功能。 也就是说，同样的运算符对于不同序列类型的意义是不一样的，这是怎么做到的呢？ 事实上，每种序列类型都是 Python 的一个类，例如列表是 list 类，字典是 dict 类等，这些序列类的内部使用了一个叫作 重载运算符 的技术来实现不同运算符所对应的操作。 所谓重载运算符，是指通过重写 Python 内置运算符对应的方法来实现的。这样当类对象在进行运算符操作时，系统就会调用类中相应重写方法来处理。这些方法都是以双下划线开头和结尾的，类似于 __X__ 的形式。 那么，Python 类支持对哪些内置方法进行重载呢？如下表列出来常用的可重载的运算符，以及各自的含义： 重载运算符 含义 __new__ 创建类，在 __init__ 之前创建对象 __init__ 类的构造函数，其功能是创建类对象时做初始化工作。 __del__ 析构函数，其功能是销毁对象时进行回收资源的操作 __add__ 加法运算符 +，当类对象 X 做例如 X+Y 或者 X+=Y 等操作，内部会调用此方法。但如果类中对 __iadd__ 方法进行了重载，则类对象 X 在做 X+=Y 类似操作时，会优先选择调用 __iadd__ 方法。 __radd__ 当类对象 X 做类似 Y+X 的运算时，会调用此方法。 __iadd__ 重载 += 运算符，也就是说，当类对象 X 做类似 X+=Y 的操作时，会调用此方法。 __or__ “或”运算符 __repr__，__str__ 格式转换方法，分别对应函数 repr(X)、str(X) __call__ 函数调用，类似于 X(*args, **kwargs) 语句 __getattr__ 点号运算，用来获取类属性 __setattr__ 属性赋值语句，类似于 X.any=value __delattr__ 删除属性，类似于 del X.any __getattribute__ 获取属性，类似于 X.any __getitem__ 索引运算，类似于 X[key]，X[i:j] __setitem__ 索引赋值语句，类似于 X[key], X[i:j]=sequence __delitem__ 索引和分片删除 __get__, __set__, __delete__ 描述符属性，类似于 X.attr，X.attr=value，del X.attr __len__ 计算长度，类似于 len(X) __lt__，__gt__，__le__，__ge__，__eq__，__ne__ 比较，分别对应于 &lt;、&gt;、&lt;=、&gt;=、=、!= 运算符。 __iter__，__next__ 迭代环境下，生成迭代器与取下一条，类似于 I=iter(X) 和 next() __contains__ 成员关系测试，类似于 item in X __index__ 整数值，类似于 hex(X)，bin(X)，oct(X) __enter__，__exit__ 在对类对象执行类似 with obj as var 的操作之前，会先调用 __enter__ 方法，其结果会传给 var；在最终结束该操作之前，会调用 __exit__ 方法（常用于做一些清理、扫尾的工作） 实例演示： [1] &gt;&gt;&gt;&gt; 构造函数和析构函数：__init__ 和 __del__ 重载 主要作用是进行对象的创建和回收，当实例创建时，就会调用 __init__ 构造方法。当实例对象被收回时，析构函数 __del__ 会自动执行。 123456789class Human: def __init__(self, name): self.name = name print(&quot;__init__&quot;, self.name) def __del__(self): print(&quot;__del__&quot;)test = Human(&quot;zhang_san&quot;)test = &quot;del&quot; [2] &gt;&gt;&gt;&gt; 加减运算： __add__ 和 __sub__ 重载 重载这两个方法就可以在普通的对象上添加＋－运算符操作。下面的代码演示了如何使用 ＋ &amp;&amp; － 运算符: 1234567891011class Computer: def __init__(self, value): self.value = value def __add__(self, other): return self.value + other def __sub__(self, other): return self.value - othertest = Computer(10)print(test + 2)print(test - 5) 如果将代码中的 __sub__ 方法去掉，再调用减号运算符就会出错。 [3] &gt;&gt;&gt;&gt; 对象的字符串表达形式： __repr__ 和 __str__ 重载 都是用来表示对象的字符串表达形式： print()、str() 方法会调用到 __str__ 方法 print()、str() 和 repr() 方法会调用 __repr__ 方法。 从下面的例子可以看出，当两个方法同时定义时，Python 会优先搜索并调用 __str__ 方法。 1234567891011121314class Str: def __str__(self): return &quot;__str__ called&quot; def __repr__(self): return &quot;__repr__ called&quot;str_test = Str()print(str_test)# __str__ calledprint(repr(str_test))# __repr__ calledprint(str(str_test))# __str__ called [4] &gt;&gt;&gt;&gt; 索引取值和赋值： __getitem__ 和 __setitem__ 重载 通过实现这两个方法，可以通过诸如 X[i] 的形式对对象进行取值和赋值，还可以对对象使用切片操作。 1234567891011121314151617class Indexer: data = [1, 2, 3, 4, 5] def __getitem__(self, index): return Indexer.data[index] def __setitem__(self, index, value): Indexer.data[index] = value print(Indexer.data)test = Indexer()print(test[1])# 2print(test[0:3])# [1, 2, 3]test[3] = 6# [1, 2, 3, 6, 5] [5] &gt;&gt;&gt;&gt; 设置和访问属性： __getattr__ 和 __setattr__ 重载 我们可以通过重载 __getattr__ 和 __setattr__ 来拦截对对象成员的访问。 __getattr__ 在访问对象中不存在的成员时会自动调用。__setattr__ 方法用于在初始化对象成员的时候调用，即在设置 __dict__ 的 item 时就会调用 __setattr__ 方法。具体例子如下： 1234567891011121314151617181920212223242526272829303132class Test: def __init__(self, ax, bx): self.ax = ax self.bx = bx def foo(self): print(self.__dict__) def __getattr__(self, name): if name in self.__dict__.keys(): return self.__dict__[name] print(&quot;__getattr__ called&quot;) def __setattr__(self, name, value): print(&quot;__setattr__ called&quot;) self.__dict__[name] = value test = Test(1, 2)test.foo()# __setattr__ called# __setattr__ called# {'ax': 1, 'bx': 2}print(test.c)# __getattr__ called# Nonetest.ax = 4test.foo()# __setattr__ called# {'ax': 4, 'bx': 2} 从结果可以看出，访问不存在的实例变量 c 时会调用 __getattr__ 方法；当 __init__ 被调用的时候，赋值运算也会调用 __setattr__ 方法。 [6] &gt;&gt;&gt;&gt; 迭代器对象: __iter__ 和 __next__ 重载 前面我们知道，Python 中的迭代，可以直接通过重载 __getitem__ 方法来实现，看下面的例子: 1234567891011121314class Indexer: data = [1, 2, 3, 4, 5] def __getitem__(self, index): return Indexer.data[index]test = Indexer()for item in test: print(item)# 1# 2# 3# 4# 5 通过上面的方法是可以实现迭代，但并不是最好的方式。 事实上，Python 中的迭代操作会优先尝试调用 __iter__ 方法，再尝试 __getitem__。迭代环境（for in）是通过 iter() 去尝试寻找 __iter__ 方法来实现，而这种方法返回一个迭代器对象。如果 __iter__ 方法已经提供，Python 会重复调用迭代器对象的 next() 方法，直到发生 StopIteration 异常；如果没有找到 __iter__，Python 才会尝试使用 __getitem__ 机制。下面看一下迭代器的例子: 123456789101112131415161718192021222324252627282930313233343536373839404142434445class Next(): def __init__(self, data=1): self.data = data def __iter__(self): print(&quot;__iter__ called&quot;) return self def __next__(self): print(&quot;__next__ called&quot;) if self.data &gt;5: raise StopIteration else: self.data += 1 return self.datafor inx in Next(3): print(inx)print(&quot;---------&quot;)# __iter__ called# __next__ called# 4# __next__ called# 5# __next__ called# 6# __next__ called# ---------n = Next(3)i = iter(n)while True: try: print(next(i)) except Exception as e: break# __iter__ called# __next__ called# 4# __next__ called# 5# __next__ called# 6# __next__ called 可见实现了 __iter__ 和 __next__ 方法后，可以通过 for in 的方式迭代遍历对象，也可以通过 iter() 和 next() 方法迭代遍历对象。 [7] &gt;&gt;&gt;&gt; 自定义序列示例 基于前面介绍的方法重载，我们来实现一个自定义的序列类。 下面列出了和自定义序列类有关的几个特殊方法： __len__(self) 返回序列类中存储元素的个数。 __contains__(self, value) 判断当前序列中是否包含 value 这个指定元素。 __getitem__(self, key) 通过指定的 key（键），返回对应的 value（值）。 __setitem__(self, key, value) 修改指定 key（键）对应的 value（值）。 __delitem__(self, key) 删除指定键值对。 重写原则 &gt;&gt;&gt;&gt; 1）在上表中的这些特殊方法进行重写时，在实现其基础功能的基础上，还可以根据实际情况，对各个方法的具体实现进行适当调整。 以 __setitem__() 方法为例，当在序列中未找到指定 key 的情况下，该方法可以报错，当然也可以将此键值对添加到当前序列中。 2）在实现自定义序列类时，并不是必须重写表中全部的特殊方法。 例如如果该自定义序列是一个不可变序列（即序列中的元素不能做修改），则无需重写 __setitem__() 和 __delitem__() 方法；反之，如果该自定义序列是一个可变序列，可以重写以上五个特殊方法。 下面实现一个比较简单的序列类（字典类），其特点是只能存储 int 类型的元素： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class IntDict: def __init__(self): # 定义用于存储数据的字典 self.__data = {} def __len__(self): return len(list(self.__data.values())) def __getitem__(self, key): if key in self.__data: return self.__data[key] return None def __setitem__(self, key, value): if not isinstance(value, int): raise TypeError(&quot;Not Int Type&quot;) self.__data[key] = value def __delitem__(self, key): if key in self.__data: del self.__data[key]dic = IntDict()# 输出序列中元素的个数，调用 __len__() 方法print(len(dic))# 向序列中添加元素，调用 __setitem__() 方法dic['a'] = 1dic['b'] = 2print(len(dic))dic['a'] = 3dic['c'] = 4print(dic['a'])# 删除指定元素，调用 __delitem__() 方法del dic['a']print(dic['a'])print(len(dic))# Output:# 0# 2# 3# None# 2 Python 中的迭代器我们已经知道，字符串（str）、列表（list）、元组（tuple）、字典（dict）、集合（set）等序列容器有一个共同的特性：它们都支持使用 for in 循环遍历存储的元素。 可迭代对象（Iterable）事实上，像字符串（str）、列表（list）、元组（tuple）、字典（dict）、集合（set）这些可以直接作用于 for in 循环的容器对象，都可以统称为可迭代对象（Iterable object）。 关于 Python 中的可迭代对象更多说明请参见：Python 中的可迭代对象（Iterable）。 我们可以通过 collections 模块中的 Iterable 类型来判断一个对象是否是可迭代对象，具体判断方法如下： 1234567891011&gt;&gt;&gt; from collections.abc import Iterable&gt;&gt;&gt; isinstance([], Iterable)True&gt;&gt;&gt; isinstance({}, Iterable)True&gt;&gt;&gt; isinstance('abc', Iterable)True&gt;&gt;&gt; isinstance((x for x in range(10)), Iterable)True&gt;&gt;&gt; isinstance(100, Iterable)False 那么，可迭代对象（Iterable）和迭代器（Iterator）是否是一回事儿？答案肯定是不是的，不然废话这么多干嘛？！！ 何为迭代器（Iterator）从字面来理解，迭代器指的是：支持迭代的容器。这里的容器可以是列表、元组等 Python 内置的基础容器，也可以是用户自定义的容器类对象，只要该容器支持迭代即可。 你可能会问，既然都是支持迭代的容器，那么迭代器（Iterator）和可迭代对象（Iterable）的差别在哪里？？？ [1] &gt;&gt;&gt;&gt; 迭代器特性 更确切的说，迭代器（Iterator） 具有如下特性： 支持迭代的（for in 遍历），可以记住遍历位置的容器； 迭代器对象从容器的第一个元素开始访问，直到所有的元素被访问完结束，并且迭代器访问只能往前无法后退； 迭代器具有两个基本的方法：iter() &amp;&amp; next()； 迭代器都是可迭代对象。 上述列出的这些特性，都可以在下文给出的迭代器中表现出来。 [2] &gt;&gt;&gt;&gt; 判断对象是否属于迭代器 那么，如何判断一个对象是否属于 Iterator呢？可以借助 connections 模块中的 Iterator： 12345678910from collections.abc import Iteratorprint(isinstance((x for x in range(10)), Iterator))print(isinstance([], Iterator))print(isinstance({}, Iterator))print(isinstance('abc', Iterator))# True# False# False# False 可以看到，列表、字典、以及字符串等确实不是迭代器。并且 list、dict、str 虽然是 Iterable，却不是 Iterator（不存在 next() 函数）。 [3] &gt;&gt;&gt;&gt; next &amp;&amp; iter 方法说明 1）–&gt; iter() iter() 函数，可以将 list、dict、str 等 Iterable 对象变为 Iterator，从而创建迭代器： 123456&gt;&gt;&gt; isinstance(iter([]), Iterator)True&gt;&gt;&gt; isinstance(iter('abc'), Iterator)True&gt;&gt;&gt; isinstance(iter({}), Iterator)True 2）–&gt; next() 迭代器容器对象可以被 next() 函数调用，并不断返回下一个元素值。元素访问完后，继续调用 next() 函数会产生 StopIteration Error。 代码演示： 1234567891011121314151617181920212223list=[1,2,3,4]it = iter(list) # 创建迭代器对象 while True: try: print (next(it)) except StopIteration: print(&quot;Iterator Occur StopIteration Error&quot;) break# 遍历后无法重新遍历出元素（只能向前访问）for item in it: print(item)# 这里会报错：StopIteration，表示容器中元素已经遍历完了print(next(it))# Output:# 1# 2# 3# 4# Iterator Occur StopIteration Error [4] &gt;&gt;&gt;&gt; 迭代器对象打印 注意，直接打印迭代器对象是无法查看迭代器容器中元素值的，你需要根据容器数据结构使用 Python 内置的 list() &amp;&amp; tuple() &amp;&amp; dict() 等来将其转化成可打印的形式： 12345678list=[1,2,3,4]it = iter(list) # 创建迭代器对象print(it)print(tuple(it))# &lt;list_iterator object at 0x0000017949EA36D8&gt;# (1, 2, 3, 4) 如何定义迭代器容器这里给出两种迭代器的实现思路： 运算符重载方法：通过重写类的 __next__() &amp;&amp; __iter__() 方法实现自定义迭代器类； 内置函数方法：通过内置的 iter() 迭代器函数实现迭代器。 [1] &gt;&gt;&gt;&gt; 自定义迭代器类 如果要自定义实现一个迭代器，则类中必须实现如下两个方法： __next__(self)：返回容器的下一个元素； __iter__(self)：该方法返回一个迭代器（iterator）对象，该对象实现了 __next__() 方法并通过 StopIteration 异常来标识迭代的完成。 事实上，在运算符重载中已经实现过一个简单的迭代器了，推荐返回重新认识一下。 例如，下面程序自定义了一个简易的列表容器迭代器，支持迭代访问（对照迭代器特性进行学习）： 1234567891011121314151617181920212223242526272829303132333435363738class listDemo: def __init__(self): self.__date=[] # 用于存储迭代器容器元素 self.__step = 0 # 记录迭代器遍历位置，用于 StopIteration 异常判断 def __next__(self): if self.__step &lt;= 0: raise StopIteration self.__step -= 1 # 返回下一个元素 return self.__date[self.__step] def __iter__(self): # 实例对象本身就是迭代器对象，因此直接返回 self 即可 return self # 用于向容器中添加元素 def __setitem__(self,key,value): self.__date.insert(key,value) self.__step += 1mylist = listDemo()mylist[0] = 1mylist[1] = 2# 判断是否为迭代器：from collections.abc import Iteratorprint(isinstance(mylist, Iterator))# Truefor i in mylist: print (i)# 2# __next__ called# 1# __next__ called# __next__ called StopIteration 说明 &gt;&gt;&gt;&gt; 迭代环境下，StopIteration 异常用于标识迭代的完成，防止出现无限循环的情况。 上面程序遍历（for in）时，会自动调用 __next__() 方法来返回迭代器容器中的下个元素直至发生 StopIteration，故需要在 __next__() 方法中设置在完成指定循环条件后触发 StopIteration 异常来结束迭代，这是必要的。 [2] &gt;&gt;&gt;&gt; 内置 iter() 迭代器函数 Python 内置的 iter() 函数可以将对象转化为一个迭代器（返回一个迭代器对象），该函数的语法格式如下： 1iter(obj[, sentinel]) 其中，obj 必须是一个可迭代的容器对象，而 sentinel 作为可选参数，如果使用此参数，要求 obj 必须是一个可调用对象，具体功能后面会讲。 关于可调用对象，指的是该类的实例对象可以像函数那样，直接以 对象名() 的形式被使用。通过在类中添加 __call__() 方法，就可以将该类的实例对象编程为可调用对象（参见博文第一章节相关内容）。 iter() 函数的两种使用形式 &gt;&gt;&gt;&gt; 1）–&gt; iter(obj) 我们常用的是仅有第一个参数的 iter() 函数，即通过传入一个可迭代对象，iter() 函数会返回一个迭代器对象。 你可以通过调用该迭代器中的 __next__() 方法即可实现迭代（或者 for in）。例如： 1234567891011121314151617181920212223242526272829mylist = [1, 2, 3]# 将可迭代的列表转换为迭代器myIter = iter(mylist)print(type(mylist))print(type(myIter))# &lt;class 'list'&gt;# &lt;class 'list_iterator'&gt;# 依次获取迭代器的下一个元素print(myIter.__next__())print(myIter.__next__())print(myIter.__next__())# 1# 2# 3# 通过 for in 进行遍历：for item in iter(mylist): print(item, end='-&gt;')# 1-&gt;2-&gt;3-&gt;# 迭代器访问结束后，继续访问会产生 StopIteration 异常print(myIter.__next__())# Traceback (most recent call last):# File &quot;.code.tio&quot;, line 7, in # print(item, end='-&gt;')# StopIteration 可以看到，当迭代完存储的所有元素之后，如果继续迭代，则 __next__() 方法会抛出 StopIteration 异常。 另外，你也可以使用 next() 内置函数来迭代，即 next(myIter)，和 __next__() 方法是完全一样的。 2）–&gt; iter(obj[, sentinel]) 如果同时使用 iter() 函数中的两个参数，则要求第一个 obj 参数必须传入可调用对象（可以不支持迭代）。 这样，当使用 iter() 函数返回的迭代器对象调用 __next__() 方法时，它会通过执行 obj() 调用 __call__() 方法来返回元素。 如果此时，__call__() 方法的返回值和第 2 个参数值相同，则输出 StopInteration 异常；反之，则输出 __call__() 方法的返回值。 例如，修改 listDemo 类如下所示： 123456789101112131415161718192021222324252627282930313233class listDemo: def __init__(self): self.__date=[] self.__step = 0 def __setitem__(self,key,value): self.__date.insert(key,value) self.__step += 1 # 使该类实例对象成为可调用对象 def __call__(self): self.__step -= 1 return self.__date[self.__step] mylist = listDemo()mylist[0]=1mylist[1]=2mylist[2]=3# 将 mylist 变为迭代器test = iter(mylist, 4)print(test)# &lt;callable_iterator object at 0x000001F22F8FC860&gt;print(next(test)) # 实际调用 __call__() 方法print(next(test))print(next(test))# 3# 2# 1print(next(test))# StopIteration Error 3）–&gt; iter(obj[, sentinel]) 实用场景 iter(obj[, sentinel]) 形式常用来构建块读取器。 例如，从二进制数据库文件中读取固定宽度的块，直至到达文件的末尾: 12345from functools import partialwith open('mydata.db', 'rb') as f: for block in iter(partial(f.read, 64), b''): process_block(block) [3] &gt;&gt;&gt;&gt; 自定义字典迭代器 Demo 运算符重载小节最后，我们实现了一个自定义字典类序列，该字典是一个可迭代对象，但该字典对象并不支持良好的迭代（死循环），这里我们来将其升级为一个良好的迭代器。 尽管上面的自定义字典类序列中重写了 __getitem__ 方法，但仍然是不支持良好迭代的，你可以尝试下~~~ 这里，基于上述知识，我们来完善一下上一小节中的自定义字典序列： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172class IntDict: def __init__(self): # 定义用于存储数据的字典 self.__data = {} self.__step = 0 self.__key_record = [] def __len__(self): return len(list(self.__data.values())) def __getitem__(self, key): if key in self.__data: return self.__data[key] return None def __setitem__(self, key, value): if not isinstance(value, int): raise TypeError(&quot;Not Int Type&quot;) self.__data[key] = value if key not in self.__key_record: self.__key_record.append(key) self.__step += 1 def __delitem__(self, key): if key in self.__data: del self.__data[key] del self.__key_record[self.__key_record.index(key)] self.__step -= 1 def __iter__(self): return self def __next__(self): if self.__step &lt;= 0: raise StopIteration self.__step -= 1 return (self.__key_record[self.__step], self.__data[self.__key_record[self.__step]])dic = IntDict()# 输出序列中元素的个数，调用 __len__() 方法print(len(dic))# 0# 判断是否为迭代器：from collections.abc import Iteratorprint(isinstance(dic, Iterator))# True# 向序列中添加元素，调用 __setitem__() 方法dic['Google'] = 1dic['Edge'] = 2print(len(dic))# 2dic['Firfox'] = 3dic['Google'] = 4print(dic['Google'])# 4# 删除指定元素，调用 __delitem__() 方法del dic['Google']print(dic['Google'])print(len(dic))# None# 2# 字典遍历，调用 __next__() 方法for key,value in dic: print(key, value)# Firfox 3# Edge 2 enumerate 迭代器enumerate 方法可以用来实现下标循环 &gt;&gt;&gt;&gt; 很多情况下，我们想要对 list 或 tuple 实现类似 Java 那样的下标循环怎么办？ Python 中内置的 enumerate 函数可以把一个 list （tuple）变成 index-element（索引-元素）对，这样就可以在for循环中同时迭代索引和元素本身。 先来给出 enumerate 内置函数的语法格式： 1enumerate(iterable, start=0) 其中，iterable 表示必须是可迭代的对象，start 表示下标开始的序号，该函数返回一个可迭代的 enumerate 对象（非枚举对象），index-element 以元组形式保存在迭代器中。 来看一个示例： 12345678910111213141516171819202122232425262728293031323334seasons = ['Spring', 'Summer', 'Fall', 'Winter']seasons_enum_1 = enumerate(seasons)# 判断是否为枚举对象from enum import Enumtype(Enum)print(isinstance(seasons_enum_1, Enum))# False# 判断是否为迭代器：from collections.abc import Iteratorprint(isinstance(seasons_enum_1, Iterator))# Truefor index, elem in seasons_enum_1: print(index, elem)print(&quot;-----------------&quot;)seasons_enum_2 = enumerate(seasons, 3)for index, elem in seasons_enum_2: print(index, elem)# Output:# &lt;enumerate object at 0x000002B6C69AA438&gt;# False# True# 0 Spring# 1 Summer# 2 Fall# 3 Winter# -----------------# 3 Spring# 4 Summer# 5 Fall# 6 Winter 你无法直接查看可迭代的 enumerate 枚举对象中的 index-element 信息： 12print(seasons_enum)&lt;enumerate object at 0x0000021C934C4CF0&gt; 但我们可以通过使用 Python 内置的 list() &amp;&amp; tuple() &amp;&amp; dict() 来将其转化成可打印的形式： 12345678910111213seasons = ['Spring', 'Summer', 'Fall', 'Winter']seasons_list = list(enumerate(seasons))print(seasons_list)# [(0, 'Spring'), (1, 'Summer'), (2, 'Fall'), (3, 'Winter')]seasons_tup = tuple(enumerate(seasons))print(seasons_tup)# ((0, 'Spring'), (1, 'Summer'), (2, 'Fall'), (3, 'Winter'))seasons_dict = dict(enumerate(seasons))print(seasons_dict)# {0: 'Spring', 1: 'Summer', 2: 'Fall', 3: 'Winter'} 这样，你就可以以 List &amp;&amp; Tuple &amp;&amp; Dict 的形式进行枚举对象数据的访问了。 深入解读迭代器我们知道，迭代器的主要功能就是进行容器元素的迭代（遍历），有了上面的知识，我们就可以重新认识一下 for 循环了： For 循环解读事实上，Python 中的迭代操作会优先尝试调用 __iter__ 方法，再尝试 __getitem__。 迭代环境（for ... in ... 或者 next(Iterator)）是通过 iter() 去尝试优先寻找 __iter__ 方法来实现，而这种方法返回一个迭代器对象。 如果 __iter__ 方法已经提供，Python 会重复调用迭代器对象的 next() 方法，直到发生 StopIteration 异常；如果没有找到 __iter__，Python 才会尝试使用 __getitem__ 机制。 示例演示: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061class listDemo: def __init__(self): self.__date=[] # 用于存储迭代器容器元素 self.__step = 0 # 记录迭代器遍历位置，用于 StopIteration 异常判断 def __next__(self): print(&quot;__next__ called&quot;) if self.__step &lt;= 0: raise StopIteration self.__step -= 1 # 返回下一个元素 return self.__date[self.__step] def __iter__(self): print(&quot;__iter__ called&quot;) # 实例对象本身就是迭代器对象，因此直接返回 self 即可 return self # 用于向容器中添加元素 def __setitem__(self,key,value): self.__date.insert(key,value) self.__step += 1mylist1 = listDemo()mylist1[0] = 1mylist1[1] = 2mylist1[2] = 3for item in mylist1: print(item)print(&quot;----------&quot;)mylist2 = listDemo()mylist2[0] = 4mylist2[1] = 5mylist2[2] = 6iter_list = iter(mylist2)while True: try: print(next(iter_list)) except Exception as e: break# Output:# __iter__ called# __next__ called# 3# __next__ called# 2# __next__ called# 1# __next__ called# ----------# __iter__ called# __next__ called# 6# __next__ called# 5# __next__ called# 4# __next__ called 可以看到，使用 for ... in ... 循环方式进行遍历和在 while 循环内使用 next(Iterator) 是等价的。 因此，对于迭代器容器中的元素遍历，支持三种方式： for … in …； while 循环结构内使用 next(Iterator) 或者 Iterator.__next__()，捕获 StopIteration 异常后停止； 借助 Python 内置的 list() &amp;&amp; tuple() &amp;&amp; dict() &amp;&amp; set() 等转化为相应基本数据类型，然后进行遍历。 关于 __getitem__ 的迭代（循环）样例这里就不重复给出了，你可以参见第一个版本的自定义字典序列 Demo，或者参见运算符重载部分关于迭代器的重载部分。 Iterator 数据流你可能还对 list、dict、str等序列容器不是 Iterator 感到很困惑。 事实上，Python 的 Iterator 对象表示的是一个数据流，Iterator 对象可以被 next() 函数调用并不断返回下一个数据，直到没有数据时抛出 StopIteration 错误。 这也就意味着，在 Iterator 数据流向前迭代过程中，可以看作是容器内数据流出的过程，表现为当前对象无法再通过迭代方式获取数据了（已经流完了）。 Iterator 数据流 可以看作是惰性的计算序列 &gt;&gt;&gt;&gt; 可以把这个数据流看做是一个有序序列，但我们却不能提前知道序列的长度，只能不断通过 next() 函数实现按需计算下一个数据，所以 Iterator 的计算是惰性的，只有在需要返回下一个数据时它才会计算。 Iterator 甚至可以表示一个无限大的数据流，例如全体自然数。而使用 list 是永远不可能存储全体自然数的。 Python 中的生成器上一小节我们解读了什么是迭代器。事实上，生成器本质上也是迭代器，不过它比较特殊。 那么，相较于一般的迭代器，生成器特殊在哪里？？？ 生成器（Generator）特性参看前面我们创建的任意一个迭代器容器，你会发现，在使用该容器迭代一组数据时，必须事先将所有数据存储到容器中，才能开始迭代。而生成器（generator）却不同，它可以实现在迭代的同时生成元素（边迭代边计算元素）。 也就是说，对于某些特定的可迭代容器（如果其内部的元素是可以用某种算法推算得到的），将其编码成一个生成器对象，该生成器不会一次性生成容器中的所有元素，而是什么时候需要，才什么时候生成。 可能有同学就要问了，这样的机制什么用处呢？？？ 想象一个容器内部元素可以用某种算法推算得到的场景 &gt;&gt;&gt;&gt; 例如前面通过列表推导式（解析式）直接创建一个列表，由于内存限制，列表容量肯定是有限的。假设要创建一个包含 10 万个元素的列表，这不仅占用很大的存储空间，如果程序中当前仅仅访问前面部分的元素，那后面绝大多数元素占用的空间都白白浪费了，这时生成器这种边迭代边推算的机制就会非常有用。 退一步来讲，就算容器中元素数量较少时，节省的内存有限，但使用生成器仍可以帮助我们获得一个方便操作的迭代器，这也是有益的。 使用生成器需要注意以下几点 &gt;&gt;&gt;&gt; 生成器适用于容器内部元素可以用某种算法推算得到的场景； 更适用于推算算法比较复杂时，用类似推导式（例如列表推导式）的 for 循环无法实现的场景； 生成器是边迭代边计算元素的，元素什么时候需要，什么时候生成，用于节省内存空间； 生成器是一个特殊的迭代器，支持迭代器中的相关使用规则。 并且，除了具有如上特性，生成器的创建方式也比迭代器简单很多。 生成器创建Python 中提供了两种生成器的创建方式：1）带 yield 关键字的生成器函数；2）元组推导式（… for … in …）。 yield 关键字使用带 yield 关键字的生成器函数来创建生成器分为以下两步： 定义一个以 yield 关键字标识返回值 的函数； 调用刚刚创建的函数，即可创建一个生成器。 Get Start &gt;&gt;&gt;&gt; 比如，构建一个著名的斐波那契数列（Fibonacci）容器，除第一个和第二个元素外，任意一个数都可由前两个数相加得到。类似于： 11, 1, 2, 3, 5, 8, 13, 21, 34, ... 斐波拉契数列用列表推导式写不出来（推导算法较复杂），但是，用函数把它打印出来却很容易： 12345678910111213def fibonc(max): idx = 0 a, b = 0, 1 while idx &lt; max: print(b) a, b = (b, a + b) idx += 1fibonc(4)# 1# 1# 2# 3 我们知道，斐波那契数列（Fibonacci）容器构建是符合生成器使用条件的，事实上上面的函数和 generator 仅一步之遥，即将 print(b) 打印函数改为 yield b 作为返回就可以了： 12345678910111213141516def fibonc(max): print(&quot; call fibonc generator &quot;) idx = 0 a, b = 0, 1 while idx &lt; max: yield b a, b = (b, a + b) idx += 1fi = fibonc(4)print(fi)# &lt;generator object fibonc at 0x0000012D76D41258&gt;from collections.abc import Iteratorprint(isinstance(fi, Iterator))# True 这样我们就成功创建了一个 fi 生成器对象。显然，和普通函数不同，fibonc(max) 函数的返回值用的是 yield 关键字，而不是 return 关键字，此类函数又称为生成器函数（generator function）。 注意，即便调用生成器函数，Python 解释器也不会执行函数中的代码，它只会返回一个生成器（对象）。并且，和 return 作为返回值关键字相比，yield 除了可以返回相应的值，还有一个更重要的功能，即每当程序执行完该语句时，程序就会暂停执行。 [1] &gt;&gt;&gt;&gt; 生成器元素访问 生成器对象创建好之后，如何使用生成器中的元素数据呢？ 即，要想使生成器函数得以执行，或者想使执行完 yield 语句立即暂停的程序得以继续执行，怎么办？ 同理于迭代器，有以下三种方式： while 循环结构内使用 next(Iterator) 或者 Iterator.__next__() 遍历生成器，捕获 StopIteration 异常后停止； 通过 for 循环遍历生成器； 借助 Python 内置的 list() &amp;&amp; tuple() &amp;&amp; dict() &amp;&amp; set() 等转化为相应基本数据类型，然后进行遍历。 示例如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748def fibonc(max): print(&quot; call fibonc generator &quot;) idx = 0 a, b = 0, 1 while idx &lt; max: yield b a, b = (b, a + b) idx += 1fi = fibonc(4)print(fi)# &lt;generator object fibonc at 0x000002564CEE2BF8&gt;from collections.abc import Iteratorprint(isinstance(fi, Iterator))# True# 调用 next() or __next__ 内置函数while True: try: print(next(fi)) # print(fi.__next__()) except Exception as e: break# call fibonc generator# 1# 1# 2# 3# 通过 for 循环遍历生成器fi1 = fibonc(4)for item in fi1: print(item)# call fibonc generator# 1# 1# 2# 3# 通过 list() 转化fi2 = fibonc(4)for item in list(fi2): print(item)# call fibonc generator# 1# 1# 2# 3 [2] &gt;&gt;&gt;&gt; 生成器执行方式 给出一个例子来看生成器内部程序的执行机制： 1234567891011121314151617181920212223242526272829303132def fibonc(max): print(&quot;Begin to run&quot;) idx = 0 a, b = 0, 1 while idx &lt; max: yield b a, b = (b, a + b) idx += 1 print(&quot;Continue to run&quot;) print(&quot;Run End&quot;)fi = fibonc(4)# 调用 next() or __next__ 内置函数print(next(fi))# Begin to run# 1print(fi.__next__())# Continue to run# 1# 通过 for 循环遍历生成器for item in fi: print(item)# Continue to run# 2# Continue to run# 3# Continue to run# Run End 1）首先，在创建有 fi 生成器的前提下，通过其调用 next() 内置函数，会使 Python 解释器开始执行 fibonc() 生成器函数中的代码，因此会输出 Begin to run，程序会一直执行到 yield b，而此时的 b==1，因此 Python 解释器输出 1。由于受到 yield 的影响，程序会在此处暂停。 2）然后，我们使用 fi 生成器调用 __next__() 方法，该方法的作用和 next() 函数完全相同（事实上，next() 函数的底层执行的也是 __next__() 方法），它会使得程序继续执行，即输出 Continue to run，程序又会执行到 yield b，此时 b==1，因此输出 1，然后程序暂停。 3）最后，我们使用 for 循环遍历 fi 生成器，之所以能这么做，是因为 for 循环底层会不断地调用 next() 函数，使暂停的程序继续执行，因此会输出后续的结果。 注意，在 Python 2.x 版本中不能使用 __next__() 方法，可以使用 next() 内置函数，另外生成器还有 next() 方法（即以 num.next() 的方式调用）。 元组推导式另外对于不复杂的算法推算场景，即容器中元素可以使用推导式（解析式）生成。 Python 中支持一个很简单的 generator 创建方法就是，使用元组推导式，其返回一个生成器对象： 12345678910gen = (x for x in range(4))print(gen)# &lt;generator object &lt;genexpr&gt; at 0x000002987E724F68&gt;for item in gen: print(item)# 0# 1# 2# 3 关于 gen 中元素遍历方式，请参见上一小节提供的三种方式。 素数示例一个生成器函数中是可以包含多个 yield 关键字作为返回的，这和 return 关键字是类似的。我们将以实现一个以素数作为元素的生成器容器进行展示。 我们知道，素数就是质数，是一个大于 1 的自然数，且除了 1 和它本身外，不再有其他的因数。 素数都有哪些？ &gt;&gt;&gt;&gt; 计算素数的一个方法是埃氏筛法，它的算法理解起来非常简单： 首先，列出从 2 开始的所有自然数，构造一个序列： 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, … 取序列的第一个数 2，它一定是素数，然后用 2 把序列的 2 的倍数筛掉： 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, … 取新序列的第一个数 3，它一定是素数，然后用 3 把序列的 3 的倍数筛掉： 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, … 取新序列的第一个数5，然后用5把序列的5的倍数筛掉： 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, … 这样不断筛下去，就可以得到所有的素数。 Python 编程实现过程 &gt;&gt;&gt;&gt; 先来看三个核心的函数功能实现： 1）–&gt; 先构造一个从 3 开始的奇数序列（注意这是一个生成器，并且是一个无限序列），作为初始序列： 12345def __oddSeq_generator(self): n = 1 while True: n += 2 yield n 2）–&gt; 然后定义一个倍数筛查函数： 12def __not_divisible(self, n): return lambda x: x % n &gt; 0 3）–&gt; 定义一个生成器，不断返回下一个素数： 1234567def __primes(self): yield 2 it = self.__oddSeq_generator() # 初始序列 while True: n = next(it) # 返回序列的第一个数 yield n it = filter(self.__not_divisible(n), it) # 构造新序列 类封装后，最终如下： 123456789101112131415161718192021222324252627282930313233343536373839404142class PrimesCalc: def __init__(self, number): self.__primes_list = [] self.__generate_flag = False self.number = number def __oddSeq_generator(self): n = 1 while True: n += 2 yield n def __not_divisible(self, n): return lambda x: x % n &gt; 0 def __primes(self): yield 2 it = self.__oddSeq_generator() # 初始序列 while True: n = next(it) # 返回序列的第一个数 yield n it = filter(self.__not_divisible(n), it) # 构造新序列 def calc(self): for item in self.__primes(): if (item &lt;= self.number) &amp; (not self.__generate_flag): self.__primes_list.append(item) else: self.__generate_flag = True break return self.__primes_listprimes_obj70 = PrimesCalc(70)res = primes_obj70.calc()print(res)# [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67]primes_obj50 = PrimesCalc(50)res1 = primes_obj50.calc()print(res1)# [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47] 生成器高级用法本节将在上述基础上，继续讲解生成器的一些高级用法，会涉及到：send() &amp;&amp; close() &amp;&amp; throw() 三种生成器方法。 send 方法我们知道，通过 for 循环以及 next() 或者 __next__() 等方法，可以实现从外界控制生成器的执行。除此之外，通过 send() 方法，还可以向生成器中传值。 需要注意的是，使用 send() 方法可选择带一个参数，也可以不带任何参数（用 None 表示）。 [1] &gt;&gt;&gt;&gt; send(None) 当使用不带参数的 send(None) 方法时，它和 next() 函数的功能完全相同。例如： 12345678910111213def intNum(): print(&quot;Start to run&quot;) for i in range(5): yield i print(&quot;Continue to run&quot;)num = intNum()print(num.send(None))# Start to run# 0print(num.send(None))# Continue to run# 1 注意，虽然 send(None) 的功能是 next() 完全相同，但更推荐使用 next()，不推荐使用 send(None)。 [2] &gt;&gt;&gt;&gt; send(value) send(value) 具备 next() 函数的部分功能，即将暂停在 yield 语句出的程序继续执行；但与此同时，该函数还会将 value 值作为 yield 语句返回值赋值给接收者。 样例演示： 12345678def foo(): buff_a = yield &quot;hello&quot; buff_b = yield buff_a yield buff_bf = foo()print(f.send(&quot;Python&quot;))# TypeError: can't send non-None value to a just-started generator 哎？报错了：”你无法传入一个非 None 的值给一个刚启动的生成器”，什么意思？ &gt;&gt;&gt;&gt; 事实上，带参数的 send(value) 无法启动执行生成器函数。必须先传递一个 None 进去或者调用一次 next() 方法（启动生成器），才能进行传值操作。修改程序如下： 12345678910111213141516171819202122232425262728def foo(): buff_a = yield &quot;hello&quot; print(&quot;buff_a --&gt;&quot;, buff_a) buff_b = yield &quot;hello&quot; print(&quot;buff_b --&gt;&quot;, buff_b) buff_c = yield buff_b print(&quot;buff_c --&gt;&quot;, buff_c) yield buff_cf = foo()print(next(f)) # 等价于 print(f.send(None))# helloprint(f.send(None)) # 等价于 print(next(f))# buff_a --&gt; None# helloprint(f.send(&quot;Python&quot;))# buff_b --&gt; Python# Pythonprint(f.send(&quot;Python is a OPP Program.&quot;))# buff_c --&gt; Python is a OPP Program.# Python is a OPP Program. 分析一下程序的执行流程： 1）首先，构建生成器函数，并利用其创建生成器对象 f。 2）使用 next() 函数启动生成器（其功能和 f.send(None) 函数完全相同），开始执行生成器函数，程序会执行到 yield &quot;hello&quot;，而此时的值为 “hello”，因此 Python 解释器输出 hello。这里注意，此时还未对 buff_a 进行赋值。 3）使用生成器 f 调用无参的 send(None) 函数重新启动生成器，它会使得程序继续执行（buff_a 赋值 -&gt; 打印 buff_a），程序执行到第二个 yield &quot;hello&quot; 语句停止（未对 buff_b 进行赋值），此时 Python 解释器输出 hello。同时，你会发现，在打印 buff_a 时，输出 buff_a --&gt; None，思考一下为什么？？？ 事实上，3）在 buff_a 进行赋值时，由于使用的是 send(None) 函数启动的生成器，其没有返回值（或者就认为它也会将 None 赋值给当前 yield 语句的接收者），这就很合理了。这是不进一步意味着 next() 函数也是同理的，你可以将 send(None) 语句换为 next() 验证一下。 4）开始使用生成器 f 调用有参的 send(value) 函数重新启动生成器，它会使得程序继续执行（buff_b 赋值 -&gt; 打印 buff_b），程序执行到 yield buff_b&quot; 语句停止（未对 buff_c 进行赋值），此时 Python 解释器输出 Python。这里，由于使用的是带 value 值的方式，故 buff_b 进行赋值时会拿到 &quot;Python&quot;，故打印输出：buff_b --&gt; Python。 5）最后依然是使用生成器 f 调用有参的 send(value) 函数重新启动生成器，过程和 4）中同理，请结合理解一下。 close 方法当程序在生成器函数中遇到 yield 语句暂停运行时，此时如果调用 close() 方法，会阻止生成器函数继续执行，该函数会在程序停止运行的位置抛出 GeneratorExit 异常。 举个例子： 1234567891011def foo(): try: yield &quot;Python&quot; except GeneratorExit: print('捕获到 GeneratorExit，你可以在这里进行异常处理操作') f = foo()print(next(f))# Pythonf.close()# 捕获到 GeneratorExit，你可以在这里进行异常处理操作 需要注意的是，生成器函数一旦使用 close() 函数停止运行，后续将无法再调用 next() 函数或者 __next__() 方法启动执行，否则会抛出 StopIteration 异常。例如： 1234567891011def foo(): yield &quot;Python&quot; print(&quot;close 后仍想要执行的代码&quot;) f = foo()print(next(f))# Pythonf.close()next(f)# StopIteration Error 这就意味着，close 后仍想要执行的代码无法执行了，怎么办？ 可以通过通过捕获 GeneratorExit 异常，可以在异常处理中继续执行生成器函数中仍然想执行的代码。但是注意这部分代码中不能再包含 yield 语句，否则程序会抛出 RuntimeError 异常。例如： 1234567891011121314151617181920def foo(): try: yield &quot;Python&quot; except GeneratorExit: print('捕获到 GeneratorExit，你可以在这里进行异常处理操作') print('close 后仍想要执行的代码') yield &quot;Java&quot; f = foo()print(next(f))# Pythonf.close()# 捕获到 GeneratorExit，你可以在这里进行异常处理操作# close 后仍想要执行的代码# RuntimeError Traceback (most recent call last)# ---&gt; f.close()# RuntimeError: generator ignored GeneratorExit throw 方法生成器 throw() 方法的功能是，在生成器函数执行暂停处，抛出一个指定的异常，之后程序会继续执行生成器函数中后续的代码，直到遇到下一个 yield 语句。 需要注意的是，如果到剩余代码执行完毕没有遇到下一个 yield 语句，则程序会抛出 StopIteration 异常。 示例如下： 123456789101112131415def foo(): try: yield 1 except ValueError: print('捕获到 ValueError')f = foo()print(next(f))# 1f.throw(ValueError)# 捕获到 ValueError# Traceback (most recent call last):# ...# StopIteration 显然，一开始生成器函数在 yield 1 处暂停执行，当执行 throw() 方法时，它会先抛出 ValueError 异常，然后继续执行后续代码找到下一个 yield 语句，该程序中由于后续不再有 yield 语句，因此程序执行到最后，会抛出一个 StopIteration 异常。 Python 中的@函数装饰器所谓函数装饰器（Decorator），是指 通过装饰器函数，在不修改原函数的前提下，来对函数的功能进行合理的扩充。 @函数装饰器引入在前面的章节，我们已经学习了三种 Python 内置的函数装饰器，分别是：＠staticmethod、＠classmethod 和 @property。它们分别是基于 Python 内置的装饰器函数 staticmethod()、classmethod() 和 property() 来实现的。 如下样例： 12345class Test: @classmethod def foo(cls): print(&quot;Class Method&quot;) 也就是说，在不修改原函数 foo(cls) 的前提下（默认为类的实例方法），我们使用了一个 @classmethod 的装饰器，使得 foo(cls) 函数成为了一个类方法（功能扩展）。其中，@classmethod 函数装饰器，是基于装饰器函数 classmethod() 实现的。 那么，到底什么是函数装饰器？装饰器函数又是如何定义的？？？ 你需要了解函数装饰器的工作原理 &gt;&gt;&gt;&gt; @函数装饰器工作原理假设用 funA() 装饰器函数所对应的函数装饰器 @funA，去装饰 funB() 函数以实现扩展其功能。如下所示： 12345678910# funA 作为装饰器函数def funA(fn): #... fn() # 执行传入的 fn 参数 #... return '...'@funAdef funB(): #... 实际上，上面程序完全等价于下面的程序： 12345678910def funA(fn): #... fn() # 执行传入的 fn 参数 #... return '...'def funB(): #...funB = funA(funB) # 等价于 @funA 对比如上程序可以发现，，使用装饰器函数 funA() 去装饰另一个函数 funB()，其底层执行了如下 2 步操作： 将 funB 作为参数传给 funA() 函数（传递的是函数，即函数名，或函数引用）； 将 funA() 函数执行完成的返回值反馈回 funB。 来看一个实例： 123456789101112131415# funA 作为装饰器函数def funA(fn): print(&quot;2018-3-13 12:30:12&quot;) fn() # 执行传入的 fn 参数 print(&quot;2018-3-13 12:30:15&quot;) return &quot;Decorator Return&quot;@funAdef funB(): print(&quot;Learning Python&quot;)# 2018-3-13 12:30:12# Learning Python# 2018-3-13 12:30:15 观察函数装饰器返回 &gt;&gt;&gt;&gt; 在此基础上，如果在程序末尾添加如下语句（打印观察返回的 funB 是什么？）： 12print(funB)# Decorator Return 可见，funB 从一个函数引用，变为了一个普通的变量引用。显然，你可以理解被 “＠函数”修饰的函数不再是原来的函数，而是被替换成一个新的东西（取决于装饰器的返回值）： 如果装饰器函数的返回值为普通变量，那么被修饰的函数名就变成了变量名； 如果装饰器返回的是一个函数的名称，那么被修饰的函数名依然表示一个函数。 带参数的@函数装饰器###分析@函数装饰器工作原理可以发现，即当被修饰的 funB() 函数无参数时，可以直接将 funB 作为 funA() 的参数传入。 思考一下，如果被修饰的函数本身带有参数 funB(arg)，那应该如何传值呢？即如何向装饰器函数传递一个带参数的函数？？？ 解决方法很简单 &gt;&gt;&gt;&gt; 就是在装饰器函数（funA()）中嵌套一个函数，该函数带有的参数个数和被装饰器修饰的函数相同。 [1] &gt;&gt;&gt;&gt; 被修饰函数带有参数 123456789101112# funA 作为装饰器函数def funA(func): def wrapper(arg): # 说明：函数对象中，有一个 `__name__ `属性，可以拿到函数的名字 print('%s %s' % (arg, func.__name__) ) return wrapper@funAdef funB(arg): print(&quot;funB call&quot;) funB(&quot;test&quot;) 等价于如下： 123456789101112# funA 作为装饰器函数def funA(func): def wrapper(arg): # 说明：函数对象中，有一个 `__name__ `属性，可以拿到函数的名字 print('%s %s' % (arg, func.__name__) ) return wrapperdef funB(arg): print(&quot;funB call&quot;) funB = funA(funB)funB(&quot;test&quot;) 显然，此时 funB() 函数被装饰器 funA() 修饰，funB 就被赋值为 wrapper。这意味着，虽然我们在程序显式调用的是 funB() 函数，但其实执行的是装饰器嵌套的 wrapper() 函数。 [2] &gt;&gt;&gt;&gt; 多个（≥ 2）函数被同一个装饰器函数修饰，这些函数带有的参数个数并不相等 解决方法很简单 &gt;&gt;&gt;&gt; 用 *args 和 **kwargs 作为装饰器内部嵌套函数的参数，*args 和 **kwargs 表示接受任意数量和类型的参数。举个例子： 123456789101112131415161718# funA 作为装饰器函数def funA(func): def wrapper(*arg, **kwarg): func(*arg, **kwarg) return wrapper@funAdef funB(arg): print(&quot;Learning&quot;, arg)@funAdef funC(name, add): print(name, add) funB(&quot;Python&quot;)funC(&quot;Learning&quot;, &quot;Java&quot;)# Learning Python# Learning Java 你应该可以想到，当只有一个被修饰函数，且被修饰函数参数列表有任意多个时，也可以采用上述方法。 上面我们提到的，都是被修饰函数中的参数场景。那你有没有考虑过一个问题，如果装饰器函数本身带有参数的话怎么办？？？ [3] &gt;&gt;&gt;&gt; 函数装饰器中含参数 如果装饰器函数（decorator）本身就需要传入参数怎么办？？？ 借鉴上面的方法，可以在装饰器函数（funA）的外面套一个外部函数，通过外部函数传入参数，但需要保证外部函数返回一个装饰器（decorator），这是必要的。 为了方便理解，我们将 funA 改名为 decorator，示例如下: 1234567891011121314151617181920212223242526# externalFunc 作为外部函数def externalFunc(text): def decorator(func): # funA 作为装饰器函数 def wrapper(*arg, **kwarg): # wrapper 作为内嵌函数 print('%s %s:' % (text, func.__name__)) # 说明：函数对象中，有一个 `__name__ `属性，可以拿到函数的名字 func(*arg, **kwarg) return wrapper return decorator@externalFunc('execute')def funB(arg): print(&quot;Learning&quot;, arg)@externalFunc('execute')def funC(name, add): print(name, add) funB(&quot;Python&quot;)funC(&quot;Learning&quot;, &quot;Java&quot;)# execute funB:# Learning Python# execute funC:# Learning Java 这种 3 层嵌套等价于如下： 1234567891011121314151617181920# externalFunc 作为外部函数def externalFunc(text): def decorator(func): # funA 作为装饰器函数 def wrapper(*arg, **kwarg): # wrapper 作为内嵌函数 print('%s %s:' % (text, func.__name__)) # 说明：函数对象中，有一个 `__name__ `属性，可以拿到函数的名字 func(*arg, **kwarg) return wrapper return decoratordef funB(arg): print(&quot;Learning&quot;, arg)def funC(name, add): print(name, add)funB = externalFunc(&quot;execute&quot;)(funB)funC = externalFunc(&quot;execute&quot;)(funC) 完整的@函数装饰器先给出一个前面的，一般@函数装饰器的样例程序： 123456789101112131415161718# funA 作为装饰器函数def funA(func): def wrapper(*arg, **kwarg): func(*arg, **kwarg) return wrapper@funAdef funB(arg): print(&quot;Learning&quot;, arg)@funAdef funC(name, add): print(name, add) funB(&quot;Python&quot;)funC(&quot;Learning&quot;, &quot;Java&quot;)# Learning Python# Learning Java 考虑一下，在以上基础上添加如下代码的输出效果： 12print(funB.__name__)print(funC.__name__) 可以看到，运行后函数名称输出的都是 wrapper，这不是我们预期的输出啊，既然访问的是 funB/funC，你应该输出相应的函数签名啊。 事实上，出现上述情况也不意外，因为装饰器函数返回的那个 wrapper() 函数名字就是 'wrapper'， funB/funC 指向的实际上还是 wrapper() 函数的空间。所以需要把原始函数的 __name__ 等属性复制到 wrapper() 函数中，否则有些依赖函数签名的代码执行就会出错。 当然了，不需要编写 wrapper.__name__ = func.__name__ 这样的代码，Python functools 模块内置的 functools.wraps 就是干这个事的，所以，一个完整的 decorator 的写法如下： 12345678import functoolsdef funA(func): @functools.wraps(func) def wrapper(*args, **kw): print('call %s():' % func.__name__) return func(*args, **kw) return wrapper 或者针对带参数的 decorator： 12345678910import functoolsdef externalFunc(text): def decorator(func): @functools.wraps(func) def wrapper(*args, **kw): print('%s %s():' % (text, func.__name__)) return func(*args, **kw) return wrapper return decorator @函数装饰器嵌套上面都是使用一个装饰器的情况，但实际上，Python 中的函数也支持多个装饰器，比如： 12345@funA@funB@funCdef fun(): #... 上面程序的执行顺序是里到外，所以它等效于下面这行代码: 1fun = funA( funB( funC(fun) ) ) 深入解读@函数装饰器这一小节将通过实际工作中的几个例子，来加深对@函数装饰器的理解。 身份认证首先是最常见的身份认证的应用。 这个很容易理解，举个最常见的例子，登录微信时，需要输入用户名密码，然后点击确认，这样服务器端便会查询你的用户名是否存在、是否和密码匹配等等。如果认证通过，就可以顺利登录；反之，则提示你登录失败。 再比如一些网站，你不登录也可以浏览内容，但如果你想要发布文章或留言，在点击发布时，服务器端便会查询你是否登录。如果没有登录，就不允许这项操作等等。 一个实现身份认证的简单示例： 12345678910111213141516import functoolsdef authenticate(func): @functools.wraps(func) def wrapper(*args, **kwargs): request = args[0] # 如果用户处于登录状态 if check_user_logged_in(request): # 执行函数 post_comment() return func(*args, **kwargs) else: raise Exception('Authentication failed') return wrapper @authenticatedef post_comment(request): pass 上面这段代码中，定义了装饰器 authenticate，函数 post_comment() 则表示发表用户对某篇文章的评论，每次调用这个函数前，都会先检查用户是否处于登录状态，如果是登录状态，则允许这项操作；如果没有登录，则不允许。 日志记录日志记录同样是很常见的一个案例。 在实际工作中，如果你怀疑某些函数的耗时过长，导致整个系统的延迟增加，想在线上测试某些函数的执行时间，那么，装饰器就是一种很常用的手段。 示例演示： 123456789101112131415161718import timeimport functoolsdef log_execution_time(func): @functools.wraps(func) def wrapper(*args, **kwargs): start = time.perf_counter() res = func(*args, **kwargs) end = time.perf_counter() print('{} took {} ms'.format(func.__name__, (end - start) * 1000)) return res return wrapper @log_execution_timedef calculate_similarity(items): passcalculate_similarity(&quot;test&quot;)# calculate_similarity took 0.00039999999999999996 ms 这里，装饰器 log_execution_time 记录某个函数的运行时间，并返回其执行结果。如果你想计算任何函数的执行时间，在这个函数上方加上 @log_execution_time 即可。 输入合理性检查在大型公司的机器学习框架中，调用机器集群进行模型训练前，往往会用装饰器对其输入（往往是很长的 json 文件）进行合理性检查。这样就可以大大避免输入不正确对机器造成的巨大开销。 示例演示： 123456789import functoolsdef validation_check(func): @functools.wraps(func) def wrapper(*args, **kwargs): ... # 检查输入是否合法 @validation_checkdef neural_network_training(*args, **kwargs): pass 很多情况下都会出现输入不合理的现象。因为我们调用的训练模型往往很复杂，输入的文件有成千上万行，很多时候确实也很难发现。 试想一下，如果没有输入的合理性检查，很容易出现“模型训练了好几个小时后，系统却报错说输入的一个参数不对，成果付之一炬”的现象。这样的“惨案”，大大减缓了开发效率，也对机器资源造成了巨大浪费。 缓存装饰器关于缓存装饰器的用法，其实十分常见，这里以 Python 内置的 LRU cache 为例来说明。 LRU cache，在 Python 中的表示形式是 @lru_cache。@lru_cache 会缓存进程中的函数参数和结果，当缓存满了以后，会删除最近最久未使用的数据。 正确使用缓存装饰器，往往能极大地提高程序运行效率。举个例子，大型公司服务器端的代码中往往存在很多关于设备的检查，比如使用的设备是安卓还是 iPhone，版本号是多少。这其中的一个原因，就是一些新的功能，往往只在某些特定的手机系统或版本上才有（比如 Android v200+）。 这样一来，我们通常使用缓存装饰器来包裹这些检查函数，避免其被反复调用，进而提高程序运行效率，比如写成下面这样： 123@lru_cachedef check(param1, param2, ...) # 检查用户设备类型，版本号等等 ...","link":"/2018/01/13/python-mian-xiang-dui-xiang-bian-cheng-zhi-lei-de-te-shu-shu-xing-he-fang-fa/"},{"title":"HTML 教程之 HTML 表单元素","text":"HTML 中的表单元素支持你通过网页来收集一些用户的信息，例如用户名、密码、电话、邮箱地址等。表单接收用户输入的信息之后，你可以选择将其发送到后端的应用程序，后端应用程序将根据定义好的业务逻辑来对表单传递来的数据进行处理。 也就是说，HTML 表单用于收集不同类型的用户输入，以传递给后端使用。 表单表单属于 HTML 文档的一部分，是一个包含表单元素（表单控件）的区域，其中包含了如输入框、文本域、下拉列表、单选框、复选框、提交按钮等不同的表单控件。 HTML 表单中，允许用户通过修改表单中的元素（例如输入文本，或选择某个选项等）来完成表单，通过表单中的提交按钮将表单数据提交给后端程序（后台）。 在 HTML 中创建表单需要用到 &lt;form&gt; 标签，其基础语法格式如下所示： 1234567&lt;form action=&quot;URL&quot; method=&quot;GET|POST&quot;&gt;. input elements .&lt;/form&gt; 其中，action 属性用来指明要将表单提交到何处（默认为当前页面），也可以是另一个页面（HTML 5 中非必须）；method 属性表示使用哪种方式提交数据，支持 GET &amp;&amp; POST 两种方式，GET 为默认提交方式。 关于 GET &amp;&amp; POST Method &gt;&gt;&gt; Method 方法规定如何发送表单数据（Form Date），表单数据会被发送到在 action 属性中规定的页面中。其中表达数据可被作为 URL 参数的形式（GET）来发送，或作为 HTTP Post 事务的形式（POST）来发送。 [1] &gt;&gt;&gt; 关于 GET 的注释 将表单数据以名称/值对的形式附加到 URL 参数中进行发送； 发送的 URL 的长度是有限的； GET 更适用于非安全数据，例如查询条件。绝不要使用 GET 来发送敏感数据（数据 URL 中可见）！ 对于用户希望加入书签的表单提交很有用。 [2] &gt;&gt;&gt; 关于 POST 的注释、 将表单数据附加到 HTTP 请求的 Body 内（数据 URL 中不可见）进行发送； 发送的 URL 没有长度限制； 通过 POST 提交的表单不能加入书签。 表单属性上面 action 和 method 是 &lt;form&gt; 标签最常用的两个属性。 HTML 为 &lt;form&gt; 标签提供了一些专用的属性，如下： [1] &gt;&gt;&gt; 属性：accept Form 元素的 accept 属性规定能够通过文件上传进行提交的 服务器接受的文件类型。其属性值为：MIME_type 类型。 HTML5 中不再支持该属性。HTML 4 中要避免使用该属性作为验证工具，应该在服务器端验证文件上传。 [2] &gt;&gt;&gt; 属性：accept-charset Form 元素的 accept-charset 属性用于设置表单数据的字符集（默认为 HTML 文档字符集）。 例如，你可以设置：accept-charset=&quot;ISO-8859-1&quot; 。 [3] &gt;&gt;&gt; 属性：autocomplete Form 元素的 autocomplete 属性用于设置是否启用表单的自动完成功能（默认开启），为 HTML 5 新属性。 当用户在字段开始键入时，浏览器会基于之前键入过的值给出输入预测提示，你可以选择选填或者键入新的值。 autocomplete 其可选属性值为：on（开启） Or off（警用）。 [4] &gt;&gt;&gt; 属性：enctype Form 元素的 enctype 属性设置在提交表单数据之前如何对数据进行编码（适用于 method=”post” 的情况）。 autocomplete 其可选属性值为：application/x-www-form-urlencoded（默认，URL 编码格式，在发送前对所有字符进行编码（将空格转换为 “+” 符号，特殊字符转换为 ASCII HEX 值）） Or multipart/form-data（不对字符编码。当使用有文件上传控件的表单时，该值是必需的） Or text/plain（将空格转换为 “+” 符号，但不编码特殊字符）。 [5] &gt;&gt;&gt; 属性：name Form 元素的 name 属性用来设置表单的名称，可被 CSS 样式表或 Javascript 选择，这里不用多说。 [6] &gt;&gt;&gt; 属性：novalidate Form 元素的 novalidate 属性表示在提交表单时不进行验证，为 HTML 5 新属性。 用法如下： 123&lt;form ... novalidate=&quot;novalidate&quot;&gt; ...&lt;/form&gt; [7] &gt;&gt;&gt; 属性：target Form 元素的 novalidate 属性设置在何处打开 action 属性设定的链接，其属性值如下： 1234&lt;!-- 默认为 _self --&gt;&lt;form target=&quot;_blank|_self|_parent|_top|framename&quot;&gt; ...&lt;/form&gt; 和链接打开方式不同的是，增加了一个 framename 属性，表示在指定的 iframe 中打开。 表单控件Form 元素中可以包括以下一个或多个控件（表单元素）： &lt;label&gt; &amp;&amp; &lt;input&gt; &amp;&amp; &lt;textarea&gt; &amp;&amp; &lt;select&gt; &amp;&amp; &lt;option&gt; &amp;&amp; &lt;button&gt; &amp;&amp; &lt;optgroup&gt; &amp;&amp; &lt;fieldset&gt; &amp;&amp; &lt;legend&gt; &gt;&gt;&gt; HTML 5 新增 &gt;&gt;&gt; &lt;datalist&gt; &amp;&amp; &lt;keygen&gt; &amp;&amp; &lt;output&gt;。 上述表单控件可分为三类： 输入元素； 下拉元素 按钮元素； HTML 5 新增元素。 输入元素&lt;input&gt; 元素是最重要的表单元素，多数情况下被用到的表单标签是就是输入标签。 输入元素根据输入类型的不同（由 type 属性来定义），具有不同的 HTML 语义。例如常见的：文本框、密码框、单选框、复选框、按钮等等。其基本语法格式如下： 123&lt;form&gt; &lt;input type=&quot;input_element_type&quot;, name=&quot;input_element_name&quot; /&gt;&lt;/form&gt; 其中，type 属性用来定义输入元素类型，name 属性用来定义输入元素名称。 文本框当用户需要输入一行普通文本内容时，就需要用到文本框（type=&quot;text&quot;）。示例如下。 示例一 &gt;&gt;&gt; 普通文本框 123&lt;form&gt; Text1: &lt;input type=&quot;text&quot; name=&quot;input_text1&quot; /&gt;&lt;/form&gt; 示例二 &gt;&gt;&gt; 规定以字符数计的输入框的可见宽度 123&lt;form&gt; Text2: &lt;input type=&quot;text&quot; name=&quot;input_text2&quot; size=&quot;10&quot;&gt;&lt;/form&gt; 示例三 &gt;&gt;&gt; 规定输入框允许的最大字符数 123&lt;form&gt; Text3: &lt;input type=&quot;text&quot; name=&quot;input_text3&quot; size=&quot;10&quot;&gt;&lt;/form&gt; 示例四 &gt;&gt;&gt; 规定输入框内容初始值 123&lt;form&gt; Text4: &lt;input type=&quot;text&quot; name=&quot;input_text4&quot; value=&quot;default value&quot;&gt;&lt;/form&gt; 示例五 &gt;&gt;&gt; 规定输入框内容提示信息（HTML5） 123&lt;form&gt; Text5: &lt;input type=&quot;text&quot; name=&quot;input_text5&quot; placeholder=&quot;Please input user name&quot;&gt;&lt;/form&gt; 示例六 &gt;&gt;&gt; 规定在提交表单之前输入框中必需填写内容（HTML5） 123&lt;form&gt; Text5: &lt;input type=&quot;text&quot; name=&quot;input_text5&quot; placeholder=&quot;Please input user name&quot;&gt;&lt;/form&gt; 如果要输入多行文本内容你可以参考下一章节的多行文本域（textarea）。 密码框当用户需要输入密码字段时，就需要用到密码框（type=&quot;password&quot;），输入数据会自动显示为星号。示例如下： 1Passwd: &lt;input type=&quot;password&quot; name=&quot;input_text7&quot; placeholder=&quot;Please input your password&quot; required=&quot;required&quot;&gt; 单选框当页面需要单选框功能时，就需要用到单选框（type=&quot;radio&quot;）。其语法格式如下： 1&lt;input type=&quot;radio&quot; value=&quot;radio_value&quot;&gt; 其中，value 用来定义可发送到服务器的单选框元素的值。 来看一个示例： 123Sex:&lt;input type=&quot;radio&quot; value=&quot;male&quot;&gt; Male&lt;input type=&quot;radio&quot; value=&quot;female&quot;&gt;Female 你会发现，用于表示性别的单选框，男女都可以选，也并不是单选框啊？！！这就涉及到单选框 分组 的概念了。 分组 是指：多个单选框，都在一个分组里，同一时间，只能选中一个单选框。这才是真正意义上我们想要的单选框功能，需要借助单选框的 name 属性来实现分组。 123Sex:&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;male&quot;&gt; Male&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;female&quot;&gt;Female 再尝试一下，是不已经可以了~~~ 默认选中某个属性 &gt;&gt;&gt; 并且，很多时候，我们想要实现页面加载后，默认选中某个单选框，需要通过 checked 属性实现： 123Sex:&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;male&quot; checked=&quot;checked&quot;&gt; Male&lt;input type=&quot;radio&quot; name=&quot;sex&quot; value=&quot;female&quot;&gt;Female checked 属性规定在页面加载时应该被预先选定的 &lt;input&gt; 元素。并且，只针对 type=&quot;checkbox&quot; 或者 type=&quot;radio&quot; 输入元素。 复选框当页面需要复选框功能时，以支持用户从若干给定的选择中选取一个或若干选项，就需要用到单选框（type=&quot;checkbox&quot;）。 类似于上面的单选框，其示例代码如下： 123456Language:&lt;input type=&quot;checkbox&quot; name=&quot;language&quot; value=&quot;Java&quot; /&gt;Java&lt;input type=&quot;checkbox&quot; name=&quot;language&quot; value=&quot;Python&quot; /&gt;Python&lt;input type=&quot;checkbox&quot; name=&quot;language&quot; value=&quot;HTML&quot; checked=&quot;checked&quot; /&gt;HTML&lt;input type=&quot;checkbox&quot; name=&quot;language&quot; value=&quot;CSS&quot; checked /&gt;CSS&lt;input type=&quot;checkbox&quot; name=&quot;language&quot; value=&quot;Javascript&quot; checked /&gt;Javascript 其中，name 属性表示可发送到服务器的当前复选框元素名称，value 用来定义复选框元素的值，checked 属性表示默认选中。 普通按钮输入元素类型中也支持定义按钮，你可以使用 type=&quot;button&quot; 来定义一个普通按钮（不具有提交功能）。 其示例代码如下： 12345&lt;form method=&quot;get&quot;&gt; 账号：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt; &lt;br /&gt; 密码：&lt;input type=&quot;password&quot; name=&quot;passwd&quot;&gt; &lt;br /&gt; &lt;input type=&quot;button&quot; value=&quot;Login&quot;&gt;&lt;/form&gt; 点击 Login 按钮后，你会发现表单并未提交！！！ 提交按钮跟多的时候，页面需要的是一个提交按钮。 输入元素类型中也支持定义提交按钮（type=&quot;submit&quot;），可用于提交表单，把数据提交到服务端。 其示例代码如下： 12345&lt;form method=&quot;get&quot;&gt; 账号：&lt;input type=&quot;text&quot; name=&quot;username&quot;&gt; &lt;br /&gt; 密码：&lt;input type=&quot;password&quot; name=&quot;passwd&quot;&gt; &lt;br /&gt; &lt;input type=&quot;submit&quot; value=&quot;Login&quot;&gt;&lt;/form&gt; 点击 Login 按钮后，你会发现表单会被进行提交！！！ 当用户单击确认按钮时，表单的内容会被传送到另一个文件。表单的动作（action）属性定义了目的文件的文件名。由动作属性定义的这个文件通常会对接收到的输入数据进行相关的处理。 重置按钮输入元素类型中也支持定义重置按钮（type=&quot;reset&quot;），用于将输入框的改动复原。 其示例代码如下： 12345&lt;form method=&quot;get&quot;&gt; 账号：&lt;input type=&quot;text&quot; name=&quot;username&quot; placeholder=&quot;Please Enter User Name&quot; /&gt; &lt;br /&gt; 密码：&lt;input type=&quot;password&quot; name=&quot;passwd&quot;&gt; &lt;br /&gt; &lt;input type=&quot;submit&quot; value=&quot;Login&quot;&gt; &lt;input type=&quot;reset&quot; value=&quot;Reset&quot;&gt;&lt;/form&gt; 图像提交输入元素类型中也支持使用图像作为提交按钮进行表单的提交（type=&quot;image&quot;），示例代码如下： 12345&lt;form method=&quot;get&quot;&gt; 账号：&lt;input type=&quot;text&quot; name=&quot;username&quot; placeholder=&quot;Please Enter User Name&quot; /&gt; &lt;br /&gt; 密码：&lt;input type=&quot;password&quot; name=&quot;passwd&quot;&gt; &lt;br /&gt; &lt;input type=&quot;image&quot; src=&quot;images/kawayi.jpg&quot; width=&quot;200px&quot; height=&quot;150px&quot;&gt;&lt;/form&gt; 其中，src 属性用于指定图片源，width 和 height 属性用于定义图像尺寸。 文本域HTML 中使用 &lt;textarea&gt; 标签来定义一个多行的文本输入控件，可容纳无限数量的文本，有滚动条。其语法格式如下： 123&lt;textarea name=&quot;textarea1&quot; rows=&quot;10&quot; cols=&quot;30&quot;&gt;This is a textarea.&lt;/textarea&gt; 其中，rows &amp;&amp; cols 属性用来定义文本区域内可见的行、列数。 文本域元素，也支持：autofocus(自动聚焦)、disabled(禁用文本区域)、maxlength(最大字符数)、placeholder(提示)、readonly(只读)、wrap(换行)等属性。 其它输入控件输入元素中还提供其它类型的输入控件，你可以尝试下现实效果，如下所示： 1234567891011121314151617&lt;form name=&quot;form_test&quot; method=&quot;get&quot;&gt; &lt;input type=&quot;color&quot;&gt; &lt;br /&gt; &lt;input type=&quot;date&quot;&gt; &lt;br /&gt; &lt;input type=&quot;datetime&quot;&gt; &lt;br /&gt; &lt;input type=&quot;month&quot;&gt; &lt;br /&gt; &lt;input type=&quot;number&quot;&gt; &lt;br /&gt; &lt;input type=&quot;range&quot;&gt; &lt;br /&gt; &lt;input type=&quot;search&quot;&gt; &lt;br /&gt; &lt;input type=&quot;tel&quot;&gt; &lt;br /&gt; &lt;input type=&quot;url&quot;&gt; &lt;br /&gt; &lt;input type=&quot;time&quot;&gt; &lt;br /&gt; &lt;input type=&quot;week&quot;&gt; &lt;br /&gt; &lt;input type=&quot;hidden&quot;&gt; &lt;br /&gt; &lt;input type=&quot;email&quot;&gt; &lt;br /&gt; &lt;input type=&quot;file&quot;&gt; &lt;br /&gt; &lt;input type=&quot;datetime-local&quot;&gt; &lt;br /&gt;&lt;/form&gt; 下拉元素HTML 中 &lt;select&gt; 标签来实现下拉列表功能，需要和 &lt;option&gt; 标签配合使用（定义列表中的可用选项）。 其示例代码如下： 123456&lt;select&gt; &lt;option value=&quot;volvo&quot;&gt;Volvo&lt;/option&gt; &lt;option value=&quot;saab&quot;&gt;Saab&lt;/option&gt; &lt;option value=&quot;opel&quot; selected=&quot;selected&quot;&gt;Opel&lt;/option&gt; &lt;option value=&quot;audi&quot;&gt;Audi&lt;/option&gt;&lt;/select&gt; 其中，其中，value 用来定义可发送到服务器的单选框元素的值，selected 属性用来指定页面加载后默认选中的下拉列表选项。 按钮元素上面我们通过输入元素定义具有不同功能的按钮，HTML 中有专门的按钮标签（&lt;button&gt;）以支持定义不同类型的按钮，功能更为丰富。 和输入元素类似的，其支持使用 type 属性来规定按钮的类型，支持：submit(提交按钮) &amp;&amp; button(普通按钮) &amp;&amp; reset(重置按钮)。不同的是，按钮元素是一个双标签，其内容可以文字、图片等，功能更加丰富。其语法格式如下： 1&lt;button name=&quot;button_name&quot; type=&quot;button&quot; value=&quot;text&quot; disabled=&quot;disabled&quot;&gt;Login&lt;/button&gt; 其中，disabled 属性用于规定禁用按钮，其它属性同输入元素。 HTML 表单中使用 &lt;button&gt; 元素，不同的浏览器可能会提交不同的按钮值。请使用 &lt;input&gt; 在 HTML 表单中创建按钮。 HTML5 中的新增按钮通用属性：autofocus（自动获得焦点）、form（规定按钮属于一个或多个表单）。 HTML5 中的新增提交按钮属性：formaction（覆盖表单元素的 action 属性）、formenctype（覆盖表单元素的 enctype 属性）、formmethod（覆盖表单元素的 method 属性）、formnovalidate（覆盖表单元素的 validate 属性） 以及 formtarget（覆盖表单元素的 target 属性）。 HTML 5 新增元素HTML5 有以下新的表单元素： &lt;datalist&gt; 元素； &lt;keygen&gt; 元素； &lt;output&gt;元素。 可能并不是所有的浏览器都支持HTML5 新的表单元素，但是你可以在使用它们，即使浏览器不支持表单属性，仍然可以显示为常规的表单元素。 Datalist &gt;&gt;&gt; Datalist 元素用于规定输入域的选项列表，需要绑定到 form 或 input 域使其拥有自动完成功能（提供一些预定选项）。 示例代码如下： 123456789&lt;input list=&quot;browsers&quot;&gt;&lt;datalist id=&quot;browsers&quot;&gt; &lt;option value=&quot;Internet Explorer&quot;&gt; &lt;option value=&quot;Firefox&quot;&gt; &lt;option value=&quot;Chrome&quot;&gt; &lt;option value=&quot;Opera&quot;&gt; &lt;option value=&quot;Safari&quot;&gt;&lt;/datalist&gt; 关于 &lt;keygen&gt; 元素 &amp;&amp; &lt;output&gt; 元素的用法可参考 HTML 5 新表单元素支持。","link":"/2019/01/02/html-jiao-cheng-zhi-html-biao-dan-yuan-su/"},{"title":"HTML 教程之 HTML 字符集和颜色","text":"HTML 文档是一种纯文本文件，因此会涉及到文件字符编码格式的问题。也就是说，Web 浏览器必须知道要使用哪种字符编码来进行正常显示 HTML 页面。 HTML 字符集为了能够正确显示 HTML 页面内容，需要为其指定某种字符编码，让 Web 浏览器知道要使用哪个字符集来解析显示页面。 从 ASCII 到 UTF-8ASCII 是第一个出现的字符编码标准，是美国人给自己设计的，并没有考虑其它国家/地区的扩展字符。ASCII 定义了 128 种可以在互联网上使用的字符：数字（0-9）、英文字母（a~z &amp;&amp; A~Z）、一些计算机常用特殊字符（# % ^ &amp; ! $ + - ( ) @ &lt; &gt;），以及一些具有控制功能的字符（换行符、制表符）等。 ISO-8859-1 是 HTML 4 的默认字符集，是大多数浏览器默认的字符集。。此字符集支持 256 个不同的字符代码。HTML 4 同时支持 UTF-8。 ANSI（Windows-1252） 是原始的 Windows 字符集。 ANSI 与 ISO-8859-1 相同，不同之处在于 ANSI 具有 32 个额外的字符。 UTF-8 是基于 Unicode 字符集的一套字符编码，用于统一所有国家的字符集。简言之支持世界上所有国家和地区几乎所有的字符和符号。 如果你对字符集和字符编码等还不了解的话，请猛击链接学习 &gt;&gt;&gt; 编程基础之编码详解。 HTML charset 属性（HTML 5 新增）设置字符编码 &gt;&gt;&gt; 为了浏览器能够正确显示包含了各国字符的 HTML 页面，你必须为 HTML 页面指定一个字符编码： 1&lt;meta charset=&quot;UTF-8&quot;&gt; 字符集字符支持[1] &gt;&gt;&gt; ASCII ASCII 使用 0 到 31（以及 127）之间的值作为控制字符。 ASCII 使用 32 到 126 的值表示字母（a[97]~z[122] &amp;&amp; A[65]~Z[90]）、数字（0[48]~9[57]）和符号。 ASCII 不使用 128 到 255 之间的值。 [2] &gt;&gt;&gt; ANSI 字符集 (Windows-1252) 对于 0 到 127 的值，ANSI 与 ASCII 相同（兼容 ASCII 码）。 ANSI 有一组专有的字符，其值从 128 到 159。 对于 160 到 255 的值，ANSI 与 UTF-8 相同。 [3] &gt;&gt;&gt; ISO-8859-1 字符集 对于 0 到 127 的值，8859-1 与 ASCII 相同（兼容 ASCII 码）。 8859-1 不使用 128 到 159 之间的值。 对于从 160 到 255 的值，8859-1 与 UTF-8 相同。 [4] &gt;&gt;&gt; UTF-8 字符集 对于 0 到 127 的值，UTF-8 与 ASCII 相同（兼容 ASCII 码）。 UTF-8 不使用 128 到 159 之间的值。 对于 160 到 255 之间的值，UTF-8 与 ANSI 和 8859-1 相同。 UTF-8 从值 256 继续，包含超过 10000 个不同字符。 关于更多字符集差异，你可以参考 &gt;&gt;&gt; HTML 字符集。 HTML 符号和字符实体上面，我们了解了不同字符集下的字符支持，这一小节来看如何在 HTML 中插入常用的符号或者特殊字符。 有时候，我们的 HTML 页面中需要添加一些：普通键盘上不存在的众多数学、技术和货币符号（符号） Or 一些在键盘上找不到的特殊字符（字符）。甚至，在 HTML 中，某些字符是预留字符，例如：大于 &lt; &amp;&amp; 小于 &gt;，浏览器会将其解析为标签，怎么办？？？ 此时，你可以通过 HTML 实体 的形式插入这些字符（符号实体 &amp;&amp; 字符实体）。 HTML 中的每个字符都可以看作是一个个实体，一些实体有专门的实体名称，你可以通过 HTML 实体名称（Entity Name） 来表示某个字符。如果某个字符没有实体名称，则可使用 实体编号（Entity Number） 来表示，它是一个十进制或十六进制的引用。语法格式如下： 12345&amp;entity_name;或&amp;#entity_number; 示例如下（文本中插入三个连续空格）： 12345&lt;!-- 不间断空格 --&gt;&amp;nbsp;&amp;nbsp;&amp;nbsp;&lt;!-- 小于号 --&gt;&amp;lt; 或 &amp;#60; 或 &amp;#060; 更多字符实体选择参考手册 &gt;&gt;&gt; HTML 符号实体参考手册 &amp;&amp; HTML ISO-8859-1 参考手册。 HTML Emoji可以想到的是，表情符号（Emoji）是来自 UTF-8 字符集中的字符定义，例如：😄😍💗。 你可以在网络上查找 HTML 特殊字符使用手册来查找你想插入的所有表情符号。 前面，你已经设置过一些 HTML 元素的颜色了，这一小节我们具体来看一下 HTML 中的颜色表示： HTML 颜色HTML 颜色采用的是 RGB 颜色，是通过对红 (R)、绿 (G)、蓝 (B) 三个颜色通道的变化以及它们相互之间的叠加来得到各式各样的颜色的。 Color Value关于颜色值 &gt;&gt;&gt; 也就是说，一个基本的 HTML 颜色由三部分组成：R（Red） &amp; G（Green） &amp; B（Blue），其中每个颜色值（R/G/B）范围从 0（十六进制为 00） ~ 255（十六进制为 FF）。 HTML 颜色值的表示方法有三种：3 位十六进制颜色值 &amp;&amp; 6 位十六进制颜色值 &amp;&amp; RGB，示例如下： 12345678&lt;!-- Black --&gt;&lt;!-- 3 位十六进制颜色值表示黑色 --&gt;#000&lt;!-- 6 位十六进制颜色值表示黑色 --&gt;#000000&lt;!-- RGB 颜色值表示黑色 --&gt;rgb(0,0,0) 关于更多的颜色值使用，你可以浏览器搜索 HTML 颜色手册即可。 Color Name关于颜色名 &gt;&gt;&gt; 除了上述的通过颜色值映入颜色的方法外，HTML 还支持通过一些标准定义好的颜色名插入颜色。 目前所有浏览器都支持 141 个颜色名称（ HTML 和 CSS 颜色规范定义）： 17 标准颜色：黑色，蓝色，水，紫红色，灰色，绿色，石灰，栗色，海军，橄榄，橙，紫，红，白，银，蓝绿色，黄色。再加 124 个其它颜色。 关于HTML 和 CSS 颜色名称支持，你可以参考 &gt;&gt;&gt; HTML 颜色手册。 网页配色方案和取色器一个优秀的、用户友好的网页，一定有一个良好的网页配色方案，它涉及网站整体的颜色显示，以及各个板块的颜色搭配。 关于配色方案，这里不多讲（毕竟不是专业的），网络上你可以查询到很多由优秀设计师设计出的配色方案，编写网页时可以借鉴。 关于上面的 HTML 颜色使用，更多时候我们是使用取色器工具直接获取某个颜色的颜色值，然后应用到网页。故，你应该准备一个适合自己的颜色取色器工具，它可以帮助你从计算机上的任何地方获取你想要的颜色值。","link":"/2019/01/04/html-jiao-cheng-zhi-html-zi-fu-ji-he-yan-se/"},{"title":"CSS 教程之初识 CSS","text":"CSS 是指层叠样式表（Cascading Style Sheets），HTML 4.0 之后添加了对 CSS 的支持，用于描述 HTML 网页的表现形式，以实现 HTML 页面内容与表现分离，极大提高了页面设计和编写的工作效率。 何为 CSS ？开始学习 CSS 之前，你应该掌握 HTML/XHTML 的基本用法。 HTML 的深入学习离不开 CSS 样式的支持，你应该已经发现 HTML 仅能呈现一些信息，表现能力非常有限，我们很多时候都推荐引入了 CSS 样式一起使用，以提供元素更多的设置，使页面更加精美。 CSS 是 Cascading Style Sheet 的缩写，译为：层叠样式表，它是在 HTML 4 开始使用的，是为了更好的渲染 HTML 元素样式而引入的。 W3C 模式 Html + Css + Javascript，已经成为了目前网页设计与编写的基础 &gt;&gt;&gt; Html 是网页的结构，CSS 是网页的样式，Javascript 是行为。可见 CSS 样式表的掌握对于 HTML 网页来说极其重要。 简单来说，CSS 专门用于渲染 HTML 元素标签的样式，使用 CSS 可以轻松实现页面的布局、内容与表现形式分离，可以极大的提高工作效率。 更具体的 &gt;&gt;&gt; CSS 用于定义网页的样式（美化网页），对网页中元素位置的排版、字体、颜色、背景等属性可以达到像素级的精确控制，CSS 不仅可以静态地修饰网页，还可以配合 JavaScript 动态地修改网页中元素的样式，而且市面上几乎所有的浏览器都支持 CSS。 CSS 发展史20 世纪 90 年代初（1991） HTML 语言诞生，这时的 HTML 只包含很少的属性来控制网页的显示效果。伴随着 HTML 的成长，各式各样的样式语言也随之出现，不同的浏览器结合它们各自的样式语言来控制页面的显示效果。 经过不断的发展，HTML 中添加了越来越多的属性来满足页面设计者的需求，随着这些属性的增加，HTML 变的越来越杂乱，而且 HTML 页面也越来越臃肿，于是 CSS 便诞生了。 1994 年，W3C 组织（World WideWeb Consortium）成立，该组织对 CSS 的发展很感兴趣，为此还专门组织了一次讨论会。最终 CSS 的全部开发成员都加入了 W3C 组织，并负责 CSS 标准的制定，至此 CSS 的发展走上正轨。 W3C，中文名为 “万维网联盟”，由万维网的发明者 蒂姆·伯纳斯·李 于 1994 年 10 月在麻省理工学院计算机科学实验室成立，是 Web 技术领域最具权威和影响力的国际中立性技术标准机构。 发展至今，CSS 总共经历了 4 个版本的迭代： 1）CSS 1.0 1996 年 12 月 W3C 发布了 CSS 的第一个版本 &gt;&gt;&gt; CSS1.0（https://www.w3.org/TR/CSS1/）。 2）CSS 2.0 1998 年 5 月，CSS 2.0 版本正式发布（https://www.w3.org/TR/CSS2/）。 3）CSS 2.1 2004 年 2 月，CSS 2.1 正式发布。该版本在 CSS2.0 的基础上略微做了改动，删除了许多不被浏览器支持的属性。 4）CSS 3 早在 2001 年，W3C 就着手开始准备开发 CSS 的第三个版本，到目前为止该版本还没有最终定稿。虽然完整的 CSS3 标准还没有最终发布，但各主流浏览器已经开始支持其中的绝大部分特性。 CSS 特点CSS 是 Web 领域的一个突破，它为 HTML 提供了一种描述元素样式的方式，使用 CSS 和 HTML 可以制作出外形优美的网页。总体来说 CSS 具有以下特点： 1）丰富的样式定义 CSS 提供了丰富的外观属性，可以在网页中实现各式各样的效果。例如：元素盒子模型设置、文本（字体、颜色、大小、格式化样式…）、页面背景色、背景图片等。 2）易于使用和修改 CSS 中提供了不同的样式信息嵌入方式，不仅可以定义在 HTML 元素的 style 属性中（内联样式或行内样式），也可以定义在 HTML 文档 &lt;head&gt; 标签内的 &lt;style&gt; 标签中（内部样式表），还可以定义在专门的 .css 格式的独立文件中（外部样式表），之后再将其引用到 HTML 文档。 推荐使用外部样式表的 CSS 嵌入方式，这样可以将 CSS 样式统一存放，方便后期维护。 3）多页面应用同一样式v前面提到了外部样式表的 CSS 嵌入方式，它不属于任何页面特有，我们可以在不同的页面引用这个 .css 格式的文件，这样就可以统一不同页面的风格。 4）样式层叠 层叠就是指可以对同一个 HTML 元素多次定义 CSS 样式，后面定义的样式会覆盖前面定义的样式。 例如整个站点引用了同样的 CSS 样式文件，但想要调整其中某个页面的某些元素，这时就可以 针对想要调整的元素单独定义一份样式文件并引用到页面中。这样后来单独定义的样式就会覆盖前面的样式，在浏览器同样只会看到最后设置的效果。 一般而言，所有的样式会根据下面的规则层叠于一个新的虚拟样式表中，优先级如下: 内联样式 &gt; 内部样式表 &gt; 外部样式表 &gt; 浏览器缺省设置（User Agent Stylesheet）。 5）页面压缩 一个网页其中通常包含大量的 HTML 元素，为了实现某些特殊效果我们往往还需要为这些元素定义样式文件，如果将它们放到一起就会使得我们的 HTML 文档过于臃肿。而使用外部样式表的样式定义方式，将 HTML 页面内容和样式实现分离，这样浏览器加载 HTML 文档所用的时间也会减少。 另外，CSS 样式可以重复使用，不同的元素可以使用相同的 CSS 样式，这样可以避免定义重复的样式，CSS 样式文件的体积也会相应的减小，从而进一步缩短页面加载的时间。","link":"/2019/01/10/css-jiao-cheng-zhi-chu-shi-css/"},{"title":"CSS 教程之 CSS 基础语法","text":"CSS 中的基础语法，包括：CSS 语法规则、CSS 选择器、嵌入 CSS 样式以及 CSS 注释。 CSS 语法规则CSS 样式由一系列的规则组成，这些规则会被 Web 浏览器解析，然后应用于 HTML 文档相应的元素上。 CSS 样式规则由两个主要的部分构成，分别是：1）选择器，2）一条或多条样式声明，如下图： 其中 &gt;&gt;&gt; 选择器（Selector）：用来指定你想要应用样式于哪些 HTML 元素上，由 HTML 元素的 id、class 属性或元素名本身（p、h1…）以及一些特殊符号构成； 样式声明（Declaration）：是由 property:property_value（样式属性:属性值） 构成的对（: 连接），多条样式声明使用 ; 隔开，并且需要使用大括号 {} 将所有样式声明括起来。 为了让 CSS 可读性更强，你可以在定义 CSS 时每一行代码上只放置一个声明： 12345/* 属性较少时可放一行 */h1 { color: blue; font-size: 12px;} 事实上，学习 CSS，就是学习有哪些选择器，支持设置哪些样式属性以及可以使用什么样的样式值。 需要注意的是，CSS 中的属性和大部分值都是不区分大小写的，但 CSS 中的选择器通常区分大小写！！！ CSS 选择器上面提到选择器（Selector）用来指定你想要应用样式于哪些 HTML 元素上，它由 HTML 元素的 id、class 属性或元素名本身（p、h1…）以及一些特殊符号构成。 你可以将选择器看作是 CSS 样式与 HTML 元素之间的匹配模式，与选择器关联的样式规则会应用于选择器所指定的 HTML 元素上。 CSS 中提供了多种不同类型的选择器，常用选择器的定义方式如下： Tag 选择器一个完整的 HTML 文档由各式各样的标签组成，而标签选择器可以通过 具体的标签名称 来匹配文档内所有同名的标签。 示例所示： 123p { color: red;} p 选择器能够匹配 HTML 文档中所有的 &lt;p&gt; 标签。 ID 选择器ID 选择器用来匹配 HTML 文档中 具有指定 ID 属性值 的标签，ID 选择器的定义需要用到井号 #。 示例所示： 123#nav { color: red;} #nav 选择器能够匹配文档中具有 id=&quot;nav&quot; 属性的标签。 ID 属性值不要以数字开头，数字开头的 ID 在某些浏览器中可能不起作用。 Class 选择器类选择器用来匹配 HTML 文档中所有 具有指定 Class 属性值 的标签，类选择器的定义需要用到一个英文的句号 . 需要注意的是：具有相同 class 属性的标签看作一个标签组，对其操作会应用于所有具有相同 class 属性的标签中。 示例所示： 123.black { color: black;} .black 选择器能够匹配文档中所有具有 class=&quot;black&quot; 属性的标签组。 [1] &gt;&gt;&gt; 指定标签中使用 Class 选择器 由于 class 属性不是唯一的，可以应用于不同的标签，因此你还可以在定义类选择器时结合标签选择器进行匹配，如下所示： 123p.black { color: black;} p.black 选择器仅会将其中的样式应用到所有具有 class=&quot;black&quot; 属性的 &lt;p&gt; 标签中，对于其它的具有 class=&quot;black&quot; 属性的标签则没有影响。 [2] &gt;&gt;&gt; 多类选择器 我们知道，一个 HTML 标签中 class 属性可能不止一个，例如： 12&lt;p class=&quot;info selected&quot;&gt;&lt;/p&gt;&lt;p class=&quot;info&quot;&gt;&lt;/p&gt; 假如我们要为所有 class 属性包含 info 的元素设置粗体；为所有 class 属性包含 selected 的元素设置红色字体；为 class 属性中既包含 info 又包含 selected 的元素设置蓝色背景。则可以写成下面这样： 123456789.info { font-weight: bold;}.selected { color: red;}.info.selected { background: blue;} 这种由多个 class 属性值所组成的类选择器我们可以称之为 多类选择器，而前面介绍的由单个 class 属性值定义的类选择器可以称为 单类选择器。 注意：多类选择器中，多个 class 属性之间是紧挨着的（.info.selected），不需要使用空格分开（.info .selected）。 通配符选择器通配符选择器用星号 * 表示，它不匹配某个特定的 HTML 元素，而是匹配 HTML 文档中的每个元素。 在实际使用中，我们通常使用通配符选择器来清除 HTML 元素中默认的内外边距，如下所示： 1234* { margin: 0 auto; padding: 0;} 注意：虽然通用选择器内的样式规则能够应用于 HTML 文档中的每个元素，但并不建议在生产环境中过于频繁地使用通用选择器。正是因为通用选择器会匹配网页上每个元素的特点，频繁的使用会给浏览器带来太多不必要的压力。 后代选择器后代选择器又称为 包含选择器，可以 选择 父元素里面子元素。其写法就是 外层标签写在前面，内标签写在后面，中间用空格分隔。当标签发生 嵌套 时，内层标签就成为外层标签的后代。 其标准语法格式如下（子元素可以是孙子）： 123父元素 子元素{ 样式声明} 你可以组合类选择器，匹配具有指定 Class 属性的父元素后代： 123.nav li a { color: green;} 需要注意的是，ul li a 选择器仅会匹配无序列表 &lt;ul&gt; 标签的所有后代 &lt;a&gt; 标签。如下： 123ul li a { text-decoration: none;} 子选择器子选择器与后代选择器类似，不过 子选择器 只能匹配作为某元素的 最近一级子元素。简单理解就是 选亲儿子元素。 其标准语法格式如下（大于号隔开）： 123父元素 &gt; 子元素{ 样式声明} 子元素必须是亲儿子，其孙子、重孙之类都不归他管。你也可以叫他 亲儿子选择器。 事实上，看到这里你也应该知道，子选择器也可组合 Class 选择器（很灵活），可以匹配具有指定 Class 属性的父元素的亲儿子元素。如下： 123.nav &gt; a { color: green;} 相邻兄弟选择器相邻兄弟选择器用于匹配某个元素之后紧邻的另一个元素（拥有同一个父级元素并且不存在嵌套关系），相邻兄弟选择器的定义需要用到加号 +。 相邻兄弟选择器匹配的是加号后面的元素（只修改该元素样式）！！！如下： 1234h2 + p { color: blue; font-size: 18px;} 上面示例，会匹配到所有 h2 元素后紧邻的 p 元素，并设置其样式。 当然了，相邻兄弟选择器也可组合 Class 选择器（很灵活），可以匹配具有指定 Class 属性元素的紧邻兄弟元素。如下： 1234h2.task + p { color: blue; font-size: 18px;} 你可以认为，相邻兄弟选择器用于匹配并设置某个元素的 关系最好（紧邻）的兄弟元素。 通用兄弟选择器与相邻兄弟选择器非常相似，但却没有那么严格（非关系最好或紧邻）。 也即是说，通用兄弟选择器同样会匹配同一父级元素下的 所有兄弟元素，兄弟元素之间无需紧邻，定义需要用到波浪号 ~。 示例如下： 1234h1 ∼ p { color: blue; font-size: 18px;} 匹配的是，和 h1 处于同一层（兄弟关系）的所有 p 元素，并设置 p 元素的样式。 同样的，通用兄弟选择器也可组合 Class 选择器（很灵活）使用，如下： 1234.task ~ p{ color: #f0f; font-size: 30px;} 并集选择器并集择器可以将同样的样式规则应用到多个选择器中，每个选择器之间使用逗号 , 进行分隔。这样可以避免定义重复的样式规则，最大程度地减少 CSS 样式表中的代码。 例如，在 CSS 样式表中，不同的选择器中可能包含同样的样式规则（font-weight: normal），如下所示： 123456789101112h1 { font-size: 36px; font-weight: normal;}h2 { font-size: 28px; font-weight: normal;}h3 { font-size: 22px; font-weight: normal;} 为了减少 CSS 样式表中的代码（尤其是不同选择器中具有大量的相同样式时），你可以： 123456789101112h1, h2, h3 { font-weight: normal;}h1 { font-size: 36px;}h2 { font-size: 28px;}h3 { font-size: 22px;} 需要注意的时，任何形式的选择器都可以作为并集选择器的一部分 &gt;&gt;&gt; 12345h1,p,.pig li {color: pink;} 属性选择器属性选择器用来匹配 具有特定属性 的元素，定义需要用到中括号 [] 来指定标签属性。 例如，匹配具有 title 属性的 p 元素： 123p[title] { color: blue;} 需要注意的时，匹配时只要 p 元素中具有 title 属性就会被匹配到。如果你只想匹配具有特定 title 属性值的 p 元素，你可以： 123p[title=&quot;test&quot;] { color: blue;} 结合正则表达式用法 &gt;&gt;&gt; 例如，属性选择器中方括号 [] 内的属性信息还支持以下几种写法： [target=_blank]：选择所有具有 target=&quot;_blank&quot; 属性的元素； [title~=flower]：选择 title 属性包含单词 flower 的所有元素； [lang|=en]：选择 lang 属性正好是 en 或以 en 为开头的所有元素。 | &gt;&gt;&gt; ========================================= Split Line====================================== &lt;&lt;&lt; | 事实上，CSS 中，还可以根据选择器的类型把选择器分为 基础选择器 和 复合选择器。 复合选择器是 由两个或多个基础选择器，通过不同的组合而成的。可以实现更加准确、更高效的匹配目标元素。 例如，常用的复合选择器包括：后代选择器 &amp;&amp; 子选择器 &amp;&amp; 相邻兄弟选择器 &amp;&amp; 通用兄弟选择器 &amp;&amp; 并集选择器，以及后面我们将会学到的 伪类选择器。 HTML 嵌入 CSS 样式CSS 样式既可以作为单独的文件（后缀为 .css 类型的文件）引入到 HTML 文档中，也可以直接写在 HTML 文档中。 CSS 可以通过以下四种方式添加到 HTML 中: 内联（行内）样式：使用 HTML 标签的 style 属性定义 CSS 样式； 内部样式表：使用 &lt;style&gt; 元素在 HTML 文档头部 &lt;head&gt; 区域定义 CSS 样式； 链接式（外部样式表）：使用 &lt;link&gt; 标签引入外部 CSS 样式表文件； 导入式（外部样式表）：使用 @import 命令导入外部 CSS 样式表文件。 最好的方式是通过外部样式表的方式，为 HTML 页面引入样式，以实现页面内容与表现形式分离。 内联样式你可以直接使用 HTML 标签的 style 属性来定义 CSS 样式。 其属性值是一个或多个由分号分隔的 CSS 属性:值 对，例如 style = “color:blue; text-align:center“。 一个修改字体、字体背景、字体颜色、字体大小、文本对齐方式以及 Div 块区使用内联样式的示例： 12345678910&lt;h1 style=&quot;font-family: verdana; text-align: center;&quot;&gt;A Center-aligned Heading&lt;/h1&gt;&lt;p style=&quot;background-color: aquamarine;&quot;&gt;A paragraph with background-color.&lt;/p&gt;&lt;p style=&quot;color:aquamarine;&quot;&gt;A paragraph with color.&lt;/p&gt;&lt;p style=&quot;font-size: 20px;&quot;&gt;A paragraph with 20px font-size.&lt;/p&gt;&lt;div style=&quot;background-color:bisque; color:blue; text-align: center;&quot;&gt; &lt;h2&gt;A Heading&lt;/h2&gt; &lt;p&gt;A paragraph.&lt;/p&gt; &lt;strong&gt;Inline elements: strong&lt;/strong&gt;&lt;/div&gt; 你可以发现，内联样式虽然编写简单，可以发现存在以下缺陷： 每一个标签要设置样式都需要添加 style 属性； 后期维护成本高，当修改页面时需要逐个打开网站每个页面一一修改； 添加如此多的行内样式，页面体积大，门户网站若釆用这种方式编写，那将浪费服务器带宽和流量。 内部样式表你可以直接使用嵌入到 HTML 文档头部 &lt;head&gt; 区域的 &lt;style&gt; 元素为当前文档定义 CSS 样式。 内部样式表的特点是该样式只能在此页使用，解决内联样式针对标签多次书写的弊端。 一个修改段落标签样式的示例： 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;HTML 演示&lt;/title&gt; &lt;style&gt; p{ text-align: left; /* 文本左对齐 */ font-size: 14px; /* 字体大小 14 像素 */ line-height: 25px; /* 行高 25 像素 */ text-indent: 2em; /* 首行缩进两个文字大小空间 */ width: 500px; /* 段落宽度 500 像素 */ margin: 0 auto; /* 浏览器下居中 */ } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;“百度”这一公司名称便来自宋词“众里寻他千百度”。（百度公司会议室名为青玉案，即是这首词的词牌）。而“熊掌”图标的想法来源于“猎人巡迹熊爪”的刺激，与李博士的“分析搜索技术”非常相似，从而构成百度的搜索概念，也最终成为了百度的图标形象。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 尽管解决了针对具有相同样式标签的多次设置，但仍然未实现网页结构与样式的分离。这就体现在，当样式需要被应用到很多页面的时候，仍然需要针对每个页面都要修改，不灵活啊。 链接式你可以直接使用 &lt;link /&gt; 标签在 HTML 文档头部 &lt;head&gt; 区域引入外部的 CSS 样式表文件，也称为外部样式表。这是络上网站应用最多的方式，同时也是最实用、最理想的方式。 链接式将 HTML 页面结构和样式完全分离，实现结构层和表示层的彻底分离，使 HTML 代码专门构建页面结构，而美化工作由 CSS 完成。增强了网页结构的扩展性和 CSS 样式的可维护性。 使用链接式为 HTML 代码应用样式示例： 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;HTML 演示&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css/style1.css&quot; type=&quot;text/css&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;css/style2.css&quot; type=&quot;text/css&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;百度渊源&lt;/h2&gt; &lt;p&gt;“百度”这一公司名称便来自宋词“众里寻他千百度”。（百度公司会议室名为青玉案，即是这首词的词牌）。而“熊掌”图标的想法来源于“猎人巡迹熊爪”的刺激，与李博士的“分析搜索技术”非常相似，从而构成百度的搜索概念，也最终成为了百度的图标形象。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 其中，HTML 中 &lt;link&gt; 标签专门用来定义文档与外部资源的关系，最常见的用途是链接外部样式表。其 href 属性用于定义链接文档的 URL，rel 属性定义当前文档与被链接文档之间的关系，type 属性用来定义被链接文档的 MIME 类型。 两个外部样式表内容如下 &gt;&gt;&gt;&gt; style1.css 文件代码： 12345h2{ background-color: aqua; height: 50px; line-height: 50px;} style2.css 文件代码： 123456p{ text-align: left; /* 文本左对齐 */ font-size: 14px; /* 字体大小 14 像素 */ line-height: 25px; /* 行高 25 像素 */ text-indent: 2em; /* 首行缩进两个文字大小空间 */} 通常，网站制作者会将公共部分样式放入一个 CSS 文件，当前页面样式编写新的样式文件。 链接式导入 CSS 样式的好处： CSS 文件可以应用于不同的 HTML 文件中，使网站所有页面样式统一； 将 CSS 代码放入一个 CSS 文件中便于管理、减少代码以及维护时间； 修改 CSS 文件时，所有应用此 CSS 文件的 HTML 文件都将更新，而不必从服务器上将所有的页面取回再修改完毕后上传。 导入式你也可以直接使用 @import 命令导入外部 CSS 样式表文件，它是 CSS2.1 新引入的一张导入方式，一些低版本浏览器可能不支持。 这里简单了解一下就行，更多使用的链接式的导入方式。 导入样式使用 @import 命令导入外部样式表。导入样式书写方式： 1234567&lt;style&gt;@import test.css;@import &quot;test.css&quot;;@import url(test.css);@import url('test.css');@import url(&quot;test.css&quot;);&lt;/style&gt; 需要注意的是，在 HTML 文档中使用 @import 时，@import 需要定义在 &lt;style&gt; 标签中。如果 &lt;style&gt; 标签中还有其它的 CSS 样式，那么 @import 就必须定义在所有样式的最前面。示例代码如下： 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;HTML 演示&lt;/title&gt; &lt;style&gt; @import url(css/style1.css); @import &quot;css/style2.css&quot;; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h2&gt;百度渊源&lt;/h2&gt; &lt;p&gt;“百度”这一公司名称便来自宋词“众里寻他千百度”。（百度公司会议室名为青玉案，即是这首词的词牌）。而“熊掌”图标的想法来源于“猎人巡迹熊爪”的刺激，与李博士的“分析搜索技术”非常相似，从而构成百度的搜索概念，也最终成为了百度的图标形象。&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 和链接式不同的是：使用 &lt;link&gt; 标签引用的样式文件会随页面同时加载，而使用 @import 引用的样式文件会等待页面加载完成后再加载。 如果 @import 引用的样式文件过大、加载时间过长的话，在页面加载完成后就会出现没有样式的情况，影响用户体验。 CSS 特性CSS 中具有如下三大特性： 继承 层叠 优先级 了解 CSS 的三大特性对于深入理解 CSS 样式表匹配、修改 HTML 元素样式具有重要的意义。 CSS 继承CSS 的继承特性，是指 子类元素会继承父类的样式。 也就是说，指对某个元素所设定的样式，不但影响该元素本身，还会影响该元素的后代元素。 示例代码如下： 123456div { color: red;}&lt;div&gt; Text1. &lt;p&gt;Text2.&lt;/p&gt;&lt;/div&gt; 此时，如果 p 元素未设置样式的话，它会继承其父类 div 元素。 需要注意的是，HTML 元素通过继承而来的样式显示优先级，仅高于浏览器默认样式（User Agent Stylesheet）。任何方式的嵌入 CSS 样式（内联样式、内部样式表、外部样式表等）都高于继承优先级，会覆盖继承的样式。 CSS 层叠CSS 的层叠特性是 CSS 最重要的三大特性之一。 多重样式层叠我们知道，HTML 中允许以多种方式嵌入 CSS 样式：内联样式、内部样式表、外部样式表，甚至可以在同一个 HTML 文档内部引用多个外部样式表。 思考一下 &gt;&gt;&gt; 当同一个 HTML 元素被不止一种嵌入方式定义时，会使用哪个样式呢？！！ 一般而言，所有的样式会根据下面的规则层叠于一个新的虚拟样式表中（多重样式层叠为一），样式声明使用优先级如下： 内联样式 &gt; 内部样式表 &gt; 外部样式表 &gt; 继承 &gt; 浏览器缺省设置（User Agent Stylesheet）。 单样式层叠上一小节我们讨论了使用多种嵌入 CSS 样式方式同时定义同一 HTML 文档中某一元素样式时的冲突问题。 这里的单样式层叠指的是，仅使用外部样式表（或内部样式表）的方式，可以多次对同一 HTML 元素的同一属性设定 CSS 样式，后面定义的样式会覆盖前面定义的样式。 例如（最终文本显示蓝色）： 123456div { color: red; }div { color: blue; }&lt;div&gt; Text1.&lt;/div&gt; 这里我们仅说明了（选择器相同，设置了同样的属性，后者覆盖前者）的情况。 那么，不同类型的 CSS 选择器，设置了同样的属性，还会是后者覆盖前者吗？？？尝试如下样例（解释请参见下一小节）： 123456789101112&lt;!-- Class Selector --&gt;.test { color: blue;}&lt;!-- Tag Selector --&gt;div { color: red;}&lt;div class=&quot;test&quot;&gt; Text1&lt;/div&gt; CSS 优先级我们知道，不同类型的 CSS 选择器代表不同的 HTML 元素匹配规则。 还是仅讨论单样式层叠的情况，当这些不同的规则都作用到了同一个 HTML 元素上时，如果定义的属性有冲突，那么应该使用那种规则？？？ 这就要涉及到 CSS 的优先级特性了~~~ [1] &gt;&gt;&gt; 基础选择器 CSS 层叠优先级展示如下（从高到低）： !important（见后文说明） ID 选择器 伪类选择器 属性选择器 类选择器 标签选择器 通配符选择器 继承 浏览器自定义设置（User Agent Stylesheet） 常用排序：!important &gt; 内联样式 &gt; { ID 选择器 &gt; … &gt; 类选择器 &gt; … &gt; 标签选择器 &gt; 通配符选择器 } &gt; 继承 &gt; 浏览器默认属性。 上面涉及到的主要都是基础选择器，那么由基础选择器组成的复合选择器如何判断优先级？？？ [2] &gt;&gt;&gt; 复合选择器 事实上，网络上存在一个权重计算标准： 内联样式表的权值最高 1000 ID 选择器的权值为 100 Class 类选择器的权值为 10 HTML 标签选择器的权值为 1 复合选择器权重越高，其优先级越高。它等于组成它的 基础选择器的权重和！！！例如： 12345678div.test { width:100px; height: 100px;}.test.test1 { width:200px; height: 200px;} 其中，div.test 复合选择器权重为：1+10=11，.test.test1 复合选择器权重为：10+10=20。这就意味着后者会覆盖前者的样式。 简洁 &amp;&amp; 高效的 CSS所谓高效的 CSS 就是，让浏览器查找更少的元素标签来确定匹配的 Style 元素。 [1] &gt;&gt;&gt; 不要在 ID 选择器前使用标签名 12345/* 一般写法 */div#divBox{color:red;}/* 推荐写法 */#divBox{color:red;} 解释：因为 ID 选择器是唯一的，加上 div 反而增加不必要的匹配。 [2] &gt;&gt;&gt; 不要在 Class 选择器前使用标签名 12345/* 一般写法 */span.red{color:red;}/* 推荐写法 */.red{color:red;} 解释：如果没有相同的名字出现就是没必要，但是如果存在多个相同名字的类选择器则有必要添加标签名防止混淆。 [3] &gt;&gt;&gt; 尽量少使用层级关系 12345/* 一般写法 */#divBox p .red{color:red;}/* 推荐写法 */.red{color:red;} [4] &gt;&gt;&gt; 使用 Class 代替层级关系 12345/* 一般写法 */#divBox p .red{color:red;}/* 推荐写法 */.red{color:red;} CSS 注释注释是用来解释你的代码，并且可以随意编辑它，浏览器在解析时会忽略它。 CSS 注释以 /* 开始，以 */ 结束，进行行、块注释。实例代码如下： 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;HTML 演示&lt;/title&gt; &lt;style&gt; /* 这是一个内部样式表 * 这里，使用内部样式表来设定样式 */ .test { color: blue; /* 设置字体颜色为蓝色 */ } div { color: red; /* 设置字体颜色为红色 */ } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; Text1. &lt;p&gt;&lt;/p&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;","link":"/2019/01/11/css-jiao-cheng-zhi-css-ji-chu-yu-fa/"},{"title":"HTML 教程之 HTML 头部与文件路径","text":"HTML 中的 Head 头部元素以及外部文件引用路径。 HTML Head 头部HTML Head 头部元素包含了所有的头部标签元素，用于定义文档相关的概要信息，例如：HTML 文档的元数据（Meta）、以及所需资源的引用（CSS &amp;&amp; Javascript），对文档能够在浏览器中正确显示起到了非常重要的作用。 &lt;head&gt; 头部元素区域可添加的元素标签为: &lt;title&gt; &amp;&amp; &lt;base&gt; &amp;&amp; &lt;style&gt; &amp;&amp; &lt;meta&gt; &amp;&amp; &lt;link&gt; &amp;&amp; &lt;script&gt; &amp;&amp; &lt;noscript&gt;。 下面分别来看如何使用： TitleTitle 元素在 HTML/XHTML 文档中是必须的，用于定义 HTML 文档的标题。&lt;title&gt; 标签仅允许存在一个，其内容仅允许包含纯文本内容，不能包含其它 HTML 标签。 Title 元素定义的 HTML 文档标题显示于：浏览器标题栏（标签栏）、当将页面添加到收藏夹（书签）时提供标题、显示在搜索引擎结果页面的标题。 Title 元素使用： 1234&lt;head&gt; &lt;meta charset=&quot;utf-8&quot; /&gt; &lt;title&gt;HTML 演示&lt;/title&gt;&lt;/head&gt; BaseBase 元素用来定义一个链接地址，作为当前 HTML 文档中所有相对链接的基本链接。 设置了基本链接后，当前页面中的所有相对链接都会使用这个基本链接作为前缀。如下： 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;HTML 演示&lt;/title&gt; &lt;base href=&quot;https://www.orangeshare.cn/&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;index.html&quot;&gt;Home Page&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;categories/index.html&quot;&gt;Blog Categories&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt;&lt;/html&gt; 上面示例中，第一个 li 中链接会被解析为：https://www.orangeshare.cn/index.html；第二个 li 中链接会被解析为：https://www.orangeshare.cn/categories/index.html。 需要注意的是，HTML 文档中的 &lt;base&gt; 标签必须出现在任何引用外部资源的标签之前，而且一个 HTML 文档中仅允许定义一个 &lt;base&gt; 标签。 LinkLink 元素用于定义文档中对外部资源的引用，常用于引入外部的 CSS 样式表或 Javascript 脚本。 Head 元素中可以包含任意数量的 &lt;link&gt; 标签。&lt;link&gt; 标签中包含两个主要的属性，分别是 rel 和 href。 rel 属性用来指示引用文件的类型，href 属性用来设置外部文件的路径。示例代码如下： 123&lt;head&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;style.css&quot; type=&quot;&quot; /&gt; &lt;/head&gt; 还有一个常见的属性：type，定义被链接文档/资源的 MIME （媒体）类型。只有当设置了 href 属性时，才能使用该属性其属性值是 MIME_type 的，支持如下媒体类型： 123456789101112131415text/plaintext/htmltext/cssimage/jpegimage/pngaudio/mpegaudio/oggaudio/*video/mp4application/*application/jsonapplication/javascriptapplication/ecmascriptapplication/octet-stream… Style前面提到过，&lt;style&gt; 标签用于在 HTML 文档中嵌入 CSS 样式，属于内部样式表。 123456&lt;head&gt; &lt;style&gt; body {background-color:yellow} p {color:blue} &lt;/style&gt;&lt;/head&gt; MetaMeta 元素用于定义有关 HTML 文档的元数据，元素据不会显示在页面上，但是对于机器是可读的（可解析的），例如：页面描述、关键词、文档的作者、最后修改时间以及其它。 [1] &gt;&gt;&gt; 定义字符集 HTML 5 中，新增了一个 charset 属性，使得 HTML 文档字符集定义更容易了，可用来解决文档编码问题。 HTML 4.01 中符集定义： 1&lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html; charset=UTF-8&quot; /&gt; HTML 5 中符集定义： 1&lt;meta charset=&quot;UTF-8&quot; /&gt; [2] &gt;&gt;&gt; 定义页面描述 &amp;&amp; 文档关键词 &amp;&amp; 页面作者 需要 name &amp;&amp; content 属性搭配使用。其中 name 用来表示定义的是什么元数据，其值包括：author &amp;&amp; description &amp;&amp; keywords &amp;&amp; application-name &amp;&amp; generator；其具体值通过关联 content 属性值获得。 也就是说，你定义了一个页面作者 name=author 的元数据，页面作者要通过关联 content=John 获得，为 John。 实例 1 - 定义文档关键词，用于搜索引擎： 1&lt;meta name=&quot;keywords&quot; content=&quot;HTML, CSS, XML, XHTML, JavaScript&quot; /&gt; 实例 2 - 定义 Web 页面描述： 1&lt;meta name=&quot;description&quot; content=&quot;Free Web tutorials on HTML and CSS&quot; /&gt; 实例 3 - 定义页面作者： 1&lt;meta name=&quot;author&quot; content=&quot;Hege Refsnes&quot; /&gt; [3] &gt;&gt;&gt; http-equiv 属性 上面提到过，HTML 4.01 中 http-equiv 是规定 HTML 文档的字符集的唯一方式： 1&lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html; charset=UTF-8&quot; /&gt; http-equiv 相当于 HTTP 的头文件，向浏览器传递有用的信息。并且类似于上面的 name 属性，需要搭配 content 属性使用。 http-equiv 支持定义的页面元数据如下： content-type：规定文档的字符编码； default-style：规定要使用的预定义的样式表，其对应的 content 属性的值必须匹配同一文档中的一个 link 元素上的 title 属性的值，或者必须匹配同一文档中的一个 style 元素上的 title 属性的值； refresh：定义文档自动刷新的时间间隔（慎重使用，会使得页面不受用户控制）。 示例如下： 12345678&lt;!-- HTML 4.0.1 中定义字符集 --&gt;&lt;meta http-equiv=&quot;content-type&quot; content=&quot;text/html; charset=UTF-8&quot; /&gt;&lt;!-- 规定要使用的预定义的样式表 --&gt;&lt;meta http-equiv=&quot;default-style&quot; content=&quot;the document's preferred stylesheet&quot; /&gt;&lt;!-- 每 30s 自动刷新页面 --&gt;&lt;meta http-equiv=&quot;refresh&quot; content=&quot;30&quot; /&gt; content 属性定义与 http-equiv 或 name 属性相关的元信息，其属性值是文本类型（text）的。需要搭配 http-equiv 或 name 属性使用，是一个辅助属性。 Script&lt;script&gt; 标签用于定义 JavaScript 脚本，示例代码如下： 12345&lt;head&gt; &lt;script&gt; document.write(&quot;Meet JavaScript&quot;) &lt;/script&gt;&lt;/head&gt; 具体可学习网络上的 JavaScript 教程，这里了解就好。 Noscript当用户的浏览器不支持 JavaScript 脚本或者禁用 JavaScript 脚本时，可以在 &lt;noscript&gt; 标签中定义一些内容来替代不能运行的 JavaScript 脚本或者给用户一些提示。 除了 &lt;script&gt; 标签外，在 &lt;noscript&gt; 标签中可以包含任何 HTML 元素，如下例所示： 12345678&lt;head&gt; &lt;script&gt; document.write(&quot;Meet JavaScript&quot;) &lt;/script&gt; &lt;noscript&gt; &lt;p&gt;当前浏览器不支持 JavaScript，或者您禁用了 JavaScript！&lt;/p&gt; &lt;/noscript&gt;&lt;/head&gt; HTML Lang=zh-CN根据 W3C 推荐标准，您应该通过 &lt;html&gt; 标签中的 lang 属性对每张页面中的主要语言进行声明，这对搜索引擎和浏览器是有帮助的: 比如声明网页主要语言为英文： 123&lt;html lang=&quot;en&quot;&gt;...&lt;/html&gt; 在 XHTML 中，采用如下方式在 标签中对语言进行声明： 123&lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; lang=&quot;en&quot; xml:lang=&quot;en&quot;&gt;...&lt;/html&gt; 关于各国语言缩略词可参考 &gt;&gt;&gt; ISO 639-1 语言代码。 你可以尝试一下，如果你在中国，本地浏览器的默认语言是中文，当我们打开一个外国网站（en）时，浏览器会提示 “是否将网页内容翻译成中文”？。登录几个中国的本土网站（zh-CN），发现源码中并没有写 lang 属性，也没有翻译的提示，默认中文。 浏览器会将读取到的页面语言和本地语言进行比较判断，如果一致，不做处理，否则提示是否需要翻译（当然前提是用户勾选了这个功能，Chrome 默认勾选）。 HTML5 中, lang 属性可用于任何的 HTML 元素 (它会验证任何 HTML 元素。但不一定是有用)。HTML 4.01 中, lang 属性不能用于: &lt;base&gt;, &lt;br&gt;, &lt;frame&gt;, &lt;frameset&gt;, &lt;hr&gt;, &lt;iframe&gt;, &lt;param&gt;, &lt;script&gt; 等。 HTML 文件路径文件路径用于定义，网站文件夹结构中（WEB 服务器上）某个文件的位置。 文件路径会在链接外部文件时被用到： 网页 图像 样式表 JavaScript 下面以图像的绝对路径和相对路径进行说明，其它网络资源文件同理： 绝对文件路径绝对路径好理解，就是图片在计算机中的完整存储路径，例如 E:/HTMLDemo/images/kawayi.jpg。 而对于网络图片资源而言，绝对路径就是万维网中图片的完整 URL。例如：https://www.domain.com/images/kawayi.jpg。 相对文件路径而相对路径是指，图片相对于当前 HTML 网页文档的路径。 先以本地计算机中图片为例： 假设，图片资源和 HTML 文档位于同一文件夹下，你可以通过如下代码使用图片： 1&lt;img src=&quot;kawayi.jpg&quot;&gt; 假设，图片资源位于 HTML 文档的上一级目录中，你可以通过如下代码使用图片： 1&lt;img src=&quot;../kawayi.jpg&quot;&gt; 同理，上上级就是 ../../kawayi.jpg，同级 images 目录下就是 images/kawayi.jpg（相当于下级目录）。 需要注意的是，并不是只有本地图片资源才可以使用相对路径！！！ 前面提到过，网站可以看作是一个绑定了特定域名的顶级目录，该目录（网站文件夹结构）位于提供 Web 服务的远程服务器上，故该网站中的网页可以访问到该顶级目录下的资源（图片、文件等）。 故，当你有了一个自己的 Web 站点之后，你在 Web 站点中的网页中插入图片时，也可以使用相对路径的定义方法。 推荐方案如果可能的话，使用文件的相对路径是个好习惯。 相对路径优势 &gt;&gt;&gt; 如果使用了相对路径，那么你的网页就不会与当前的基准 URL 进行绑定，避免网页上传至服务器后需要重新修改相关资源文件的路径（路径失效）。 这也就意味着，相对路径的定义方法降低和本地环境的关联性，所有文件路径在你的本地电脑上 (localhost &gt;&gt;&gt; 本地开发) 或未来的公共域（WEB Server &gt;&gt;&gt; 产品发布）中均可正常工作。 如果你想深入了解 URL 的内容，可以参考博文系列中 &gt;&gt;&gt; 网站基础之 URL 全结构解析 一文。","link":"/2019/01/03/html-jiao-cheng-zhi-html-tou-bu-yu-wen-jian-lu-jing/"},{"title":"CSS 教程之 CSS 颜色和长度说明","text":"CSS 中的颜色设置，以及元素长度单位说明。 CSS 颜色在前面博文【HTML 教程之 HTML 字符集和颜色】中提到过，HTML 颜色采用的是 RGB 颜色模式，是通过对红 (R)、绿 (G)、蓝 (B) 三个颜色通道的变化以及它们相互之间的叠加来得到各式各样的颜色的。 并且，我们还提到可以使用颜色值（Color Value，3/6 位十六进制颜色值/RGB）和颜色名称（Color Name）来指定 HTML 元素的颜色。 CSS 中也提供了 不同模式 的值来为元素指定颜色，如下表所示： 值 描述 实例 Color Name 使用颜色名称（不区分大小写）来设置具体的颜色，例如 red、blue、brown color: red; Color Value 使用 3/6 位十六进制字符的形式来设置具体颜色，形式：#RRGGBB 或 #RGB，例如 #ff0000 color: #f03; RGB 使用 rgb() 函数（R &amp;&amp; G &amp;&amp; B）三通道的强度进行控制，从而实现不同的颜色 color: rgb(255,0,51); RGBA RGBA 扩展了 RGB，在 RGB 的基础上增加了 alpha 通道来设置颜色的透明度，需要 rgba() 函数 color: rgba(255,0,0,0.1); HSL 使用 hsl() 函数，对颜色的色调、饱和度、亮度进行调节，从而实现不同的颜色 color: hsl(120,100%,25%); HSLA HSLA 扩展了 HSL，在 HSL 的基础上增加了 alpha 通道来设置颜色的透明度，需要 hsla() 函数 color: hsla(240,100%,50%,0.5); Color Name使用颜色名称来设置颜色是最简单的方法。 颜色名称是通过一些标准定义好的颜色名，目前所有浏览器都支持 141 个标准颜色名称（ HTML 和 CSS 颜色规范定义） 17 标准颜色：黑色，蓝色，水，紫红色，灰色，绿色，石灰，栗色，海军，橄榄，橙，紫，红，白，银，蓝绿色，黄色。再加 124 个其它颜色。 关于HTML 和 CSS 颜色名称支持，你可以参考 &gt;&gt;&gt; HTML 颜色手册。 需要注意的是，不同的浏览器之间对颜色的解析可能存在差异，为了安全起见，不建议你在 CSS 中使用颜色名称来指定颜色。 Color Value使用 3 位 或 6 位十六进制码的形式设置颜色是最常见的一种方法。 它们都可以分为三组，分别对应 R &amp;&amp; G &amp;&amp; B 三个颜色通道，形式为：#RRGGBB（6 位） 或 #RGB（3 位）。 在使用十六进制码表示颜色时，如果每组的两个十六进制数都是相同的，例如 #00ff00、#ffffff、#aabbcc，则可以将它们简写为 #0f0、#fff、#abc。 需要注意的是，你不需要查颜色手册，可以通过一些 取色器 软件即可获取任意可见颜色的十六进制码。 RGBCSS 中要使用 RGB 模式来设置颜色需要借助 rgb() 函数，函数的语法格式如下： 1rgb(red, green, blue) 其中，red、green、blue 分别表示三原色红、绿、蓝的强度，这三个参数的取值可以是 0~255 之间的整数，也可以是 0%~100% 之间百分比数值。 样例如下： 123456h1 { color: rgb(255, 165, 0);}p { color: rgb(0%, 100%, 0%);} RGBARGBA 是 RGB 的扩展，在 RGB 的基础上又增加了对 Alpha 通道的控制，Alpha 通道可以设置颜色的透明度。 故，CSS 中要使用 RGBA 模式来设置颜色需要借助 rgba() 函数，函数的语法格式如下： 1rgba(red, green, blue, alpha); 其中，alpha 表示颜色的透明度，取值为 0~1（ 0 表示完全透明，1 表示完全不透明）之间的小数。 样例如下： 123p { color: rgba(255, 0, 0, 0.5);} HSLHSL 是 Hue（色调）、Saturation（饱和度）、Lightness（亮度）的缩写，它同样也是一种色彩模式，可以通过对色调、饱和度、亮度三个属性的调节来实现不同颜色的。 CSS 中要使用 HSL 模式来设置颜色需要借助 hsl() 函数，函数的语法格式如下： 1hsl(hue, saturation, lightness) 其中， [1] &gt;&gt;&gt; hue 参数 hue 表示颜色在色盘上的度数（0~360），0/360 表示红色，120 表示绿色，240 表示蓝色。 [2] &gt;&gt;&gt; saturation 参数 saturation 为一个百分比数值，表示色彩的饱和度，0% 表示灰色，100% 表示全彩。 [3] &gt;&gt;&gt; lightness 参数 lightness 同样为一个百分比数值，表示颜色的亮度，0% 是黑色（没有亮度），50% 为最合适的亮度（既不发黑也不过亮），100% 是白色（曝光严重）。 实例如下： 123p { color: hsl(0, 100%, 50%);} HSLAHSLA 是 HSL 的扩展，在 HSLA 中增加了对 Alpha 通道（颜色透明度）的控制，其余与 HSL 相同。 CSS 中要使用 HSLA 模式来设置颜色需要借助 hsla() 函数，函数的语法格式如下： 1hsla(hue, saturation, lightness, alpha) 其中，alpha 表示颜色的透明度，取值为 0~1（ 0 表示完全透明，1 表示完全不透明）之间的小数。 实例如下： 123p { color: hsla(0, 100%, 50%, 0.5);} CSS 长度单位HTML 中元素的尺寸是非常的属性，例如字体大小、元素宽高等等，这就要涉及到长度的单位问题。 CSS 支持多种不同的长度单位，根据类型的不同可以分为两类： 绝对长度单位； 相对长度单位。 下面我们来看 CSS 中支持的几种具体度量单位： 绝对长度单位绝对长度单位表示一个真实的物理尺寸，它的大小是固定的，不会因为其它元素尺寸的变化而变化。 如下列举了 CSS 中支持的绝对长度单位（常用高亮）： 单位 描述 示例 cm 厘米 p{font-size: 0.5cm;} mm 毫米 p{font-size: 5mm;} in inch 英寸（1in = 96px = 2.54cm） p{font-size: 1in;} px pixel 像素（1px = 1/96in） p{font-size: 16px;} pt point，专用印刷单位 “磅”，（1pt = 1/72in） p{font-size: 16pt;} pc pica，专用字体大小印刷单位 “派卡”，相当于我国新四号铅字的尺寸（1pc = 12pt） p{font-size: 5pc;} 实例代码如下： 1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;CSS 演示&lt;/title&gt; &lt;style&gt; .box{ width: 4in; height: 4.5cm; border: 2mm solid black; font-size: 16px; } .pt{ font-size: 6pt; } .pc{ font-size: 3pc; } &lt;/style&gt; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;div class=&quot;box&quot;&gt; 这是 16px 的字体 &lt;p class=&quot;pt&quot;&gt;这是 6pt 的字体&lt;/p&gt; &lt;p class=&quot;pc&quot;&gt;这是 3pc 的字体&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 相对长度单位相对长度单位指的是这个单位没有一个固定的值，它的值受到其它元素属性（例如浏览器窗口的大小、父级元素的大小）的影响。 也即是说，相对长度单位必须有一个对照物，即相对于谁的（那个元素）长度单位，在 响应式布局方面相对长度单位非常适用。 如下列举了 CSS 中支持的相对长度单位（常用高亮）： 单位 描述 示例 em 相对于自身 font-size 属性的值（未设置，默认继承父元素 font-size 属性的值），1em 等同于 font-size=”xx” 的属性值。例如 font-size 的值为 16px，那么 1em 就等于 16px p{line-height:2em;} rem 相对于根元素的 font-size 属性的大小。例如根元素的 font-size 是 100px，那么 1.2rem 就相当于 120px p{font-size: 1.2rem;} ex 相对于所用字体中，小写英文字母 x 的高度，若无法确定 x 的高度则使用 0.5em 计算 p{font-size: 1ex;} ch 相对于所用字体中，数字 0 的高度，若无法确定 0 的高度则使用 0.5em 计算 p{line-height: 3ch} vw 相对于浏览器窗口的宽度，1vw = 窗口宽度的 1% p{font-size: 5vw;} vh 相对于浏览器窗口的高度，1vh = 窗口高度的 1% p{font-size: 5vh;} vmin vw 与 vh 中较小的值 p{font-size: 5vmin;} vmax vw 与 vh 中较大的值 p{font-size: 5vmax;} % 相对于父元素宽度或字体大小的百分比 div{width: 55%} 实例代码如下： 123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;CSS 演示&lt;/title&gt; &lt;style&gt; .box{ width: 50vw; height: 50vh; border: 1ex solid black; font-size: 16px; } .info{ font-size: 2em; } .ex &gt; span{ font-size: 2ex; } .ch &gt; span{ font-size: 4ch; } &lt;/style&gt; &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;box&quot;&gt; &lt;p style=&quot;font-size: 32px;&quot;&gt;这是 32px 的字体&lt;/p&gt; &lt;p class=&quot;info&quot;&gt;这是 2em 的字体&lt;/p&gt; 这是 16px 的字体 &lt;p class=&quot;ex&quot;&gt; x: &lt;span&gt;这是 3ex 的字体&lt;/span&gt; &lt;/p&gt; &lt;p class=&quot;ch&quot;&gt; 0: &lt;span&gt;这是 4ch 的字体&lt;/span&gt; &lt;/p&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;","link":"/2019/01/12/css-jiao-cheng-zhi-css-yan-se-he-chang-du-shuo-ming/"},{"title":"CSS 教程之 CSS 基础样式设置之一","text":"CSS 基础样式设置，包括：背景（Background）样式、文本（Text）样式，以及字体（Fonts）样式。 背景（Background）在制作网页时，我们往往需要在网页中添加一些背景颜色、背景图像等让网页更加美观，吸引访问者的眼球。 CSS 中提供了一系列用于 设置 HTML 元素背景（Background）效果 的属性，如下所示： background-color：设置元素的背景颜色； background-image：设置元素的背景图像； background-repeat：控制背景图像是否重复； background-attachment：控制背景图像是否跟随窗口滚动； background-position：控制背景图像在元素中的位置； background-size：设置背景图像的尺寸； background-origin：设置 background-position 属性相对于什么位置来定位背景图像； background-clip：设置背景图像的显示区域； background：背景属性的缩写，可以在一个声明中设置所有的背景属性。 下面来看各个背景属性的用法： 背景颜色你可以通过 background-color 属性来为元素设置一个背景颜色，该属性支持以下几种属性值： 值 描述 transparent 默认值（设置背景颜色为透明）。大多数情况下并不会用到它，但如果你不希望某个元素拥有背景颜色，或者不希望用户对浏览器的设置（比如开启夜间模式、护眼模式）影响到你的设计，那么就可以使用 transparent 来将颜色设置为透明的 inherit 从父元素继承对背景颜色的设置 CSS Color 符合 CSS 颜色定义的颜色形式值 实例代码如下： 123456789101112131415161718192021222324252627&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;CSS 演示&lt;/title&gt; &lt;style&gt; h1 { background-color: #6495ed; } div { background-color: #e0ffff; } p { background-color: #b0c4de; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;CSS 背景设置实例&lt;/h1&gt; &lt;div&gt; 当前为 div 元素中的一行文本。 &lt;p&gt;该段落拥有自己的背景颜色&lt;/p&gt; 当前仍然为 div 元素中的一行文本。 &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 通过该属性可以为元素设置某种颜色的背景，这种 颜色会填充元素的内容、内边距以及边框区域（也可以理解为边框及以内的所有区域），对于元素边框以外的区域（外边距）则没有影响。 需要注意的是，设置页面的背景颜色，即设置 body 元素的背景色。 背景图像你可以通过 background-image 属性来为某个元素设置背景图像。其属性支持以下几种属性值： 值 描述 none 默认值，不显示背景图像 inherit 从父元素继承背景图像的设置 url(‘URL’) 定义图像的路径，URL 为图像资源地址 实例代码如下： 1234567891011121314151617&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;CSS 演示&lt;/title&gt; &lt;style&gt; h1 { background-color: #6495ed; } p { background-image: url(&quot;images/kawayi.jpg&quot;); } &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;h1&gt;CSS 背景设置实例&lt;/h1&gt; &lt;p&gt;Hello World&lt;/p&gt;&lt;/body&gt; 默认情况下，浏览器会从元素内容的左上角开始（若有内边距则从元素内边距区域的左上角开始），在水平和垂直方向上重复背景图像，以填充整个元素区域，您可以使用 background-repeat 属性来控制背景图像是否重复或如何重复。 需要注意的是，类似于背景颜色填充，背景图像同样会填充元素的内容、内边距以及边框区域，对于元素边框以外的区域（外边距）则没有影响。 图像平铺设置背景图像中提到，默认情况下背景图像会从元素内容的左上角开始（若有内边距则从元素内边距区域的左上角开始），在水平和垂直方向上重复背景图像（图像平铺）以填充整个元素区域（不包括元素的外边距区域）。 看到上述现象，主要是由于用于设置的 背景图像尺寸调小，无法完整填充整个元素空间（边框，以及边框以内的区域）。你可以尝试修改元素尺寸小于图像尺寸，或修改图像尺寸大于元素尺寸再观察一下填充效果。 事实上，当背景图片尺寸较小时，我们可以通过 background-repeat 属性来控制背景图像的平铺方式，支持一下几种属性值： 值 描述 repeat 默认值，背景图像将在垂直方向和水平方向上重复 repeat-x 背景图像仅在水平方向上重复 repeat-y 背景图像仅在垂直方向上重复 no-repeat 背景图像仅显示一次，不在任何方向上重复 inherit 从父元素继承 background-repeat 属性的设置 你可以通过为 background-repeat 属性设置不同的取值，观察一下上一小节实例的效果。 图像位置你可以通过 background-position 属性来设置背景图像的起始位置。其属性支持以下几种属性值： 值 描述 left top（左上）left center（左中）、left bottom（左下）、right top（右上）、right center（右中）、right bottom（右下）、center top（中上）、center center（居中）、center bottom（中下） 使用位置关键词表示背景图像的位置（如果仅设置第一个关键词，那么第二个将默认为 center） x% y% 使用百分比表示背景图像距离元素左上角（0% 0%）的距离，x% 为水平方向，y% 为垂直方向。（如果仅设置第一个值，那么另一个值将是 50%，默认值为 0% 0%） xpos ypos 使用 像素或者其它 CSS 单位 表示背景图像距离元素左上角（0px 0px）的距离，xpos 为水平方向，ypos 为垂直方向。（右下角视元素的尺寸而定，百分比和单位的形式可以混用，如果您仅设置第一个值，那么另一个值将默认为 50%） 你可以通过为 background-position 属性设置不同的取值，观察一下上一小节实例的效果。 如何实现背景图片居中 &gt;&gt;&gt; (50% 50%) 或 (center center) 123background-image: url(&quot;images/kawayi.jpg&quot;);background-repeat: no-repeat;background-position: center center; 图片固定你可以通过 background-attachment 属性来设置背景图像是固定在某个位置还是跟随页面一起滚动。其属性支持以下几种属性值： 值 描述 scroll 默认值，背景图像随着页面元素的滚动而移动 fixed 当页面的其余部分滚动时，背景图像固定不动 inherit 从父元素继承 background-attachment 属性的设置 当你设置为 fixed 后，你会发现图片会被固定到页面初始位置，当页面滚动时，其余部分滚动时，而背景图像固定不动。 图像尺寸你可以通过 background-size 属性来设置背景图像的尺寸。其属性支持以下几种属性值： 值 描述 xpos ypos 使用像素或其它 CSS 单位来设置背景图像的高度和宽度，xpos 表示宽度，ypos 表示高度。如果只设置第一个值，那么第二个值将被设置为默认值 auto（自动） x% y% 使用百分比表示背景图像相对于所在元素宽度与高度的百分比，x% 表示宽度，y% 表示高度。如果只设置第一个值，那么第二个值将被设置为默认值 auto（自动） cover 保持背景图像的横纵比例并将图像缩放至足够大，使背景图像可以 完全覆盖元素所在的区域（可能会导致背景图像的某些部分超出元素区域而无法显示） contain 保持背景图像的横纵比例并将图像缩放至足够大，使背景图像可以 完整的显示在元素所在区域（背景图像可能无法完全覆盖整个元素区域） 使用 background-size 属性设置背景图像的尺寸，并将背景图像完全覆盖整个元素区域（可能导致失真）： 123456div { background-image: url(&quot;images/kawayi.jpg&quot;); background-repeat: no-repeat; background-position: center center; background-size: cover;} 图像相对定位CSS3 中新增了 background-origin 属性。 我们知道，在使用 background-position 属性来设置背景图像的位置时，默认是以元素左上角的位置来计算的。您还可以使用 background-origin 属性来 设置 background-position 属性相对哪个位置（内边距区域、边框区域、内容区域）来定位背景图像。 background-origin 属性的可选值如下： 值 描述 padding-box 相对于元素的内边距区域来定位背景图像 border-box 相对于元素的边框区域来定位背景图像 content-box 相对于元素的内容区域来定位背景图像 【示例】使用 background-origin 属性设置背景图像相对于元素的边框区域来定位： 123456789div { background-image: url(&quot;images/kawayi.jpg&quot;); background-repeat: no-repeat; background-origin: padding-box; background-position: 5px 5px; margin: 20px; /* */ padding: 20px; border: 10px dotted red;} 你可以修改为 background-position: 20px 20px; 再次尝试一下显示效果。甚至 background-origin: border-box;。 图像显示区域CSS3 中新增了 background-clip 属性。 你可以通过 background-clip 属性设置背景图像的显示区域，可选属性值如下： 值 说明 border-box 默认值。在元素边框，及以内的区域显示背景图像 padding-box 在元素内边距，及以内的区域显示背景图像 content-box 在元素内容区域显示背景图像 【示例】通过 background-clip 属性设置，背景图像仅在元素内容区域显示： 12345678div { background-image: url(&quot;images/kawayi.jpg&quot;); background-repeat: no-repeat; background-clip: content-box; margin: 20px; padding: 20px; border: 10px dotted red;} Backgroundbackground 是背景属性的简写形式，可以为元素同时设置前面的多个或者所有的背景属性。 在设置多个背景属性时并没有固定的顺序，但推荐使用如下顺序进行设置： background-color || background-image || background-position [/ background-size]? || background-repeat || background-attachment || background-origin || background-clip 在设置多个背景属性时，有以下几点需要注意： 每个属性之间使用空格进行分隔； 如果同时设置 background-position 和 background-size 属性，这两个属性之间需要使用斜线/分隔，并且需要遵循 background-position 属性在前 background-size 属性在后的顺序； 如果同时设置 background-origin 和 background-clip 属性，需要遵循 background-origin 属性在前 background-clip 属性在后的顺序; 如果 background-origin 与 background-clip 属性的值相同，则可以只设置一个值。 设置多个背景属性实例如下： 123div { background: #f1f2f3 url(&quot;images/kawayi.jpg&quot;) center center/50% auto no-repeat fixed ;} background 属性还支持设置多组属性值，例如 #f1f2f3 url(&quot;images/kawayi.jpg&quot;) center center/50% auto no-repeat fixed 就可以看作是一组属性。每组属性值之间使用逗号 , 分隔。但需要注意的是 background-color 属性不能设置多个，并且只能在最后一组属性值中设置。 实例如下： 1234div { background: url(&quot;images/kawayi.jpg&quot;) left center/50% 50% no-repeat fixed, #f1f2f3 url(&quot;images/kawayi.jpg&quot;) center center/50% 50% no-repeat fixed;} 需要注意的是，如果设置的多组属性中，背景图像之间存在重叠，那么前面设置的背景图像会覆盖在后面的背景图像之上。 字体（Fonts）除了上述的背景设置，字体设置也是网页设计中的重要组成部分，合适的字体不仅会使页面更加美观，也可以提升用户体验。 CSS 中提供了一系列用于 设置元素内文本的字体样式 的属性： font-family：设置字体； font-style：设置字体的倾斜、斜体风格； font-weight：设置字体粗细； font-size：设置字体尺寸； font-variant：将小写字母转换为小型大写字母（不常使用）； font-stretch：对字体进行伸缩变形（使用较少，并且主流浏览器都不支持）； font：字体属性的缩写，可以在一个声明中设置所有的字体属性。 下面来看各个字体属性的用法： 文本字体CSS 中使用 font-family 属性来设置元素内文本的字体。 由于字体的种类成千上万，而且有些还不是免费的，因此我们的电脑上几乎不可能拥有所有的字体。 因此，为了最大程度的保证我们设置的字体能够正常显示，可以通过 font-family 属性定义一个由若干字体名称组成的列表，字体名称之间使用逗号 , 分隔，浏览器会首先尝试列表中的第一个字体，如果不支持则尝试下一个，以此类推。 font-family 属性支持以下几种属性值： 值 描述 family-name、generic-family family-name：字体名称，一个字体名称就代表一种字体，比如 “微软雅黑” 就是一种字体；generic-family：字体族，也就是某种类型的字体组合，一个字体族代表一种类型的字体，其中包含很多相似但又不同的字体，比如 “sans-serif” 就是一种无衬线字体，其中包含很多种相似的字体。 inherit 从父元素继承字体的设置 CSS 中常用的 5 种字体族（generic-family）： 字体族 说明 字体 serif 有衬线字体，即在文字笔画的结尾添加特殊的装饰线或衬线 “Lucida Bright”、”Lucida Fax”、Palatino、”Palatino Linotype”、Palladio、”URW Palladio”、serif sans-serif 无衬线字体，即在文字笔画结尾处是平滑的 “Open Sans”、”Fira Sans”、”Lucida Sans”、”Lucida Sans Unicode”、”Trebuchet MS”、”Liberation Sans”、”Nimbus Sans L”、sans-serif monospace 等宽字体，即每个文字的宽度都是相同的 “Fira Mono”、”DejaVu Sans Mono”、Menlo、Consolas、”Liberation Mono”、Monaco、”Lucida Console”、monospace cursive 草书字体，该字体有连笔或者特殊的斜体效果，会给人一种手写的感觉 “Brush Script MT”、”Brush Script Std”、”Lucida Calligraphy”、”Lucida Handwriting”、”Apple Chancery”、cursive fantasy 具有特殊艺术效果的字体 Papyrus、Herculanum、”Party LET”、”Curlz MT”、Harrington、fantasy 在网页设计中最常用的字体族是 serif 和 sans-serif，因为它们适合阅读。在显示一些程序代码是通常使用等宽字体（monospace），这样可以使用程序代码看起来更加工整。 使用 font-family 属性为 HTML 元素中文本设置字体样式： 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;CSS 演示&lt;/title&gt; &lt;style&gt; div { font-family:'Trebuchet MS', 'Lucida Sans Unicode', 'Lucida Grande', 'Lucida Sans', Arial, sans-serif; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;CSS 字体设置实例&lt;/h1&gt; &lt;div&gt; Hello HTML + CSS World. &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 需要注意的是，如果字体族或字体名称中包含空格或多个单词，则必须将它们使用引号包裹起来，例如”Times New Roman”、”Courier New”、”Segoe UI” 等，如果是在元素的 style 属性中使用则必须使用单引号。 字体风格使用 font-style 属性来设置字体的风格样式，如斜体、倾斜等，该属性的可选属性值如下： 值 描述 normal 默认值，文本以正常字体显示 italic 文本以斜体显示 oblique 文本倾斜显示 inherit 从父元素继承字体样式 实例代码如下： 123456789101112131415161718192021222324252627282930313233&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;CSS 演示&lt;/title&gt; &lt;style&gt; div { font-style: oblique; } .normal { font-style: normal; } .italic { font-style: italic; } .oblique { font-style: oblique; } .inherit { font-style: inherit; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;p class=&quot;normal&quot;&gt;normal: 显示一个标准的字体&lt;/p&gt; &lt;p class=&quot;italic&quot;&gt;italic: 显示一个斜体的字体&lt;/p&gt; &lt;p class=&quot;oblique&quot;&gt;oblique: 显示一个倾斜的字体&lt;/p&gt; &lt;p class=&quot;inherit&quot;&gt;inherit: 从父元素继承字体样式&lt;/p&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 需要注意的是，italic 和 oblique 浏览器种的效果尽管看起来是一样的，但 italic 显示的是字体的斜体版本，而 oblique 则只是一个倾斜的普通字体。 字体粗细font-weight 属性可用来设置字体的粗细，可选属性值如下： 值 描述 normal 默认值，标准字体 bold 粗体字体 bolder 更粗的字体 lighter 更细的字体 100~900(step: 100) 由细到粗的设置字体粗细，100 为最细的字体，400 等同于 normal，700 等同于 bold inherit 从父元素继承字体的粗细 实例代码如下： 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;CSS 演示&lt;/title&gt; &lt;style&gt; .normal { font-weight: normal; } .bold { font-weight: bold; } .weight-700 { font-weight: 700; } .bolder { font-weight: bolder; } .lighter { font-weight: lighter; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;p class=&quot;normal&quot;&gt;font-weight: normal&lt;/p&gt; &lt;p class=&quot;bold&quot;&gt;font-weight: bold&lt;/p&gt; &lt;p class=&quot;weight-700&quot;&gt;font-weight: 700&lt;/p&gt; &lt;p class=&quot;bolder&quot;&gt;font-weight: bolder&lt;/p&gt; &lt;p class=&quot;lighter&quot;&gt;font-weight: lighter&lt;/p&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 字体字号font-size 属性可用来设置字体的大小（字号），可选属性值如下： 值 描述 xx-small、x-small、small、medium、large、x-large、xx-large 以关键字的形式把字体设置为不同的大小，从 xx-small 到 xx-large 依次变大，默认值为 medium smaller 为字体设置一个比父元素更小的尺寸 larger 为字体设置一个比父元素更大的尺寸 length 以数值加单位的形式把字体设置为一个固定尺寸，例如 18px、2em % 以百分比的形式为字体设置一个相对于父元素字体的大小 inherit 从父元素继承字体的尺寸 实例代码如下： 1234567891011121314151617181920212223242526272829303132333435&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;CSS 演示&lt;/title&gt; &lt;style&gt; .xx_small { font-weight: normal;} .x_small { font-weight: bold; } .small { font-size: small; } .medium { font-size: medium; } .large { font-size: large; } .x-large { font-size: x-large; } .xx-large { font-size: xx-large; } .smaller { font-size: smaller; } .larger { font-size: larger; } .font-20 { font-size: 20px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;p class=&quot;xx_small&quot;&gt;将字体大小设置为：xx-small&lt;/p&gt; &lt;p class=&quot;x_small&quot;&gt;将字体大小设置为：x-small&lt;/p&gt; &lt;p class=&quot;small&quot;&gt;将字体大小设置为：small&lt;/p&gt; &lt;p class=&quot;medium&quot;&gt;将字体大小设置为：medium&lt;/p&gt; &lt;p class=&quot;large&quot;&gt;将字体大小设置为：large&lt;/p&gt; &lt;p class=&quot;x-large&quot;&gt;将字体大小设置为：x-large&lt;/p&gt; &lt;p class=&quot;xx-large&quot;&gt;将字体大小设置为：xx-large&lt;/p&gt; &lt;p&gt;默认字体大小显示&lt;/p&gt; &lt;p class=&quot;smaller&quot;&gt;将字体大小设置为：smaller&lt;/p&gt; &lt;p class=&quot;larger&quot;&gt;将字体大小设置为：larger&lt;/p&gt; &lt;p class=&quot;font-20&quot;&gt;将字体大小设置为 20 像素&lt;/p&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 需要注意的是，1em 和当前字体大小（font-size）相等。在浏览器中默认的文字大小是 16px。关于更多的字体大小可以参看 &gt;&gt;&gt; CSS 教程之 CSS 长度说明。 文本字母转换font-variant 属性可以将文本中的小写英文字母转换为小型大写字母，转换后的大写字母与转换前小写字母的大小相仿，所以称之为小型大写字母。 font-variant 属性的可选属性值如下： 值 描述 normal 默认值，浏览器会显示一个标准的字体 small-caps 将文本中的小写英文字母转换为小型大写字母 inherit 从父元素继承 font-variant 属性的值 实例代码如下： 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;CSS 演示&lt;/title&gt; &lt;style&gt; .normal { font-variant: normal; } .small-caps { font-variant: small-caps;} &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;p class=&quot;normal&quot;&gt;This is a paragraph.&lt;/p&gt; &lt;p class=&quot;small-caps&quot;&gt;This is a paragraph.&lt;/p&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; FontFont 是字体属性的简写形式，可以为元素中文本同时设置前面的多个或者所有的字体属性。 在设置多个字体属性时并没有固定的顺序，但推荐使用如下顺序进行设置： font：[[font-style||font-variant||font-weight||font-stretch]?font-size[ /line-height]?font-family] | caption | icon | menu | message-box | small-caption | status-bar 在设置多个字体属性时，有以下几点需要注意： 使用 font 属性时必须按照如上所示的顺序，并且 font-size 和 font-family 两个属性不可忽略； 除 font-size 和 font-family 属性外，被忽略的属性将被设置为各自的默认值； 若要定义 line-height 属性，则需要使用斜线/将 font-size 和 line-height 属性分开。 设置多个字体属性实例如下： 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;CSS 演示&lt;/title&gt; &lt;style&gt; div { font: italic small-caps bold 16px/20px arial, sans-serif; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;p&gt;This is a paragraph.&lt;/p&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 文本（Text）CSS 中的文本（Text）属性允许你像操作 Word 文档那样，来定义页面文档中的文本颜色、字符间距、文本对齐方式、文本缩进等等样式。 CSS 中提供了一系列用于 设置元素内文本样式 的属性： color: 设置文本颜色； text-align：设置文本的水平对齐方式； text-decoration：设置文本的装饰； text-transform：设置文本中英文的大小写转换方式； text-indent：设置文本的缩进方式； line-height：设置行高； letter-spacing：设置字符间距； word-spacing：设置单词与单词之间的间距（对中文无效）； text-shadow：设置文本阴影； vertical-align：设置文本的垂直对齐方式； white-space：设置文本中空白的处理方式； direction：设置文本方向。 下面来看各个文本属性的用法： 文本颜色color 属性被用来设置元素中文本的颜色。 关于文本颜色设置你可以参考 CSS 教程之 CSS 颜色说明。 对于 W3C 标准的 CSS：如果你定义了颜色属性，你还必须定义元素的背景色属性（background-color）。 文本水平对齐text-align 属性用来设置元素中文本的水平对齐方式，其可选的属性值如下： 值 描述 left 默认值，左对齐 right 右对齐 center 居中对齐 justify 两端对齐 inherit 从父元素继承 text-align 属性的值 【示例】使用 text-align 属性设置文本的水平对齐方式： 12345678910111213141516171819202122232425&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;CSS 演示&lt;/title&gt; &lt;style&gt; p, span { border: 1px solid black; /* 为了能更直观的体现出文本的对齐方式，这里给标签设置一个边框 */ } .text1 { text-align: left; } .text2 { text-align: center; } .text3 { text-align: right; } .text4 { text-align: center; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;p class=&quot;text1&quot;&gt;左对齐&lt;/p&gt; &lt;p class=&quot;text2&quot;&gt;居中对齐&lt;/p&gt; &lt;p class=&quot;text3&quot;&gt;右对齐&lt;/p&gt; &lt;span class=&quot;text4&quot;&gt;Span 元素的居中对齐&lt;/span&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 浏览器中可以看到，块级元素 p 可以看到水平对齐效果，而内联元素 span 却看不出居中对齐效果？这是由于：块级元素，其默认宽度是100%，所以文本有对齐的空间前提。而 span 是内联元素其默认宽度就是其文本内容的宽度，文本已经粑在其边框上了，对齐是看不出效果来的。 需要注意的是：text-align: justify 文本两端对齐设置 &gt;&gt;&gt; 将拉伸每一行文本（增加字符之间的间距），以使每行文本具有相同的宽度（最后一行除外），这种对齐方式通常用于出版物，例如杂志和报纸。 如果元素中的文本不足一行时，是无法实现两端对齐的（默认会以左对齐的效果显示）。只有当元素中的文本足够长，并且在元素中发生了自动换行时，才会将除最后一行以外的文本实现两端对齐。 文本修饰text-decoration 属性用于设置或删除文本的装饰，其可选的属性值如下： 值 描述 none 默认值，标准文本，没有额外装饰，可以用来删除已有的文本装饰 underline 在文本下方添加一条下滑线 overline 在文本上方添加一条上滑线 line-through 在文本的中间定义一条横向贯穿文本的线（类似于删除线） blink 定义闪烁的文本（目前主流浏览器不再支持） inherit 从父元素继承 text-decoration 属性的值 从设计的角度看主要是用来删除链接的下划线修饰。当然了，你也可以在需要的地方为元素中的文本添加一些装饰，达到突出显示的效果。 示例代码如下： 123456789101112131415161718192021222324&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;CSS 演示&lt;/title&gt; &lt;style&gt; .text1, .linkclear { text-decoration: none; } .text2 { text-decoration: underline; } .text3 { text-decoration: overline; } .text4 { text-decoration: line-through; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;p class=&quot;text1&quot;&gt;无装饰文字&lt;/p&gt; &lt;p class=&quot;text2&quot;&gt;带下划线文字&lt;/p&gt; &lt;p class=&quot;text3&quot;&gt;带上划线文字&lt;/p&gt; &lt;p class=&quot;text4&quot;&gt;带贯穿线文字&lt;/p&gt; &lt;a href=&quot;https://www.baidu.com&quot;&gt;默认带下划线修饰的链接&lt;/a&gt; &lt;a class=&quot;linkclear&quot; href=&quot;https://www.baidu.com&quot;&gt;删除下划线修饰的链接&lt;/a&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 文本字母转换text-transform 属性用来控制文本中英文字母的大小写转换，可以在不修改原文的基础上，将文本中的英文统一更改为小写字母、大写字母或者首字母大写的形式。 其可选的属性值如下： 值 描述 none 默认值，以原文显示，对文本中的英文不做更改 capitalize 将文本中的每个单词更改为以大写字母开头的形式 uppercase 将文本中的英文字母全部更改为大写 lowercase 将文本中的英文字母全部更改为小写 inherit 从父元素继承 text-transform 属性的值 示例代码如下： 12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;CSS 演示&lt;/title&gt; &lt;style&gt; .none { text-transform: none; } .uppercase { text-transform: uppercase; } .lowercase { text-transform: lowercase; } .capitalize { text-transform: capitalize; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;p&gt;原文： text-transform &amp;emsp;&lt;span class=&quot;none&quot;&gt;转换后：text-transform&lt;/span&gt;&lt;/p&gt; &lt;p&gt;原文： text-transform &amp;emsp;&lt;span class=&quot;uppercase&quot;&gt;转换后：text-transform&lt;/span&gt;&lt;/p&gt; &lt;p&gt;原文： TEXT-TRANSFROM &amp;emsp;&lt;span class=&quot;lowercase&quot;&gt;转换后：text-transform&lt;/span&gt;&lt;/p&gt; &lt;p&gt;原文： text-transform &amp;emsp;&lt;span class=&quot;capitalize&quot;&gt;转换后：text-transform&lt;/span&gt;&lt;/p&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 文本缩进text-indent 属性用来为元素中的文本添加首行缩进的效果，其可选的属性值如下： 值 描述 length 以固定的值加单位的形式（例如 2em）定义缩进距离，默认值为 0 % 以基于父元素宽度的百分比来定义缩进距离 inherit 从父元素继承 text-indent 属性的值 实例代码如下： 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;CSS 演示&lt;/title&gt; &lt;style&gt; p { text-indent: 2em;} &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;p&gt;text-indent 属性用来为元素中的文本添加首行缩进的效果，至于是从左侧还是从右侧缩进则取决于 direction 属性定义的文本方向。&lt;/p&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 文本行高line-height 属性用来设置文本的行高，其可选的属性值如下： 值 描述 normal 默认值，使用默认的行高，不对行高进行额外设置 number 以具体的数字设置行高，这个数字会与当前的字体大小相乘，并将得到的值设置为行高 length 以数字加单位的形式设置固定的行高 % 以百分比的形式设置基于当前字体尺寸百分比的行高 inherit 从父元素继承 line-height 属性的值 示例代码如下： 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;CSS 演示&lt;/title&gt; &lt;style&gt; .small { line-height: 0.8; } .big { line-height: 200%; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;p&gt;默认的标准行高&lt;br&gt;默认的标准行高&lt;/p&gt; &lt;p class=&quot;small&quot;&gt;使用数字定义一个较小的行高&lt;br&gt;使用数字定义一个较小的行高&lt;/p&gt; &lt;p class=&quot;big&quot;&gt; 使用百分比的形式定义一个较大的行高&lt;br&gt; 使用百分比的形式定义一个较大的行高&lt;/p&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 文本间隔[1] &gt;&gt;&gt; 文本字符间隔 letter-spacing 属性用来设置字符之间的间距，其可选的属性值如下： 值 描述 normal 默认值，表示字符之间没有额外的间距 length 以数值加单位的形式设置字符之间的固定间距（允许使用负值） inherit 从父元素继承 letter-spacing 属性的值 实例代码如下： 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;CSS 演示&lt;/title&gt; &lt;style&gt; p { letter-spacing: 5px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;p&gt;letter-spacing 属性用来设置字符之间的间距&lt;br&gt; letter-spacing 属性用来设置字符之间的间距&lt;br&gt; letter-spacing 属性用来设置字符之间的间距&lt;/p&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; [2] &gt;&gt;&gt; 文本词间隔 word-spacing 属性用来设置元素文本中单词与单词之间的间距（对中文无效），其可选的属性值如下： 值 描述 normal 默认值，表示单词与单词之间没有额外的间距 length 以数值加单位的形式设置单词与单词之间的固定间距（允许使用负值） inherit 从父元素继承 word-spacing 属性的值 实例代码如下： 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;CSS 演示&lt;/title&gt; &lt;style&gt; p { word-spacing: 20px; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;p&gt;word-spacing 属性用来设置单词与单词之间的间距，但对中文无效&lt;br&gt; word-spacing 属性用来设置单词与单词之间的间距，但对中文无效&lt;br&gt; word-spacing 属性用来设置单词与单词之间的间距，但对中文无效&lt;/p&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 文本阴影text-shadow 属性用来为文本添加阴影及模糊效果，属性的语法格式如下： text-shadow: h-shadow v-shadow blur color; 其中，h-shadow 为必填值，用来设置阴影的水平位置，允许为负值；v-shadow 为必填值，用来设置阴影的垂直位置，允许为负值；blur 为可选值，用来设置模糊的距离；color 为可选值，用来设置阴影的颜色。 类似于 background 属性，text-shadow 属性可以设置一个或多个阴影效果，只需要将每组的值使用逗号 , 分隔即可。示例代码如下： 12345678910111213141516171819&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;CSS 演示&lt;/title&gt; &lt;style&gt; p { text-shadow: 2px 15px red, 0px -15px 2px blue; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;p&gt;text-shadow 属性可以为文本添加阴影和模糊效果&lt;/p&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 文本垂直对齐方式vertical-align 属性用来定义元素内文本的垂直对齐方式，其可选的属性值如下： 值 描述 baseline 默认值，将元素的基线与父元素的基线对齐 sub 下标对齐，将元素的基线相对于父元素的基线降低 super 上标对齐，将元素的基线相对于父元素的基线升高 top 顶部对齐，将元素行内框的顶端与行框的顶端对齐 text-top 文本顶部对齐，把元素的顶端与父元素字体的顶端对齐 middle 居中对齐，通常使用在图片上，将图片垂直方向的中线与文本的中线对齐 bottom 底部对齐，将元素行内框的顶端与行框的底端对齐 text-bottom 文本底部对齐，是将元素行内框的底端与行框的底线对齐 length 以数字加单位的形式设置元素基线距离父元素基线的距离（可以为负值） % 使用 “line-height” 属性的百分比值来排列此元素，允许使用负值 inherit 从父元素继承 vertical-align 属性的值 上表中提到了基线、底线、顶线、中线等概念，它们到底指什么呢？ 顶线：中文汉字的上边沿； 中线：贯穿小写英文字母 x 中间的线； 基线：小写英文字母 x 的下边沿； 底线：中文汉字的下边沿； 内容区：指底线与顶线包裹的区域； 行高：包括内容区与以内容区为基础对称拓展的空白区域，也可以认为是相邻文本行基线间的距离；\\ 行距：指相邻文本行间上一个文本行底线和下一文本行顶线之间的距离； 行内框：是一个浏览器渲染模型中的概念，无法显示出来，但是它又确实存在，它的高度与行高相同； 行框：同行内框类似的概念，行框是指本行的一个虚拟的矩形框，也是浏览器渲染模式中的一个概念。行框高度等于本行内所有元素中行内框最大的值（以行高值最大的行内框为基准，其他行内框采用自己的对齐方式向基准对齐，最终计算行框的高度）。 示意图如下所示： 实例代码如下： 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;CSS 演示&lt;/title&gt; &lt;style&gt; .sub { vertical-align: sub; } .supper { vertical-align: supper; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;p&gt;vertical-align 属性用来&lt;span class=&quot;sub&quot;&gt;定义元素内文本的垂直对齐方式&lt;/span&gt;&lt;/p&gt; &lt;p&gt;vertical-align 属性用来&lt;span class=&quot;supper&quot;&gt;定义元素内文本的垂直对齐方式&lt;/span&gt;&lt;/p&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 文本空白格white-space 属性用来设置如何处理元素内的空白，其可选的属性值如下： 值 描述 normal 默认值，忽略文本中的空白 pre 保留文本中的空白，类似于 &lt;pre&gt; 标签的效果 nowrap 文本会在一行中显示，不会自动换行，直到遇到 &lt;br&gt; 标签为止 pre-wrap 保留文本中的空白，但是正常地进行换行 pre-line 合并文本中的空白，但是保留换行符 inherit 从父元素继承 white-space 属性的值 实例代码如下： 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;CSS 演示&lt;/title&gt; &lt;style&gt; p { white-space: pre-line; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;p&gt;white-space 属性用来设置如何处理元素内的空白 white-space 属性用来设置如何处理元素内的空白 &lt;/p&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt; 文本方向direction 属性用来设置文本的方向，其可选的属性值如下： 值 描述 ltr 默认值，文本按从左到右的方向输出 rtl 文本按从右到左的方向输出 inherit 从父元素继承 direction 属性的值 实例代码如下： 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;CSS 演示&lt;/title&gt; &lt;style&gt; .ltr { direction: ltr; } .rtl { direction: rtl; } &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;div&gt; &lt;p class=&quot;ltr&quot;&gt;direction 属性用来设置文本的方向&lt;/p&gt; &lt;p class=&quot;rtl&quot;&gt;direction 属性用来设置文本的方向&lt;/p&gt; &lt;/div&gt; &lt;/body&gt;&lt;/html&gt;","link":"/2019/01/13/css-jiao-cheng-zhi-css-ji-chu-yang-shi-she-zhi-zhi-yi/"},{"title":"CSS 教程之 CSS 基础样式设置之二","text":"CSS 基础样式设置，包括：链接（Link）样式、列表（List）样式，以及表格（Table）样式。","link":"/2019/01/14/css-jiao-cheng-zhi-css-ji-chu-yang-shi-she-zhi-zhi-er/"},{"title":"JS 教程之初识 JavaScript","text":"JavaScript，简称 JS，是当前互联网上最流行、应用最广泛的客户端脚本语言，用来为网页添加一些动态效果或者用户交互功能，在 Web 开发领域有着举足轻重的地位。 认识 JS前面我们提过，JavaScript 与 HTML 和 CSS 共同构成了我们所看到的网页（W3C 标准模式），其中： HTML 用来定义网页的内容 &gt;&gt;&gt; 例如标题、正文、图像等； CSS 用来控制网页的外观 &gt;&gt;&gt; 例如颜色、字体、背景等； JavaScript 是行为，用来实时更新网页中的内容 &gt;&gt;&gt; 例如从服务器获取数据并更新到网页中，修改某些标签的样式或其中的内容等，可以让网页更加生动。 通俗的来说，JavaScript 是一种可插入 HTML 文档的，由浏览器解释执行的，轻量级脚本编程语言。 JS 的历史JavaScript 最初被称为 LiveScrip，由 Netscape（Netscape Communications Corporation，网景通信公司）公司的布兰登·艾奇（Brendan Eich）在 1995 年开发。在 Netscape 与 Sun（Sun Microsystems，现已被甲骨文公司收购）合作之后正式更名为了 JavaScript。 之所以将 LiveScript 更名为 JavaScript，是因为 JavaScript 是受 Java 的启发而设计的，因此在语法上它们有很多相似之处 ，JavaScript 中的许多命名规范也都借鉴自 Java，还有一个原因就是 为了营销，蹭 Java 的热度。 同一时期，微软和 Nombas 公司也分别开发了 JScript 和 ScriptEase 两种脚本语言，与 JavaScript 形成了三足鼎立之势。它们之间没有统一的标准，不能互用。随着版本不同暴露的问题日益加剧，JavaScript 的规范化最终被提上日程。 为了解决这一问题，1997 年，在 ECMA（European Computer Manufacturers Association，欧洲计算机制造商协会）的牵头下，Netscape、Sun、微软、Borland 等公司组成了工作组，并 以 JavaScript1.1 为蓝本制定了 ECMA-262，它是一种名为 ECMAScript 脚本语言标准。 第二年，ISO/IEC（国际标准化组织及国际电工委员会）也采用了 ECMAScript 作为标准（即 ISO/IEC-16262）。 JS Vs ECMAScript有时人们会将 JavaScript 与 ECMAScript 看作是相同的。其实不然，JavaScript 中所包含的内容远比 ECMA-262 中规定的多得多，完整的 JavaScript 是由以下三个部分组成： 核心（ECMAScript）：提供 JS 语言的核心语法和基本对象支持等； 文档对象模型（DOM）：提供操作网页内容的方法和接口； 浏览器对象模型（BOM）：提供与浏览器进行交互的方法和接口。 也就是说，ECMAScript（核心）只是定义了 JavaScript 脚本语言的基础，而在此基础上通过其它部分（DOM、BOM）构建更完善的 JS 脚本语言。 如何运行 JS作为一种脚本语言，JavaScript 代码不能独立运行，通常情况下我们需要 借助浏览器来运行 JavaScript 代码，目前所有 Web 浏览器都支持 JavaScript。 除了可以在浏览器中执行外，也可以在 服务端（Nodejs）或者搭载了 JavaScript 引擎的设备 中执行 JavaScript 代码。 浏览器之所以能够运行 JavaScript 代码就是因为浏览器中都嵌入了 JavaScript 引擎。常见的 JavaScript 引擎有： V8 In Chrome &amp;&amp; Opera； SpiderMonkey In Firefox； Chakra In ChakraCore In Microsoft Edge； SquirrelFish In Safari。 认识 Node.jsJavaScript 诞生于 1995 年，几乎是和互联网同时出现；Node.js 诞生于 2009 年，比 JavaScript 晚了 15 年左右。 在 Node.js 之前，JavaScript 只能运行在浏览器中，作为网页脚本使用。有了 Node.js 以后，JavaScript 就可以脱离浏览器，像其它编程语言一样直接在计算机（服务器）上使用，想干什么就干什么，再也不受浏览器的限制了。 Node.js 既不是一门新的编程语言，也不是一个 JavaScript 框架，它是 一套基于 V8 引擎的 JavaScript 运行环境，用来支持 JavaScript 代码的执行。 用编程术语来讲，Node.js 是一个 JavaScript 运行时（Runtime）。 现在的 JavaScript 除了用于 Web 前端编程（网页编程），还能干很多事情，比如： 网站后台（Node.js）； CLI 命令行工具(Node.js)； 桌面 GUI 程序（Electron）； 手机 App(Cordova)； 控制硬件-物联网(Ruff)； 游戏开发(cocos2d-js)。 也就是说，学会了 JavaScript，你不但是全栈工程师，甚至还将无所不能，这都是 Node.js 带给我们的。 Runtime 详解 &gt;&gt;&gt; 所谓运行时，就是程序在运行期间需要依赖的一系列组件或者工具；把这些工具和组件打包在一起提供给程序员，程序员就能运行自己编写的代码了。 例如：解释器、JS 标准库、JS 本地模块（网络模块、Debugger 模块、HTML 解析模块）等各种组件/工具共同支撑了 JavaScript 代码的运行，它们统称为 JavaScript 运行时。 在 Node.js 之前，JavaScript 运行时被绑定在浏览器中，作为浏览器的各种模块出现。 这意味着，要想运行 JavaScript 代码就必须启动浏览器，JavaScript 逃不出浏览器的手掌心，它的功能受到很大的限制，只能作为网页脚本使用。 JS 特点JavaScript 具有以下特点： [1] &gt;&gt;&gt; 解释型脚本语言 JavaScript 是一种解释型脚本语言，与 Java、C/C++ 等语言需要先编译再运行不同，使用 JavaScript 编写的代码不需要编译，可以直接运行。 [2] &gt;&gt;&gt; 面向对象 JavaScript 是一种面向对象语言，使用 JavaScript 不仅可以创建对象，也能操作使用已有的对象。 [3] &gt;&gt;&gt; 弱类型语言 avaScript 是一种弱类型的编程语言，对使用的数据类型没有严格的要求。例如你可以将一个变量初始化为任意类型，也可以随时改变这个变量的类型。 [4] &gt;&gt;&gt; 动态性 JavaScript 是一种采用事件驱动的脚本语言，它不需要借助 Web 服务器就可以对用户的输入做出响应。例如我们在访问一个网页时，通过鼠标在网页中进行点击或滚动窗口时，通过 JavaScript 可以直接对这些事件做出响应。 [5] &gt;&gt;&gt; 跨平台 JavaScript 不依赖操作系统，在浏览器中就可以运行。因此一个 JavaScript 脚本在编写完成后可以在任意系统上运行，只需要系统上的浏览器支持 JavaScript 即可。","link":"/2019/02/01/js-jiao-cheng-zhi-chu-shi-javascript/"},{"title":"JS 教程之 JavaScript 基础语法","text":"JavaScript 基础语法部分内容，包括：JS 构成、JS 运行、JS 输出、JS 注释、以及 JS 基本概念等等。 JS 构成前面我们提到过，完整的 JavaScript 由以下三个部分组成： 语言基础（核心，ECMAScript）：提供 JS 语言的基础语法和基本对象定义等； 浏览器对象模型（BOM）：提供与浏览器进行交互的方法和接口； 文档对象模型（DOM）：提供操作网页内容的方法和接口。 本博文系列，我们更多的是介绍 JS 语言基础（ECMAScript）和 BOM 的相关使用说明。关于更详细的文档对象模型（DOM）可以参看后续的博文系列 HTML DOM 中说明。 ECMAScriptECMAScript 简称 “ES”，是基于 ECMA-262 标准实现的通用脚本语言核心。主要规定了脚本语言核心的语法、数据类型、语句、关键字、保留字、操作符、流程控制、对象等几个部分。 也就是说，ECMAScript（核心）只是定义了 JavaScript 脚本语言的基础，而在此基础上通过其它部分（DOM、BOM）构建更完善的 JS 脚本语言。 ECMAScript 版本 &gt;&gt;&gt;&gt; ECMAScript 版本发展如下（2015 年开始按年命名）： 版本 官方名称 描述 ES1 ECMAScript 1 (1997) 第一版 ES2 ECMAScript 2 (1998) 只改变编辑方式 ES3 ECMAScript 3 (1999) 添加了正则表达式。添加了 try/catch。 ES4 ECMAScript 4 从未发布过。 ES5 ECMAScript 5 (2009) 添加了 “严格模式”。添加了 JSON 支持。添加了 String.trim()。添加了 Array.isArray()。添加了数组迭代方法。 ES5.1 ECMAScript 5.1 (2011) 编辑改变。 ES6 ECMAScript 2015 添加了 let 和 const 添加了默认参数值添加了 Array.find() 添加了 Array.findIndex() ES7 ECMAScript 2016 添加了指数运算符（**）。添加了 Array.prototype.includes。 ES8 ECMAScript 2017 添加了字符串填充。添加了新的 Object 属性。添加了异步功能。添加了共享内存。 ES9 ECMAScript 2018 添加了 rest / spread 属性。添加了异步迭代。添加了 Promise.finally()。增加 RegExp。 所有浏览器都完全支持 ECMAScript 3，所有现代浏览器都完全支持 ECMAScript 5。 DOMDOM 即 Document Object Model，文档对象模型的缩写。 DOM 把整个 HTML 网页映射为一个多层的节点树结构，HTML 页面中的每一个组成部分都是某种类型的节点。 通过 HTML DOM 创建的表示文档的树形图，且借助 DOM 提供的 API，可以轻松自如地删除，添加，替换或修改任何的 HTML 节点。 BOMBOM 即 Browser Object Model，浏览器对象模型的缩写。 浏览器提供了可访问和操作浏览器窗口的浏览器对象模型，通过其提供的 API 可轻松自如的操作浏览器。 目前 BOM 已经正式纳入HTML5 标准。 JS 运行我们知道，JavaScript 程序不能够独立运行，只能在 具有 JavaScript 引擎的宿主环境中执行。 在前端页面开发中，一般情况下 JavaScript 程序有以下两种运行方式： JavaScript 代码嵌入到 HTML 文档中，借助浏览器环境来运行； 通过浏览器控制台（Console）中以交互式的方式运行 JavaScript 代码（简单了解）。 JS 嵌入类似于 CSS 嵌入，HTML 文档中提供了以下两种 JS 的嵌入方式： 行内嵌入：JS 脚本直接嵌入到 HTML 标签中； 内部嵌入：JS 脚本直接嵌入到 &lt;head&gt; 或 &lt;body&gt; 标签中； 外部文件嵌入：JS 脚本保存到外部文件，后引入 HTML 文档中。 行内嵌入你可以在 HTML 事件属性中直接插入 JS 代码以响应事件执行。例如： 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;JS 演示&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=&quot;button&quot; value=&quot;ClickMe&quot; onclick=&quot;alert('Hello, JavaScript.')&quot;&gt; &lt;/body&gt;&lt;/html&gt; 如上，我们为按钮绑定了一个点击事件（onclick），点击按钮后网页会弹出弹出一个警示框，显示 Hello, JavaScript.。 内部嵌入在 HTML 页面中嵌入 JavaScript 脚本需要使用 &lt;script&gt; 标签，JavaScript 代码必须包含在 &lt;script&gt;...&lt;/script&gt; 标签中。 由 &lt;script&gt;...&lt;/script&gt; 标签包含的 JS 脚本代码，可被放置在 HTML 文档中的 &lt;body&gt; 和 &lt;head&gt; 元素中（可共存）。 通常函数放入 &lt;head&gt; 部分（推荐）中，或者放在页面底部。这样尽可能的把它们安置到同一处位置，不会干扰页面的内容。 实例代码如下： 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;JS 演示&lt;/title&gt; &lt;script&gt; document.write(&quot;Hello JavaScript.&quot;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 这里，document.write 方法会将字符串 Hello JavaScript. 直接写入到 HTML 输出流中，和其它 HTML 内容共同显示。 同理，你也可以将其嵌入到 &lt;body&gt; 中： 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;JS 演示&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;script&gt; document.write(&quot;&lt;h1&gt;JS Demo&lt;/h1&gt;&quot;); document.write(&quot;&lt;p&gt;Hello JavaScript.&lt;p&gt;&quot;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 现代浏览器以及 HTML 5 种默认 &lt;script&gt; 标签的脚本类型为 JavaScript，因此可以省略 type=&quot;text/javascript&quot; 属性；如果考虑到兼容早期版本浏览器，则需要设置 type 属性。 外部文件嵌入JavaScript 脚本代码不仅可以直接嵌入 HTML 文档中，也可以通过引用外部 JavaScript 脚本文件（js）的方式进行嵌入。JavaScript 脚本文件是纯文本文件，扩展名为 .js。 类似于外部样式表，外部 JavaScript 脚本文件的嵌入方式，可以实现 JS 代码与 HTML 内容的分离，且外部文件可被多个网页使用。 如需引用外部 JS 文件，可以通过 &lt;script&gt; 标签的 src 属性来设置指向外部 JavaScript 文件的 URL，引入语法格式如下： &lt;script type=&quot;text/javascript&quot; src=&quot;test.js&quot;&gt;&lt;/script&gt; 需要注意的是，所引用的外部 JS 文件内，不要使用 &lt;script&gt; 标签，直接写 JS 代码即可。并且定义 src 属性的 &lt;script&gt; 标签不应再包含 JavaScript 代码。如果嵌入了代码，则只会下载并执行外部 JavaScript 文件，嵌入代码将被忽略。 示例：首先创建一个外部 JavaScript 文件（test.js），并写入以下内容： 1document.write(&quot;Hello JavaScript.&quot;); HTML 文档中引入上述 JS 脚本文件： 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;JS 演示&lt;/title&gt; &lt;script src=&quot;js/test.js&quot;&gt;&lt;/script&gt; &lt;script&gt; document.write(&quot;JS Output Test.&quot;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; JS 执行顺序我们知道，浏览器在解析 HTML 文档时，将根据 HTML 文档流从上到下逐行解析和显示。 而 JavaScript 代码也是 HTML 文档的组成部分，因此 JavaScript 脚本的执行顺序也是根据 HTML 文档中 &lt;script&gt; 标签的位置来确定的。 实例代码如下： 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;JS 演示&lt;/title&gt; &lt;script&gt; document.write(&quot;Hello JavaScript.&quot;); &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;JS Demo&lt;/h1&gt; &lt;script&gt; document.write(&quot;&lt;p&gt;This is a paragraph.&lt;/p&gt;&quot;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 控制台执行你还可以直接通过在浏览器的控制台（Console）中，以交互式的方式运行 JavaScript 代码（简单了解一下）。 目前的主流浏览器：Google Chrome、Microsoft Edge、IE、Safari 等，这些浏览器均提供有浏览器开发者工具，且功能都大同小异，这里将以谷歌的 Chrome 浏览器为例进行简单介绍。 Chrome 是由 Google 开发的免费网页浏览器，对于前端开发来说（尤其是调试代码）非常方便。 你可以在 Chrome 浏览器中，通过快捷键 F12（或：More Tools &gt;&gt;&gt; Developer Tools）快速启用开发者工具，界面如下： Console Run打开开发者工具后，你可以直接在 Console 窗口调试 JavaScript 代码，如下图： 你可以在输入提示符 &gt; 后输入想要执行的代码，例如 console.log(&quot;Hello, JavaScript&quot;)，按回车（Enter）后执行。 如果你想输入多行代码，你可以使用 Shift + Enter 进行换行输入，然后按回车（Enter）后执行。 你还可以使用蓝色框中的按钮，清空 Console 窗口的代码和输出信息。 Snippets Run除了使用控制台窗口，也可以在 Chrome 浏览器中创建一个脚本来执行 JavaScript 代码。 打开开发者工具后，&gt;&gt;&gt; 点击 Sources 面板 &gt;&gt;&gt; 选择 Snippets 选项卡 &gt;&gt;&gt; 选择 New Snippet 来新建一个脚本文件，如下： 如果你没看到 Snippets ，可以点左下面板上蓝色框中的 &gt;&gt; 就可以将其显示出来。 点击 New Snippet 后，会自动创建一个文件，你只需在右侧窗口输入以下代码，然后保存代码（Ctrl + S）： 12console.log(&quot;Debug JS Code&quot;);console.log(&quot;Console Output&quot;); 保存后，右击文件名，选择 “Run” 执行代码： JS 输出某些情况下，我们可能需要将程序的运行结果输出到浏览器中，例如检验程序的运行是否符合我们的预期（调试）。 JavaScript 中提供了 5 种不同的方式来向浏览器中输出内容： 使用 window.alert() 函数来弹出警告框； 使用 window.confirm() 函数来弹出一个验证对话框； 使用 document.write() 函数将内容写到 HTML 文档输出流中； 使用 innerHTML 标签属性将内容写入到 HTML 元素中； 使用 console.log() 函数在浏览器的控制台中输出内容。 严格来说，JavaScript 是没有任何打印或者输出函数的，以上几种方式都只不过是一种数据展示的方法。最接近输出的方法应该是 console.log()，但该方法只是一种调试辅助工具。 下面分别来看上述的 5 种数据输出方法： alert你可以使用 JS window.alert() 函数在浏览器窗口中弹出一个警告框来，在警告框中你可以定义要输出的内容，语法格式如下： alert(message); 或者 window.alert(message) 其中，message 为要在警告框中输出的内容。这里，由于 alert() 函数是 window 对象下的一个函数，故也可以使用 window.alert() 的形式来调用 alert() 函数。 实例代码如下： 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;JS 演示&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;JS Demo&lt;/h1&gt; &lt;script&gt; window.alert(&quot;这是一个提示信息！&quot;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; confirm类似于 alert，confirm() 函数也是 window 对象下的一个函数，其会在浏览器窗口中弹出一个验证（授权）提示框，在提示框中你可以定义要告知用户须知的内容。 不同的是，使用 confirm() 函数创建的提示框中，除了包含一个 “确定” 按钮外，还有一个 “取消” 按钮。如果点击 “确定” 按钮，那么 confirm() 函数会返回一个布尔值 true，如果点击 “取消” 按钮，那么 confirm() 函数会返回一个布尔值 false。 实例代码如下： 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;JS 演示&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;JS Demo&lt;/h1&gt; &lt;script&gt; window.confirm(&quot;你是否同意完整获取网页权限？&quot;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 需要注意的是，同 alert，window.confirm() 函数也可以简写为 confirm()。 console.log在上面说明 JS 运行方式时，就已经见过 console.log() 函数了。 使用 JS console.log() 函数可以向浏览器的控制台种输出信息，通常用来调试程序，其语法格式如下： console.log(message); 其中，message 为要输出的内容，可以是字符串或者对象类型。但需要注意的是，console.log() 函数不能简写为 log()！ 想要查看 console.log() 函数的输出内容，需要先打开浏览器的控制台（见 JS 运行部分说明）。 实例代码如下： 12345678910111213&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;JS 演示&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;JS Demo&lt;/h1&gt; &lt;script&gt; console.log(&quot;JavaScript Output Test&quot;); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; document.write使用 JS document.write() 函数可以向 HTML 文档输出流中写入 HTML 或者 JavaScript 代码，语法格式如下： document.write(exp1, exp2, exp3, …); 其中，exp1、exp2、exp3 为要向文档中写入的内容（可接收多个写入参数），内容之间使用逗号进行分隔。 实例代码如下： 1234567891011121314&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;JS 演示&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;JS Demo&lt;/h1&gt; &lt;script&gt; document.write(&quot;&lt;p&gt;写入 HTML 段落&lt;/p&gt;&quot;); document.write(Date()); // Date() 是一个 JS 日期函数。 &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 需要注意的是，如果在文档已完成加载后执行 document.write，整个 HTML 页面将被覆盖： 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;JS 演示&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;JS Demo&lt;/h1&gt; &lt;p&gt;点击按钮后，页面内容会被覆盖&lt;/p&gt; &lt;button onclick=&quot;myfunction()&quot;&gt;Click Me&lt;/button&gt; &lt;script&gt; function myfunction(){ document.write(Date()); } &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 这里 JS 脚本代码不用深究，后续会理解相关代码的含义。 innerHTML相较于前面，innerHTML 有点特殊。innerHTML 是一个 HTML DOM 属性而不是一个函数，通过它可以设置或者获取指定 HTML 元素中的内容。 由于 innerHTML 是一个 HTML DOM 属性，需要配合 HTML DOM 中的 document.getElementById(id) 方法使用，该方法可通过 id 属性来访问具有指定 id 属性值的 HTML 元素。 实例代码如下： 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;JS 演示&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;JS Demo&lt;/h1&gt; &lt;p id=&quot;demo&quot;&gt;元素中内容&lt;/p&gt; &lt;script&gt; document.write(&quot;修改前 &gt;&gt;&gt;&quot;, document.getElementById(&quot;demo&quot;).innerHTML, &quot;&lt;br/&gt;&quot;); document.getElementById(&quot;demo&quot;).innerHTML = &quot;元素中的内容已被修改！&quot; document.write(&quot;修改后 &gt;&gt;&gt;&quot;, document.getElementById(&quot;demo&quot;).innerHTML); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 更多关于 HTML DOM 的介绍，可以参看后续的 HTML DOM 博文系列。这里仅仅需要知道的是 HTML DOM 定义了访问和操作 HTML 文档中元素的方法。 JS 注释注释是给开发人员看的，程序在执行时会自动忽略注释的内容。程序中通常会使用注释来为代码添加一些解释说明或描述，以提高代码的可读性。或者为了方便代码调试，可以将不需要运行的代码注释起来等。 并且类似于 Java 语法风格，JS 也支持单行注释和块注释两种风格： 行注释单行注释以双斜杠 // 开头，// 之后的所有内容都会看作是注释的内容（仅作用于所在行）。 实例代码如下： 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;JS 演示&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;JS Demo&lt;/h1&gt; &lt;script&gt; // 使用 document.write() 函数向 HTML 输出流中写入： document.write(&quot;&lt;p&gt;写入 HTML 段落&lt;/p&gt;&quot;); document.write(Date()); // Date() 是一个 JS 日期函数。 &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 块注释块注释以 /* 开头，并以 */ 结尾，出现在 /* 和 */ 之间的所有内容都会看作是注释的内容（包围一个代码块的内容）。 实例代码如下： 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;JS 演示&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;JS Demo&lt;/h1&gt; &lt;p id=&quot;demo&quot;&gt;元素中内容&lt;/p&gt; &lt;script&gt; /* 操作 id 属性为 demo 的元素： 1）获取元素中内容； 2）修改元素中内容。 */ document.write(&quot;修改前：&quot;, document.getElementById(&quot;demo&quot;).innerHTML, &quot;&lt;br/&gt;&quot;); document.getElementById(&quot;demo&quot;).innerHTML = &quot;元素中的内容已被修改！&quot; document.write(&quot;修改后：&quot;, document.getElementById(&quot;demo&quot;).innerHTML); &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 需要注意的是，块注释不允许嵌套，否则会产生语法错误！！！ HTML 风格注释由于 JS 支持 HTML 的内部嵌入方式，故内嵌的 JavaScript 还能够识别 HTML 注释的开始符 &lt;!--，并将其看作单行注释，与 // 效果相同。 至于 HTML 注释的结束符，JavaScript 不能识别，应该使用 JavaScript 的单行注释将 HTML 注释的结束符注释掉，例如 //--&gt;。 实例代码如下： 123456&lt;script&gt; &lt;!--document.getElementById(&quot;demo&quot;).innerHTML = &quot;元素中的内容已被修改！&quot;; // --&gt; // document.getElementById(&quot;demo&quot;).innerHTML = &quot;元素中的内容已被修改！&quot;;&lt;/script&gt; 上面两种注释方式等效。需要注意的是，&lt;!-- 只生效于其所在行，故不可将需注释内容置于下行！ JS 基本概念正式开始学习 JS 语言基础之前，这里先来了解一下 JavaScript 脚本语言中的几个简单的基本概念，例如：标识符、关键字、保留字、字面量、语句等等，它们是 JS 的基本组成元素。 标识符命名规范程序设计语言中，标识符（Identifier）就是名称，用于给变量、常量、函数、类、对象等命名，以建立起名称与使用之间的关系。 但标识符的命名不是随意的，而是要遵守一定的命令规则（合法标识符），比如说： 【1】 标识符可以由字母、数字、下划线以及美元符号（$）组成，其中，数字不允许作为首字符。 【2】 标识符对大小写敏感。 【3】 JS 中允许使用 Unicode（汉字）作为标识符（避免使用），建议仅使用 ASCII 编码的字母。 【4】 JavaScript 中的关键字、保留字不可作为标识符。 【5】 标识符命名方法推荐采用知名的 匈牙利命名法 或 驼峰命名法： 匈牙利命名法 &gt;&gt;&gt; 变量名 = 类型（Int &gt; i；Float &gt; fl；Boolean &gt; b；String &gt; s；Array &gt; a；Object &gt; o；Function &gt; fn；Regular Expression &gt; re） + 对象描述； 驼峰命名法 &gt;&gt;&gt; 大驼峰（每个单词首字母大写）&amp;&amp; 小驼峰（第一个单词首字母小写，其余单词首字母大写）&amp;&amp; 全部小写（单词间使用下划线分割） 【6】 标识符应尽量遵循 “见名知义”，让自己或者他人能轻易看懂。 【7】 英文名可参照 CODELF 给出： 困扰：取名字真难？！！对于英语水平高考即巅峰的同学（当然不是贬低）达到见面知义有一定难度。 这里推荐一个网站：CODELF。命名前可以输入中文看看网络大佬们都是如何进行命名的。 关键字关键字（Key Word）就是 JavaScript 语言内部使用的命名，已经被 JS 系统赋予了特定的意义，我们不能把它们用作任何标识符名称。 JavaScript 中的关键字列表： Col1 Col2 Col3 Col4 Col5 break delete if this while case do in throw with catch else instanceof try continue finally new typeof debugger for return var default function switch void 保留字保留字（Reserved Word）就是 JavaScript 语言内部预备使用的命名。这些名字可能目前还没有具体的用途，是 为 JavaScript 升级版本预留备用的，建议用户不要把它们用作任何标识符名称。 JavaScript 中的保留字列表： Col1 Col2 Col3 Col4 Col5 abstract double goto native static boolean enum implements package super byte export import private synchronized char extends int protected throws class final interface public transient const float long short volatile JavaScript 全局变量、对象、属性和方法 &gt;&gt;&gt; JavaScript 预定义了很多全局变量、对象、属性和方法，用户也应该避免使用它们作为标识符： Col1 Col2 Col3 Col4 Col5 arguments encodeURL Infinity Number RegExp Array encodeURLComponent isFinite Object String Boolean Error isNaN parseFloat SyntaxError Date eval JSON parseInt TypeError decodeURL EvalError Math RangeError undefined decodeURLComponent Function NaN ReferenceError URLError HTML &amp;&amp; Windows &amp;&amp; Java &gt;&gt;&gt; JavaScript 经常与 HTML &amp;&amp; Java 一起使用，你必须（为了可移植性，你也应该这么做）避免使用 Java、HTML 和 Windows 对象和属性的名称作为 JS 标识符。 数据类型类似于其它编程语言，JavaScript 中也支持多种数据类型，用于描述或存储不同类型的数据： 数字（Number） 字符串（String） 布尔（Boolean） 空（Null） 未定义（Undefined） Symbol 数组（Array） 函数（Function） 对象（Object） 字面量字面量（Literal）也叫直接量（或字面值），就是具体的值，即能够直接参与运算或显示的值。 针对值类型的不同，可以分为不同数据类型的字面值。例如：数值字面值、布尔字面值、字符串字面值、正则表达式字面值、对象字面值、数组字面值、函数字面值等。 不同类型字面值实例如下： 12345678&quot;Johnson&quot; //字符串直接量666 //数值直接量true //布尔值直接量/a/g //正则表达式直接量null //特殊值直接量{} //空对象直接量[] //空数组直接量function(){} //空函数直接量，也就是函数表达式 JS 语句JavaScript 脚本程序就是由一行行的 JS 语句构成的，对应的是一条条的 JS 指令，用来告诉浏览器要做什么事情。 通常，你需要在每条可执行的 JS 语句结尾添加分号（;），用于分割语句。示例代码如下： 123a = 5;b = 6;c = a + b; 你也可以在一行中，写多个 JS 语句（为了提高可读性，不推荐）： 1a = 5; b = 6; c = a + b;","link":"/2019/02/01/js-jiao-cheng-zhi-javascript-ji-chu-yu-fa/"},{"title":"Web Crawler 教程之初识网络爬虫","text":"网络爬虫（又称为网页蜘蛛，网络机器人），是一种按照一定的规则，自动浏览、抓取万维网上信息的程序或者脚本。爬虫能够自动请求网页，并解析网页结构和内容，以提取我们期望的有价值信息完成存储。 认识爬虫通俗的来讲，假如你需要互联网上某网站（电影站点）中的信息，如片名、演员、电影描述信息、下载链接等，但你又不想或者不能打开网页一个个去收集，这时你可以通过编写爬虫脚本，让爬虫按照你定义的规则自动地去网站上收集你需要的信息。 事实上，我们所熟知的一系列 搜索引擎 都是 大型的 网络爬虫，例如：百度（Baidu）、谷歌（Google）、搜狗（Sogou）等等。其中，每个搜索引擎都拥有自己的爬虫程序，比如：谷歌的爬虫也称为 GoogleSpider，搜狗的爬虫也叫 SogouSpider。 百度搜索引擎（BaiduSpider） &gt;&gt;&gt;&gt; BaiduSpider 每天都会在海量的互联网信息中爬取优质的信息，并进行收录。 当用户通过百度检索关键词时，百度首先会对用户输入的关键词进行分析，然后从收录的网页中找出相关的网页，并按照排名规则对网页进行排序，最后将排序后的结果呈现给用户。 数据分析 &amp;&amp; 深度学习 &gt;&gt;&gt;&gt; 在数据分析以及深度学习领域，网络爬虫通常是 搜集海量数据的必备工具。 对于数据分析师或深度学习工程师而言，要进行数据分析或深度学习模型训练，首先要有数据源，而学习爬虫，就可以获取更多的数据源。 在数据采集过程中，可以按照自己的目的去采集有价值的数据，过滤掉那些无效的数据。 爬虫是否合法？网络爬虫在带给我们便利的同时，也给网络安全带来了一定的隐患，所以很多小伙伴都会产生这个疑问。 事实上，爬虫只是一门技术，技术应该是中立的，合不合法本质上取决于使用的目的，由爬虫背后的使用者来决定。 一般来说，只要不干违法（非法搜集网民信息）的事情，不影响网站的正常运转，也不是出于商业目的，一般也就只会封下的 IP，账号之类的，不至于法律风险！！！ 其实，为了限制爬虫带来的危险，大多数网站都有良好的 反爬措施（封 IP、账户…），并且通过网站的 robots 协议 做了进一步的说明。 大多数网站的根目录下会有个 robots.txt 的文件，里面写明了网站里面哪些内容可以抓取，哪些不允许。以淘宝网 robots.txt 的内容为例： 123456789User-agent: Baiduspider Disallow: /baidu Disallow: /s? Disallow: /ulink? Disallow: /link? Disallow: /home/news/data/ Disallow: /bh.....User-agent: * Disallow: / robots 协议是一个业内约定，并不具备法律效力，它体现了互联网人的“契约精神”，是一种 “君子协议”。 爬虫类型爬虫可分为三大类： [1] &gt;&gt;&gt; 通用网络爬虫 通用网络爬虫，是搜索引擎的重要组成部分，见上面【百度搜索引擎（BaiduSpider）】中说明。 [2] &gt;&gt;&gt; 聚焦网络爬虫 聚焦网络爬虫，是一种面向特定需求的网络爬虫程序。 与通用爬虫的区别在于：聚焦爬虫在实施网页抓取的时候会对网页内容进行筛选和处理，尽量保证只抓取与需求相关的网页信息。 可以极大地节省了硬件和网络资源，由于保存的页面数量少所以更新速度很快，这也很好地满足一些特定人群对特定领域信息的需求。 [3] &gt;&gt;&gt; 增量式网络爬虫 增量式网络爬虫，是指对已下载网页采取增量式更新。它是一种只爬取新产生的或者已经发生变化网页的爬虫程序，能够在一定程度上保证所爬取的页面是最新的页面。 Why Python？除 Python 语言外，其他语言，诸如 PHP、Java、C/C++ 都可以用来写爬虫程序，且一般来说执行效率还要比 Python 要高。 为什么很多人提到爬虫就会想到 Python ？？？优势如下： 开发效率高：语法简单、代码简洁，学习成本较低； 爬虫对于代码执行效率要求不高：网站 IO 才是最影响爬虫效率的，如一个网页请求可能需要 100ms，数据处理 10ms 还是 1ms 影响不大； 丰富的类库支持：支持多个优秀的爬虫相关类库，如：urllib、Requests、Bs4、Selenium 等。 准备工作在开始正式的网络爬虫编写之气，你需要完成一些准备工作，以帮助你快速入门： 知识储备[1] &gt;&gt;&gt; Python 语言基础 Python 网络爬虫，是 Python 编程的进阶知识，你必须具备一定的 Python 编程基础，以帮助你实现网络爬虫快速入门。 同时，你需要了解 Python 语言的多进程与多线程，并熟悉正则表达式语法，有助于你编写高效的网络爬虫程序。 [2] &gt;&gt;&gt; WEB 前端 编写网络爬虫的一个重要步骤就是，分析网页结构以及元素节点内容。 了解 Web 前端的基本知识，如 HTML &amp;&amp; CSS &amp;&amp; JavaScript，能够帮助你分析网页结构，提炼出有效信息。 [3] &gt;&gt;&gt; HTTP 协议 掌握 OSI 七层网络模型，了解 TCP/IP 协议、HTTP 协议，将帮助你了解网络请求（GET 请求、POST 请求）和网络传输的基本原理。 环境准备编写 Python 爬虫程序前，需要准备相应的开发环境：Python3.5 环境以上 &amp;&amp; IDE（VS Code/Sublime Text/Pycharm…）。 通用爬虫流程不同于其它脚本程序，爬虫脚本的编写思维逻辑一般都是相似的，所以一般无需在逻辑方面花费大量的时间。 编写爬虫脚本的通用流程如下： 通过 Python 网络模块（urllib/requests）发送 URL 请求以获取网页的 HTML 对象； 通过浏览器并借助网页元素审查工具分析网页结构以及元素节点信息； 根据网页结构以及元素节点信息，借助 HTML 对象解析工具（Regular Expression/Xpath/Beautiful Soup 4）以解析页面提取有效数据； 将提取到的有效数据持久化到本地磁盘（文件）或数据库。 爬虫脚本的目的，就是 尽量伪装成人访问网站的样子 以提取有效信息，而非机器访问，否则就会被网站的反爬策略限制，甚至直接封杀 IP 或账户。","link":"/2020/01/20/web-crawler-jiao-cheng-zhi-chu-shi-wang-luo-pa-chong/"},{"title":"Web Crawler 教程之网络爬虫通用流程解读","text":"全流程解读网络爬虫通用编写流程，帮助你完成网络爬虫的快速入门指导！！！ 编写爬虫脚本的通用流程如下： 通过 Python 网络模块（urllib/requests）发送 URL 请求以获取网页的 HTML 对象信息； 通过浏览器并借助网页元素审查工具分析网页结构以及元素节点信息； 根据网页结构以及元素节点信息，借助 HTML 对象解析工具（Regular Expression/Xpath/Beautiful Soup 4）以解析页面提取有效数据； 将提取到的有效数据持久化到本地磁盘（文件）或数据库。 下面将依照上述网络爬虫通用流程，逐布完善我们的网络爬虫脚本，最终已给出一个爬虫全流程示例。 请求获取网页 HTML 信息首先来看，如何使用 Python 网络模块（urllib/requests）发送 URL 请求以获取网页的 HTML 信息？！！ 以 Python 内置的 urllib 网络库为例 &gt;&gt;&gt; Use Built-in UrlLib Liburllib 库属于 Python 的标准库内置模块，故安装 Python 后即可使用，无须单独安装。 Python 3 中，统一为 urllib 库，已经不存在 urllib2 库了。较低的 Python 2 中支持 urllib &amp;&amp; urlib2 两个库来实现网络请求的发送。 urllib 库中包括了四个关键模块： urllib.request 模块：用来发送 Request 以及获取 Request 的响应结果（Response）； urllib.error 模块：定义了 urllib.request 模块可能产生的异常，你可以通过异常处理机制进行捕获处理； urllib.parse 模块：用来解析和处理 URL，例如 URL 编码以及解码； urllib.robotparser 模块：用来解析页面的 robots.txt 协议文件。 模拟发送请求urllib.request 模块提供了基本的 HTTP Request 的构造方法，并且可以模拟发起一个浏览器的请求（Request）过程。 先来感受一下它的强大之处，以向百度（http://www.baidu.com/）发起请求为例，获取百度首页的 HTML 信息： 123456789# 导入 urllib 网络库的 request 请求模块:# from urllib import requestimport urllib.request# 向 URL（http://www.baidu.com/）发送请求 &lt;&lt;&lt; URL 中必须带有 `HTTP/HTTPS` 传输协议:response = urllib.request.urlopen(&quot;http://www.baidu.com/&quot;)# 打印返回类型:print(type(response)) 输出结果如下： 1&lt;class 'http.client.HTTPResponse'&gt; 可见，通过 urllib.request 模块的 urlopen(url) 方法向 URL 发送请求后，会返回一个百度首页的响应对象（HTTPResponse）。 已经获取到了网站的响应消息，如何通过响应消息对象获取我们需要的信息： 响应对象（HTTPResponse）重要属性与方法支持&gt;&gt;&gt;&gt; 123456789101112# 主要方法：response.getcode() # 获取请求的 HTTP 响应码response.read() # 获取网页的 HTML 内容；response.getheaders() # 获取响应的所有头信息；response.getheader(name) # 根据响应头信息中的头部字段名（关键字），获取相应字段名所对应的值；response.geturl() # 获取响应对象的 URL 地址；# 主要属性：response.status # 获取响应的状态码response.msgresponse.versionresponse.closed 示例代码如下： 12345678910111213&gt;&gt;&gt; import urllib.request&gt;&gt;&gt; response = urllib.request.urlopen(&quot;https://www.baidu.com&quot;)&gt;&gt;&gt; print(response.geturl())http://www.baidu.com/&gt;&gt;&gt; print(response.getcode())200&gt;&gt;&gt; print(response.status)200&gt;&gt;&gt; print(response.getheaders())[('Server', 'BWS/1.1'), ('Date', 'Fri, 30 Dec 2022 09:07:13 GMT'), ('Content-Type', 'text/html; charset=utf-8'), ('Transfer-Encoding', 'chunked'), ('Connection', 'close'), ('Bdpagetype', '1'), ('Bdqid', '0xf71f01670008eef5'), ('P3p', 'CP=&quot; OTI DSP COR IVA OUR IND COM &quot;'), ('P3p', 'CP=&quot; OTI DSP COR IVA OUR IND COM &quot;'), ('Set-Cookie', 'BAIDUID=A401074D3A894C1EF658A7E9ED45D774:FG=1; expires=Thu, 31-Dec-37 23:55:55 GMT; max-age=2147483647; path=/; domain=.baidu.com'), ('Set-Cookie', 'BIDUPSID=A401074D3A894C1EF658A7E9ED45D774; expires=Thu, 31-Dec-37 23:55:55 GMT; max-age=2147483647; path=/; domain=.baidu.com'), ('Set-Cookie', 'PSTM=1672391233; expires=Thu, 31-Dec-37 23:55:55 GMT; max-age=2147483647; path=/; domain=.baidu.com'), ('Set-Cookie', 'BAIDUID=A401074D3A894C1EB80F6C57BCB052E4:FG=1; max-age=31536000; expires=Sat, 30-Dec-23 09:07:13 GMT; domain=.baidu.com; path=/; version=1; comment=bd'), ('Set-Cookie', 'BDSVRTM=0; path=/'), ('Set-Cookie', 'BD_HOME=1; path=/'), ('Set-Cookie', 'H_PS_PSSID=36558_37647_37906_36920_37990_37926_37901_26350_37957_37881; path=/; domain=.baidu.com'), ('Traceid', '1672391233035428020217806952993540075253'), ('Vary', 'Accept-Encoding'), ('X-Frame-Options', 'sameorigin'), ('X-Ua-Compatible', 'IE=Edge,chrome=1')]&gt;&gt;&gt; print(response.getheader(&quot;Server&quot;))BWS/1.1 上面，通过调用响应对象（HTTPResponse）的属性与方法，分别输出了：响应对象的 URL 地址、响应状态码、响应头信息，以及通过传递一个头部字段名称获取了 Server 的类型。 获取 HTML 信息我们提到，通过响应对象（HTTPResponse）的 read() 方法可以获取到百度首页的 HTML 内容，即抓取到了网页的源代码，尝试一下： 1234567&gt;&gt;&gt; import urllib.request&gt;&gt;&gt; response = urllib.request.urlopen(&quot;https://www.baidu.com&quot;)&gt;&gt;&gt; html = response.read().decode('utf-8')&gt;&gt;&gt; print(html)# 内容过长，这里只截取了一部分：&lt;!DOCTYPE html&gt;&lt;!--STATUS OK--&gt; &lt;html&gt;&lt;head&gt;&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html;charset=utf-8&quot;&gt;&lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot;&gt;&lt;meta content=&quot;always&quot; name=&quot;referrer&quot;&gt;&lt;meta name=&quot;theme-color&quot; content=&quot;#2932e1&quot;&gt;&lt;meta name=&quot;description&quot; content=&quot;全球最大的中文搜索引擎、致力于让网民更便捷地获取信息，找到...&quot;&gt;...&lt;/html&gt; 可以看到，这里我们成功抓取到了百度首页的 HTML 源代码。那得到源代码之后呢？？？ &gt;&gt;&gt; 我们想要的链接、图片地址、文本信息不就都可以提取出来了吗？！！ 字节串解码 &gt;&gt;&gt;&gt; 需要注意的是，响应对象（HTTPResponse）的 read() 方法提取 HTML 信息，返回的数据是字节串类型（bytes）的。 为了将其转化为易于处理的字符串类型，故需要 对字节串进行解码操作，这就涉及到 Python 中常用的编码、解码操作： 1234567# 按照特定字符集（'utf-8'），将字符串编码为采用特定字符编码的字节串：string.encode(&quot;utf-8&quot;)# 按照特定字符集（'utf-8'），将采用特定字符编码的字节串解码为字符串：bytes.decode(&quot;utf-8&quot;)# 需要注意的是，编码 &amp;&amp; 解码时使用的字符集必须一致，否则会出现乱码的情况!!! 由于 read() 方法返回的是采用 UTF-8 字符编码之后的字节串（bytes），故解码如下： 1response.read().decode('utf-8') 自此，我们已经基本完成了本节的目标：使用 Python 网络模块（urllib/requests）发送 URL 请求以获取网页的 HTML 信息。 URL 的编码和解码我们知道，WEB 浏览器会通过 URL 发送一个请求，实现从相应的 Web 服务器请求特定的资源。 如果 URL 路径或者查询参数中，带有中文或者特殊字符的时候，浏览器在发送请求前会对 URL 进行 URL 编码，这是 URL 编码协议 规定的。 URL 编码协议中规定：URL 只允许使用 ASCII 字符集中可以显示的字符来通过因特网进行发送。 关于 URL 编码更详细的说明，请参见博文系列中 [ &gt;&gt;&gt;&gt; 网站基础之 URL 结构解析 &lt;&lt;&lt;&lt; ] 关于 URL 编码的说明。 以百度搜索查找关键词信息为例 &gt;&gt;&gt;&gt; 打开 百度首页，在搜索框中输入：爬虫，然后点击 “百度一下”。 当搜索结果显示后，此时地址栏的 URL 信息显示如下： 1h ttps://www.baidu.com/s?ie=utf-8&amp;f=8&amp;rsv_bp=1&amp;rsv_idx=1&amp;tn=baidu&amp;wd=爬虫&amp;fenlei=256&amp;rsv_pq=0xbf2a62e800111815&amp;rsv_t=b88069xmyZzI8CzsTc9MHk9vLc%2Bpuy4NY0tyL6LdQx6z%2BCTKd1ZouF0Rn%2FFk&amp;rqlang=en&amp;rsv_enter=1&amp;rsv_dl=tb&amp;rsv_sug3=9&amp;rsv_sug1=9&amp;rsv_sug7=101&amp;rsv_sug2=0&amp;rsv_btype=i&amp;inputT=1812&amp;rsv_sug4=2982&amp;rsv_sug=1 可以看到，URL 中包含了很多的查询字符串，你可以找到一个 wd=爬虫，其中 wd 表示查询字符串的键（word），而 爬虫 则代表你输入的值。 你可以在网页地址栏中删除多余的查询字符串，只保留 wd=爬虫，如下： 1https://www.baidu.com/s?wd=爬虫 然后使用修改后的 URL 进行搜索，你会发现仍然得到了相同的页面。这是由于 wd 参数是 百度搜索的 关键查询参数。 | &gt;&gt;&gt; ============================================ Split Line ========================================= &lt;&lt;&lt; | 接下来，使用上面 【 1.1.1 &amp;&amp; 1.1.2 】小节介绍到的方法来抓取上述页面的 HTML 信息： [1] &gt;&gt;&gt; 编码 URL 查询字符串 在模拟发送请求前，你需要对 URL 中不符合 URL 编码协议的查询字符串进行编码处理。 urllib.parse 模块提供了 URL 的编码和解码方法，如下： 123456# 编码：urllib.parse.urlencode({'key':'value'}) # 编码查询字符串字典urllib.parse.quote(string) # 编码查询字符串# 解码：urllib.parse.unquote(string) # 对编码的查询字符串进行解码，以还原 URL 注意 urlencode(dict) &amp;&amp; quote(string) 方法的使用差异： 【示例一】 &gt;&gt;&gt; urlencode 12345678910111213# 导入 urllib 网络库的 URL 解析模块 parse:import urllib.parse# 构建查询字符串字典：query_str = {&quot;wd&quot;: &quot;爬虫&quot;}# 编码查询字符串字典：res = urllib.parse.urlencode(query_str)# 使用 Python Format 字符串格式化方法，拼接 URL 地址：url = &quot;http://www.baidu.com/s?{}&quot;.format(res)# 打印完整的编码后的 URL：print(url) 编码后的完整 URL 如下： 1http://www.baidu.com/s?wd=%E7%88%AC%E8%99%AB 【示例二】 &gt;&gt;&gt; quote（URL 编码后结果同上） 12345678910111213# 导入 urllib 网络库的 URL 解析模块 parse:import urllib.parse# 构建查询字符串：word = &quot;爬虫&quot;# 编码查询字符串：res = urllib.parse.quote(word)# 注意与 urlencode 的不同：url = &quot;http://www.baidu.com/s?w={}&quot;.format(res)# 打印完整的编码后的 URL：print(url) 我们知道，经过浏览器编码处理之后的 URL 才是最终请求中的 URL，故通过编码后的 URL 必然也是可以访问相应的 Web 服务器的。你可以认为我们浏览器中通常可见的未编码处理的 URL 是给用户看的，而编码之后的 URL 是给设备使用的。 [2] &gt;&gt;&gt; URL 地址拼接 上面我们使用了 Python 的 Format 格式化方法进行了 URL 地址的拼接，你还可以： 12345678910# Python 字符串加法：baseurl = 'http://www.baidu.com/s?'params = 'wd=%E7%88%AC%E8%99%AB'url = baseurl + paramsprint(url)# Python 格式化占位符：params = 'wd=%E7%88%AC%E8%99%AB'url = 'http://www.baidu.com/s?%s' % paramsprint(url) [3] &gt;&gt;&gt; 模拟发送请求 &amp;&amp; 获取 HTML 信息 准备好访问的 URL，就可以模拟发送，以及抓取目标页面的 HTML 信息了~~~ 为了更好的使用 urllib 网络库编写爬虫，我们需要继续深入解读一下其中关键函数的用法： 深入解读 UrlLib 库上面对 urlopen() 方法的简单使用，可以实现对简单页面的 GET 请求抓取。 如果我们想给 URL 传递一些隐式的参数该怎么实现呢（POST 请求）？？？ [1] &gt;&gt;&gt; urllib.request.urlopen() 详解 先来看一下 urlopen() 函数的 API： 1urllib.request.urlopen(url, data=None, [timeout, ]*, cafile=None, capath=None, cadefault=False, context=None) 可以发现，除了可以传递 URL 外，我们还可以传递其它的内容：比如 data（附加参数），timeout（超时时间）等等。 1）data 参数（可选） data 参数，需要的是字节流编码格式的内容，即 bytes 类型。也就是说，需要将构建的附加参数转化为字节流才可传入。 并且需要注意的是，如果你传入了 data 参数，它的请求方式就不再是 GET 方式请求，而是 POST 。看如下示例： 12345678910from urllib import request, parse# 构建参数字典：params = {&quot;word&quot;: &quot;hello&quot;}# 采用 &quot;UTF-8&quot; 字符编码，编码参数字典字符串为字节串：data = bytes(parse.urlencode(params), encoding=&quot;utf-8&quot;)# 发送 POST 请求：response = request.urlopen(&quot;http://httpbin.org/post&quot;, data=data)print(response.read().decode(&quot;utf-8&quot;)) 这里是通过向 HTTP 测试网站：httpbin.org，发送 POST 请求来查看发送的请求和收到的响应信息。输出（请求）如下： 1234567891011121314151617{ &quot;args&quot;: {}, &quot;data&quot;: &quot;&quot;, &quot;files&quot;: {}, &quot;form&quot;: { &quot;word&quot;: &quot;hello&quot; }, &quot;Content-Length&quot;: &quot;10&quot;, &quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded&quot;, &quot;Host&quot;: &quot;httpbin.org&quot;, &quot;User-Agent&quot;: &quot;Python-urllib/3.7&quot;, &quot;X-Amzn-Trace-Id&quot;: &quot;Root=1-63aeec25-63fa00987b2dca0168c5ef58&quot; }, &quot;json&quot;: null, &quot;origin&quot;: &quot;120.208.214.164&quot;, &quot;url&quot;: &quot;http://httpbin.org/post&quot;} 可以看到，我们发送的附加参数出现在了 form 中，这表明是模拟了表单提交的方式，以 POST 方式传输数据。 注意：HTTP 测试网站 &gt;&gt;&gt; httpbin.org，能测试 HTTP 请求和响应的各种信息，比如 cookie、IP、headers 和登录验证等，且支持 GET、POST 等多种方法，对 Web 开发和测试很有帮助。 2）timeout 参数（可选） timeout 参数可以设置请求的超时时间（单位为秒），支持 HTTP 、HTTPS 、FTP 请求。 如果请求超出了设置的这个时间还没有得到响应，就会抛出异常；如果不指定，就会使用全局默认时间。 来个实例感受一下： 1234from urllib import requestresponse = request.urlopen(&quot;http://httpbin.org/get&quot;, timeout=0.1)print(response.read().decode(&quot;utf-8&quot;)) 这里我们 请求了 http://httpbin.org/get 这个测试链接，并且设置了超时时间是 0.1 秒（基本不可能得到服务器响应），于是抛出一个超市异常：socket.timeout: timed out。 因此，你可以通过设置超时时间来控制一个网页如果长时间未响应就跳过它的抓取： 1234567import urllib.requestimport sockettry: response = urllib.request.urlopen('http://httpbin.org/get', timeout=0.1)except socket.timeout: print(&quot;Time Out !!!&quot;) 或者，你可以捕获这个异常，做一些其它的处理。 3）其它参数 其中，context 参数，它必须是 ssl.SSLContext 类型，用来指定 SSL 设置。 cafile 和 capath两个参数是指定 CA 证书和它的路径，这个在请求 HTTPS 链接时会有用。 cadefault 参数现在已经弃用了，默认为 False。 [2] &gt;&gt;&gt; urllib.request.Request() 详解 从上一小节可以看出，单纯使用 urlopen() 方法不足以构建一个完整的 HTTP 请求。 考虑一下，假设请求中需要添加请求头（Request Headers）等信息时，比如重构 User-Agent（用户代理，指用户使用的浏览器）使程序更像人类的请求，而非机器（反爬第一步）。怎么办？？？ 我们可以使用更强大的 Request 类来构建一个请求，然后发送： 12345import urllib.requestrequest = urllib.request.Request(&quot;https://www.baidu.com&quot;)response = urllib.request.urlopen(request)print(response.getcode()) 可以发现，我们依然使用 urlopen() 方法来发送这个请求，只不过这次 urlopen(url/Request) 方法的参数不再是一个 URL，而是一个 Request。通过构造这种数据结构（Request），一方面我们可以将请求独立成一个对象，另一方面可配置参数更加丰富和灵活。 Request 类的构造方法： 1class urllib.request.Request(url, data=None, headers={}, origin_req_host=None, unverifiable=False, method=None) | &gt;&gt;&gt; ============================================ 参数说明 ========================================= &lt;&lt;&lt; | url 参数（必备），其它参数可选。 data 参数同 urlopen 方法，必须传 bytes（字节流）类型的数据。如果添加参数是一个字典，可以先用 urllib.parse.urlencode() 编码为字符串，然后转化为字节串。 headers 参数是一个字典，你可以在构造 Request 时通过 headers 参数传递，也可以通过调用 Request 对象的 add_header() 方法来添加请求头。最常用的就是重构 User-Agent，默认的 User-Agent 是 Python-urllib（爬虫访问），你可以通过重构它来伪装成浏览器（而非爬虫），使程序更像人类的请求，而非机器。 origin_req_host 指的是请求方的 host 名称或者 IP 地址。 unverifiable 指的是这个请求是否是无法验证的，默认是 False。意思就是说用户没有足够权限来选择接收这个请求的结果。例如我们请求一个 HTML 文档中的图片，但是我们没有自动抓取图像的权限，这时 unverifiable 的值就是 True。 method 是一个字符串，它用来指示请求使用的方法，比如 “GET”，”POST”，”PUT” 等等。 | &gt;&gt;&gt; ============================================================================================ &lt;&lt;&lt; | 构建一个 Request 来感受一下其强大： 12345678910111213141516171819import urllib.requestimport urllib.parseurl = &quot;http://httpbin.org/post&quot;params = {&quot;word&quot;: &quot;Spider&quot;}data = bytes(urllib.parse.urlencode(params), encoding=&quot;utf-8&quot;)# 请求头信息：headers = { # 伪装成：Windows IE &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; WOW64; Trident/7.0; rv:11.0) like Gecko&quot;, &quot;host&quot;: &quot;httpbin.org&quot;}req = urllib.request.Request(url=url, data=data, headers=headers, method=&quot;POST&quot;)response = urllib.request.urlopen(req, timeout=1)print(response.read().decode(&quot;utf-8&quot;)) 运行结果如下： 123456789101112131415161718{ &quot;args&quot;: {}, &quot;data&quot;: &quot;&quot;, &quot;files&quot;: {}, &quot;form&quot;: { &quot;word&quot;: &quot;Spider&quot; }, &quot;headers&quot;: { &quot;Content-Length&quot;: &quot;11&quot;, &quot;Content-Type&quot;: &quot;application/x-www-form-urlencoded&quot;, &quot;Host&quot;: &quot;httpbin.org&quot;, &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; WOW64; Trident/7.0; rv:11.0) like Gecko&quot;, &quot;X-Amzn-Trace-Id&quot;: &quot;Root=1-63af03d3-26062be47c618d2115808836&quot; }, &quot;json&quot;: null, &quot;origin&quot;: &quot;120.208.214.164&quot;, &quot;url&quot;: &quot;http://httpbin.org/post&quot;} 可以看到，我们已经成功设置了 data，headers 以及 method。 另外，你也可以通过 Request 对象的 add_header(key, value) 方法来添加 headers： 12req = urllib.request.Request(url=url, data=data, method=&quot;POST&quot;)req.add_header(&quot;User-Agent&quot;, &quot;Mozilla/5.0 (Windows NT 10.0; WOW64; Trident/7.0; rv:11.0) like Gecko&quot;) [3] &gt;&gt;&gt; urllib.request 高级特性 上面，我们虽然可以构造 Request 请求对象，但是一些更高级但常见的操作，如 authenticaton（授权验证），redirections（重定向)、Cookies、代理 IP 怎么设置？？？ 这就需要更强大的工具 Handler 登场了~~~ 简而言之，你可以把它理解为各种处理器（Handler）：有专门处理登录验证的，有处理 Cookies 的，有处理代理设置的，利用它们我们几乎可以做到任何 HTTP 请求中所有的事情。 处理器（Handler）类说明 &gt;&gt;&gt;&gt; 首先需要说明下 urllib.request.BaseHandler，它是所有其他 Handler 的父类，提供了最基本的 Handler 的方法。 接下来就有各种 Handler 类继承这个 BaseHandler： HTTPDefaultErrorHandler：用于处理 HTTP 响应错误的处理器（错误都会抛出 HTTPError 类型的异常）； HTTPRedirectHandler：用于处理重定向的处理器； HTTPCookieProcessor：用于处理 Cookie 的处理器； ProxyHandler：用于设置代理的处理器（默认代理为空）； HTTPPasswordMgr：用于管理密码的处理器，它维护了用户名密码的表； HTTPBasicAuthHandler：用于管理认证的处理器，如果一个链接打开时需要认证，那么可以用它来解决认证问题。 其他的 Handler，可参考 &gt;&gt;&gt; 官方文档。 OpenerDirector 概念 &gt;&gt;&gt;&gt; OpenerDirector 也叫 Opener。前面的 urllib.request.urlopen() 方法实际上就是一个 Opener。 为什么要引入 Opener 呢？？？ 之前我们使用的 Request、urlopen() 相当于类库为你封装好了极其常用的请求方法，利用它们两个就可以完成基本的请求。但是现在我们需要实现更高级的功能，所以就要用到比调用 Request &amp;&amp; urlopen() 的对象的更普遍的对象，也就是 Opener。 并且，Opener 可以使用 open() 方法，返回的类型和 urlopen() 如出一辙。 那么 Opener 和 Handler 有什么关系？简而言之，就是利用 Handler 来构建 Opener。 代理设置样例 &gt;&gt;&gt;&gt; 12345678import urllib.requestproxy_handler = urllib.request.ProxyHandler({'http': 'http://218.202.111.10:80','https': 'https://180.250.163.34:8888'})opener = urllib.request.build_opener(proxy_handler)response = opener.open('https://www.baidu.com')print(response.read()) 上面，ProxyHandler 的参数是一个字典，key 是协议类型，比如 http 还是 https 等，value 是代理链接，可以添加多个代理。 然后利用 build_opener() 方法，利用 ProxyHandler 构造一个 Opener ，然后发送请求即可。 Cookie 设置样例 &gt;&gt;&gt;&gt; 如何将网站的 Cookie 获取下来： 12345678910import http.cookiejarimport urllib.requestcookie = http.cookiejar.CookieJar()handler = urllib.request.HTTPCookieProcessor(cookie)opener = urllib.request.build_opener(handler)response = opener.open('http://www.baidu.com')for item in cookie: print(item.name+&quot;=&quot;+item.value) 首先，声明了一个 CookieJar 对象，接下来使用 HTTPCookieProcessor 来构建一个 handler ，最后利用 build_opener 方法构建出 opener ，执行 open() 即可。 程序运行结果如下： 123456BAIDUID=552C3DCBEB1E5259021C3B13D89EFE9E:FG=1BIDUPSID=552C3DCBEB1E5259DB7B1C021AEC02BDH_PS_PSSID=36548_37647_38024_38012_36921_37990_37793_37922_38000_37901_26350_37881PSTM=1672418818BDSVRTM=0BD_HOME=1 可以看到输出了每一条 Cookie 的名称还有值。 不过既然能输出，那可不可以输出成文件格式呢？？？我们知道很多 Cookie 实际也是以文本形式保存的，实例： 123456789101112import http.cookiejarimport urllib.requestfilename = 'cookie.txt'cookie = http.cookiejar.MozillaCookieJar(filename)handler = urllib.request.HTTPCookieProcessor(cookie)opener = urllib.request.build_opener(handler)response = opener.open('http://www.baidu.com')cookie.save(ignore_discard=True, ignore_expires=True) 这时的 CookieJar 就需要换成 MozillaCookieJar ，生成文件时需要用到它，它是 CookieJar 的子类，可以用来处理 Cookie 和文件相关的事件，读取和保存 Cookie ，它可以将 Cookie 保存成 Mozilla 型的格式。 运行之后可以发现生成了一个 cookie.txt 文件，内容如下： 12345678910# Netscape HTTP Cookie File# http://curl.haxx.se/rfc/cookie_spec.html# This is a generated file! Do not edit..baidu.com TRUE / FALSE 1703955537 BAIDUID 57210CFA95ED4AAE5E41CE04319F9861:FG=1.baidu.com TRUE / FALSE 3819903184 BIDUPSID 57210CFA95ED4AAEE6DCD16048C7FA1B.baidu.com TRUE / FALSE H_PS_PSSID 36552_37647_37906_38014_37625_36920_37989_37936_37951_37903_26350_22158_37881.baidu.com TRUE / FALSE 3819903184 PSTM 1672419537www.baidu.com FALSE / FALSE BDSVRTM 0www.baidu.com FALSE / FALSE BD_HOME 1 另外还有一个 LWPCookieJar，同样可以读取和保存 Cookie。但是保存的格式和 MozillaCookieJar 的不一样，它会保存成与libwww-perl的Set-Cookie3文件格式的 Cookie。使用时只需要在声明时就改为： 1cookie = http.cookiejar.LWPCookieJar(filename) 生成文件内容如下： 1234567#LWP-Cookies-2.0Set-Cookie3: BAIDUID=&quot;E4A0DC4870957473807CD2478492DDD5:FG=1&quot;; path=&quot;/&quot;; domain=&quot;.baidu.com&quot;; path_spec; domain_dot; expires=&quot;2023-12-30 17:03:19Z&quot;; comment=bd; version=0Set-Cookie3: BIDUPSID=E4A0DC4870957473D133AD644C840120; path=&quot;/&quot;; domain=&quot;.baidu.com&quot;; path_spec; domain_dot; expires=&quot;2091-01-17 20:17:26Z&quot;; version=0Set-Cookie3: H_PS_PSSID=36554_37647_38024_37907_38018_37623_36920_37990_37797_37927_37952_37904_26350_37881; path=&quot;/&quot;; domain=&quot;.baidu.com&quot;; path_spec; domain_dot; discard; version=0Set-Cookie3: PSTM=1672419800; path=&quot;/&quot;; domain=&quot;.baidu.com&quot;; path_spec; domain_dot; expires=&quot;2091-01-17 20:17:26Z&quot;; version=0Set-Cookie3: BDSVRTM=0; path=&quot;/&quot;; domain=&quot;www.baidu.com&quot;; path_spec; discard; version=0Set-Cookie3: BD_HOME=1; path=&quot;/&quot;; domain=&quot;www.baidu.com&quot;; path_spec; discard; version=0 既然生成了 Cookie 文件，怎样从文件读取并利用呢？？？ 以 LWPCookieJar 格式为例： 1234567891011import http.cookiejarimport urllib.requestcookie = http.cookiejar.LWPCookieJar()cookie.load('cookie.txt', ignore_discard=True, ignore_expires=True)handler = urllib.request.HTTPCookieProcessor(cookie)opener = urllib.request.build_opener(handler)response = opener.open('http://www.baidu.com')print(response.status) 前提是我们首先利用上面的方式生成了 LWPCookieJar 格式的 Cookie ，然后利用 load() 方法，传入文件名称，后面同样的方法构建 handler 和 opener 即可。 | &gt;&gt;&gt; ============================================== Split Line =========================================== &lt;&lt;&lt; | 事实上，Python 内置的 urllib 网络库的使用较为 “繁琐”，不利于初学者的掌握。 后续，我们会引入一个第三方的，方便、快捷的 Requests 库，Requests 库是在 urllib 的基础上开发而来，其宗旨就是 “让 HTTP 服务于人类”。 关于 Requests 库的使用说明可以参见博文系列中 [ &gt;&gt;&gt;&gt; Web Crawler 教程之网络爬虫工具库 &lt;&lt;&lt;&lt;] 中 Requests 网络库部分的说明。 ↓↓↓↓↓↓↓ 反爬第一步 ↓↓↓↓↓↓↓ User-AgentUser-Agent（UA）即用户代理，它是一个特殊字符串头部字段（headers）。 网站服务器，可以通过识别请求头中的 UA 来确定用户所使用的操作系统版本、CPU 类型、浏览器版本等信息，然后通过判断 UA 来给客户端发送不同的页面。 大多数网站，会通过识别请求头中 User-Agent 信息来判断是否是爬虫访问网站（Python-urllib）。例如，一旦检测到是爬虫在访问，会对发送请求的 IP 进行预警并重点监控，如果发现 IP 超过规定时间内的访问次数， 将在一段时间内禁止其再次访问网站（封 IP）。如果你在爬虫时登录了该网站，甚至会被封禁登录账户（封账户）。 所以，你需要重构爬虫程序访问时的 User-Agent，这是必要的，这是反爬策略的第一步！！！ 你可以，基于常见的浏览器 User-Agent 重构爬虫 UA &gt;&gt;&gt;&gt; 系统 浏览器 User-Agent字符串 Mac Chrome Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.75 Safari/537.36 Mac Firefox Mozilla/5.0 (Macintosh; Intel Mac OS X 10.12; rv:65.0) Gecko/20100101 Firefox/65.0 Mac Safari Mozilla/5.0 (Macintosh; Intel Mac OS X 10_12_6) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/12.0.3 Safari/605.1.15 Windows Edge Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.140 Safari/537.36 Edge/18.17763 Windows IE Mozilla/5.0 (Windows NT 10.0; WOW64; Trident/7.0; rv:11.0) like Gecko Windows Chrome Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/72.0.3626.121 Safari/537.36 iOS Chrome Mozilla/5.0 (iPhone; CPU iPhone OS 7_0_4 like Mac OS X) AppleWebKit/537.51.1 (KHTML, like Gecko) CriOS/31.0.1650.18 Mobile/11B554a Safari/8536.25 iOS Safari Mozilla/5.0 (iPhone; CPU iPhone OS 8_3 like Mac OS X) AppleWebKit/600.1.4 (KHTML, like Gecko) Version/8.0 Mobile/12F70 Safari/600.1.4 Android Chrome Mozilla/5.0 (Linux; Android 4.2.1; M040 Build/JOP40D) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/31.0.1650.59 Mobile Safari/537.36 Android Webkit Mozilla/5.0 (Linux; U; Android 4.4.4; zh-cn; M351 Build/KTU84P) AppleWebKit/534.30 (KHTML, like Gecko) Version/4.0 Mobile Safari/534.30 更多浏览器 UA 信息（移动端 &amp;&amp; PC端）可参考 [ &gt;&gt;&gt; 常见的浏览器 User-Agent &lt;&lt;&lt; ] 如何查看本机的浏览器版本以及 UA 信息 &gt;&gt;&gt;&gt; [ &gt;&gt;&gt; Browser Version &amp;&amp; UA 在线识别工具 &lt;&lt;&lt; ] 爬虫程序 UA 信息你可以通过 HTTP 测试网站 &gt;&gt;&gt; http://httpbin.org/ &gt;&gt;&gt; 发送一个 GET 请求来获取请求头信息，从而获取爬虫程序的 UA 信息： 1234import urllib.requestresponse = urllib.request.urlopen(&quot;http://httpbin.org/get&quot;)print(response.read().decode(&quot;utf-8&quot;)) 输出的请求头信息如下： 12345678910111213{ &quot;args&quot;: {}, # 请求头信息 &quot;headers&quot;: { &quot;Host&quot;: &quot;httpbin.org&quot;, &quot;User-Agent&quot;: &quot;Python-urllib/3.7&quot;, # User-Agent 信息包含在请求头中 &quot;X-Amzn-Trace-Id&quot;: &quot;Root=1-63afe3f5-431e63ad6501f31a0c7aca33&quot; }, &quot;origin&quot;: &quot;120.208.214.xxx&quot;, &quot;url&quot;: &quot;http://httpbin.org/get&quot;} 可以看到，爬虫程序的 User-Agent 竟然是 Python-urllib/3.7，网站基于此会判断出是爬虫脚本在访问。 所以，我们需要重构爬虫程序访问时的 User-Agent，以伪装成 “浏览器” 访问网站： 重构爬虫 UA 信息你可以使用 urllib.request 中的 Request 类来重构 User-Agent 信息： 123456789101112import urllib.requesturl = &quot;http://httpbin.org/get&quot;# 重构请求头中 User-Agent：伪装成 Chrome 浏览器，可以使用上面常见的浏览器 User-Agent 信息支持headers = { &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/72.0.3626.121 Safari/537.36&quot;}req = urllib.request.Request(url=url, headers=headers)response = urllib.request.urlopen(req)print(response.read().decode(&quot;utf-8&quot;)) 输出的请求信息如下： 12345678910{ &quot;args&quot;: {}, &quot;headers&quot;: { &quot;Host&quot;: &quot;httpbin.org&quot;, &quot;User-Agent&quot;: &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/72.0.3626.121 Safari/537.36&quot;, &quot;X-Amzn-Trace-Id&quot;: &quot;Root=1-63afed6e-65a5d0397ba0e73d1fbf3e1b&quot; }, &quot;origin&quot;: &quot;120.208.214.164&quot;, &quot;url&quot;: &quot;http://httpbin.org/get&quot;} 可以看到，网站接收到的请求头信息中的 UA 信息已经变为伪装的 Chrome 浏览器 UA 了。 构建 UA 代理池如果短时间内总是使用一个 UA 来高频率访问网站，可能会引起网站的警觉，认为是爬虫在访问，从而封禁 IP（账户）。 因此，我们需要构建用户代理池（User-Agent Pool），避免总是使用一个 UA 来访问网站。 用户代理池（User-Agent Pool），就是把多个浏览器的 UA 信息放入一个列表中，访问网站时从中随机选择一个浏览器 UA。 自定义 UA 代理池 &gt;&gt;&gt;&gt; 通过收集的浏览器 UA 来自定义一个 User-Agent Pool，然后随机获取 UA： 1234567891011121314151617181920import random# 构建随机产生 UA 的自定义用户代理池ua_pool = [ 'Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; Maxthon 2.0', 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_7_0) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.56 Safari/535.11', 'Opera/9.80 (Windows NT 6.1; U; en) Presto/2.8.131 Version/11.11', 'Mozilla/5.0 (Windows NT 6.1; rv:2.0.1) Gecko/20100101 Firefox/4.0.1', 'Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 6.0)', 'Mozilla/5.0 (Windows; U; Windows NT 6.1; en-us) AppleWebKit/534.50 (KHTML, like Gecko) Version/5.1 Safari/534.50', 'Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Trident/5.0', 'Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1', 'Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1', 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10.6; rv:2.0.1) Gecko/20100101 Firefox/4.0.1']# 通过 Python 随机模块 random 随机产生 UA# ua_info = ua_pool[random.randint(0, len(ua_pool)-1)]ua_info = random.choice(ua_pool)print(ua_info) 除了上述的自定义用户代理池的方法，还有专门的第三方库支持随机获取浏览器 UA 信息（不用手动收集）。 随机产生 UA 的用户代理池第三方库 &gt;&gt;&gt;&gt; fake-useragent 由于 fake-useragent 库是一个第三方库，故需要单独按照： 1pip install fake-useragent 安装成功之后，来看如何使用 fake-useragent 模块随机产生一个 UA： 1234567891011# 使用第三方用户代理池库随机产生 UAimport fake_useragent# 实例化用户代理词对象ua = fake_useragent.UserAgent()# 随机产生一个 UA：print(ua.random)# 输出：# Mozilla/5.0 (Windows; U; Windows NT 6.1; de-DE) AppleWebKit/534.10 (KHTML, like Gecko) Chrome/8.0.552.224 Safari/534.10 如何产生指定浏览器的随机 UA &gt;&gt;&gt; 1234567891011121314# 使用第三方用户代理池库随机产生 UAimport fake_useragent# 实例化用户代理词对象ua = fake_useragent.UserAgent()# 支持的 Browser 列表：# [&quot;chrome&quot;, &quot;edge&quot;, &quot;internet explorer&quot;, &quot;firefox&quot;, &quot;safari&quot;, &quot;opera&quot;]print(ua.ie) # &quot;internet explorer（ie）&quot;print(ua.firefox) # &quot;firefox&quot;print(ua.chrome) # &quot;chrome&quot;print(ua.edge) # &quot;edge&quot;print(ua.safari) # &quot;safari&quot;print(ua.opera) # &quot;opera&quot; 输入的不同浏览器的 UA 信息如下： 123456Mozilla/4.0 (compatible; MSIE 5.16; Mac_PowerPC)Mozilla/5.0 (X11; U; Linux i686; fr; rv:1.9.0.9) Gecko/2009042113 Ubuntu/8.04 (hardy) Firefox/3.0.9Mozilla/6.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/532.0 (KHTML, like Gecko) Chrome/3.0.195.27 Safari/532.0Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/64.0.3282.140 Safari/537.36 Edge/18.17720Mozilla/5.0 (Macintosh; U; PPC Mac OS X; fr) AppleWebKit/412.7 (KHTML, like Gecko) Safari/412.5Opera/9.64 (X11; Linux i686; U; sv) Presto/2.1.1 实例：爬虫抓取网页信息有了上面的知识储备，这里完成我们的第一个 Python 爬虫实战案例：抓取期望的网页信息，并将其保存至本地。 案例说明：抓取 百度搜索 关键词后检索到的首页信息 &gt;&gt;&gt;&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import urllib.parseimport fake_useragentimport urllib.request# 获取完整的 URL：def getUrl(word): url = &quot;http://www.baidu.com/s?{}&quot; # 编码 URL 中查询字符串： query_str = {&quot;wd&quot;: word} params = urllib.parse.urlencode(query_str) # 拼接 URL： url = url.format(params) print(&quot;Request URL: &quot; + url) return url# 随机获取浏览器伪装 UA：def getUA(): ua = fake_useragent.UserAgent() return ua.edge# 请求检索到的首页信息（GET）：def requestHtml(url): ua_info = getUA() print(&quot;User-Agent: &quot; + ua_info) headers = { &quot;User-Agent&quot;: ua_info, } # 重构请求对象： req = urllib.request.Request(url=url, headers=headers) # 发送请求： response = urllib.request.urlopen(req) print(&quot;Request Status Code:&quot;, response.status) # 期望的网页信息： html = response.read().decode(&quot;utf-8&quot;) return html# 本地持久化：def dataSave(word, data): filename = word + &quot;.html&quot; with open(filename, &quot;w&quot;, encoding=&quot;utf-8&quot;) as f: f.write(data)# 主程序入口：if __name__ == &quot;__main__&quot;: print(&quot;| &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Start Spider &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; |&quot;) word = input(&quot;Please Enter Your Search: &quot;) url = getUrl(word) html = requestHtml(url) dataSave(word, html) print(&quot;| &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Close Spider &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; |&quot;) 可以发现，通过百度搜索关键词后检索到的首页 HTML 代码都抓取了下来，并且保存在了被你的文件中。 需要注意的是，查看生成的网页信息文件时，你可能会发现抓取到的不是网页信息，响应内容显示 ….百度安全验证….网络不给力，请稍后重试….返回首页…问题反馈。出现此问题可能是请求头定义不完善被反爬，详细请参见后文【网络爬虫常见问题】&gt;&gt;&gt;【百度安全验证问题】。 审查网页结构以及元素节点信息接着来看，如何通过浏览器并借助网页元素审查工具分析网页结构以及元素节点信息？！！ 前面我们已经可以将网页中的所有信息（不管是否有用）都抓取下来了，为了提取出我们期望的信息，你必须先了解抓取网页文档的结构以及元素节点信息！！！ 网页的构成根据 W3C 标准模式，网页一般由三部分组成： HTML：负责定义网页的内容； CSS：负责描述网页的样式； JavaScript：负责网页的行为。 网页构成是爬虫的基础，关于 HTML &amp;&amp; CSS &amp;&amp; JavaScript 的详细说明可以参考相关博文系列。 动态网页 VS 静态网页实际上，在编写爬虫之前，你首先需要 明确待爬取页面的类型：页面是静态的，还是动态的？？？ 这是由于，对于不同的网页类型，编写爬虫程序时所使用的方法也不尽相同。 | &gt;&gt;&gt; ============================================= Split Line ========================================== &lt;&lt;&lt; | 静态网页静态网页是网站设计的基础，早期的网站一般都是由静态网页制作的。 纯粹 HTML 格式的网页通常被称为 “静态网页”，静态网页是标准的 HTML 文件，它的文件扩展名是 .htm Or .html，可以包含文本、图像、声音、FLASH 动画、客户端脚本和 ActiveX 控件等。 容易误解的是&gt;&gt;&gt;&gt; 静态并非静止不动 ，页面中也可以出现各种动态的效果，如 GIF 动画、FLASH、滚动字幕等等，这只是一种网页内容的表现形式。 我们知道，当页面所包含的信息量较大时，网页的生成速度会降低。而由于 静态网页的内容相对固定，且不需要连接后台数据库，因此响应速度非常快。但静态网页的更新相较比较麻烦，需要将所有的更新内容添加的页面中，故一般适用于更新较少的展示型网站。 静态页面抓取 &gt;&gt;&gt; 静态网页可以通过 GET/POST 请求方法直接获取，它的数据全部包含在 GET/POST 请求返回的 HTML 文档中，因此爬虫程序可以直接在返回的 HTML 文档中提取数据。 也就是说，只要通过分析静态网页的 URL，找到 URL 查询参数的变化规律之后，就可以实现静态页面的抓取了。 与动态网页相比，静态网页对搜索引擎更加友好，有利于搜索引擎的收录。 动态网页动态网页，指的是采用了动态网页技术的页面，例如：AJAX（是指一种创建交互式、快速动态网页应用的网页开发技术）、ASP(是一种创建动态交互式网页并建立强大的 web 应用程序)、JSP(是 Java 语言创建动态网页的技术标准) 等技术。 动态网页中，不需要重新加载整个页面内容，就可以实现网页的局部更新。 也就是说，动态页面使用 “动态页面技术” 与服务器进行数据交换，从而实现了网页的异步加载。 动态页面技术 &gt;&gt;&gt; 实际上，你可以将 动态页面技术 理解为：页面中除了 HTML 标记语言外的一些具有特定功能的代码。 这些代码，可以使得浏览器和服务器进行交互，服务器端会根据客户端的不同请求，执行可能涉及到数据库连接、访问、查询等一系列的 IO 操作（响应速度略差于静态网页），然后返回请求信息给浏览器，从而实现网页的异步加载。 以查看百度图片为例 &gt;&gt;&gt; 浏览器中打开百度图片（https://image.baidu.com/）并搜索 Python，向下滚动鼠标滑轮，会查看到越来越多的逐渐加载出来的图片。 也就意味着，当你滚动鼠标滑轮时，网页会从服务器数据库自动加载数据并渲染页面。如下所示： 动态页面抓取 &gt;&gt;&gt; 抓取动态网页的过程较为复杂，需要通过动态抓包来获取客户端与服务器交互的 JSON 数据。 抓包可以使用谷歌浏览器开发者模式（快捷键：F12）Network 选项，然后点击 XHR，找到获取 JSON 数据的 URL，如下所示： 或者，你也可以使用专业的抓包工具 &gt;&gt;&gt;&gt; Fiddler。 审查页面元素对于一个优秀的爬虫工程师而言，要善于发现 HTML 网页元素的规律，并且能从中提炼出有效的信息。 浏览器都自带审查页面元素（Inspect）的功能，你可以通过打开浏览器的开发者工具（F12），审查页面元素功能在页面的左上角，如图： 通过审查页面元素（Inspect）功能，你可以确定网页中某内容所对应的 HTML 代码位置。下图以 百度首页中搜索框 为例： 点击审查元素按钮 &gt;&gt;&gt; 将鼠标移动至想审查的位置（如：百度的输入框），然后单击 &gt;&gt;&gt; 自动显示该位置内容的代码段（如上图）。 并且，代码段处支持快速复制 &gt;&gt;&gt; 右击代码段 &gt;&gt;&gt; Copy 选项卡 &gt;&gt;&gt; 二级会话框内选择 Copy element。即可复制正在审查的元素代码，如下： 1&lt;input id=&quot;kw&quot; name=&quot;wd&quot; class=&quot;s_ipt&quot; value=&quot;&quot; maxlength=&quot;255&quot; autocomplete=&quot;off&quot;&gt; 依照上述方法，你可以检查页面内的所有元素。 编辑网页代码 &gt;&gt;&gt;&gt; 通过元素审查，你可以快速定位到页面内容的元素代码段。然后你可以基于定位代码段，更改网页代码。 以 阿里云个人邮箱登录界面 为例： 检查密码框的 HTML 代码，代码如下所示： 1&lt;input id=&quot;fm-login-password&quot; class=&quot;fm-text&quot; type=&quot;password&quot; name=&quot;password&quot; tabindex=&quot;2&quot; placeholder=&quot;Password&quot; autocorrect=&quot;off&quot; autocapitalize=&quot;off&quot; data-spm-anchor-id=&quot;0.0.0.i1.18d9614fk4hZWl&quot;&gt; 你只需要在代码段上稍微做一下更改（双击 type=&quot;password&quot; 将输入框类型更改为 type=&quot;text&quot;），密码就会变为可见状态。效果如下： 此操作适用于所有网站的登录界面！！！ 需要注意的是，更改网页代码效果仅限本次有效，当关闭（或重新刷新）网页后，会自动恢复为原来的状态。 检查网页结构对于网络爬虫而言，检查网页结构是至关重要的一步。 检查网页结构，即 对网页的 HTML 文档结构进行分析，并找出要提取信息所对应元素节点的相似性（规律）。 以 猫眼电影网 榜单页面为例（期望提取榜单中电影信息），审查每部影片的 HTML 元素结构： 第一部影片的代码段如下所示： 1234567891011121314&lt;div class=&quot;board-item-main&quot;&gt; &lt;div class=&quot;board-item-content&quot;&gt; &lt;div class=&quot;movie-item-info&quot;&gt; &lt;p class=&quot;name&quot;&gt;&lt;a href=&quot;/films/1205&quot; title=&quot;放牛班的春天&quot; data-act=&quot;boarditem-click&quot; data-val=&quot;{movieId:1205}&quot;&gt;放牛班的春天&lt;/a&gt; &lt;/p&gt; &lt;p class=&quot;star&quot;&gt;主演：热拉尔·朱诺,弗朗西斯·贝尔兰德,凯德·麦拉德&lt;/p&gt; &lt;p class=&quot;releasetime&quot;&gt;上映时间：2004-10-16&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;movie-item-number score-num&quot;&gt; &lt;p class=&quot;score&quot;&gt;&lt;i class=&quot;integer&quot;&gt;9.&lt;/i&gt;&lt;i class=&quot;fraction&quot;&gt;6&lt;/i&gt; &lt;/p&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 接下来，检查第二部影片的代码段，如下所示： 1234567891011121314&lt;div class=&quot;board-item-main&quot;&gt; &lt;div class=&quot;board-item-content&quot;&gt; &lt;div class=&quot;movie-item-info&quot;&gt; &lt;p class=&quot;name&quot;&gt;&lt;a href=&quot;/films/341219&quot; title=&quot;穿靴子的猫2&quot; data-act=&quot;boarditem-click&quot; data-val=&quot;{movieId:341219}&quot;&gt;穿靴子的猫2&lt;/a&gt; &lt;/p&gt; &lt;p class=&quot;star&quot;&gt;主演：安东尼奥·班德拉斯,萨尔玛·海耶克,哈维·吉兰&lt;/p&gt; &lt;p class=&quot;releasetime&quot;&gt;上映时间：2022-12-23&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;movie-item-number score-num&quot;&gt; &lt;p class=&quot;score&quot;&gt;&lt;i class=&quot;integer&quot;&gt;9.&lt;/i&gt;&lt;i class=&quot;fraction&quot;&gt;3&lt;/i&gt; &lt;/p&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 对比可发现，每部影片的除了信息不同之外，它们的 HTML 结构是相同的。比如，每部影片都使用 &lt;dd&gt;&lt;/dd&gt; 标签包裹起来。 这里我们只检查了两部影片，在实际编写时，你可以多检查几部，从而确定它们的 HTML 结构是相同的。 实例：爬虫抓取百度贴吧数据有了上面的知识储备，这里来看一个 Python 爬虫实战案例：抓取百度贴吧信息（某贴吧下多个页面信息），并将其保存至本地。 案例说明：抓取 百度贴吧 搜索关键词（Python）后检索到的 Python 吧 中前 5 个页面信息 &gt;&gt;&gt;&gt; 以下案例流程为 &gt;&gt;&gt; 编写网络爬虫脚本的通用流程： 预分析在开始编写网络爬虫脚本之前，你需要对待爬取的页面进行如下分析： [1] &gt;&gt;&gt; 判断页面类型 分析方法 &gt;&gt;&gt; 如果页面中的所有数据信息都包含在其 HTML 文档中，那么当前待爬取的页面属于静态页面，而网页数据存在异步加载的页面为动态页面。 以案例为例，具体操作为：打开百度贴吧，搜索 Python，在出现的页面中复制任意一段信息，比如 解决一切python问题，然后点击右键选择查看源码（View Page Source），并使用 Ctrl+F 快捷键在源码页面搜索刚刚复制的数据。 故，可以判断出 &gt;&gt;&gt;&gt; 抓取的百度贴吧页面属于静态网页。 [2] &gt;&gt;&gt; 分析 URL 变化规律 接下来，你需要寻找待爬取百度贴吧页面的 URL 规律（用于后续的请求发送以获取带爬取页面的 HTML 信息）： 搜索 “Python” 后，此贴吧第一页的的 URL 如下所示： 1https://tieba.baidu.com/f?ie=utf-8&amp;kw=python&amp;fr=search 点击第二页，其 URL 信息如下： 1https://tieba.baidu.com/f?kw=python&amp;ie=utf-8&amp;pn=50 点击第三页，其 URL 信息如下： 1https://tieba.baidu.com/f?kw=python&amp;ie=utf-8&amp;pn=100 重新点击第一页，其 URL 信息如下： 1https://tieba.baidu.com/f?kw=python&amp;ie=utf-8&amp;pn=0 如果还不确定，你可以继续多浏览几页。你可以发现 URL 具有两个关键查询参数，分别是 kw 和 pn，并且 pn 参数具有规律性： 123456789第 N 页：pn = (n-1) * 50# 查询参数：pn = (pageNum - 1) * 50# 查询参数字典：params = { &quot;kw&quot;: &quot;python&quot;, &quot;pn&quot;: &quot;str(pn)&quot;} 故，百度贴吧页面访问 URL 规则可以简写为： 1https://tieba.baidu.com/f?kw=python&amp;pn=(pageNum-1)*50 [3] &gt;&gt;&gt; 审查网页结构以及元素节点信息 一般情况下，为了提取页面中的期望信息，在编写网络爬虫脚本前你还必须审查 期望信息在 HTML 文档中的结构以及元素节点信息 以确定内容提取的解析表达式。审查方法可参考上文，解析表达式可参见下文。 这里，因为我们抓取的是整个页面，故不需要进一步审查。 网络爬虫编写这里，以面向对象的编程设计思路，给出案例的爬虫脚本代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384import timeimport urllib.parseimport urllib.requestimport fake_useragentimport random# 定义爬虫类：class TiebaSpider(object): def __init__(self): self.url = &quot;https://tieba.baidu.com/f?{}&quot; # 1. 请求获取网页 HTML 信息（GET）： def requestHTML(self, url): # 随机获取浏览器伪装 UA： ua = fake_useragent.UserAgent() ua_info = ua.random # print(&quot;User-Agent: &quot; + ua_info) headers = { &quot;User-Agent&quot;: ua_info, # &quot;Accept&quot;: &quot;&quot;, # &quot;Cookie&quot;: &quot;&quot; } # 重构请求对象： req = urllib.request.Request(url=url, headers=headers) # 发送请求 response = urllib.request.urlopen(req) # print(&quot;Request Status Code:&quot;, response.status) # 响应的网页信息： html = response.read().decode(&quot;utf-8&quot;) # html = response.read().decode(&quot;gbk&quot;, &quot;ignore&quot;) return html # 2. 页面解析： def parseHTML(self): # TODO: 后续介绍解析模块后进行完善 pass # 3. 数据持久化： def dataSave(self, filename, data): with open(filename, &quot;w&quot;, encoding=&quot;utf-8&quot;) as f: f.write(data) # print(&quot;Data is stored&quot;) # 入口函数： def run(self): name = input(&quot;Input Tieba Name: &quot;) pnum_start = int(input(&quot;Input Start Page: &quot;)) pnum_end = int(input(&quot;Input Abort Page: &quot;)) # 遍历所有待爬取页面： for page in range(pnum_start, pnum_end+1): # 构建 URL： page_num = (page - 1) * 50 params = { &quot;kw&quot;: name, &quot;pn&quot;: str(page_num) } url = self.url.format(urllib.parse.urlencode(params)) # 请求获取网页 HTML 信息： html = self.requestHTML(url) # 数据持久化： filename = &quot;{}-{}p.html&quot;.format(name, page) self.dataSave(filename, html) print(&quot;Page %d was successfully crawled&quot; % page) # 每爬取一个页面随机休眠 1-2 秒： time.sleep(random.randint(1, 2))# 爬虫主程序入口if __name__ == &quot;__main__&quot;: print(&quot;| &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Start Spider &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; |&quot;) start = time.time() spider = TiebaSpider() spider.run() end = time.time() print(&quot;Script Runtime:%.2f s&quot; % (end - start)) print(&quot;| &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Close Spider &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; |&quot;) 程序执行结果（数据文件保存在当前工作目录下）： 123456789| &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Start Spider &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; |Input Tieba Name: PythonInput Start Page: 1Input Abort Page: 3Page 1 was successfully crawledPage 2 was successfully crawledPage 3 was successfully crawledScript Runtime:16.51 s| &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Close Spider &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; | 爬虫程序结构解析 &gt;&gt;&gt; 用面向对象的方法编写爬虫程序时，逻辑结构较为固定，如下： 12345678910111213141516171819class xxxSpider(object): def __init__(self): # 常量定义 def requestHTML(self): # 请求获取网页 HTML 信息（GET） def parseHTML(self): # 页面解析：Regular Expression/Xpath/Beautiful Soup 4，以提取期望数据 def dataSave(self): # 将提取到的数据进行持久化：CSV/MySQL def run(self): # 主入口函数，控制脚本整体逻辑 if __name__ == '__main__': spider = xxxSpider() spider.run() 爬虫随机休眠爬虫程序访问网站会非常快，这与正常人类的点击行为非常不符。 因此，你可以通过设置随机休眠，来使爬虫程序更像是人类在访问网站，从而让网站不易察觉是爬虫访问网站： 12# 每爬取一个页面爬虫随机休眠 1-2 秒：time.sleep(random.randint(1, 2)) 爬虫随机休眠代价 &gt;&gt;&gt;&gt; 影响程序的执行效率。 页面内容结构解析以提取有效信息这一章节来看 &gt;&gt;&gt; 如何根据网页内容结构以及元素节点信息，借助 HTML 对象解析工具（Regular Expression/Xpath/Beautiful Soup 4）以解析页面提取有效数据？！！ 以 猫眼电影网 榜单页面为例 &gt;&gt;&gt;&gt; 假设我们想要提取：榜单页面中每部电影的名称、主演、上映时间以及评分信息（页面中的特定内容）。 你可以先通过浏览器元素审查工具（Inspect）审查每部影片的 HTML 元素结构： 每一部影片的代码段都类似如下（以第一部为例）： 1234567891011121314&lt;div class=&quot;board-item-main&quot;&gt; &lt;div class=&quot;board-item-content&quot;&gt; &lt;div class=&quot;movie-item-info&quot;&gt; &lt;p class=&quot;name&quot;&gt;&lt;a href=&quot;/films/1205&quot; title=&quot;放牛班的春天&quot; data-act=&quot;boarditem-click&quot; data-val=&quot;{movieId:1205}&quot;&gt;放牛班的春天&lt;/a&gt; &lt;/p&gt; &lt;p class=&quot;star&quot;&gt;主演：热拉尔·朱诺,弗朗西斯·贝尔兰德,凯德·麦拉德&lt;/p&gt; &lt;p class=&quot;releasetime&quot;&gt;上映时间：2004-10-16&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;movie-item-number score-num&quot;&gt; &lt;p class=&quot;score&quot;&gt;&lt;i class=&quot;integer&quot;&gt;9.&lt;/i&gt;&lt;i class=&quot;fraction&quot;&gt;6&lt;/i&gt; &lt;/p&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 这就涉及到一个问题 &gt;&gt;&gt; 如何从页面的所有 HTML 对象信息中仅提取 &gt;&gt;&gt; 每部电影的名称、主演、上映时间以及评分？？？ 你需要编写 &gt;&gt;&gt; 可以匹配目标信息（数据）的 解析表达式，常见的解析表达式工具有：Regular Expression &amp;&amp; Xpath &amp;&amp; Beautiful Soup 4。 也就是说，解析表达式（Regular Expression/Xpath/BS 4）可以使得爬虫从整个页面的 HTML 对象信息中，抓取我们所关注的有效信息（数据），而不是整个 HTML。 开始本章节的学习之前，你需要基本掌握正则表达式的基础语法，初学者请参见 [ &gt;&gt;&gt;&gt; 一文学会正则表达式语法 &lt;&lt;&lt;&lt;]。 以正则表达式（Regular Expression）实现解析表达式为例： Use Built-in Re LibPython 中内置的 re 模块，用于提供正则表达式支持。 也就是说，通过编写可以匹配 目标信息（或数据） 的正则表达式，然后通过 re 模块提供的文本（字符串）查找方法，可以轻松提取到有效信息（每部电影的名称、主演、上映时间以及评分）。 Re 模块常用爬虫方法网络爬虫中常用的 re 模块方法如下： 1）re.findall() re.findall() 方法会根据正则表达式的文本匹配模式（pattern），来匹配目标字符串中内容。其语法格式如下： 1re.findall(pattern, string, flags=0) 其中，参数 pattern 为正则表达式；string 参数为匹配的目标字符串；而 flags 表示功能标志位，可用来拓展正则表达式功能。 该函数的返回值是 pattern 匹配内容的列表。需要注意的是，如果正则表达式中含有一个分组，则返回分组所匹配内容字符串的列表（每个字符串元素都是一次成功的匹配）；如果含有多个分组，则返回一个元组列表（每个元组元素都是一次成功的匹配，可以包含多个分组内容）。 2）re.split() re.split() 方法会根据正则匹配内容，来切割目标字符串，返回值是切割后的内容列表。其语法格式如下： 1re.split(pattern, string, flags=0) 3）re.sub() re.sub() 方法会一个替换字符串（replace），来替换正则匹配到的内容，返回值是替换后的字符串。其语法格式如下： 1re.sub(pattern, replace, string, maxcount, flags=0) 其中，参数 replace 为替换字符串；maxcount 参数为最多替换基础，默认为全替换；其它参数同上。 4）re.match() &amp;&amp; re.search() re 模块中还支持几乎所有编程语言都支持的 match() 和 search() 方法等等。 关于 flags 功能标志位 &gt;&gt;&gt; 功能标志位的作用是扩展正则表达的匹配功能。常用的 flag 如下所示： 缩写元字符 说明 A 元字符只能匹配 ASCII 码。 I 匹配忽略字母大小写。 S 使得 . 元字符可以匹配换行符。 M 多行模式，使 ^ &amp;&amp; $ 可以匹配每一行的开头和结尾位置。 注意：可以同时使用多个功能标志位（| 连接），比如 flags=re.I|re.S。 正则表达式对象方法绝大部分重要的应用，总是会先将正则表达式编译为正则表达式对象，之后再进行操作，这可以为正则的使用提供一些其它特性。 你可以通过 re 模块提供的 re.compile() 方法来生成一个正则表达式对象，其语法格式如下： 1regex = re.compile(pattern, flags=0) 生成正则表达式对象之后，就可以调用其方法以及属性了。 正则表达式对象中也提供了上一小节中提到的所有方法（match、search、findall…），注意新的特性。例如： 123# 以 findall() 方法为例：regex = re.compile(pattern, flags=0)regex.findall(string, pos, endpos) 其中，参数 string 为匹配的目标字符串；pos 参数为目标字符串的开始匹配位置；endpos 参数为目标字符串的结束匹配位置。 是不是感觉用法上更加灵活了？？？ 适合 HTML 文档的正则规则首先，给出一个使用贪婪以及非贪婪模式来匹配 HTML 元素的实例，如下： 1234567891011121314151617181920212223import rehtml = &quot;&quot;&quot;&lt;div&gt;&lt;p&gt;JavaScript Lesson&lt;/p&gt;&lt;/div&gt;&lt;div&gt;&lt;p&gt;Hello JS.&lt;/p&gt;&lt;/div&gt;&quot;&quot;&quot;# 正则表达式文本模式（贪婪模式）：pattern = &quot;&lt;div&gt;&lt;p&gt;.*&lt;/p&gt;&lt;/div&gt;&quot;# 构建正则表达式对象（flags=re.S）：regRex = re.compile(pattern, flags=re.S)# 匹配 HTMLX 元素，提取信息：res_list = regRex.findall(html)print(res_list)# 输出：# ['&lt;div&gt;&lt;p&gt;JavaScript Lesson&lt;/p&gt;&lt;/div&gt;\\n&lt;div&gt;&lt;p&gt;Hello JS.&lt;/p&gt;&lt;/div&gt;']# 正则表达式文本模式（非贪婪模式 &amp;&amp; flags=re.S）：regRex1 = re.compile(&quot;&lt;div&gt;&lt;p&gt;.*?&lt;/p&gt;&lt;/div&gt;&quot;, flags=re.S)res_list1 = regRex1.findall(html)print(res_list1)# 输出：# ['&lt;div&gt;&lt;p&gt;JavaScript Lesson&lt;/p&gt;&lt;/div&gt;', '&lt;div&gt;&lt;p&gt;Hello JS.&lt;/p&gt;&lt;/div&gt;'] 从输出结果中可以看出，非贪婪模式要更加适合提取 HTML 元素节点中信息。 我们期望的是，仅提取出 JavaScript Lesson &amp;&amp; Hello JS. 信息就可以了，怎么办？！！ 肯定有人能想到 findall() 方法中正则表达式包含分组 的情况，其仅返回分组所匹配内容的列表。上述实例修改为如下： 12345678910111213import rehtml = &quot;&quot;&quot;&lt;div&gt;&lt;p&gt;JavaScript Lesson&lt;/p&gt;&lt;/div&gt;&lt;div&gt;&lt;p&gt;Hello JS.&lt;/p&gt;&lt;/div&gt;&quot;&quot;&quot;# 正则表达式文本模式（非贪婪模式 &amp;&amp; flags=re.S &amp;&amp; 分组）：regRex1 = re.compile(&quot;&lt;div&gt;&lt;p&gt;(.*?)&lt;/p&gt;&lt;/div&gt;&quot;, flags=re.S)res_list1 = regRex1.findall(html)print(res_list1)# 输出：# ['JavaScript Lesson', 'Hello JS.'] OK~~~ 深入解读 Re 库关于 Python re 正则表达式模块的详细用法可参见 Python 博文系列 [ &gt;&gt;&gt;&gt; Python 教程 &lt;&lt;&lt;&lt;]。 | &gt;&gt;&gt; ============================================== Split Line =========================================== &lt;&lt;&lt; | 事实上，正则表达式（Regular Expression）的语法较为 “复杂”，初学者学习成本较高。 后续，我们会引入第三方的、方便快捷的 Beautiful Soup 4（BS 4）&amp;&amp; lxml 库，以更简单、便捷的方式实现解析表达式。 关于 BS 4 &amp;&amp; lxml 库的使用说明可以参见博文系列中 [ &gt;&gt;&gt;&gt; Web Crawler 教程之网络爬虫工具库 &lt;&lt;&lt;&lt;] 中解析库部分的说明。 网页有效信息提取再回过头来思考本章节开头的问题， 如何使用正则表达式来解析每部影片的代码段（类似如下）以提取 &gt;&gt;&gt; 每部电影的名称、主演、上映时间以及评分？？？ 1234567891011121314&lt;div class=&quot;board-item-main&quot;&gt; &lt;div class=&quot;board-item-content&quot;&gt; &lt;div class=&quot;movie-item-info&quot;&gt; &lt;p class=&quot;name&quot;&gt;&lt;a href=&quot;/films/1205&quot; title=&quot;放牛班的春天&quot; data-act=&quot;boarditem-click&quot; data-val=&quot;{movieId:1205}&quot;&gt;放牛班的春天&lt;/a&gt; &lt;/p&gt; &lt;p class=&quot;star&quot;&gt;主演：热拉尔·朱诺,弗朗西斯·贝尔兰德,凯德·麦拉德&lt;/p&gt; &lt;p class=&quot;releasetime&quot;&gt;上映时间：2004-10-16&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;movie-item-number score-num&quot;&gt; &lt;p class=&quot;score&quot;&gt;&lt;i class=&quot;integer&quot;&gt;9.&lt;/i&gt;&lt;i class=&quot;fraction&quot;&gt;6&lt;/i&gt; &lt;/p&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 实战演练（提取连续两部影片的名称、主演、上映时间以及评分信息）： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950import rehtml = &quot;&quot;&quot;&lt;div class=&quot;board-item-main&quot;&gt; &lt;div class=&quot;board-item-content&quot;&gt; &lt;div class=&quot;movie-item-info&quot;&gt; &lt;p class=&quot;name&quot;&gt;&lt;a href=&quot;/films/1205&quot; title=&quot;放牛班的春天&quot; data-act=&quot;boarditem-click&quot; data-val=&quot;{movieId:1205}&quot;&gt;放牛班的春天&lt;/a&gt; &lt;/p&gt; &lt;p class=&quot;star&quot;&gt;主演：热拉尔·朱诺,弗朗西斯·贝尔兰德,凯德·麦拉德&lt;/p&gt; &lt;p class=&quot;releasetime&quot;&gt;上映时间：2004-10-16&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;movie-item-number score-num&quot;&gt; &lt;p class=&quot;score&quot;&gt;&lt;i class=&quot;integer&quot;&gt;9.&lt;/i&gt;&lt;i class=&quot;fraction&quot;&gt;6&lt;/i&gt; &lt;/p&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class=&quot;board-item-main&quot;&gt; &lt;div class=&quot;board-item-content&quot;&gt; &lt;div class=&quot;movie-item-info&quot;&gt; &lt;p class=&quot;name&quot;&gt;&lt;a href=&quot;/films/243&quot; title=&quot;阿凡达&quot; data-act=&quot;boarditem-click&quot; data-val=&quot;{movieId:243}&quot;&gt;阿凡达&lt;/a&gt; &lt;/p&gt; &lt;p class=&quot;star&quot;&gt;主演：萨姆·沃辛顿,佐伊·索尔达娜,米歇尔·罗德里格兹&lt;/p&gt; &lt;p class=&quot;releasetime&quot;&gt;上映时间：2010-01-04&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;movie-item-number score-num&quot;&gt; &lt;p class=&quot;score&quot;&gt;&lt;i class=&quot;integer&quot;&gt;9.&lt;/i&gt;&lt;i class=&quot;fraction&quot;&gt;4&lt;/i&gt; &lt;/p&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt;&quot;&quot;&quot;# 正则表达式文本模式（贪婪模式）：pattern = r'&lt;div.*?title=&quot;(.*?)&quot;.*?star&quot;&gt;主演：(.*?)&lt;/p.*?time&quot;&gt;上映时间：(.*?)&lt;/p.*?integer&quot;&gt;(.*?)&lt;/i.*?fraction&quot;&gt;(.*?)&lt;/i.*?/div&gt;'# 正则表达式文本模式（非贪婪模式 &amp;&amp; flags=re.S）：regRex = re.compile(pattern, flags=re.S)res_list = regRex.findall(html)print(res_list)# 整理数据格式并输出if res_list: print(20*&quot;*&quot;) for item in res_list: print(&quot;影片名称：&quot;, item[0]) print(&quot;影片主演：&quot;, item[1]) print(&quot;上映时间：&quot;, item[2]) print(&quot;影片评分：&quot;, item[3] + item[4]) print(20*&quot;*&quot;) 输出结果如下： 123456789101112[('放牛班的春天', '热拉尔·朱诺,弗朗西斯·贝尔兰德,凯德·麦拉德', '2004-10-16', '9.', '6'), ('阿凡达', '萨姆·沃辛顿,佐伊·索尔达娜,米歇尔·罗德里格兹', '2010-01-04', '9.', '4')]********************影片名称： 放牛班的春天影片主演： 热拉尔·朱诺,弗朗西斯·贝尔兰德,凯德·麦拉德上映时间： 2004-10-16影片评分： 9.6********************影片名称： 阿凡达影片主演： 萨姆·沃辛顿,佐伊·索尔达娜,米歇尔·罗德里格兹上映时间： 2010-01-04影片评分： 9.4******************** 持久化存储页面有效信息获取到页面中的有效信息后，这一章节来看 &gt;&gt;&gt; 如何将这些提取到的有效的信息（数据）存储下来？！！ 通过爬虫脚本将有效信息（数据）抓取下来，然后将数据存储在本地文件，或数据库中，这个过程就称为 &gt;&gt;&gt; 数据持久化存储。 两种常见的数据持久化存储方式： 本地文件存储 数据库存储 本地文件存储CSV 是电子表格（如 Excel）和数据库中最常见的输入、输出文件格式。 CSV 文件，又称为 逗号分隔值文件，适用于存储表格数据（数据或字符）。 Python 中内置的 csv 模块，用来提供 CSV 格式文件的读、写操作。 写入 CSV 文件我们可以，通过 Python csv 模块提供的文件读写类中的方法，来向 CSV 文件中写入数据。 CSV 模块中，常用的写文件类如下： [1] &gt;&gt;&gt; csv.writer csv 模块中的 writer 类，可用于向 CSV 文件写入序列化的数据。构建 writer 类的语法格式如下： 1csv.writer(csvfile, dialect='excel', **fmtparams) 其中，参数 csvfile 必须是可迭代（Iterator）对象，例如 文件对象（file）或列表（list）等；参数 dialect 指编码风格（方言），默认为 Excel 的风格，也就是使用都好（,）分隔；**fmtparams 格式化参数，用来覆盖之前 dialect 参数指定的编码风格。 关于 **fmtparams 格式化参数，假如你不想使用 Excel 风格，你可以使用如下格式化参数进行覆盖： delimiter &gt;&gt;&gt; 用来指定写入行内多个数据项的分隔符； quotechar &gt;&gt;&gt; 用来指定引用符，如果数据项内本身包含分隔字符时，为了排除歧义，可以将当前数据项使用引用符引起来表示完整的一个数据项。 逐行写入内容的实例代码如下： 1234567891011# 导入 csv 模块import csv# 操作文件对象时，需要添加 newline 参数逐行写入，否则会出现空行现象with open(&quot;test.csv&quot;, mode=&quot;w&quot;, newline=&quot;&quot;) as csvfile: # 构建文件读写对象 writer： obj_CSVWrite = csv.writer(csvfile, delimiter=&quot; &quot;, quotechar=&quot;/&quot;) # 单行写入方法，列表格式传入数据： obj_CSVWrite.writerow([&quot;Hello&quot;]*5 + [&quot;JS&quot;]) obj_CSVWrite.writerow([&quot;Hello&quot;, &quot;JS&quot;, &quot;Welcome to JS World&quot;]) 生成文件 test.csv 内容如下： 12Hello Hello Hello Hello Hello JSHello JS /Welcome to JS World/ 可见文件中，使用 writerow() 方法逐行写入，行内多个数据项以空格（delimiter=&quot; &quot;）分隔，对于本身包含分隔符的数据项会使用斜杠符（quotechar=&quot;/&quot;）包围以引用。 如何同时写入多行内容 &gt;&gt;&gt; 如果想同时写入多行数据，需要使用 writerrows() 方法： 12345678910import csv# 操作文件对象时，需要添加 newline 参数逐行写入，否则会出现空行现象with open(&quot;test.csv&quot;, mode=&quot;w&quot;, newline=&quot;&quot;) as csvfile: # 构建文件读写对象 writer： obj_CSVWrite = csv.writer(csvfile) # 同时多行写入方法：元组元素列表格式传入数据： # 列表中的每个元组元素为一行数据 obj_CSVWrite.writerows([(&quot;Javascript&quot;, &quot;Course&quot;), (&quot;Spider&quot;, &quot;Course&quot;)]) 生成文件 test.csv 内容如下： 12Javascript,CourseSpider,Course [2] &gt;&gt;&gt; csv.DictWriter() 类似于 writer 读写类，可以使用 DictWriter 类向 CSV 文件中以字典（Dict）的形式写入数据。其构建语法格式如下： 1csv.writer(csvfile, fieldname, **fmtparams) 其中，参数 fieldname 可用于指定表头（表格字段名），对应字典的 Key；其它参数类似 writer。 实例代码如下： 12345678910111213141516171819import csv# 操作文件对象时，需要添加 newline 参数逐行写入，否则会出现空行现象with open(&quot;test1.csv&quot;, mode=&quot;w&quot;, newline=&quot;&quot;) as csvfile: # 构建表头（字段名称）： fieldname = [&quot;first_name&quot;, &quot;last_name&quot;] # 构建文件读写对象 DictWriter： obj_CSVWrite = csv.DictWriter(csvfile, fieldnames=fieldname, delimiter=&quot;,&quot;) # 写入字段名称，作为表头： obj_CSVWrite.writeheader() # 单行写入方法，字典格式传入数据： obj_CSVWrite.writerow({&quot;first_name&quot;: &quot;Baked&quot;, &quot;last_name&quot;: &quot;Beans&quot;}) obj_CSVWrite.writerow({&quot;first_name&quot;: &quot;Black&quot;, &quot;last_name&quot;: &quot;John&quot;}) # 同时多行写入方法：字典元素列表格式传入数据： # 列表中的每个字典元素为一行数据 obj_CSVWrite.writerows([{'first_name': 'Baked', 'last_name': 'Beans'},{'first_name': 'Lovely', 'last_name': 'Spam'}]) 生成文件 test1.csv 内容如下： 12345first_name,last_nameBaked,BeansBlack,JohnBaked,BeansLovely,Spam 读取 CSV 文件同理，通过 Python csv 模块提供的文件读写类中的方法，来从 CSV 文件中读取数据。 CSV 模块中，常用的读文件类如下： [1] &gt;&gt;&gt; csv.reader csv 模块中的 reader 类，可用于从 CSV 文件中读取数据。构建 reader 类的语法格式如下： 1csv.reader(csvfile, dialect='excel', **fmtparams) 读取文件 test.csv 内容实例代码如下： 123456789101112import csv# 操作文件对象时，需要添加 newline 参数逐行写入，否则会出现空行现象with open(&quot;test.csv&quot;, mode=&quot;r&quot;, newline=&quot;&quot;) as csvfile: # 构建文件读写对象 reader： obj_CSVReader = csv.reader(csvfile, delimiter=&quot; &quot;, quotechar=&quot;/&quot;) # 输出读取的每行内容： for row in obj_CSVReader: # 输出行内的数据项列表： print(row) [2] &gt;&gt;&gt; csv.DictReader 类似于 csv 模块中的 reader 类，DictReader 类可用于从 CSV 文件中以字典的形式读取数据。构建 reader 类的语法格式如下： 1csv.DictReader(csvfile, filedname, **fmtparams) 读取文件 test1.csv 内容实例代码如下： 1234567891011import csv# 操作文件对象时，需要添加 newline 参数逐行写入，否则会出现空行现象with open(&quot;test1.csv&quot;, mode=&quot;r&quot;, newline=&quot;&quot;) as csvfile: # 构建文件读写对象 reader： obj_CSVReader = csv.DictReader(csvfile, delimiter=&quot;,&quot;) # 输出读取的每行内容： for row in obj_CSVReader: print(row[&quot;first_name&quot;], row[&quot;last_name&quot;]) 输出结果如下： 1234Baked BeansBlack JohnBaked BeansLovely Spam 实例：抓取猫影电影排行榜有了上面的知识储备，我们来演示一个完整的 Python 爬虫实战案例：抓取 猫眼电影网 TOP100 排行榜 中的影片信息，包括电影名称、上映时间、主演信息以及电影评分。 以下案例流程为 &gt;&gt;&gt; 编写网络爬虫脚本的通用流程： [1] &gt;&gt;&gt; 预分析 在开始编写网络爬虫脚本之前，你需要对待爬取的排行榜页面进行如下分析： 1.1】 &gt;&gt;&gt; 判断页面类型 点击右键查看页面源码，确定要抓取的数据是否存在于页面内。 以排行榜为例，具体操作为：猫眼电影网 TOP100 排行榜，在出现的页面中复制任意一部影片的信息，比如 肖申克的救赎，然后点击右键选择查看源码（View Page Source），并使用 Ctrl+F 快捷键在源码页面搜索刚刚复制的影片名称。 故，可以判断出 &gt;&gt;&gt;&gt; 抓取的百度贴吧页面属于静态网页。 1.2】 &gt;&gt;&gt; 分析 URL 变化规律 接下来，你需要寻找待爬取TOP100 排行榜页面的 URL 规律（用于后续的请求发送以获取带爬取页面的 HTML 信息）： 12345第一页 &gt;&gt;&gt; https://www.maoyan.com/board/4?offset=0第二页 &gt;&gt;&gt; https://www.maoyan.com/board/4?offset=10第三页 &gt;&gt;&gt; https://www.maoyan.com/board/4?offset=20...第 n 页 &gt;&gt;&gt; https://www.maoyan.com/board/4?offset=(n-1)*10 1.3】 &gt;&gt;&gt; 审查网页结构以及元素节点信息以确定解析表达式 审查 期望信息在 HTML 文档中的结构以及元素节点信息 以确定内容提取的解析表达式： 123456789101112&lt;div class=&quot;board-item-main&quot;&gt; &lt;div class=&quot;board-item-content&quot;&gt; &lt;div class=&quot;movie-item-info&quot;&gt; &lt;p class=&quot;name&quot;&gt;&lt;a href=&quot;/films/1200486&quot; title=&quot;我不是药神&quot; data-act=&quot;boarditem-click&quot; data-val=&quot;{movieId:1200486}&quot;&gt;我不是药神&lt;/a&gt;&lt;/p&gt; &lt;p class=&quot;star&quot;&gt;主演：徐峥,周一围,王传君&lt;/p&gt; &lt;p class=&quot;releasetime&quot;&gt;上映时间：2018-07-05&lt;/p&gt; &lt;/div&gt; &lt;div class=&quot;movie-item-number score-num&quot;&gt; &lt;p class=&quot;score&quot;&gt;&lt;i class=&quot;integer&quot;&gt;9.&lt;/i&gt;&lt;i class=&quot;fraction&quot;&gt;6&lt;/i&gt;&lt;/p&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 使用 Chrome 开发者调试工具来精准定位要抓取信息的元素结构。之所以这样做，是因为这能避免正则表达式的冗余，提高编写正则表达式的速度。最终正则表达式如下： 1&lt;div class=&quot;board-item-main&quot;&gt;.*?title=&quot;(.*?)&quot;.*?class=&quot;star&quot;&gt;(.*?)&lt;/p&gt;.*?releasetime&quot;&gt;(.*?)&lt;/p&gt;.*?integer&quot;&gt;(.*?)&lt;/i&gt;.*?fraction&quot;&gt;(.*?)&lt;/i&gt; 正则表达式中，将需要提取的信息使用 (.*?) 代替，而不需要的内容（包括元素标签）使用 .*? 代替。 [2] &gt;&gt;&gt; 网络爬虫编写 这里，以面向对象的编程设计思路，给出案例的爬虫脚本代码： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119import timeimport urllib.parseimport urllib.requestimport fake_useragentimport reimport csvimport random# 定义爬虫类：class MaoyanSpider(object): def __init__(self): self.url = &quot;https://www.maoyan.com/board/4?{}&quot; # 计数器 self.counter = 0 # 1. 请求获取网页 HTML 信息（GET）： def requestHTML(self, url): # 随机获取浏览器伪装 UA： ua = fake_useragent.UserAgent() # ua_info = ua.random ua_info = ua.edge # print(&quot;User-Agent: &quot; + ua_info) headers = { &quot;User-Agent&quot;: ua_info, # &quot;Accept&quot;: &quot;*/*&quot;, &quot;Cookie&quot;: &quot;你本机浏览器的 Cookie&quot; } # 重构请求对象： req = urllib.request.Request(url=url, headers=headers) # 发送请求 response = urllib.request.urlopen(req) # print(&quot;Request Status Code:&quot;, response.status) # 响应的网页信息： html = response.read().decode(&quot;utf-8&quot;) # html = response.read().decode(&quot;gbk&quot;, &quot;ignore&quot;) return html # 2. 页面解析： def parseHTML(self, pattern, html): # 基于 Pattern 构建正则表达式对象（非贪婪模式 &amp;&amp; flags=re.S）： regExp_Obj = re.compile(pattern=pattern, flags=re.S) # 查找匹配内容： find_res = regExp_Obj.findall(html) # 返回一个元组元素列表（每个元组元素都是一次成功的匹配，可以包含多个分组内容）： return find_res # 3. 数据持久化： def dataSave(self, filename, validData): # 操作文件对象时，需要添加 newline 参数逐行写入，否则会出现空行现象 with open(filename, &quot;a&quot;, newline=&quot;&quot;, encoding=&quot;utf-8&quot;) as csvfile: # 构建文件读写对象 writer： csvWriter_Obj = csv.writer(csvfile) # 数据处理： if validData: for record in validData: video_name = record[0].strip() video_actor = record[1].strip()[3:] video_time = record[2].strip()[5:] video_score = record[3] + record[4] lineData = [video_name, video_time, video_actor, video_score] csvWriter_Obj.writerow(lineData) # 打印第一页影片信息 if (self.counter &lt; 10): print(video_name, video_time, video_actor, video_score) self.counter = self.counter + 1 else: print(&quot;Request Failed&quot;) # 入口函数： def run(self): pnum_start = 1 pnum_end = 10 # 遍历所有待爬取页面： for page in range(pnum_start, pnum_end+1): # 构建 URL： page_num = (page - 1) * 10 params = { &quot;offset&quot;: page_num } url = self.url.format(urllib.parse.urlencode(params)) # print(&quot;Request URL: &quot;, url) # 请求获取网页 HTML 信息： html = self.requestHTML(url) # 页面解析以提取有效数： # 正则表达式文本模式： pattern = '&lt;div class=&quot;board-item-main&quot;&gt;.*?title=&quot;(.*?)&quot;.*?class=&quot;star&quot;&gt;(.*?)&lt;/p&gt;.*?releasetime&quot;&gt;(.*?)&lt;/p&gt;.*?integer&quot;&gt;(.*?)&lt;/i&gt;.*?fraction&quot;&gt;(.*?)&lt;/i&gt;' validData_list = self.parseHTML(pattern, html) # 数据持久化存储： filename = &quot;maoyanTop100.csv&quot; self.dataSave(filename, validData_list) print(&quot;Page %d was successfully crawled&quot; % page) # 每爬取一个页面随机休眠 1-2 秒： time.sleep(random.randint(1, 2))# 爬虫主程序入口if __name__ == &quot;__main__&quot;: print(&quot;| &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Start Spider &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; |&quot;) start = time.time() # 捕捉异常： try: spider = MaoyanSpider() spider.run() except Exception as e: print(&quot;Error: &quot;, e) end = time.time() print(&quot;Script Runtime:%.2f s&quot; % (end - start)) print(&quot;| &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Close Spider &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; |&quot;) 输出如下： 1234567891011121314151617181920212223| &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Start Spider &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; |我不是药神 2018-07-05 徐峥,周一围,王传君 9.6肖申克的救赎 1994-09-10(加拿大) 蒂姆·罗宾斯,摩根·弗里曼,鲍勃·冈顿 9.5海上钢琴师 2019-11-15 蒂姆·罗斯,比尔·努恩 ,克兰伦斯·威廉姆斯三世 9.3绿皮书 2019-03-01 维果·莫腾森,马赫沙拉·阿里,琳达·卡德里尼 9.5霸王别姬 1993-07-26 张国荣,张丰毅,巩俐 9.4美丽人生 2020-01-03 罗伯托·贝尼尼,朱斯蒂诺·杜拉诺,赛尔乔·比尼·布斯特里克 9.3小偷家族 2018-08-03 中川雅也,安藤樱,松冈茉优 8.1这个杀手不太冷 1994-09-14(法国) 让·雷诺,加里·奥德曼,娜塔莉·波特曼 9.4哪吒之魔童降世 2019-07-26 吕艳婷,囧森瑟夫,瀚墨 9.6怦然心动 2010-07-26(美国) 玛德琳·卡罗尔,卡兰·麦克奥利菲,艾丹·奎因 8.9Page 1 was successfully crawledPage 2 was successfully crawledPage 3 was successfully crawledPage 4 was successfully crawledPage 5 was successfully crawledPage 6 was successfully crawledPage 7 was successfully crawledPage 8 was successfully crawledPage 9 was successfully crawledPage 10 was successfully crawledScript Runtime:19.87 s| &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Close Spider &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; | 同时，查看当前工作目录下的生成的数据存储文件 maoyanTop100.csv，可以看到抓取到的 100 条影片数据。 开始之前，相信你已经掌握了 SQL 语言的基本语法 &gt;&gt;&gt; 数据库存储上面我们将提取到的网页有效数据存储到了本地 CSV 格式的文件中，这里来看如何将有效数据存储至 MySQL 数据库？！！ Python 第三方的 pymysql 模块，用于提供 Python 连接，以及操作 MySQL 数据库。安装方法如下： 1 库以及存储数据表准备首先，你应该确保你安装有可供测试、使用的 MySQL 数据库。然后，在 DOS 下进行如下操作以构建用于存储有效数据的库以及数据表： 123456789101112131415161718192021222324# 1. 开启 MySQL 服务（未开启时）：&gt; net start mysqlMySQL 服务正在启动 .MySQL 服务已经启动成功。# 2. 连接 MySQL 数据库：&gt; mysql -h 127.0.0.1 -u root -padminmysql&gt;# 3. 构建库：mysql&gt; CREATE DATABASE maoyandb CHARSET UTF8;Query OK, 1 row affected (0.00 sec)# 4. 切换库：mysql&gt; USE maoyandbDatabase changed# 5. 构建数据表mysql&gt; CREATE TABLE filmtb ( -&gt; name varchar(50), -&gt; time varchar(30), -&gt; actor varchar(100), -&gt; score varchar(10) -&gt; );Query OK, 0 rows affected (0.01 sec) Use Third-Party Pymysql网络爬虫相关的 MySQL 操作： [1] &gt;&gt;&gt; 连接数据库 1db = pymysql.connect(host=&quot;localhost/ip&quot;, user, password, database) 其中，参数 host 用来指定 MySQL 数据库地址，可以是本地服务端地址，也可以是远程数据库 IP 地址；参数 user 用来指定用于连接数据库的用户名；password 参数用于指定连接数据库的用户密码；database 用来指定想要连接的数据库名称。 [2] &gt;&gt;&gt; 构建游标对象 1cursorObject = db.cursor() [3] &gt;&gt;&gt; 执行 sql 语句 cursor 对象提供的 execute() 语句用于执行 sql 语句，以实现数据库表的增、删、改、查等操作。如下： 1234567# 方法一：通过占位符传入数据sql = &quot;insert into filmtb values('%s', '%s', '%s', '%s')&quot; % ('我不是药神', '2018-07-05', '徐峥,周一围,王传君', '9.6')cursorObject.execute(sql)# 方法二：通过列表传参方式sql = &quot;insert into filmtb values(%s, %s, %s, %s)&quot;cursorObject.execute(sql, ['我不是药神', '2018-07-05', '徐峥,周一围,王传君', '9.6']) [4] &gt;&gt;&gt; 提交数据 1db.commit() [5] &gt;&gt;&gt; 资源释放 1234# 关闭游标cursorObject.close()# 断开连接db.close() 存储实例向数据库表中插入一条数据： 123456789101112131415161718import pymysql# 构建数据库连接：db = pymysql.connect(host=&quot;localhost&quot;, user=&quot;root&quot;, password=&quot;admin&quot;, database=&quot;maoyandb&quot;)# 构建游标 Cursor 对象：cursorObj = db.cursor()# 执行 SQL 语句，进行单行数据插入：data_list = ['我不是药神', '2018-07-05', '徐峥,周一围,王传君', '9.6']sql = &quot;insert into filmtb values(%s, %s, %s, %s)&quot;cursorObj.execute(sql, data_list)# 提交数据至数据库：db.commit()# 释放资源：cursorObj.close()db.close() DOS 下连接数据库查询数据结果，如下： 1234567mysql&gt; SELECT * FROM FILMTB;+-----------------+------------+----------------------------+-------+| name | time | actor | score |+-----------------+------------+----------------------------+-------+| 我不是药神 | 2018-07-05 | 徐峥,周一围,王传君 | 9.6 |+-----------------+------------+----------------------------+-------+1 row in set (0.00 sec) 多条数据同时插入 &gt;&gt;&gt; cursor 对象还提供了一种更效率的插入方法 executemany()，支持同时向表中插入多条数据： 12345678910111213141516171819import pymysql# 构建数据库连接：db = pymysql.connect(host=&quot;localhost&quot;, user=&quot;root&quot;, password=&quot;admin&quot;, database=&quot;maoyandb&quot;)# 构建游标 Cursor 对象：cursorObj = db.cursor()# 执行 SQL 语句，同时插入多行数据：dataTuple_list = [(&quot;肖申克的救赎&quot;, &quot;1994-09-10&quot;, &quot;蒂姆·罗宾斯,摩根·弗里曼,鲍勃·冈顿&quot;, &quot;9.5&quot;), (&quot;海上钢琴师&quot;, &quot;2019-11-15&quot;, &quot;蒂姆·罗斯,比尔·努恩 ,克兰伦斯·威廉姆斯三世&quot;, &quot;9.3&quot;)]sql = &quot;insert into filmtb values(%s, %s, %s, %s)&quot;cursorObj.executemany(sql, dataTuple_list)# 提交数据至数据库：db.commit()# 释放资源：cursorObj.close()db.close() DOS 下连接数据库查询数据结果，如下： 123456789mysql&gt; SELECT * FROM FILMTB;+--------------------+------------+-----------------------------------------------------------------+-------+| name | time | actor | score |+--------------------+------------+-----------------------------------------------------------------+-------+| 我不是药神 | 2018-07-05 | 徐峥,周一围,王传君 | 9.6 || 肖申克的救赎 | 1994-09-10 | 蒂姆·罗宾斯,摩根·弗里曼,鲍勃·冈顿 | 9.5 || 海上钢琴师 | 2019-11-15 | 蒂姆·罗斯,比尔·努恩 ,克兰伦斯·威廉姆斯三世 | 9.3 |+--------------------+------------+-----------------------------------------------------------------+-------+3 rows in set (0.00 sec) 实例：抓取猫影电影排行榜预分析过程同【4.2】小节，这里我们使用数据库的存储方法重写【4.2】小节中的网络爬虫脚本： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133import timeimport urllib.parseimport urllib.requestimport fake_useragentimport re# import csvimport pymysqlimport random# 定义爬虫类：class MaoyanSpider(object): def __init__(self): # Base URL： self.url = &quot;https://www.maoyan.com/board/4?{}&quot; # 构建数据库连接对象： self.db = pymysql.connect(host=&quot;localhost&quot;, user=&quot;root&quot;, password=&quot;admin&quot;, database=&quot;maoyandb&quot;, charset=&quot;utf8&quot;) # 构建游标对象： self.cursorObject = self.db.cursor() # 计数器 self.counter = 0 # 1. 请求获取网页 HTML 信息（GET）： def requestHTML(self, url): # 随机获取浏览器伪装 UA： ua = fake_useragent.UserAgent() # ua_info = ua.random ua_info = ua.edge # print(&quot;User-Agent: &quot; + ua_info) headers = { &quot;User-Agent&quot;: ua_info, &quot;Accept&quot;: &quot;*/*&quot;, &quot;Cookie&quot;: &quot;__mta=146102795.1672499681444.1673112786612.1673166343246.9; uuid_n_v=v1; uuid=D815AEF0891D11ED8B7C3F15132DB86FB3A3D5406DE64D05805D9B914B5EC73D; _csrf=c0b537815f7f65bdd82c6a2df76280c3a4cc2ba75dbac1113793e4c716926538; _lxsdk_cuid=18568bfd59ec8-063f8bb1638243-7a575473-144000-18568bfd59ec8; Hm_lvt_703e94591e87be68cc8da0da7cbd0be2=1672499681; _lxsdk=D815AEF0891D11ED8B7C3F15132DB86FB3A3D5406DE64D05805D9B914B5EC73D; __mta=146102795.1672499681444.1673111960576.1673112438542.42; Hm_lpvt_703e94591e87be68cc8da0da7cbd0be2=1673166343; _lxsdk_s=185907c46cf-0b7-a45-7b0%7C%7C4&quot; } # 重构请求对象： req = urllib.request.Request(url=url, headers=headers) # 发送请求 response = urllib.request.urlopen(req) # print(&quot;Request Status Code:&quot;, response.status) # 响应的网页信息： html = response.read().decode(&quot;utf-8&quot;) # html = response.read().decode(&quot;gbk&quot;, &quot;ignore&quot;) return html # 2. 页面解析： def parseHTML(self, pattern, html): # 基于 Pattern 构建正则表达式对象（非贪婪模式 &amp;&amp; flags=re.S）： regExp_Obj = re.compile(pattern=pattern, flags=re.S) # 查找匹配内容： find_res = regExp_Obj.findall(html) # 返回一个元组元素列表（每个元组元素都是一次成功的匹配，可以包含多个分组内容）： return find_res # 3. 数据持久化： def dataSave(self, validData): # 定义数据仓库 dataRepo = [] # 数据处理： if validData: for record in validData: video_name = record[0].strip() video_actor = record[1].strip()[3:] video_time = record[2].strip()[5:15] video_score = record[3] + record[4] dataItem = (video_name, video_time, video_actor, video_score) dataRepo.append(dataItem) # 打印第一页影片信息 if (self.counter &lt; 10): print(str(dataItem)) self.counter = self.counter + 1 # 存入数据库： sql = &quot;insert into filmtb values (%s, %s, %s, %s)&quot; try: self.cursorObject.executemany(sql, dataRepo) self.db.commit() except Exception as e: print(&quot;Error: &quot;, e) # 发生错误后回滚数据库 self.db.rollback() else: print(&quot;Request Failed&quot;) # 入口函数： def run(self): pnum_start = 1 pnum_end = 10 # 遍历所有待爬取页面： for page in range(pnum_start, pnum_end+1): # 构建 URL： page_num = (page - 1) * 10 params = { &quot;offset&quot;: page_num } url = self.url.format(urllib.parse.urlencode(params)) # print(&quot;Request URL: &quot;, url) # 请求获取网页 HTML 信息： html = self.requestHTML(url) # 页面解析以提取有效数： # 正则表达式文本模式： pattern = '&lt;div class=&quot;board-item-main&quot;&gt;.*?title=&quot;(.*?)&quot;.*?class=&quot;star&quot;&gt;(.*?)&lt;/p&gt;.*?releasetime&quot;&gt;(.*?)&lt;/p&gt;.*?integer&quot;&gt;(.*?)&lt;/i&gt;.*?fraction&quot;&gt;(.*?)&lt;/i&gt;' validData_list = self.parseHTML(pattern, html) # 数据持久化存储： self.dataSave(validData_list) print(&quot;Page %d was successfully crawled&quot; % page) # 每爬取一个页面随机休眠 1-2 秒： time.sleep(random.randint(1, 2)) # 释放资源： self.cursorObject.close() self.db.close()# 爬虫主程序入口if __name__ == &quot;__main__&quot;: print(&quot;| &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Start Spider &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; |&quot;) start = time.time() spider = MaoyanSpider() spider.run() end = time.time() print(&quot;Script Runtime:%.2f s&quot; % (end - start)) print(&quot;| &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; Close Spider &lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt; |&quot;) 数据库查询存储结果，如下所示（篇幅原因，只截取一部分）： 123456789101112131415161718192021222324252627mysql&gt; SELECT * FROM FILMTB;+---------------------------------+--------------------+-----------------------------------------------------------------------------------------+-------+| name | time | actor | score |+---------------------------------+--------------------+-----------------------------------------------------------------------------------------+-------+| 我不是药神 | 2018-07-05 | 徐峥,周一围,王传君 | 9.6 || 肖申克的救赎 | 1994-09-10 | 蒂姆·罗宾斯,摩根·弗里曼,鲍勃·冈顿 | 9.5 || 海上钢琴师 | 2019-11-15 | 蒂姆·罗斯,比尔·努恩 ,克兰伦斯·威廉姆斯三世 | 9.3 || 绿皮书 | 2019-03-01 | 维果·莫腾森,马赫沙拉·阿里,琳达·卡德里尼 | 9.5 || 霸王别姬 | 1993-07-26 | 张国荣,张丰毅,巩俐 | 9.4 || 美丽人生 | 2020-01-03 | 罗伯托·贝尼尼,朱斯蒂诺·杜拉诺,赛尔乔·比尼·布斯特里克 | 9.3 || 小偷家族 | 2018-08-03 | 中川雅也,安藤樱,松冈茉优 | 8.1 || 这个杀手不太冷 | 1994-09-14 | 让·雷诺,加里·奥德曼,娜塔莉·波特曼 | 9.4 |............| 波西米亚狂想曲 | 2019-03-22 | 拉米·马雷克,本·哈迪,约瑟夫•梅泽罗 | 9.4 || 真爱至上 | 2003-11-21 | 休·格兰特,比尔·奈伊,连姆·尼森 | 8.6 || 大鱼 | 2003-12-04 | 伊万·麦克格雷格,阿尔伯特·芬尼,杰西卡·兰格 | 8.6 || 模仿游戏 | 2015-07-21 | 本尼迪克特·康伯巴奇,凯拉·奈特莉,马修·古迪 | 9.3 || 血战钢锯岭 | 2016-12-08 | 安德鲁·加菲尔德,雨果·维文,卢克·布雷西 | 9.3 || 傲慢与偏见 | 2008-02-10 | 马修·麦克费登,吉娜·马隆,妲露拉·莱莉 | 8.4 || 致命魔术 | 2006-10-17 | 休·杰克曼,克里斯蒂安·贝尔,迈克尔·凯恩 | 8.8 || 奇迹男孩 | 2018-01-19 | 雅各布·特瑞布雷,朱莉娅·罗伯茨,欧文·威尔逊 | 9.2 || 禁闭岛 | 2010-02-13 | 莱昂纳多·迪卡普里奥,马克·鲁法洛,本·金斯利 | 8.7 || 鬼子来了 | 2000-05-13 | 姜文,姜宏波,陈强 | 8.9 |+---------------------------------+--------------------+-----------------------------------------------------------------------------------------+-------+100 rows in set (0.01 sec) 可见，爬虫脚本已将猫眼电影 TOP100 排行榜中的所有影片信息全部抓取存储到了数据库表中。 网络爬虫常见问题这一小节来看网络爬虫常见问题以及其解决方法： 百度安全验证问题爬虫抓取百度搜索页面信息时，你可能会发现抓取到的内容不是网页信息，响应内容显示：百度安全验证 &amp; 网络不给力，请稍后重试 &amp; 返回首页 &amp; 问题反馈。如下显示： 12345678910111213141516171819202122232425262728293031&lt;!DOCTYPE html&gt;&lt;html lang=&quot;zh-CN&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;百度安全验证&lt;/title&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt; &lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot;&gt; &lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;black&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, user-scalable=no, initial-scale=1.0, minimum-scale=1.0, maximum-scale=1.0&quot;&gt; &lt;meta name=&quot;format-detection&quot; content=&quot;telephone=no, email=no&quot;&gt; &lt;link rel=&quot;shortcut icon&quot; href=&quot;https://www.baidu.com/favicon.ico&quot; type=&quot;image/x-icon&quot;&gt; &lt;link rel=&quot;icon&quot; sizes=&quot;any&quot; mask href=&quot;https://www.baidu.com/img/baidu.svg&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=Edge&quot;&gt; &lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;upgrade-insecure-requests&quot;&gt; &lt;link rel=&quot;stylesheet&quot; href=&quot;https://ppui-static-wap.cdn.bcebos.com/static/touch/css/api/mkdjump_aac6df1.css&quot; /&gt;&lt;/head&gt;&lt;body&gt; &lt;div class=&quot;timeout hide&quot;&gt; &lt;div class=&quot;timeout-img&quot;&gt;&lt;/div&gt; &lt;div class=&quot;timeout-title&quot;&gt;网络不给力，请稍后重试&lt;/div&gt; &lt;button type=&quot;button&quot; class=&quot;timeout-button&quot;&gt;返回首页&lt;/button&gt; &lt;/div&gt; &lt;div class=&quot;timeout-feedback hide&quot;&gt; &lt;div class=&quot;timeout-feedback-icon&quot;&gt;&lt;/div&gt; &lt;p class=&quot;timeout-feedback-title&quot;&gt;问题反馈&lt;/p&gt; &lt;/div&gt;&lt;script src=&quot;https://wappass.baidu.com/static/machine/js/api/mkd.js&quot;&gt;&lt;/script&gt;&lt;script src=&quot;https://ppui-static-wap.cdn.bcebos.com/static/touch/js/mkdjump_db105ab.js&quot;&gt;&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 通过查阅资料了解到，出现此问题可能是请求头（Request Headers）定义不完善被百度反爬（大多数是因为请求头缺少 Accept），还有可能是因为未登录时获取无效 Cookie 来定义请求头等。 解决思路 &gt;&gt;&gt; 需要进一步重构请求头信息，以实现更真实的浏览器请求伪装。 解决办法 &gt;&gt;&gt;&gt; 收集浏览器中百度搜索页面的请求头（Request Headers）信息，如下图： 你可以将 Accept &amp;&amp; Cookie 的键值对 Copy 下来，用于重构爬虫的请求头： 1234header{ &quot;Cookie&quot;: '填写你浏览器的 Cookie 值', &quot;Accept&quot;: &quot;text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3;q=0.9&quot;,} HTTP Error 302有时爬虫在抓取某些网站时，可能出现如下错误： 12HTTPError: HTTP Error 302: The HTTP server returned a redirect error that would lead to an infinite loop.The last 30x error message was: ..... 查询资料，发现是请求资源发生重定向导致无限循环的错误，这也是网站反爬机制的一种。 解决方法一 &gt;&gt;&gt; 一种原因可能是请求时没有 Cookie，被网站反爬。你可以通过重构请求头，为请求添加 Cookie。 解决方法二 &gt;&gt;&gt; 看到有一篇博文说，可以使用 Requests 库来发送请求，可以作为一种尝试方法。","link":"/2020/01/21/web-crawler-jiao-cheng-zhi-wang-luo-pa-chong-tong-yong-liu-cheng-jie-du/"},{"title":"Web Crawler 教程之网络爬虫工具库","text":"Requests 网络库","link":"/2020/01/22/web-crawler-jiao-cheng-zhi-wang-luo-pa-chong-gong-ju-ku/"},{"title":"一文学会正则表达式语法","text":"正则表达式（Regular Expression）是一种 文本匹配模式（Pattern），基本上所有的程序设计语言都支持利用正则表达式进行字符串的操作，它是学习编程的基础。 本博文中，有些地方会将正则表达式简称为 &gt;&gt;&gt; 正则: 什么是正则日常中，典型的文本搜索和替换操作，都要求你提供与预期搜索结果匹配的 确切文本。 而正则表达式（Regular Expression）是一种文本（或字符串）匹配模式（Pattern）。 常用于 &gt;&gt;&gt; 在文本（或字符串）中，查找、替换 符合某种正则匹配模式 的子文本（子串）场景。 你可以简单的理解为 &gt;&gt;&gt; | &gt;&gt;&gt;&gt; 正则就是用有限的字符，来表达无限的序列 &lt;&lt;&lt; | 正则的构成正则表达式，是由 普通字符 &amp;&amp; 特殊字符（也称为元字符）组成的文本模式（Pattern）。 正则表达式的语法一般类似如下： 12# JS 中两条斜线中间是正则主体（匹配模式）：/^abc/ 字符（普通字符 &amp;&amp; 特殊字符）作为正则的基本构成，接下来需要深入了解一下字符的分类： 普通字符区别于特殊字符，没有特殊意义的字符即简单字符。 简单字符，在正则中就代表其自身，绝大部分的字符都是简单字符。示例如下（匹配确切文本）： 1234/abc/ // 用于匹配 abc/123/ // 匹配 123/-_-/ // 匹配 -_-/测试/ // 匹配 测试 特殊字符所谓特殊字符，是指在正则中具有特殊含义的字符。 可以先跳过本章节内容，或对照下一章节内容进行学习。 正则表达式中支持的特殊字符如下： Characters Description $ 定位符，匹配输入字符串的结尾位置。要匹配 $ 字符本身，请使用 \\$ ( ) 分组，标记一个子表达式（分组）的开始和结束位置。要匹配这些字符，请使用 \\( 和 \\) * 量词，匹配前面的子表达式零次或多次（零次及以上）。要匹配 * 字符，请使用 \\* + 量词，匹配前面的子表达式一次或多次（一次及以上）。要匹配 + 字符，请使用 \\+ . 匹配除换行符 \\n \\r 之外的任何单字符。要匹配 . ，请使用 \\. [ 标记一个中括号表达式（字符集合）的开始。要匹配 [，请使用 \\[ ? 量词，匹配前面的子表达式零次或一次，或定义非贪婪模式。要匹配 ? 字符，请使用 \\? \\ 转义，将下一个字符标记为：转义字符、原义字符、特殊字符，或向后引用。要匹配 \\ 字符，请使用 \\\\ ^ 定位符，匹配输入字符串的开始位置，或在字符集合 [] 中使用表示取反（非）。要匹配 ^ 字符本身，请使用 \\^ { 量词，数量表达式的开始。要匹配 {，请使用 \\{ | 选择，两项之间的一个选择（取或）。要匹配 |，请使用 | 转义字符详解 &gt;&gt;&gt;&gt; 字符 \\ 表示转义，其后跟的字符不同具有不同的含义，可分为四类： 转义字符：匹配无法显示的特殊字符，如 换行（\\n）、制表符（\\t）等； 原义字符：让特殊字符显示其自身，即匹配特殊字符本身，如 \\\\ &amp;&amp; \\$ 等； 特殊字符：具有特殊含义，如：\\w &amp;&amp; \\s 等； 向后引用：后跟数字表示引用。 常用转义字符支持： 正则匹配模式正则表达式中使用不同的特殊字符，可以构建具有不同匹配规则的文本模式。 字符匹配首先来基本的字符匹配语法： 纵向模糊匹配纵向模糊匹配，就是 想要匹配的某个字符不确定，有多种情况（属于某个字符簇）。 方法 &gt;&gt;&gt; 使用字符簇（[]）。如下： 12/[abc]/ // 可以匹配：a 或 b 或 c/a[123]b/ // 可以匹配：a1b 或 a2b 或 a3b [1] &gt;&gt;&gt; 字符簇范围表示法 对于很长的、且有规律的字符簇，可以使用范围表示法（-）。如下： 12/[0-9]/ // 等价于：[0123456789]/[1-5a-eA-E]/ // 等价于：[12345abcedABCDE] [2] &gt;&gt;&gt; 排除字符簇 在字符簇中的第一位写 ^，表示取非。例如： 1/[^abc]/ // 可以匹配：a、b、c 之外的任意字符 [3] &gt;&gt;&gt; 常见字符簇 正则内置了 7 种常见的字符簇简写形式： \\d = [0-9] &gt;&gt;&gt; 匹配数字； \\D = [^0-9] &gt;&gt;&gt; 匹配除数字以外的任意一个字符 \\w = [0-9a-zA-Z_] &gt;&gt;&gt; 匹配字母、数字或下划线 \\W = [^0-9a-zA-Z_] &gt;&gt;&gt; 匹配除字母、数字或下划线以外的任意一个字符 \\s = [ \\t\\v\\n\\r\\f] &gt;&gt;&gt; 匹配任意一个空白符（空格、制表符、换行符以及换页符） \\S = [^ \\t\\v\\n\\r\\f] &gt;&gt;&gt; 匹配非空白符以外的任意一个字符 . = [^\\n\\r] &gt;&gt;&gt; 匹配除换行符以外的任意一个字符; 横向模糊匹配横向模糊匹配，就是 想要匹配的某个字符，可能会连续出现多次。 方法 &gt;&gt;&gt; 使用量词（{m, n}），为匹配字符可连续出现 m~n 次（优先匹配 n 次）。如下： 1/ab{2,4}c/ // 可以匹配：abbbbc 或 abbbc 或 abbc，优先匹配 abbbbc [1] &gt;&gt;&gt; 常见量词形式 正则内置了 5 种常见的量词简写形式： {m}：匹配 m 次，等价于 {m, m}。例如 a{2} 表示：匹配 aa； {m,}：匹配 m~∞ 次，等价于 {m, ∞}，优先匹配 ∞ 次。例如 a{1,} 可以匹配：aaaa…； ?：匹配 0 次或 1 次，等价于 {0, 1}，优先匹配 1 次（记忆：有吗？&gt;&gt;&gt; 出现或不出现）； +：匹配 1~m 次，等价于 {1, m}，优先匹配 m 次（记忆：追加 &gt;&gt;&gt; 至少有一个，再追加）； *：匹配 0~m 次，等价于 {0, m}，优先匹配 m 次（记忆：星星，可能一颗，可能几颗，可能数不清）。 [2] &gt;&gt;&gt; 贪婪匹配 正则量词默认和人心一样是贪婪的，其默认是使用 贪婪模式 去匹配的，都优先匹配上限而不是下限（尽可能多）。例如： 1/a{1, 3}/ // 匹配字符串 `aaa` 时，会匹配 `aaa` 而不是 `a` 如何开启 非贪婪模式匹配 &gt;&gt;&gt; 有时侯，我们不希望使用贪婪模式去匹配，可以通过在量词后面加一个 ?，表示开启非贪婪模式： 1/a{1, 3}?/ // 匹配字符串 `aaa` 时，会匹配 `a` 而不是 `aaa` 选择表达式上面我们知道，上面的字符簇是对单个字符取或，例如 [abc] 可以匹配 a 或 b 或 c。 如果，我们想要对 多个字符拼成的像单词 这样的形式取或，怎么办？ 方法 &gt;&gt;&gt; 使用 | 构建 选择表达式 。如下： 1/xxx|yyy|zzz/ // 可以匹配：xxx 或 yyy 或 zzz 需要注意的是，选择表达式会优先匹配排在前面的 “单词”，如下： 1/good|goodbye/ // 匹配字符串 `goodbye` 时，会匹配 `good` 而不是 `goodbye` 修饰符正则表达式中，可以通过在正则表达式的后面增加修饰符（flags），来指定额外的匹配策略。其语法格式如下： 1/pattern/flags 额外的匹配策略？！！ &gt;&gt;&gt; 例如，默认情况下，正则匹配时是区分大小写的！！！你可以通过添加修饰符（i &gt;&gt;&gt; ignore）来将匹配设置为不区分大小写： 1/ab/i // 可以匹配：ab 或 aB 或 Ab 或 AB 正则表达式支持的其它常用修饰符 &gt;&gt;&gt; g &gt;&gt;&gt; global：全局匹配策略，默认情况下正则遇到第一个匹配项就会结束；而加上全局修饰符，可以查找所有的匹配项； m &gt;&gt;&gt; Multiline：多行模式，使边界字符 ^ 和 $ 可以匹配每一行（\\n &amp;&amp; 、r）的开头和结尾；而非多行模式则只能匹配整个字符串的起始位置与结束位置； s：默认情况下的圆点 . 是匹配除换行符 \\n、\\r 之外的任何字符；而加上 s 修饰符，. 中包含换行符 \\n &amp;&amp; \\r。 示例如下： 12345678/JS/g // 可以匹配字符串 `Hello JS, I love JS` 中的所有 `JS`// 参考下文位置匹配：/^hello/g // 只可以匹配字符串 `hello Google\\nEdge\\nhello IE` 中的第一个 `hello`/^hello/gm // 可以匹配字符串 `hello Google\\nEdge\\nhello IE` 中的所有 `hello`/Google./ // 无法匹配字符串 `Google\\nEdge\\nIE` 中的 `Google`/Edge./s // 可以匹配字符串 `Google\\nEdge\\nIE` 中的 `Edge` 位置匹配位置（锚）是指 &gt;&gt;&gt; 相邻字符之间的位置。如下： [1] 特殊位置 &gt;&gt;&gt; 字符边界 &gt;&gt;&gt; 1.1 字符边界】&gt;&gt;&gt; ^ &amp;&amp; $ ^ 在字符簇（[]）外表示匹配文本开头位置的意思，代表文本开头的位置。例如，你可以匹配以某字符开头的文本： 1/^abc/ // 可以匹配 abcde，但是不能匹配 aabcde $ 表示匹配文本结尾位置的意思，代表文本的结尾位置。例如，你可以匹配以某字符结尾的文本： 1/abc$/ // 可以匹配 defabc，但是不能匹配 defabcc 观察匹配位置实质 &gt;&gt;&gt; 12345678// 以 JavaScript 为例：&gt; var str = 'hello\\nworld\\ni\\nam\\nfine';&gt; console.log(str.replace(/^|$/gm, '#')); // 匹配位置后替换#hello##world##i##am##fine# 1.2 字符边界】&gt;&gt;&gt; \\b &amp;&amp; \\B \\b 表示匹配文本中的单词边界位置的意思，包括：单词和非单词之间、单词和开头之间、单词和结尾之间。 例如，你可以匹配文本中以某字符开头（结尾）的单词： 123/\\bJS/ // 可以匹配 `Hello JS`，但是不能匹配 `HelloJS`/JS\\b/ // 可以匹配 `HelloJS`/\\bJS\\b/ // 仅匹配单词 `JS` 而 \\B 表示匹配文本中的非单词边界位置的意思，除了 \\b 的位置，别的都是 \\B。 观察匹配位置实质 &gt;&gt;&gt; 12345&gt; console.log('[apple] test.mp4 你好'.replace(/\\b/g, '#'));[#apple#] #test#.#mp4# 你好&gt; console.log('[apple] test.mp4'.replace(/\\B/g, '#'));#[a#p#p#l#e]# t#e#s#t.m#p#4 #你#好# [2] &gt;&gt;&gt; 预查（断言） 2.1 正向预查】&gt;&gt;&gt; (?=pattern) &amp;&amp; (?!pattern) (?=pattern)：表示正向肯定预查 &gt;&gt;&gt; 即该位置后面的字符要匹配 pattern。 例如，Windows(?=95|98|NT|2000) 能匹配 “Windows2000” 中的 “Windows”，但不能匹配 “Windows3.1” 中的 “Windows”。 (?!pattern)：表示正向否定断言。即该位置后面的字符不能匹配 pattern。 例如，Windows(?!95|98|NT|2000) 能匹配 “Windows3.1” 中的 “Windows”，但不能匹配 “Windows2000” 中的 “Windows”。 观察匹配位置实质 &gt;&gt;&gt; 1234&gt; console.log('hello'.replace(/(?=l)/g, '#'));he#l#lo&gt; console.log('hello'.replace(/(?!l)/g, '#'));#h#ell#o# 2.2 反向预查】&gt;&gt;&gt; (?&lt;=pattern)：表示反向肯定预查 &gt;&gt;&gt; 即该位置前面的字符要匹配 pattern。 例如，(?&lt;=95|98|NT|2000)Windows 能匹配 “2000Windows” 中的 “Windows”，但不能匹配 “3.1Windows” 中的 “Windows”。 (?&lt;!pattern)：表示反向否定断言。即该位置前面的字符不能匹配 pattern。 例如，(?&lt;!95|98|NT|2000)Windows 能匹配 “3.1Windows” 中的 “Windows”，但不能匹配 “2000Windows” 中的 “Windows”。 注意，JS 中仅支持正向预查，不支持反向预查。 需要注意的是，这里特殊字符（^ $ \\b \\B (?=p) (?!p)）匹配到的是位置！！！其本质代表某一个位置。 分组与引用正则表达式使用 () 来表示分组，即构成一个子表达式。 通过分组可以使得上面的 量词应用于多个字符，而非单个字符： 1/(abc){2}/ // 可以匹配：abcabc 由于分组的这种特性，故其 不能放在字符簇（[]）中，但分组中 可以使用选择表达式： 1/(123|456){2}/ // 可以匹配：123123 或 456456 或 123456 或 456123 [1] &gt;&gt;&gt; 捕获和非捕获分组 默认情况下，正则引擎在匹配过程中，会为每一个分组都开辟一个空间（用来捕获匹配到的文本），用来存储每一个分组匹配到的数据，以便于引用分组匹配的数据（捕获分组）。如下： 1234567891011&gt; var regex = /(\\d{4})-(\\d{2})-(\\d{2})/;&gt; var str = '2021-10-20';&gt; console.log(str.match(regex));[ '2021-10-20', '2021', // Group 1，捕获到 `2021` '10', // Group 2，捕获到 `10` '20', // Group 3，捕获到 `20` index: 0, input: '2021-10-20', groups: undefined] 你也可以通过在分组起始字符 (后，添加 ?: 让捕获分组变为非捕获分组 (?:pattern)。 非捕获分组不会开辟空间来捕获存储，示例如下（日期格式中的月、日不捕获）： 123456789&gt; var regex = /(\\d{4})-(?:\\d{2})-(?:\\d{2})/;&gt; var str = '2021-10-20';&gt; console.log(str.match(regex));[ '2021-10-20', '2021', // Group 1，仅捕获到年分组 `2021` index: 0, input: '2021-10-20', groups: undefined] 非捕获分组，可以起到性能优化的作用，节省了内存。 [2] &gt;&gt;&gt; 捕获分组反向引用 使用捕获分组（默认）后，你可以在正则表达式分组之后，引用前面分组中捕获的数据（ 捕获就是为了使用，否则就采用非捕获模式匹配，以优化性能）。 正则中，反向引用的语法是 &gt;&gt;&gt; \\number，即反斜杠（反向）加数字，其中数字表示引用前面第几个捕获分组。 例如，在匹配 HTML 标签时，为了使得 &lt;xxx&gt;&lt;/xxx&gt; 中后面的 xxx 能够和前面保持一致，你可以： 1/&lt;([a-z]+)&gt;&lt;\\/\\1&gt;/ // 可以匹配：`&lt;div&gt;&lt;/div&gt;` 或 `&lt;span&gt;&lt;/span&gt;` 等双标签 正则可视化为了更直观的查看正则表达式，推荐一个图形化展示工具 [ &gt;&gt;&gt; RegulEx &lt;&lt;&lt; ]。 正则表达式的基本语法，在任意编程语言中都是一样的。不同的是：每种编程语言会有自己独特的表现形式。 比如 JS 中用两个斜杠来包裹正则表达式的内容（/pattern/），而 Java 里没有这种写法；但是表达式里概念与写法是一样的。 运算符优先级正则表达式计算遵循优先级顺序：相同优先级的从左到右进行运算，不同优先级的运算先高后低。 运算符优先级列表如下： 运算符 描述 \\ 转义符 (), (?:), (?=), [] 分组和字符簇 *, +, ?, {n}, {n,}, {n,m} 量词 ^, $, \\任何元字符、任何字符 定位点和序列（即：位置和顺序） | 选择表达式，取或","link":"/2016/10/01/yi-wen-xue-hui-zheng-ze-biao-da-shi-yu-fa/"},{"title":"JS 教程之 JavaScript 变量和数据类型","text":"JavaScript 语言基础部分内容，包括：JS 变量、JS 数据类型、JS 数据类型转换、javascript:void(0) 以及 JS 严格模式等等。 在开始学习数据类型之前，我们先来看 JS 中的变量概念： JS 变量和常量–&gt; 变量是什么？ 变量（variables），你可以将其看成是一个个带有标签（名字）的小盒子，用来存放我们的数据。 严格来说 &gt;&gt;&gt; 变量，就是指向一个计算机内存单元的引用，它没有类型。我们所说的 “变量的类型” 是变量指向的内存中数据对象的类型。 –&gt; 常量又是什么？ 和变量相对应的是 常量（Constant），它们都是用来“盛装”数据的小箱子，不同的是：变量保存的数据可以被多次修改，而常量一旦保存某个数据之后就不能修改了 变量定义JS 中变量的定义需要使用关键字 var 进行声明（声明时创建），声明后即可使用。语法格式如下： var varName; 例如： 123var str;var age;var prePage; 多变量声明 &gt;&gt;&gt;&gt; JS 允许你同时声明多个变量，多个变量之间使用逗号 , 分隔开。例如： var varName1, varName2, varName3; // 同时声明多个变量 需要注意的是，变量声明后，如果没有为变量赋值，那么其会被赋予一个初始值 &gt;&gt;&gt; undefined（未定义）。 变量赋值数学等号（=）用来给变量赋值。 赋值运算符（=）左边是一个变量名，右边是存储在变量中的值。例如： 12var num = 66; // 声明一个数值变量var carName=&quot;Volvo&quot;; // 声明一个字符串变量 [1] 多变量赋值 &gt;&gt;&gt;&gt; JS 允许你同时为多个变量赋值，例如： 1var num = 66, carName=&quot;Volvo&quot;, job=&quot;teacher&quot;; 为了让代码看起来更工整，变量定义也可横跨多行： 123var num = 66, carName=&quot;Volvo&quot;, job=&quot;teacher&quot;; [2] 重新声明问题 &gt;&gt;&gt;&gt; 需要注意的是，重新声明 JavaScript 变量，变量的值不会丢失！！！ 如下，变量 carname 的值依然是 “Volvo”： 123var carName=&quot;Volvo&quot;;var carName;document.write(carName) 变量提升JavaScript 在预编译期会先预处理声明的变量（即使有赋值也不进行赋值操作），而变量的赋值操作发生在 JavaScript 执行期，而不是预编译期。 也就是说 &gt;&gt;&gt; JavaScript 引擎的解析方式：先解析获取代码中所有被声明的变量，然后再一行一行地顺序运行。 这样，所有声明的变量都会被提升到代码的头部，这个过程就叫做 变量提升。 来看一个示例： 1234document.write(str); // 显示: undefinedstr = &quot;changes&quot;;document.write(str); // 显示: changesvar str = &quot;test&quot;; 如上，JavaScript 引擎在预编译期会对 所有声明的变量 进行 预解析，但不会进行赋值操作，故第一个输出流写入语句使用变量时不会抛出异常，且返回未初始化的值 undefined。而第二个输出流写入语句是在重新赋值操作之后读取，故显示为：changes。 强类型语言特性JS 中可以把任意数据类型赋值给变量。即 &gt;&gt;&gt; 同一个变量可以反复赋值，而且可以是不同类型的值。例如： 123var test = 66;test = &quot;changes&quot;;test = true; 这种变量本身类型不固定的语言称之为 动态语言，也称为 弱类型语言。 与之相对的是 静态语言（强类型语言），静态语言在定义变量时必须指定变量类型，如果赋值的数据类型和定义类型不匹配时，就会报错（例如：强类型语言的代表：Java，C，C++ 等）。 let &amp;&amp; constECMAScript6（ES6）之前，JavaScript 只能通过 var 关键字来声明变量，ES6 发布之后，新增了 let 和 const 两个关键字来声明变量： let：其声明的变量 只在其所在的代码块中有效（类似于局部变量）；且当前代码块中，同名的变量不能重复声明； const：功能和 let 相同，但由 const 定义的变量，一旦定义，就不能修改（常量）；且声明时必须赋值。 示例代码如下： 12345var str = &quot;Google&quot;; // 声明一个变量 strlet str; // 报错：变量 str 不能重复定义const PI = &quot;3.14&quot;;console.log(PI); // 控制台打印: PI 事实上，在使用关键字 var 定义变量（var varName = &quot;test&quot;;）时，关键词可有可无，即 varName = &quot;test&quot;;，你可以自行尝试一下。并且，不使用 var 定义的变量是全局的，可跨函数访问！！！ 关于代码块说明 &gt;&gt;&gt; var 定义变量，没有块的概念，可以跨块访问，不能跨函数访问； let 定义变量，只能在块作用域（{}，例如 if 块 或 循环体）里访问，也不能跨函数访问； const 定义变量，也只能在块作用域里访问，也不能跨函数访问； JS 数据类型JavaScript 中的数据类型可以分为两种类型： 基本数据类型：数字（Number）、字符串（String）、布尔（Boolean）、空（Null）、未定义（Undefined）、Symbol 引用数据类型：对象（Object） Symbol 是 ECMAScript6（ES6）中引入的一种新的数据类型，表示独一无二的值。 typeof 操作符 &gt;&gt;&gt; 我们知道，变量是动态类型的，所以无法确定 变量当前到底是哪种类型？，使用 typeof 可以返回变量中存放数据的类型。 typeof 操作符有带括号和不带括号两种用法，如下： 12345typeof x;或者：typeof(x); 需要注意的是，其返回的是一个字符串（可用于判断某变量是否为某特定数据类型）。 基本数据类型基本数据类型，也称为 值类型，或 原始类型（Primitive Type），是构成 JS 的基本元素，不能再细分。 你需要注意的是 &gt;&gt;&gt;&gt; 基本数据类型和基本数据类型所对应的包装类的区别，可参见 &gt;&gt;&gt;【JS 教程之浅析原始数据类型和包装类】。通过该博文的学习，你可以更加深入了解原始类型和引用类型的区别。 JS 中内置了六大基本数据类型，分别如下： String 类型字符串是 JS 中最常用的数据类型。 JS 中的字符串（String）类型是一段以单引号 '' 或双引号 &quot;&quot; 包裹起来的文本序列，同时支持使用反斜杠 \\ 来转义特殊字符。 创建字符串很简单，只要为声明的变量分配一个字符串类型的值即可。例如： 12var str1 = 'abc';var str2 = &quot;XYZ&quot;; 这里，'' 或 &quot;&quot; 本身只是一种定义方式，不是字符串的一部分，因此，字符串 'abc' 只有 a，b，c 这 3 个字符。 需要注意的是，不同于 Java，JS 不支持单独的字符类型（char 型），一个字符就是长度为 1 的字符串。 定义空字符串 &gt;&gt;&gt; 12var str1 = '';var str2 = &quot;&quot;; [1] &gt;&gt;&gt; 单引号 ' 或双引号 &quot; 使用 如果 ' 本身也是字符串中的一个字符，那就可以用 &quot;&quot; 括起来，比如 &quot;I' am OK&quot;。同理，如果 &quot; 也是字符串本身的一个字符的话，外面可以用 '' 括起来，如：'I&quot;m OK'。注意，都一致的话会报错： 12&gt; var str = &quot;I&quot; am OK&quot;;Uncaught SyntaxError: Unexpected identifier 'am' 并且切记不要混合使用，如下： 1var str = &quot;I'm OK'; 思考一下？&gt;&gt;&gt; 如果字符串内部既包含 ' 又包含 &quot; 怎么办？？？ 此时只能使用转义字符 \\ 来标识，比如： 1'I\\'m \\&quot;OK\\&quot;!' 表示的字符串内容是： 1I'm &quot;OK&quot;! [2] &gt;&gt;&gt; 字符串中的转义字符 当然了，转义字符 \\ 也可以转义其它特殊字符。、 比如，\\n 表示换行；\\t 表示制表符；\\r 表示回车；\\b 表示空格；\\f 表示换页符；字符 \\ 本身也要转义，所以 \\\\ 表示的字符就是 \\。 示例代码如下： 123&gt; console.log('I\\'m learning\\nPython.')I'm learningPython. [3] &gt;&gt;&gt; 字符串折行 你可以在文本字符串中使用反斜杠 \\ 对长代码行进行换行。 例如，要想换行书写一个比较长的字符串，必须在行尾添加反斜杠 \\，请看下面的例子： 123var str1 = 'It took me six months to write this Python tutorial.\\Please give me more support.\\I will keep it updated.' 上面定义的 str1 字符串比较长，所以使用了反斜杠 \\ 对字符串内容进行了换行，这样就可以把一个长字符串写成多行。 [4] &gt;&gt;&gt; 字符串序列支持 &gt;&gt;&gt; JS 中的字符串是一个不可变的字符序列（Immutable Sequence），支持以下序列操作： 4.1】 &gt;&gt;&gt; 字符串索引 JS 中的字符串仅支持一种字符索引方式，即从左往右以 0 开始（正向），以此类推。 12345678&gt; var str1 = &quot;Welcome to JS world.&quot;;&gt; console.log(str1);Welcome to JS world.&gt; console.log(str1[0]);W&gt; console.log(str1[2]);l 注意，其不支持反向索引方式（-1），也不支持通过索引进行切片操作！！！ 4.2】 &gt;&gt;&gt; 字符串拼接（加法操作） 你可以通过加法（+）运算符实现字符串的拼接： 12345678&gt; var str1 = &quot;Welcome to JS world.&quot;;&gt; console.log(str1 + &quot;test&quot;);Welcome to JS world.test&gt; console.log(str1 + 123);Welcome to JS world.123&gt; console.log(str1 + [1,2,3]);Welcome to JS world.1,2,3 [5] &gt;&gt;&gt; 字符串伪对象 JS 中的原始字符串类型不是对象，如 &quot;Hello JS&quot;，其没有属性和方法。 但是，原始字符串可以使用 JS 中的属性和方法，因为 JS 在执行 方法和属性 时可以把原始类型当作对象。 或者，你可以这么认为：JS 中原始字符串类型，既是基本类型，也是伪对象，故有相应的属性和方法（同内置 String 对象）。 5.1] &gt;&gt;&gt; 常用伪对象属性 字符串伪对象常用属性支持： 5.1.1】 &gt;&gt;&gt; length 属性 字符串的 length 属性可用于获取字符串长度，示例代码如下： 1234567&gt; var str1 = &quot;Hello JS World&quot;&gt; console.log(str1.length);14&gt; var str2 = &quot;&quot;;&gt; console.log(str2.length);0 5.2] &gt;&gt;&gt; 常用伪对象方法 Python 中的字符串是不可变的，所以所有修改和生成字符串的操作的实现方法，都是在另一个内存片段中生成一个新字符串对象，都不能改变字符串本身的内容。 字符串伪对象常用方法支持： 5.2.1】 &gt;&gt;&gt; 字符串大小写转换 1）toLowerCase 1str.toLowerCase() 返回一个新的字符串，在其中原始 str 字符串中的所有大写字符全部被转换为了小写字符。注意字符串中的小写字母或中文字符不做任何改变！！！ 示例代码如下： 123&gt; var str1 = &quot;测试：Hello, JavaScript World.&quot;;&gt; console.log(str1.toLowerCase());测试：hello, javascript world. 2）toUpperCase 1str.toUpperCase() 返回一个新的字符串，在其中原始 str 字符串中的所有小写字符全部被转换为了大写字符。注意字符串中的大写字母或中文字符不做任何改变！！！ 示例代码如下： 123&gt; var str1 = &quot;测试：Hello, JavaScript World.&quot;;&gt; console.log(str1.toUpperCase());测试：HELLO, JAVASCRIPT WORLD. 5.2.2】 &gt;&gt;&gt; 子串搜索与截取 1）indexOf &amp;&amp; lastIndexOf 12str.indexOf(searchvalue, fromindex)str.lastIndexOf(searchvalue, fromindex) indexOf() 搜索字符串 str 中是否包含子串 searchvalue。如果包含，则返回 首次出现的 searchvalue 第一个字符的索引位置，否则返回 -1。开始检索的位置在字符串的 fromindex 处或字符串的开头（没有指定 fromindex 时），fromindex 合法取值：(0, str.length-1)。 区别的，lastIndexOf() 会从字符串的 fromindex 处或字符串的结尾（没有指定 fromindex 时），按照从尾到头的方向搜索。如果包含，则立即返回出现的 searchvalue 第一个字符的索引位置，否则返回 -1。 示例代码如下： 123456789101112131415161718192021&gt; var str1 = &quot;I love JS and I study JS From Baidu&quot;;&gt; var iIdx = str1.indexOf(&quot;JS&quot;);&gt; var iLastIdx = str1.lastIndexOf(&quot;JS&quot;);&gt; console.log(iIdx);7&gt; console.log(iLastIdx);22&gt; var iIdx1 = str1.indexOf(&quot;JS&quot;, 8);&gt; console.log(iIdx1);22&gt; var iLastIdx1 = str1.lastIndexOf(&quot;JS&quot;, 21);&gt; console.log(iLastIdx1);7&gt; var iIdxNo = str1.indexOf(&quot;Javascript&quot;);&gt; var iLastIdxNo = str1.lastIndexOf(&quot;Javascript&quot;);&gt; console.log(iIdxNo);-1&gt; console.log(iLastIdxNo);-1 2）search 1str.search(searchvalue/regexp) search() 搜索字符串 str 中是否包含子串 searchvalue 或是否匹配正则表达式对象 regexp。如果包含（匹配），则返回 str 中第一个与 searchvalue/regexp 相匹配的子串的起始位置，否则返回 -1。 示例代码如下： 1234567891011121314&gt; var str1 = &quot;I love JS and I study JS From Baidu&quot;;&gt; var iIdx = str1.search(&quot;JS&quot;);&gt; var iIdxRE = str1.search(/JS/);&gt; console.log(iIdx);7&gt; console.log(iIdxRE);7&gt; var iIdxNo = str1.search(&quot;Javascript&quot;);&gt; var iIdxRENo = str1.search(/Javascript/);&gt; console.log(iIdxNo);-1&gt; console.log(iIdxRENo);-1 3）match 1str.match(searchvalue/regexp) match() 搜索字符串 str 中是否包含子串 searchvalue 或是否匹配正则表达式对象 regexp。如果包含（匹配），则返回一个存放匹配结果的数组，否则返回 null。 关于数组内容（存放了匹配文本有关的信息）&gt;&gt;&gt;&gt; 如果检索的是 searchvalue，则该数组的第 0 个元素存放的是第一次匹配到的文本；还包含两个对象属性，其中 index 属性声明的是匹配文本的起始字符在 str 中的位置，input 属性声明的是对 str 的引用。 如果检索的是 regexp，其内容依赖于正则表达式对象是否具有全局标志 g，以找到一个或多个与 regexp 匹配的文本。如果 regexp 没有全局标志 g，match() 方法只能在 str 中执行一次匹配（第一次匹配），如果没有找到匹配的文本将返回 null；否则返回数组内容同 searchvalue。如果 regexp 具有全局标志 g，则 match() 方法将执行全局检索，找到 str 中的所有匹配子字符串，如果没有找到匹配的文本将返回 null；如果找到了一个或多个匹配子串，其返回的数组存放的是 str 中所有的匹配子串，没有 index 属性或 input 属性。 示例代码如下： 12345678910111213141516&gt; var str1 = &quot;I love JS and I study JS From Baidu&quot;;&gt; var res = str1.match(&quot;JS&quot;);&gt; console.log(res);['JS', index: 7, input: 'I love JS and I study JS From Baidu', groups: undefined]&gt; console.log(res['index']);7&gt; var resNo = str1.match(&quot;JavaScript&quot;);&gt; console.log(resNo);null&gt; var res1 = str1.match(/JS/);&gt; console.log(res1);['JS', index: 7, input: 'I love JS and I study JS From Baidu', groups: undefined]&gt; var res1g = str1.match(/JS/g);&gt; console.log(res1g);(2) ['JS', 'JS'] 需要注意的是，全局检索模式（g）下，match() 方法不提供与子表达式匹配的文本的信息（例如字串位置），如果你需要这些全局检索的信息，可以使用 RegExp.exec() 来替换 match() 方法的全局检索模式。 | &gt;&gt;&gt; ============================================= Split Line ============================================ &lt;&lt;&lt; | 上面我们已经可以获取字符串（str）中 某个特定字串（或具有某种正则匹配模式的子串）的位置信息，下面来看如何根据上述的字串位置信息截取相应的字串： 4）substring &amp;&amp; substr 12str.substring(start, stop)str.substr(start, length) substring() 方法可用于截取字符串（str）中介于两个指定下标之间（start-stop）的子串，返回一个新字符串。其中，start（非负的整数）是要提取的子串的首字符索引，stop（非负的整数）是要提取的子串的最后一个字符的索引（缺省表示要截取到字符串结尾）值加 1，即前闭后开的（也可以表示为 start + substring.length）。 substr() 方法可用于截取字符串（str）中从 start 下标开始的指定长度（length）的子串，返回一个新字符串。其中，start（整数）为负数时采用反向索引方式来标识开始下标，length（非负的整数）为子串中的字符数（缺省表示要截取到字符串结尾）。 示例代码如下： 1234567891011121314&gt; var str1 = &quot;I love JS and I study JS From Baidu&quot;;&gt; var subStr1 = str1.substring(7, 9);&gt; console.log(subStr1);JS&gt; var subStr2 = str1.substring(7);&gt; console.log(subStr2);JS and I study JS From Baidu&gt; var subStr3 = str1.substr(-13, 2);&gt; console.log(subStr3);JS&gt; var subStr4 = str1.substr(-13);&gt; console.log(subStr4);JS From Baidu 5）slice 1str.slice(start, end); slice() 方法可用于截取（分片）字符串（str）中介于两个指定下标之间（start-end）的子串，返回一个新字符串。 其中，start（整数）是要提取的子串的首字符索引，end（整数）是要提取的子串的最后一个字符的索引（缺省表示要截取到字符串结尾）值加 1，即前闭后开的（也可以表示为 start + substring.length）。需要注意的是 start &amp;&amp; end 为负整数的情况。 示例代码如下： 1234567&gt; var str1 = &quot;I love JS and I study JS From Baidu&quot;;&gt; var subStr1 = str1.slice(7, 9);&gt; console.log(subStr1);JS&gt; var subStr2 = str1.slice(-13, -11);&gt; console.log(subStr2);JS | &gt;&gt;&gt; ============================================= Split Line ============================================ &lt;&lt;&lt; | 如果仅仅是判断字符串（str）中是否存在某个特定的子串： 6）includes 1str.includes(searchvalue, start); ES 6 中提供的 includes() 函数用于判断字符串中是否包含指定的子串。如果找到返回 true，否则返回 false。其中，searchvalue 表示需检索的子串，start（非负整数）表示在字符串中开始检索的位置，其合法取值为（0, str.length - 1），缺省表似乎从字符串的第一个位置处开始检索。 示例代码如下： 12345678910&gt; var str1 = &quot;I love JS and I study JS From Baidu&quot;;&gt; var isFind = str1.includes(&quot;JS&quot;);&gt; console.log(isFind);true&gt; var isFind1 = str1.includes(&quot;Javascript&quot;);&gt; console.log(isFind1);false&gt; var isFind2 = str1.includes(&quot;love&quot;, 7);&gt; console.log(isFind2);false 5.2.3】 &gt;&gt;&gt; 字符串替换 1）replace 1str.replace(substr/regexp, replacement) replace() 方法执行的是查找并替换的操作，它将在 str 中查找与 substr/regexp 相匹配的子字符串，然后用替换值 replacement 来替换查找到的子串，返回一个替换后的新字符串。 需要注意的是，如果 regexp 具有全局标志 g，那么将替换所有匹配的子串。否则（substr/regexp）只替换第一个匹配到的子串。 1.1）replace(substr/regexp, newSubStr) 当替换值为一个字符串（还可以函数）时，示例代码如下： 1234567891011&gt; var str1 = &quot;I love JS and I study JS From Baidu&quot;;&gt; var res1 = str1.replace(&quot;JS&quot;, &quot;JavaScript&quot;);&gt; console.log(res1);I love JavaScript and I study JS From Baidu&gt; var res2 = str1.replace(/JS/, &quot;JavaScript&quot;);&gt; console.log(res2);I love JavaScript and I study JS From Baidu&gt; var res3 = str1.replace(/JS/g, &quot;JavaScript&quot;);&gt; console.log(res3);I love JavaScript and I study JavaScript From Baidu 替换字符串（newSubStr）中 支持一些特殊的用法 &gt;&gt;&gt; 可以插入下面的特殊变量名： 字符 替换文本 $1 … $n 插入与 regexp 中子表达式 () 对应的第 1 个或第 n 个子表达式相匹配的文本 $&amp; 插入与 regexp 相匹配的子串 $` 插入当前匹配的子串左边的内容 $’ 插入当前匹配的子串右边的内容 $$ 插入一个 $ 字符本身 示例代码如下： 12345678910111213141516&gt; var name = &quot;Doe, John&quot;;&gt; var resName = name.replace(/(\\w+)\\s*, \\s*(\\w+)/, &quot;First Name: $2, Last Name: $1&quot;);&gt; console.log(resName);First Name: John, Last Name: Doe&gt; var resName1 = name.replace(/[a-zA-z]+/g, &quot;'$&amp;'&quot;);&gt; console.log(resName1);'Doe', 'John'&gt; var resName2 = name.replace(/[a-zA-z]+/, &quot;$'&quot;);&gt; console.log(resName2);, John, John&gt; var resName3 = name.replace(/[a-zA-z]+/, &quot;$`&quot;);&gt; console.log(resName3);, John | &gt;&gt;&gt; ============================================= Split Line ============================================ &lt;&lt;&lt; | 上述字符串替换功能比较简单，有时需要做一些更复杂的字符串替换操作，这就涉及到 正则 + function 的高级用法了。 1.2）replace(regexp, function) 事实上，replace() 方法中的替换值除了可以是上述的字符串外，还可以是一个每次匹配时都要调用的回调函数（匹配时执行），函数的返回值将作为替换字符串。 需要注意的是，对 str 使用 Regexp 进行匹配，如果匹配到多项结果（全局匹配 g，或者分组），那么 每一个匹配结果都将执行一次回调函数，并且用该函数的返回值替代源字符串中的匹配项。 下面，我们将根据 Regexp 中是否使用分组分为两种场景进行说明（影响回调函数默认参数列表）： 1.2.1）正则表达式中不使用分组 12345678&gt; var str = &quot;I love JS and I study JS From Baidu&quot;;&gt; var res = str.replace(/JS/, function(){ console.log(arguments); return &quot;JavaScript&quot; })&gt; console.log(res);I love JavaScript and I study JS From Baidu 可见，正则表达式没有使用全局匹配符 g，所以只替换了源字符串中第一个 JS 子串。通过 console.log(arguments)（输出回调函数参数信息）可以看出回调函数只执行了一次，如下： 可以看出，回调函数是有默认参数的： arguments[0]：是匹配到的子字符串； arguments[1]：是匹配到的子串的索引位置； arguments[2]：是源字符串本身。 再来尝试一下全局匹配（g）的情况： 12345678&gt; var str = &quot;I love JS and I study JS From Baidu&quot;;&gt; var res = str.replace(/JS/, function(){ console.log(arguments); return &quot;JavaScript&quot; })&gt; console.log(res);I love JavaScript and I study JavaScript From Baidu 可见，输出了 2 个 Arguments。这是由于使用全局匹配（g）后，匹配到两个匹配项，执行了 2 次 回调函数。 1.2.2）正则表达式中使用分组 示例，将字符串中所有以 W 为单位的工资，其金额改为元 Y。例如 4W，改为 40000Y。 12345678&gt; var txt = &quot;John:5W;Lihua:5000Y;Bob:2000Y;Lucy:20W;Charli:8500Y.&quot;;&gt; var res = txt.replace(/(\\d+)(W)/g, function(){ console.log(arguments); return arguments[1] + &quot;0000&quot; + &quot;Y&quot;; });&gt; console.log(res);John:50000Y;Lihua:5000Y;Bob:2000Y;Lucy:200000Y;Charli:8500Y. 输出展示： 可以看出，对于使用两个分组的情况，其回调函数刚好增加了两个参数： arguments[0]：是匹配到的子字符串； arguments[1]：是匹配到的第 1 个分组项； arguments[2]：是匹配到的第 2 个分组项； arguments[3]：是匹配到的字符串的索引位置； arguments[4]：是源字符串本身。 事实上，如果你在 Regexp 中使用了 n 个分组的话，其回调函数会增加 n 个至 arguments[n]。 5.2.4】 &gt;&gt;&gt; 字符串分割 很多时候我们有 分割字符串 的需求，即把一个字符串 按照某种特定的分隔符进行切割，注意其与 字符串截取 的区别。 1）split 1str.split(separator, howmany) split() 方法会通过根据指定的 separator 分隔符来对 str 进行分割，返回一个字符串数组。其中，howmany（可选，非负整数）用于指定返回数组的长度，即返回几个子串（不全部返回）；如果不指定 howmany，则会从左向右搜索并且每遇到 separator 一次就分割直到搜索完字符串。 示例代码如下： 12345678&gt; var str = &quot;I love JS and I study JS From Baidu&quot;;&gt; var res = str.split(&quot; &quot;);&gt; console.log(res);(9) ['I', 'love', 'JS', 'and', 'I', 'study', 'JS', 'From', 'Baidu']&gt; var res1 = str.split(&quot; &quot;, 5);&gt; console.log(res1);(5) ['I', 'love', 'JS', 'and', 'I'] 需要注意的是，如果把空字符串 (&quot;&quot;) 用作 separator，那么 str 中的每个字符之间都会被分割： 1234&gt; var str = &quot;Split Test&quot;;&gt; var res = str.split(&quot;&quot;);&gt; console.log(res);(10) ['S', 'p', 'l', 'i', 't', ' ', 'T', 'e', 's', 't'] 分隔符可以是子串或正则表达式 &gt;&gt;&gt; 返回 数组 中包括与正则表达式中子表达式 () 匹配的字串（但不包括与整个正则表达式或子串匹配的文本）: 123456789101112&gt; var str = &quot;I love JS and I study JS From Baidu&quot;;&gt; var res = str.split(&quot;JS&quot;);&gt; console.log(res);(3) ['I love ', ' and I study ', ' From Baidu']&gt; var res1 = str.split(/JS/);&gt; console.log(res1);(3) ['I love ', ' and I study ', ' From Baidu']&gt; var res2 = str.split(/(\\s)(JS)/);&gt; console.log(res2);(7) ['I love', ' ', 'JS', ' and I study', ' ', 'JS', ' From Baidu'] 5.2.5】 &gt;&gt;&gt; 字符串拼接 1）加法 + 1str = str1 + str2 + ...; 加法运算符（+）可以直接将多个字符串拼接在一起。示例代码如下： 123456&gt; var str1 = &quot;Hello &quot;;&gt; var str2 = &quot;JavaScript &quot;;&gt; var str3 = &quot;World.&quot;;&gt; var res_str = str1 + str2 + str3;&gt; console.log(res_str);Hello JavaScript World. 2）join 1234var arr = new Array();arr.push(str1);arr.push(str2);var str = arr.join(&quot;separator&quot;); join() 方法实现字符串拼接需要借助 数组（Array）对象以及其 push() 方法。需要先将待拼接的字符串（str1/str2/str3…）存储到数组（字符串数组）中，最后调用数组的 join() 方法实现字符串的拼接。其中，separator 可用于指定拼接时的连接符。 1234567891011121314151617&gt; var arr = new Array();&gt; var str1 = &quot;Hello&quot;;&gt; var str2 = &quot;JavaScript&quot;;&gt; var str3 = &quot;World.&quot;;&gt; arr.push(str1);&gt; arr.push(str2);&gt; arr.push(str3);&gt; console.log(arr);(3) ['Hello', 'JavaScript', 'World.']&gt; var res = arr.join(&quot;&quot;)&gt; console.log(res);HelloJavaScriptWorld.&gt; var res1 = arr.join(&quot; &quot;);&gt; console.log(res1);Hello JavaScript World. 3）concat JS 中字符串伪对象和数组对象均支持使用 concat() 函数进行连接操作： 12str1.concat(str2, str3, ...)arrayObject.concat(arrayX, arrayY, arrayZ, ...) concat() 方法参数列表中为待连接的多个字符串或数组，返回一个新的字符串或数组。需要注意的是，concat 连接数组时，添加的是数组中的元素，而不是数组。 示例代码如下： 123456789101112&gt; var str1 = &quot;Hello &quot;;&gt; var str2 = &quot;JavaScript&quot;;&gt; var str3 = &quot; World.&quot;&gt; var res_str = str1.concat(str2, str3);&gt; console.log(res_str);&gt; Hello JavaScript World.&gt; var arr_a = [&quot;Hello&quot;, &quot;JS&quot;];&gt; var arr_b = [1, 2];&gt; var arr_res = arr_a.concat(arr_b);&gt; console.log(arr_res);(4) ['Hello', 'JS', 1, 2] 5.2.6】 &gt;&gt;&gt; 字符串修剪 1）trim JS 中字符串伪对象和数组对象均支持使用 concat() 函数进行连接操作： 1str.trim() trim() 方法可用于删除字符串头尾的空白符，包括空格、制表符 tab、换行符或其他空白符等。 示例代码如下： 1234&gt; var str = &quot; Hello JS &quot;;&gt; var res = str.trim();&gt; console.log(&quot;Before trim =[&quot;, str, &quot;], Res =[&quot;, res, &quot;]&quot;);Before trim =[ Hello JS ], Res =[ Hello JS ] 2）自定义 myTrim 方法 有些浏览器可能不支持 trim 函数，你可以通过字符串替换方法实现 trim 函数功能： 1234567&gt; var str = &quot; Hello JS &quot;;&gt; function myTrim(x){ return x.replace(/^\\s+|\\s$/gm, &quot;&quot;); };&gt; console.log(myTrim(str));Hello JS 5.2.7】 &gt;&gt;&gt; 索引访问字符 访问字符串中指定下标的字符： 1）[] &amp;&amp; charAt &amp;&amp; charCodeAt 123str[index];str.charAt(index);str.charCodeAt(index); 其中，str 表示要访问的字符串，index 表示要访问的某字符的下标索引。 区别的是，对于 []，如果访问的索引在字符串中，则返回该索引处的字符，否则返回 undefined；对于 charAt，如果访问的索引在字符串中，则返回该索引处的字符，否则返回空字符串 &quot;&quot;；对于 charCodeAt，如果访问的索引在字符串中，则返回该索引处字符的 Unicode 码，否则返回 NaN。 示例代码如下： 12345678910111213141516171819&gt; var str = &quot;Hello JS Wrold.&quot;;&gt; var char1 = str[3];&gt; console.log(char1);l&gt; console.log(str[20]);undefined&gt; var char2 = str.charAt(3);&gt; console.log(char2);l&gt; console.log(str.charAt(20));&gt; var char3 = str.charCodeAt(3);&gt; console.log(char3);&gt; 108&gt; console.log(str.charCodeAt(20));\\NaN [6] &gt;&gt;&gt; 字符串包装对象 上面我们提到，可以将基本字符串数据类型看作伪对象，但实际上其并不是一个对象。 但是，你可以使用基本类型的包装对象将其定义为一个对象，详细说明可参加 &gt;&gt;&gt; 【JS 教程之 JS 内置 String 对象】中相关说明。 Number 类型JS 中，数值类型（Number）用来定义数值。并且，JS 中的数值是不区分整数和浮点数的，统一使用 Number 类型表示。如下： 12var num1 = 123; // 整数var num2 = 3.14; // 浮点数 尽管 JS 中数值类型不区分具体的整数和浮点数，但由于整数值和浮点数值使用上的差异，故在使用上以区分： [1] &gt;&gt;&gt; 整数（Int）&amp;&amp; 浮点数（Float） 先来看整数细节： 1.1】 &gt;&gt;&gt; 整数（Int） 同数学上的整数，JS 中的 Int 也包括正整数、负整数、0，且在 JS 中的表示方法和 数学上的写法 一模一样，例如：1，100，-8080，0，等等（十进制写法，Decimal）。 而计算机由于使用二进制，所以有时候用 二进制（Binary）、八进制（Octal） 或者 十六进制（Hexadecimal） 表示整数比较方便： 123456789101112131415161718&gt; var num = 1024;&gt; console.log(num);1024/* 数字前缀 '0b' 表示二进制数 */&gt; var num = 0b1001;&gt; console.log(num);9/* 数字前缀 '0' 表示八进制数 */&gt; var num = 037;&gt; console.log(num);31/* 数字前缀 '0x' 表示十六进制数 */&gt; var num = 0xA0F;&gt; console.log(num);&gt; 2575 1.2】 &gt;&gt;&gt; 浮点数（Float） 浮点数也就是小数，之所以称为浮点数，是因为按照科学记数法表示时，一个浮点数的小数点位置是可变的，比如：1.23 ×10^9 和 12.3 × 10^8 是完全相等的。 浮点数可以用一般的 数学写法，如 1.23，3.14，-9.01 等等。但是对于很大或很小的浮点数，使用 科学计数法 表示更为方便，把 10 用 e 替代，1.23 × 10^9 就是 1.23e9，或者 12.3e8，0.000012 可以写成 1.2e-5，等等。 1234567&gt; var num = 1.23e5;&gt; console.log(num);123000&gt; var num = 1.23e-3;&gt; console.log(num);0.00123 | &gt;&gt;&gt; ========================================= 浮点数计算精度问题 ======================================== &lt;&lt;&lt; | 注意：永远不要直接比较两个浮点的大小。 12# 尝试一下比较如下大小：0.1 + 0.2 &gt; 0.3 // true 这是由于计算机中浮点型数值的存储以及计算是不精确的（十进制和二进制转换引发），这种问题不仅在 JS 中存在，在所有支持浮点数运算的编程语言中都会遇到，它不光是 JS 的 Bug。 详情请关注编程基础系列博文： [ &gt;&gt;&gt;&gt; 编程基础之进制详解 &lt;&lt;&lt;&lt; ][ &gt;&gt;&gt;&gt; 为什么 0.1 + 0.2 不等于 0.3? &lt;&lt;&lt;&lt; ] [2] &gt;&gt;&gt; Number 数值范围 JS 中，Number 类型所能定义的数值并不是无限的，其只能表示 -(2^53 - 1) 到 (2^53 -1) 之间的数值。 数值类型（Number）所能表示的最大值（MAX VALUE）以及最小值（MIN VALUE），可以通过原始数值类型所对应的数值包装对象（Number）中定义的常量值获得： 12345&gt; Number.MAX_VALUE1.7976931348623157e+308&gt; Number.MIN_VALUE5e-324 JS 中，如果某次运算的结果超出了 Number 类型的取值范围 (Number.MIN_VALUE，Number.MAX_VALUE)，那么这个数就会自动转化为无穷大： Number 包装对象中还定义了两个比较特殊的常量值，用于表示无穷大：Infinity（正无穷大） &amp;&amp; -Infinity（负无穷大）。 12345&gt; Number.NEGATIVE_INFINITY-Infinity&gt; Number.POSITIVE_INFINITYInfinity 其中: Infinity：用来表示正无穷大的数值，一般指大于 1.7976931348623157e+308（Number.MAX_VALUE）的数； -Infinity：用来表示负无穷大的数值，一般指小于 5e-324（Number.MIN_VALUE）的数。 无穷数值检测 &gt;&gt;&gt; 你还可以通过数值包装对象（Number）中提供的 Number.isFinite(number) 方法来检测某个数值变量是否非无穷（运算超出数值范围）： 1234567&gt; var num = 123456;&gt; Number.isFinite(num);true&gt; num = Infinity;&gt; Number.isFinite(num);false 如果，isFinite() 方法返回 true 表示变量中数值为有限的，否则为无穷大。 [3] &gt;&gt;&gt; NaN（Not a Number） NaN，即非数值（Not a Number 的缩写），是 Number 包装对象中定义的一个特殊属性值： 12&gt; Number.NaN;NaN NaN 表示，当前的 Number 类型值不是一个数字，即非数值。 你可能比较困惑：什么时候会出现非数值的 Number 数值类型？！！ 事实上，当出现无效或不合法的数学运算时，其返回 NaN。例如 5 除以 0、将一个非数值类型的字符串转化为数值类型。 需要注意的是，NaN 与任何值都不相等，包括其本身： 12&gt; console.log(NaN == NaN);false 这也就意味着，你不能直接判断一个数值变量是否为 Nan，例如：variable == NaN。 NaN 检测 &gt;&gt;&gt; 但，你可以通过数值包装对象（Number）中提供的 Number.isNaN(number) 方法来检测某个数值变量是否不是一个数字： 123&gt; var num = NaN;&gt; console.log(Number.isNaN(num));true 如果，isNaN() 方法返回 true 表示变量中数值是一个数字，否则返回 false。 关于 Number 对象中特殊值更详细的说明，可参见 &gt;&gt;&gt; 【探秘 JavaScript 世界的神秘数字】。 [4] &gt;&gt;&gt; 数值包装对象 上面你已经见过原始数值数据类型的包装对象中提供的一些属性和方法了~~~ 类似于字符串，可以将基本数值数据类型看作伪对象，但实际上其并不是一个对象。 但是，你可以使用基本类型的包装对象将其定义为一个对象，详细说明可参加 &gt;&gt;&gt; 【JS 教程之 JS 内置 Number 对象】中相关说明。 Boolean 类型JS 中，布尔（Boolean）类型只有两个值，true（真）或者 false（假）。并将其定义成关键字了（请注意大小写）。 并且 true 在内部存储的值是 1，false 在内部存储的值是 0。故可以直接和数字运算： 123456789&gt; console.log( true == 1 );1 true&gt; console.log( true + 2 );3&gt; console.log( false == 0 );true&gt; console.log( false + 2 );2 除了直接定义变量为：true Or false，你： [1] ––&gt; 也可以通过 比较运算符（&gt;、&lt;、==、!=）计算出来： 123456&gt; 3 &gt; 2true&gt; 3 &lt; 2false&gt; true == 2;false [2] ––&gt; 还可以进行 &amp;&amp;、|| 和 ! 逻辑表达式 运算： &amp;&amp; 运算是 ”与运算”，只有所有都为 true，&amp;&amp; 运算结果才是 true； || 运算是”或运算”，只要其中有一个为 true，|| 运算结果就是 true； ! 运算是”非运算”，它是一个单目运算符，把 true 变成 false，false 变成 true。 123456789101112131415161718192021222324252627282930313233&gt; console.log(true &amp;&amp; true);true&gt; console.log(true &amp;&amp; false);false&gt; console.log(true || false);true&gt; console.log(false || true);true// 逻辑表达式中以下值会被认为是 False：// 为零的数：0 or -0 or 0.0 or NaN；// 空字符串：''，&quot;&quot;；// 空对象：null；// 未定义：undefined；// 其他的值（非空字符串、非零数值、非空对象）都认为是 True（注意：[] &amp;&amp; {}）。// 你可以使用 `Boolean(obj)` 对 JS 中的所有对象进行真假值的测试：包括字符串、数值、null、undefined、obj、表达式等。&gt; Boolean(null)false&gt; Boolean(undefined);false&gt; Boolean([]);true&gt; Boolean({});true&gt; Boolean(true &amp;&amp; &quot;test&quot;);true&gt; Boolean(true &amp;&amp; NaN);false&gt; Boolean(false || 1.25);true&gt; Boolean(false || &quot;&quot;);false [3] ––&gt; 还常常用于 条件判断（或 while 循环条件）中： 12345678910111213141516171819// 条件判断（或 while 循环条件）中以下值会被认为是 False：// 为零的数：0 or -0 or 0.0 or NaN；// 空字符串：''，&quot;&quot;；// 空对象：null；// 未定义：undefined；// 其他的值（非空字符串、非零数值、非空对象）都认为是 True（注意：[] &amp;&amp; {}）。&gt; if (&quot;&quot;){ console.log(true); } else { console.log(false); };false&gt; if (123){ console.log(true); } else { console.log(false); };true null 类型null 是一个只有一个值的特殊数据类型，表示 “空”（大小写敏感）。即不存在任何值，什么都没有，用来定义一个空对象指针。 使用 typeof 操作符来查看 null 的类型，会发现 null 的类型为 Object，说明 Null 其实是属于 Object（对象）的一个特殊值。 因此，你可以通过将变量赋值为 null 我们可以创建一个空的对象（空对象指针）。 基于 null 的这种特性，你可以通过将变量重新赋值为 null，以实现清空对象的目的： 1var person = null; // 值为 null(空), 但类型为对象 undefined 类型Undefined 也是一个只有一个值的特殊数据类型，表示未定义。非关键字，而是一个全局变量，是 Global 的一个属性。 以下情况会返回 undefined：&gt;&gt;&gt; 访问了一个未定义的变量； 访问了一个已声明但未赋值的变量； 使用了一个对象属性，但该属性不存在或者未赋值； 调用函数时，需要提供的参数没有提供； 函数没有返回值时，默认返回 undefined。 示例代码如下： 1234567891011121314&gt; var num;&gt; console.log(num); // 输出 undefined：访问已声明但未赋值的变量undefined&gt; typeof(num); // 输出 undefined：访问已声明但未赋值的变量undefined&gt; typeof(num1); // 输出 undefined：访问未定义的变量undefined&gt; function func(a){ console.log(a); return &quot;Hello&quot;; };&gt; func() // 输出 undefined：调用函数时，需要提供的参数没有提供undefined Symbol 类型Symbol 是 ECMAScript6(ES6) 中引入的一种新的数据类型，表示独一无二的值。 Symbol 类型的值只能使用 Symbol() 函数来生成，如下例所示： 12345678var str = &quot;123&quot;;var sym1 = Symbol(str);var sym2 = Symbol(str);console.log(sym1); // 输出 Symbol(123)console.log(sym2); // 输出 Symbol(123)\\// 虽然 sym1 与 sym2 看起来是相同的，但实际上它们并不一样。根据 Symbol 类型的特点，sym1 和 sym2 都是独一无二的console.log(sym1 == sym2); // 输出 false 关于 Symbol 数据类型的深入理解和实际应用请参见：[ &gt;&gt;&gt;&gt; 一文了解 JavaScript Symbol &lt;&lt;&lt;&lt; ]。 这里为了保持数据类型章节的完整性，先来简单认识一下基本的 JS 对象概念，后续在 JS 对象中会进行详细、专门的介绍。 引用数据类型JS 中的引用类型，即 Object（对象）。 JS 是一种面向对象的编程语言，几乎所有的东西都是对象。例如内置的 Array、Date、Math、RegExp 等均属于对象，属于引用类型。 Object 类型JavaScript 中的对象（Object）类型是一组由键、值对（key:value）组成的无序集合，定义对象类型需要使用花括号 {}。语法格式如下： {name1: value1, name2: value2, name3: value3, …, nameN: valueN} 其中 name1、name2、name3、…、nameN 为对象中的键，value1、value2、value3、…、valueN 为对应的值。 需要注意的是，JS 中，对象类型的键都是字符串类型（或 Symbol 类型）的，值则可以是任意数据类型。 示例代码如下： 12345678910var person = { name: 'Bob', age: 20, tags: ['js', 'web', 'mobile'], city: 'Beijing', hasCar: true, zipcode: null};console.log(person.name); // 输出 Bobconsole.log(person['age']); // 输出 20 如上，对象的属性有两种寻址方式： 12name = person.name;name = person['name']; 其它常见的内置对象： Array 类型数组（Array）是一组按一定顺序排列的数据的集合，数组中的每个值都称为元素，而且数组中可以包含任意类型的数据。 JS 中定义数组需要使用方括号 []，数组中的每个元素使用逗号 , 进行分隔，例如： 1[1, 2, 3, 'hello', true, null] 数组中的元素可以通过索引来访问。数组中的索引从 0 开始，并依次递增，也就是说数组第一个元素的索引为 0，第二个元素的索引为 1，以此类推。如下例所示： 1234var arr = [1, 2, 3.14, 'Hello', null, true];console.log(arr[0]); // 输出索引为 0 的元素，即 1console.log(arr[5]); // 输出索引为 5 的元素，即 trueconsole.log(arr[6]); // 索引超出了范围，返回 undefined 值类型 VS 引用类型这一小节来总结一下值（原始）类型和引用类型的区别： 原始类型 &gt;&gt;&gt; 保存在栈中，占用空间固定； 保存和复制的是值本身； 使用 typeof 来检测数据的类型； 基本（原始）类型数据是值类型。 引用类型 &gt;&gt;&gt; 保存在堆中，占用空间不固定； 保存和复制的是指向对象的一个指针（引用）； 使用 instanceof 来检测数据的类型； 使用 new() 方法构造出来的对象是引用类型。 JS 数据类型转换我们知道，JS 中可以定义不同数据类型的变量，而不同数据类型的变量之间的运算需要先对变量的数据类型进行转换，之后才可以进行运算。 JS 中支持两种数据类型转换方式： 隐式类型转换； 显式（强制）类型转换。 隐式类型转换隐式类型转换，就是 JS 系统在 运算前自动对 参与运算的操作符（变量） 进行类型转换。 例如在一个加法表达式中，运算符两边的操作符数据类型分别为字符串和数字（即字符串加数字），运算时会自动进行类型转换： 1234567&gt; var str = &quot;Hello JS&quot;;&gt; var num = 666;&gt; var res = str + num;&gt; console.log(res);Hello JS666&gt; typeof(res);'string' 可以看到，将一个字符串与一个数字相加，会得到一个字符串类型的值。上面运算之前 JS 解释器会将 num 变量隐式的转换为字符串类型，之后再进行字符串加法运算。 事实上，当 JS 中的表达式包含以下运算符时，会发生隐式类型转换： 算术运算符：加（+）、减（-）、乘（*）、除（/）、取模（%）； 逻辑运算符：逻辑与（&amp;&amp;）、逻辑或（||）、逻辑非（!）； 赋值运算符：+、+=、-= 等。 关于运算符说明可见博文系列运算符章节，其运算规律如下： 字符串和数字相加 &gt;&gt;&gt; 数字会转换为字符串； 字符串和数字相减、乘、除 &gt;&gt;&gt; 字符串会转换为数字，如果字符串无法转换为数字（不满足数值规范，如 “abc”、”JavaScript”，而 123 可以），则会转换为 NaN； 数值运算：undefined 转化为数值 NaN，null 转化为数值 0。 实例代码如下： 123456789console.log(&quot;3&quot; - 2); // 输出：1console.log(&quot;3&quot; + 2); // 输出：&quot;32&quot;console.log(3 + &quot;2&quot;); // 输出：&quot;32&quot;console.log(3 * &quot;2&quot;); // 输出：6console.log(&quot;10&quot; / &quot;2&quot;); // 输出：5console.log(1 + undefined); // 输出：NaNconsole.log(1 + null); // 输出：1console.log(true + null); // 输出：1console.log(true + undefined); // 输出：NaN 强制类型转换不同于隐式类型转换，你也可以手动使用 特定的转换函数 进行 不同数据类型变量 的 转换。 数据类型转化函数列表如下： 转换函数 说明 案例 toString 转换成字符串类型 x.ToString() String 转换成字符串类型 String(x) Number 转换成数字类型 Number(x) parseInt 转换成整数类型 parseInt(x) parseFloat 转换成浮点数类型 parseFloat(x) Boolean 转换成布尔类型 Boolean(x) 下面针对具体的应用场景，来看不同转换函数的使用： 字符串类型转化这一小节来看，JS 中如何将其它基本数据类型的变量转化为字符串类型？！！ &lt;&lt;&lt; 使用 x.toString() 或 String(x) 方法，返回转化成功后的字符串。 需要注意的是，null &amp;&amp; undefined 特殊数据类型 没有 toString 方法，想要将其转化为字符串需要 借助 String() 全局方法。 [1] &gt;&gt;&gt; Number 类型转为字符串 12345678&gt; var num = 1024;&gt; var snum = num.toString(); // 使用 x.toString() 方法&gt; console.log(&quot;num to string =&quot;, snum, &quot;; type snum:&quot;, typeof(snum));num to string = 1024 ; type snum: string&gt; var numS = String(num); // 使用 String(x) 方法&gt; console.log(&quot;num to string =&quot;, numS, &quot;; type numS:&quot;, typeof(numS));num to string = 1024 ; type numS: string [2] &gt;&gt;&gt; Boolean 类型转为字符串 12345678&gt; var isT = true;&gt; var sIsT = isT.toString(); // 使用 x.toString() 方法&gt; console.log(&quot;isTrue to string =&quot;, sIsT, &quot;; type sIsT:&quot;, typeof(sIsT));isTrue to string = true ; type sIsT: string&gt; var isTStr = String(isT); // 使用 String(x) 方法&gt; console.log(&quot;isTrue to string =&quot;, isTStr, &quot;; type isTStr:&quot;, typeof(isTStr));isTrue to string = true ; type isTStr: string [3] &gt;&gt;&gt; null &amp;&amp; undefined 类型转为字符串 前面提到过，null &amp;&amp; undefined 只可以使用 String(x) 方法转化为字符串（使用 toString 方法会产生：TypeError）： 123456789&gt; var isNull = null;&gt; var sIsNull = String(isNull);&gt; console.log(&quot;isNull to string =&quot;, sIsNull, &quot;; type sIsNull:&quot;, typeof(sIsNull));isNull to string = null ; type sIsNull: string&gt; var isUndfd = undefined;&gt; var isUndfdStr = String(isUndfd);&gt; console.log(&quot;isUndfd to string =&quot;, isUndfdStr, &quot;; type isUndfdStr:&quot;, typeof(isUndfdStr));isUndfd to string = undefined ; type isUndfdStr: string 数值类型转化JS 中如何将其它基本数据类型的变量转化为数值类型？！！ &lt;&lt;&lt; 使用 Number(x) 方法，返回转化成功后的数值。 先来看较为简单的布尔类型、null 以及 undefined 转化为数值的情况： [1] &gt;&gt;&gt; Boolean &amp;&amp; null &amp;&amp; undefined 类型转为数值 前面在介绍 Boolean 类型时说过， true 在内部存储的值是 1，false 在内部存储的值是 0，转化为数值之后也一样。 而特殊类型值 null 转化为数值类型后是 0，undefined 转化为数值类型后是 NaN。 示例如下： 123456789101112131415161718192021// Boolean：&gt; var isT = true;&gt; var isTNum = Number(isT);&gt; console.log(&quot;isTrue to number =&quot;, isTNum, &quot;; type isTNum:&quot;, typeof(isTNum));isTrue to number = 1 ; type isTNum: number&gt; var isF = false;&gt; var isFNum = Number(isF);&gt; console.log(&quot;isFalse to number =&quot;, isFNum, &quot;; type isFNum:&quot;, typeof(isFNum));isFalse to number = 0 ; type isFNum: number// null &amp;&amp; undefined:&gt; var isNull = null;&gt; var isNullNum = Number(isNull);&gt; console.log(&quot;isNull to number =&quot;, isNullNum, &quot;; type isNullNum:&quot;, typeof(isNullNum));isNull to number = 0 ; type isNullNum: number&gt; var isUndfd; // 声明后未赋值变量，默认为 undefined&gt; var isUndfdNum = Number(isUndfd);&gt; console.log(&quot;isUndfd to number =&quot;, isUndfdNum, &quot;; type isUndfdNum:&quot;, typeof(isUndfdNum));isUndfd to number = NaN ; type isUndfdNum: number [2] &gt;&gt;&gt; String 类型转为数值 当要转化的数据为字符串时，存在一定的限制：只有 符合数值规范 的字符串类数据，才能被强制转换，否则返回一个 NaN。 符合数值规范 &gt;&gt;&gt; 字符串前包含除空格、+ 和 - 以外的其它非数字字符，或在字符串中包含了空格、+ 和 - 以及其它非数字字符，将返回 NaN。 其它如下： 空字符串 &quot;&quot; 会被转化为 0； 字符串中只包含 数字，将转化为十进制数字，会忽略前导的的 0 以及前后导的空格（前导有正负号时，只保留符号 -）； 字符串中包含 有效浮点数字，将转换为对应的浮点数字，会忽略前导的的 0 以及前后导的空格（前导有正负号时，只保留符号 -）； 字符串中包含 有效的十六进制（或二进制）数字，将转换为对应大小的十进制数字（八进制无法区分，以数字 0 为前缀）； 实例代码如下： 123456789101112&gt; console.log(Number(&quot; -00123 &quot;));-123&gt; console.log(Number(&quot; -000.38 &quot;));-0.38&gt; console.log(Number(&quot; 0x123 &quot;));291&gt; console.log(Number(&quot; 0b111 &quot;));7&gt; console.log(Number(&quot;123+456&quot;));NaN 事实上，数值类型的包装对象 Number 还提供了两个函数 parseInt(string, radix) &amp;&amp; parseFloat(string) 可用于将字符串转化为数值类型： 1）parseInt parseInt 方法是将字符串类型数据解析转化为整型（Int），其语法格式如下： 1parseInt(string, radix); 其中，参数 radix 表示转化基数（多少进制），默认或为零时表示以十为基（十进制），其范围为（2, 36）&lt;&lt;&lt; 不在范围内返回 NaN。 和上面 Number 不同的是 &gt;&gt;&gt; 字符串前包含除空格、+、- 和 a～f（或 A～F） 以外的其它非数字字符，将返回 NaN。如果在字符串中包含了非数字字符，则返回开头的合法数字部分。 其它如下： 空字符串 &quot;&quot; 会被转化为 NaN。 实例代码如下： 12345678910&gt; console.log(parseInt(&quot;1101&quot;,2));13&gt; console.log(parseInt(&quot;a37f&quot;,16));41855&gt; console.log(parseInt(&quot; 00123 &quot;));123&gt; console.log(parseInt(&quot;&quot;));NaN&gt; console.log(parseInt(&quot;a37f&quot;));NaN 2）parseFloat parseFloat 方法是将字符串类型数据解析转化为浮点型（Float），其语法格式如下： 1parseFloat(string); 其数值规范 &gt;&gt;&gt; 解析的过程中遇到了正号（+）、负号（-）、数字（0-9）、小数点（.）、或科学计数法中的指数（e 或 E）以外的字符，则会忽略该字符以及之后的所有字符，并返回解析到的浮点数； 解析过程中若遇到多个小数点，则会在解析到第二个小数点时停止，并返回第二个小数点之前的解析结果； 实例代码如下： 12345678910&gt; console.log(parseFloat(&quot;312.456&quot;));312.456&gt; console.log(parseFloat(&quot;312.45.6&quot;));312.45&gt; console.log(parseFloat(&quot;312..456&quot;));312&gt; console.log(parseFloat(&quot; -3.12 &quot;));-3.12&gt; console.log(parseFloat(&quot;.12&quot;));0.12 [3] &gt;&gt;&gt; 其它特殊类型（Date、Array）转为数值 如果待转化数据为 Date 对象，将转换为从 1970 年 1 月 1 日到执行转换时的毫秒数； 如果待转化数据为函数、包含两个元素以上的数组对象以及除 Date 对象以外的其他对象，将转换为 NaN； 实例代码如下： 12345678&gt; var d = new Date();&gt; console.log(Number(d));1673601667653&gt; console.log(Number([123]));123&gt; console.log(Number([123, 456]));NaN 布尔类型转化JS 中如何将其它基本数据类型的变量转化为布尔类型？！！ &lt;&lt;&lt; 使用 Boolean(x) 方法，返回转化成功后的布尔值。 [1] &gt;&gt;&gt; Number 类型转为布尔 JS 中，非 0 数字转成布尔之后，都返回 true，否则都返回 false。实例如下： 12345678910&gt; console.log(Boolean(1));true&gt; console.log(Boolean(0));false&gt; console.log(Boolean(2));true&gt; console.log(Boolean(2.3));true&gt; console.log(Boolean(NaN));false [2] &gt;&gt;&gt; String 类型转为布尔 JS 中，非空 &quot;&quot; 字符串转成布尔之后，都返回 true，否则都返回 false。实例如下： 123456&gt; console.log(Boolean(&quot;&quot;));false&gt; console.log(Boolean(&quot;test&quot;));true&gt; console.log(Boolean(&quot; hello &quot;));true [3] &gt;&gt;&gt; null &amp;&amp; undefined 类型转为布尔 特殊类型值 null 转化为布尔类型后是 false，undefined 转化为数值类型后也是 false。 实例代码如下： 123456789&gt; var isNull = null;&gt; var isNullBL = Boolean(isNull);&gt; console.log(&quot;isNull to boolean =&quot;, isNullBL, &quot;; type isNullBL:&quot;, typeof(isNullBL));isNull to boolean = false ; type isNullBL: boolean&gt; var isUndfd = undefined;&gt; var isUndfdBL = Boolean(isUndfd);&gt; console.log(&quot;isUndfd to boolean =&quot;, isUndfdBL, &quot;; type isUndfdBL:&quot;, typeof(isUndfdBL));isUndfd to boolean = false ; type isUndfdBL: boolean javascript:void(0)页面代码中，你经常会见到 javascript:void(0) 这样的语句，那么 JavaScript 中的 javascript:void(0) 到底代表的是什么意思呢？ 而 javascript:void(0) 中最关键的就是 void 关键字： void 关键字void 是 JS 中非常重要的关键字，其表示 &gt;&gt;&gt; 运行一个表达式或定义一个函数，但是不返回任何值。 [1] &gt;&gt;&gt; 定义无返回值的函数 JS 中定义无返回值函数的语法格式如下： 123void func();或void(func()); 关于 JS 中函数部分的用法，可以参见后续博文系列中说明，这里有无返回值函数定义的概念即可。 [2] &gt;&gt;&gt; 运行一个无返回值的表达式 以下实例中变量 a 将返回 undefined: 123456789101112131415161718&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;JS 演示&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;input type=&quot;button&quot; value=&quot;ClickMe&quot; onclick=&quot;getValue()&quot;&gt; &lt;script&gt; function getValue(){ var a, b, c; a = void (b = 2, c = 3); document.write(&quot;a = &quot; + a + &quot; b = &quot; + b + &quot; c = &quot; + c) } &lt;/script&gt; &lt;/body&gt;&lt;/html&gt; 故，可以知道 void(0) 计算为 0，不返回任何值，不执行任何动作。 void(0) 修饰超链接JS 中使用 void(0) 修饰超链接，表明点击超链接不执行任何动作。如下： 12345678910&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;JS 演示&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;a href=&quot;javascript:void(0)&quot;&gt;单击此处什么也不会发生&lt;/a&gt; &lt;/body&gt;&lt;/html&gt; 如果你想在用户点击超链接时执行一些动作，你可以通过在 void() 中定义表达式实现： 1234567891011&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;title&gt;JS 演示&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;a href=&quot;javascript:void(alert('alert dialog'))&quot;&gt;alert dialog&lt;/a&gt; &lt;a href=&quot;javascript:void(console.log('console log info'))&quot;&gt;console log&lt;/a&gt; &lt;/body&gt;&lt;/html&gt; 上面的 HTML 页面中，当你点击第一个超链接（alert dialog）时，浏览器会弹出一个警示框；而当你点击第二个超链接（console log）时，浏览器控制台会输出 console log info。 herf=”” &amp;&amp; herf=”#”如果 a 标签中 herf 属性为 herf=&quot;&quot; 时，点击超链接会刷新页面。 而 herf=&quot;javascript: void(0)&quot; 仅仅代表一个无聊的，点击啥也不发生的链接。 herf 属性中的 # 包含一个位置信息（锚），默认的是锚是 #top，也就是网页的顶端。对于很长的页面，可以使用 herf=&quot;#&quot; 来定义页面书签实现快速跳转（# + id）。 JS 严格模式前面在介绍 ECMAScript 版本时提到过，ES5 中 JavaScript 添加了 “严格模式”。 所谓的 “严格模式”，是具有严格限制性的 JavaScript 风格，从而使 JS 代码显式地脱离 Sloppy 模式（马虎模式/稀松模式/懒散模式）。 简单理解为，严格模式下的 JS 代码具有严格的语法规范。 在 JavaScript 中，如果你想要开启严格模式（Strict），只需要使用如下语句（JS 旧版本中会被忽略）： 1&quot;use strict&quot;; 严格模式限制严格模式下，具有如下限制： 不允许使用未声明的 变量； 不允许删除 变量 或 对象； 不允许删除 函数； 不允许 变量重名； 不允许使用八进制； 不允许使用 转义字符； 不允许对只读属性赋值； 不允许对一个使用 getter 方法读取的属性进行赋值； 不允许删除一个不允许删除的属性； 变量名不能使用 “eval” 字符串； 变量名不能使用 “arguments” 字符串； 由于一些安全原因，在作用域 eval() 创建的变量不能被调用； 禁止 this 关键字指向全局对象。 为什么使用严格模式？ 消除 JavaScript 语法的一些不合理、不严谨之处、不安全之处，减少一些怪异行为以及保证代码运行的安全； 严格模式修复了一些导致 JavaScript 引擎难以执行优化的缺陷（提高编译器效率，增加运行速度）：有时候，相同的代码，严格模式可以比非严格模式下运行得更快； 禁用了在 ECMAScript 的未来版本中可能会定义的一些语法，为未来新版本的 JavaScript 做好铺垫； “严格模式” 体现了 JavaScript 更合理、更安全、更严谨的发展方向，包括 IE 10 在内的主流浏览器，都已经支持它，许多大项目已经开始全面拥抱它；","link":"/2019/02/02/js-jiao-cheng-zhi-bian-liang-he-shu-ju-lei-xing/"},{"title":"JS 教程之 JavaScript 运算符以及流程控制","text":"前面我们已经解读了 JS 中变量以及基本数据类型等基本概念，本文接着来看 JavaScript 中的运算符以及程序流程控制语句，这是一个 JavaScript 程序实现的必要部分。 JS 中的运算符开始后续的流程控制学习之前，我们需要系统的认识一下 JavaScript 中的运算符（也称为操作符）。 我们先来看一个简单的例子： 12&gt; 4 + 59 其中，4，5 被称为 操作数，+ 被称之为 运算符（操作符），它们共同构成一个 表达式。 可以看到，JS 中的表达式类似于数学上的数学表达式，由操作数以及操作符（运算符）组合而成。 [1] &gt;&gt;&gt; 特殊概念 –&gt; 优先级 &amp; 结合性 JS 中的运算符，等价于数学中的运算符，也是有优先级，和结合性的概念的。 这也就是说 &gt;&gt;&gt; 当一个表达式中出现多种操作符时，执行的先后顺序不仅要遵守操作符优先级规定，还要受操作符结合性的约束，以便确定是自左向右进行运算？还是自右向左进行运算？ –&gt; 操作数 操作数是指 &gt;&gt;&gt; 运算符进行运算时，所操作（依赖）的数据。 [2] &gt;&gt;&gt;运算符分类 JavaScript 语言中最基本的运算符可归纳为以下 5 大类: 赋值运算符 算术运算符 关系（比较）运算符 逻辑运算符 位运算符 并且，根据【操作数的数量】又衍生出了：单目运算符、双目运算符、三目运算符 的概念（看到这样的表述不要疑惑）。 JS 运算符详解这一小节将详细解读上面提到的 5 种 JS 基本运算符用法： 赋值运算符前面的变量章节部分中提到过 &gt;&gt;&gt; 变量声明时（后），可以使用赋值运算符为变量进行赋值。 赋值运算符就是指，为 变量或常量 指定数值（赋值） 的符号。使用很简单，其语法格式如下所示： 1变量名称 = 值（或表达式） 它是一个双目运算符。其左边的操作数必须是变量，不能是常量值或表达式；右侧可以为字面值，或表达式。 需要注意的是 &gt;&gt;&gt; 不要将赋值运算符与相等运算符 “==” 混淆。 示例代码如下： 12&gt; var i = 1;&gt; var j = i + 2; 事实上，JS 中还有一种 扩展赋值运算符，它是由其它基本运算符和赋值运算符结合而成。例如算术赋值运算符（+= &amp;&amp; -= &amp;&amp; *= 等），以及位赋值运算符（&lt;&lt;= &amp;&amp; &gt;&gt;= 等）。通常情况下，只要能使用扩展后的赋值运算符，都推荐使用这种赋值运算符。 关于扩展赋值运算符的使用，将在其结合运算符中进行说明。 算术运算符算术运算符的功能是 &gt;&gt;&gt; 对变量与/或字面量（变量与变量、变量与字面量、字面量与字面量）进行算术运算。 JS 中支持如下的算术运算： 运算符 说明 范例 结果 + 正号 +3 3 - 负号 -4 -4 + 加法运算 5 + 5 10 - 减法运算 10 - 5 5 * 乘法运算 5 * 2 10 / 除法运算 10 / 3 3.333 % 取模（余）运算 10 % 3 1 ++ 自增运算 a = 2; a++ 3 -- 自减运算 a = 10; a-- 9 这里为了方便记忆，特将算术运算分为三类： 基本算术运算符：+（加） -（减） *（乘） /（除）％（取模/取余）； 算术赋值运算符：+=（加法赋值）-=（减法赋值）*=（乘法赋值）/=（除法赋值）%=（取模赋值）； 算术单目运算符：+（正） -（负） ++（自增） --（自减）。 [1] &gt;&gt;&gt; 基本算术运算符 JS 算术运算符中，最基本的算术运算就是： 1+（加） -（减） *（乘） /（除）％（取模/取余） 上述算术运算，和我们平常接触的数学运算具有相同的含义。 加法运算】示例代码如下 &gt;&gt;&gt; 12345&gt; var aNum = 21;&gt; var bNum = 10;&gt; cNum = aNum + bNum;&gt; console.log(&quot;The Value of cNum:&quot;, cNum);The Value of cNum: 31 当 + 用于数值（Number）类型时表示加法运算；但是当 + 用于字符串类型时表示连接运算（连接运算符），请参照 JavaScript 中的原始 String 类型中的说明。 + 除了用作加法运算符之外，还可以作为正数（正号）的标志（例如：+2），一般缺省。 减法运算】示例代码如下 &gt;&gt;&gt; 1234&gt; var aNum = 21, bNum = 10;&gt; var cNum = aNum - bNum;&gt; console.log(&quot;The Value of cNum:&quot;, cNum);The Value of cNum: 11 - 除了可以用作减法运算之外，还可以用作求负（负号）运算（正数变负数，负数变正数），即取相反数。 乘法运算】示例代码如下 &gt;&gt;&gt; 1234&gt; var aNum = 21, bNum = 10;&gt; var cNum = aNum * bNum;&gt; console.log(&quot;The Value of cNum:&quot;, cNum);The Value of cNum: 210 需要注意的是，JS 中 * 仅用于数值相乘；而有些编程语言中，* 还用于进行序列（字符串）的重复运算，用于将某个序列复制几份并连接起来。 除法运算】示例代码如下 &gt;&gt;&gt; 1234&gt; var aNum = 21, bNum = 10;&gt; var cNum = aNum / bNum;&gt; &gt; console.log(&quot;The Value of cNum:&quot;, cNum);The Value of cNum: 2.1 需要注意的是，JS 进行除法运算时，除数为 0 时不会产生错误（ZeroDivisionError），而是输出 Infinity（正无穷大）。 取模（取余）运算】示例代码如下 &gt;&gt;&gt; 1234&gt; var aNum = 21, bNum = 10;&gt; var cNum = aNum % bNum;&gt; &gt; console.log(&quot;The Value of cNum:&quot;, cNum);The Value of cNum: 1 [2] &gt;&gt;&gt; 算术赋值运算符 算术赋值运算符只是一种（赋值和算术运算符结合的）简写形式，一般用于变量自身的变化。 上述的每一种基本算术运算符，都有一种对应的和赋值符结合的简写形式： 运 算 符 名 称 例 子 等价于 += 加法赋值 a += b + 3 a = a + b + 3 -= 减法赋值 a -= b a = a - b *= 乘法赋值 a *= b a = a*b /= 除法赋值 a /= b a = a/b [3] &gt;&gt;&gt; 算术单目运算符 算术操作符中，单目运算符有 4 个，分别表示：+（正） -（负） ++（自增） --（自减）。 其中，+（正）&amp;&amp; -（负）较为简单，就是数学上的含义，不做过多说明。下面重点来看自增、自减的使用。 自增 &amp;&amp; 自减 &gt;&gt;&gt; 使用原则： 自增/自减只能作用于变量，不允许对字面量、表达式等进行操作； 自增/自减运算作用于变量自身加/减 1，放在操作数的 前面或后面 都是允许的。 3.1 –&gt; 自增 &amp; 自减 i++（自增）i--（自减）：在变量 i 原来的基础上，增加 1 或者减少 1。 1234567891011// 自增:&gt; var i = 4;&gt; i++;&gt; console.log(&quot;The Value of i:&quot;, i);The Value of i: 5// 自减:&gt; var j = 4;&gt; j--;&gt; console.log(&quot;The Value of j:&quot;, j);The Value of j: 3 3.2 –&gt; 前后置的区别 以 ++（自增）为例，-- 同理。 123456&gt; var i = 4;&gt; i++; // 先取值，再运算4&gt; ++i; // 先运算，再取值6 具体示例代码如下： 1234567891011&gt; var i = 5;&gt; console.log(i++); // 输出 55&gt; console.log(i); // 输出 66&gt; var j = 5;&gt; console.log(++j); // 输出 66&gt; console.log(j); // 输出 66 思考一下：下面的 j 是 多少？ 12&gt; var i = 1;&gt; var j = ++i + i++ + ++i + ++i + i++; // 2 + 2(3) + 4 + 5 + 5 = 18 关系运算符关系操作符（relational operators）也可以称为：“比较操作符”，用来比较判断两个变量或字面量的大小关系。 关系运算的结果都是 Boolean 型的。当操作符对应的大小关系成立时，运算结果是 true，否则是 false。 JS 中支持的比较操作符列表如下： 运算符 说明 范例 结果 == 等于，如果 == 两边的值相等，则返回 True；否则返回 False 4 == 4 true != 不相等 （等价于数学中的 ≠），如果 != 两边的值不相等，则返回 True；否则返回 False 4 != “4” false === 等值等型，如果 === 两边的操作数的值以及数据类型都相同，则返回 True；有一个不同则返回 False 4 == “4” false !== 不等值或不等型，如果 !== 两边的操作数的值以及数据类型至少有一个不同，则返回 True；否则返回 False 4 !== “4” true &lt; 小于，如果 &lt; 前面的值小于后面的值，则返回 True，否则返回 False 4 &lt; 3 false &gt; 大于，如果 &gt; 前面的值大于后面的值，则返回 True，否则返回 False 4 &gt; 3 true &lt;= 小于等于（等价于数学中的 ≤），如果 &lt;= 前面的值小于或者等于后面的值，则返回 True，否则返回 False 4 &lt;= 3 false &gt;= 大于等于（等价于数学中的 ≥），如果 &gt;= 前面的值大于或者等于后面的值，则返回 True，否则返回 False 4 &gt;= 3 true 这里为了方便记忆，特将关系运算分为三类： 大小关系检测：&lt;（小于） &lt;=（小于等于） &gt;（大于） &gt;=（大于等于）； 等值关系检测：==（等于） !=（不相等）； 相同关系检测：===（等值等型） !==（不等值或不等型）。 [1] &gt;&gt;&gt; 大小关系检测 大小关系检测时，操作数的比较规则： 数值与数值比较 &gt;&gt;&gt; 直接比较它们的代数值； 仅一个操作数是数值 &gt;&gt;&gt; 将另一个操作数转化为数值后，比较它们的代数值； 字符串与字符串比较 &gt;&gt;&gt; 逐字符比较它们的 Unicode 数值； 字符串与非数值比较 &gt;&gt;&gt; 将非数值操作数转化为字符串后，进行比较； 只要与 NaN 比较 &gt;&gt;&gt; 均返回 false； 操作数既非数值也非字符串 &gt;&gt;&gt; 转化为数值或字符串后进行比较； 操作数无法被转化为数值或字符串 &gt;&gt;&gt; 均返回 false。 关于操作数的类型转化，你可以参见博文系列中的 JS 中数据类型转换章节。 [2] &gt;&gt;&gt; 等值关系检测 等值关系检测时，操作数的比较规则： 数值与/或字符串比较规则同上； null == undefined（两者相等），比较前不进行任何转换（相等比较中，null &amp;&amp; undefined 允许被转换为其他类型的值。）； NaN 与任何值都不相等，包括其本身（即：NaN != NaN）； 操作数都是对象时，则比较引用地址，引用地址相同，则相等；否则不等。 特殊操作数相等比较实例代码如下： 123456789101112131415161718console.log(&quot;1&quot; == 1); // 返回 trueconsole.log(true == 1); // 返回 trueconsole.log(false == 0); // 返回 trueconsole.log(null == 0); // 返回 falseconsole.log(undefined == 0); // 返回 falseconsole.log(undefined == null); // 返回 trueconsole.log(NaN == &quot;NaN&quot;); // 返回 falseconsole.log(NaN == 0); // 返回 falseconsole.log(NaN == NaN); // 返回 falseconsole.log(NaN != NaN); // 返回 truevar aArray = [1, 2];var bArray = [1, 2];console.log(aArray == bArray); // 引用地址不同，返回 falsevar cArray = aArray;console.log(aArray == cArray); // 引用地址相同，返回 true [3] &gt;&gt;&gt; 相同关系检测 相同关系检测时，操作数的比较规则： 值类型间比较 &gt;&gt;&gt; 数据类型相同且数值也相等，才相同； 值类型与引用类型比较 &gt;&gt;&gt; 肯定不相同； 引用类型间比较 &gt;&gt;&gt; 比较引用地址，引用地址相同，则相同。 特殊操作数相等比较实例代码如下： 123456789console.log(null === undefined); // 返回 falseconsole.log(0 === &quot;0&quot;); // 返回 falseconsole.log(0 === false); // 返回 falsevar a = {};var b = {};console.log(a === b); // 返回 falsevar c = a;console.log(a === c); // 返回 true 逻辑运算符逻辑运算又称为 布尔代数运算，就是布尔值的运算。JS 中支持的逻辑运算符如下： a &amp;&amp; b：等价于数学中的 “且”，a 和 b 两个表达式都真为真，有假即假； a || b：等价于数学中的 “或”，a 和 b 两个表达式有真即真，都假为假； !a：等价于数学中的 “非”（相当于对 a 取反），如果 a 为真，那么 !a 的结果为假；如果 a 为假，那么 !a 的结果为真。 [1] &gt;&gt;&gt; 短路逻辑特性 短路逻辑概念的引入，是为了优化逻辑表达式的计算方式，从而提高程序效率（实际编程中，应优先考虑使用短路逻辑）。 于是，编程语言设计中对逻辑运算符又进一步细分： “且/与” &gt;&gt;&gt; 逻辑与（&amp;） 和 短路与（&amp;&amp;）； “或” &gt;&gt;&gt; 逻辑或（|） 和 短路或（||）。 对于 短路与（&amp;&amp;）&gt;&gt;&gt; 若第一个表达式是 false，后续的就不进行运算了（有假即假）；短路或（||）&gt;&gt;&gt; 若第一个表达式是 true，后续的就不进行运算了（有真即真）。而对于逻辑与（&amp;）和 逻辑或（|）所有表达式均需要计算（效率较低）。 需要注意的是，JS 中的逻辑运算符就是优化计算的短路与（&amp;&amp;）和 短路或（||），不支持另外单独的的逻辑与、或运算符。 [2] &gt;&gt;&gt; 操作关系表达式 由于关系表达式的返回结果都是 Boolean 型的，故： 一般情况下，逻辑运算符会把多个 关系表达式（返回布尔值） 组合成一个逻辑表达式，以判断整个逻辑表达式是否成立，返回的结果是 true 或 false。 1234&gt; var ageNum = 23;&gt; var heightNum = 178;&gt; console.log(&quot;是否符合报考飞行员的条件:&quot;, ageNum &gt;= 18 &amp;&amp; ageNum &lt;= 30 &amp;&amp; heightNum &gt;= 170 &amp;&amp; heightNum &lt;= 185);是否符合报考飞行员的条件: true [3] &gt;&gt;&gt; 更一般的表达式 前面在介绍原始 Boolean 类型转换时，提到过 布尔值（true &amp;&amp; false）可以直接参与逻辑表达式运算。且： 123456789101112131415161718192021222324// 逻辑表达式中以下值会被认为是 False：// 为零的数：0 or -0 or 0.0 or NaN；// 空字符串：''，&quot;&quot;；// 空对象：null；// 未定义：undefined；// 其他的值（非空字符串、非零数值、非空对象）都认为是 True（注意：[] &amp;&amp; {}）。// 你可以使用 `Boolean(obj)` 对 JS 中的所有对象进行真假值的测试：包括字符串、数值、null、undefined、obj、表达式等。&gt; Boolean(null)false&gt; Boolean(undefined);false&gt; Boolean([]);true&gt; Boolean({});true&gt; Boolean(true &amp;&amp; &quot;test&quot;);true&gt; Boolean(true &amp;&amp; NaN);false&gt; Boolean(false || 1.25);true&gt; Boolean(false || &quot;&quot;);false 也就是说，逻辑运算符可以用来操作任何类型的表达式，不管表达式返回是不是 Boolean 类型的。 [4] &gt;&gt;&gt; 逻辑运算本质 并且，通过逻辑运算的结果也不一定是 Boolean 类型，它也可以是任意类型。 对于 短路与（&amp;&amp;），两边的值都为假时最终结果才为假，有假即假。所以 JS 按照下面的规则执行短路与运算： 如果左边表达式的值可转换为假（false），那么就不用计算右边表达式的值了（不管右边表达式的值是什么，都不会影响最终结果，为假），此时会返回左边表达式的值； 如果左边表达式的值可转换为真（true），那么最终值是不能确定的，短路与（&amp;&amp;）会继续计算右边表达式的值，并返回右边表达式的值。 对于 短路或（||），情况是类似的，两边的值都为假时最终结果才为假，有真即真。所以 JS 按照下面的规则执行短路与运算： 如果左边表达式的值可转换为真（true），那么就不用计算右边表达式的值了（不管右边表达式的值是什么，都不会影响最终结果，为真），此时会返回左边表达式的值； 如果左边表达式的值可转换为假（false），那么最终值是不能确定的，短路或（||）会继续计算右边表达式的值，并返回右边表达式的值。 使用代码验证上面的结论： 123456789101112131415161718// 逻辑表达式中以下值会被认为是 False：// 为零的数：0 or -0 or 0.0 or NaN；// 空字符串：''，&quot;&quot;；// 空对象：null；// 未定义：undefined；// 其他的值（非空字符串、非零数值、非空对象）都认为是 True（注意：Infinity &amp;&amp; [] &amp;&amp; {}）。// 你可以使用 `Boolean(obj)` 对 JS 中的所有对象进行真假值的测试：包括字符串、数值、null、undefined、obj、表达式等。str = &quot;hello JS&quot;;console.log(&quot;----False and xxx-----&quot;);console.log(false &amp;&amp; str);console.log(&quot;----True and xxx-----&quot;);console.log(true &amp;&amp; str);console.log(&quot;----False or xxx-----&quot;);console.log(false || str);console.log(&quot;----True or xxx-----&quot;);console.log(true || str); 运行看一下： 12345678----False and xxx-----false----True and xxx-----hello JS----False or xxx-----hello JS----True or xxx-----true [5] &gt;&gt;&gt; 取反（!） 真变为假，假变为真。示例代码如下： 12345&gt; var isTrue = true;&gt; console.log(isTrue);true&gt; console.log(!isTrue);false 位运算符编程语言中的位运算（bitwise operators），表示 按 数值 在内存中的每个二进制位（bit）进行计算，也称为 按位运算。 也就是说，JS 中可以直接对 数值类型数据 的二进制位进行操作，其操作数和运算结果都是数值型值。 JS 中支持的位运算操作符列表如下： 运算符 描述 示例 &amp; 按位与：参与运算的两个数值，如果对应的二进制位都为 1，则该二进制位的结果为 1；否则为 0 5 &amp; 1 等同于 0101 &amp; 0001，结果为 0001，十进制结果为 1 | 按位或：参与运算的两个数值，如果对应的二进制位至少有一个为 1，则该二进制位的结果为 1；否则为 0 5 | 1 等同于 0101 | 0001，结果为 0101，十进制结果为 5 ^ 按位异或：参与运算的两个数值，如果对应的二进制位互异时，则该二进制位的结果为 1；相同结果为 0 5 ^ 1 等同于 0101 ^ 0001，结果为 0100，十进制结果为 4 ~ 按位非：对某个数值的所有二进制位按位取反，即 1 转换为 0；0 转换为 1 ~5 等同于 ~0101，结果为 1010，十进制结果为 -6 &lt;&lt; 按位左移：把 “&lt;&lt;” 左边的操作数各二进位全部左移若干位，”&lt;&lt;” 右边的数用来指定移动的位数；高位丢弃，低位补 0 5 &lt;&lt; 1 等同于 0101 &lt;&lt; 1，结果为 1010，十进制结果为 10 &gt;&gt; 按位右移（有符号右移）：把 “&gt;&gt;” 左边的操作数的各二进位全部右移若干位，”&gt;&gt;” 右边的数指定移动的位数；拷贝最左侧的符号位来填充左侧 5 &gt;&gt; 1 等同于 0101 &gt;&gt; 1，结果为 0010，十进制结果为 2 &gt;&gt;&gt; 按位右移零（无符号右移）：把 “&gt;&gt;&gt;” 左边的操作数的各二进位全部右移若干位，”&gt;&gt;&gt;” 右边的数指定移动的位数；最左侧补 0 5 &gt;&gt;&gt; 1 等同于 0101 &gt;&gt;&gt; 1，结果为 0010，十进制结果为 2 这里为了方便记忆，特将位运算分为三类： 位逻辑运算符：&amp;（按位与）、|（按位或）、~（按位非）和 ^（按位异或） 位移运算符：&lt;&lt;（按位左移）、&gt;&gt;（有符号按位右移）、&gt;&gt;&gt;（无符号按位右移） 位赋值运算符：&amp;=（按位与赋值）、|=（按位或赋值）、^=（按位异或赋值）、&lt;&lt;=（按位左移赋值）、&gt;&gt;=（有符号按位右移赋值）以及 &gt;&gt;&gt;=（无符号按位右移赋值）。 [1] &gt;&gt;&gt; 位逻辑运算符 三目（条件）运算符 其它运算符","link":"/2019/02/05/js-jiao-cheng-zhi-yun-suan-fu-yi-ji-liu-cheng-kong-zhi/"},{"title":"一文详解全平台 TensorFlow 深度学习框架在线搭建 (CPU&amp;GPU 支持)","text":"工欲善其事，必先利其器。在开始深度学习课程之前，首要的是需要选择一台性能合适的机器来部署深度学习环境以进行学习试验。关于 “选择性能合适的机器”，一般意味着 “好的CPU”，“大内存”，“大硬盘”，“GPU支持”。当然考虑到经济问题以及以学习为优先，利用我们手头闲置的配置最好的机器就可以开始配置深度学习环境了（性能低）。 本文我们将详细介绍如何基于 Windows/ Centos6(7) / Ubuntu 单机或集群服务器搭建 TensorFlow [ CPU/GPU Support ] 深度学习单机或集群分布式学习开发环境。事实上，TensorFlow 集群分布式环境搭建就是多台单机服务器的重复安装过程，可以通过自动化部署完成。 最后，我们将在搭建好的深度学习环境中，运行和测试入门级的 TensorFlow 样例程序以验证安装是否成功。 更多 TensorFlow 框架搭建相关内容，请关注博主相关博文系列 ↓↓↓↓↓ 之一 &gt;&gt;&gt;&gt; 一文详解全平台 TensorFlow 深度学习框架在线搭建 (CPU&amp;GPU 支持) 之二 &gt;&gt;&gt;&gt; TensorFlow GPU 支持: Ubuntu16.04 + Nvidia GTX + CUDA + CUDNN Before Reading在安装 TensorFlow 之前，我们需要知道的是: TensorFlow 属于很高层的应用！！！高层应用的一个比较大的麻烦就是需要依赖的底层相关很多，如果底层依赖没有弄好的话，高层应用是没法玩转的。那么 解决 Tensorflow 应用和其相关底层的依赖关系 对于开发者的安装而言尤为重要。 TensorFlow 网络教程中，支持五种常用的 TensorFlow 安装方式，分别为：'原生' Pip、Docker、 Virtualenv、 Anaconda 或 源码编译 来安装 TensorFlow。后文会对上述五种方式分别进行介绍，以方便我们根据具体的软硬件、以及应用需求采用不同的安装方式。 初学者一般 推荐使用 Anaconda 进行 TensorFlow 学习环境的安装，更多关于 Anaconda 的介绍，建议参考文档 &gt;&gt;&gt; 【一文了解数据科学神器 Anaconda】。 Installation Options这里，首先给出一般情况下的 TensorFlow 开发环境搭建场景，来帮助我们明确安装选择： | &gt;&gt;&gt;&gt; 1 搭建 TensorFlow [CPU Support] 环境 ↓↓↓↓↓↓↓ 搭建基于 CPU 运算的 TensorFlow 深度学习环境是最简单、最常见的，运算性能较低。 | &gt;&gt;&gt;&gt; 2 搭建 TensorFlow [GPU Support] 环境 ↓↓↓↓↓↓↓ 搭建基于 GPU 运算的 TensorFlow 深度学习环境。建议先明确当前服务器所搭载独立显卡的相关信息（GPU 型号、计算性能等），然后参考后文附录【TensorFlow &amp;&amp; NVIDIA 版本信息对照表】，选择安装相互兼容的显卡驱动（CUDA）、显卡加速包（CUDNN）以及 Tensorflow 版本。 | &gt;&gt;&gt;&gt; 3 搭建 TensorFlow 集群（既有集群/新建集群）分布式开发环境 ↓↓↓↓↓↓↓ 在新建的服务器集群上搭建 TensorFlow 深度学习环境可以不断尝试安装，不用担心把服务器系统搞崩。但对于在既有集群搭建 TensorFlow 环境（生产/半生产环境），建议先从集群子节点开始一台台安装 TensorFlow，将安装风险降到最低。当然，如果还是担心有风险，可以先通过虚拟机重构伪集群开发环境测试安装过程。熟悉安装过程后，再开始实际安装，尽量将风险降到最低。 推荐使用 Docker 的安装方式，安全、无风险的批量部署（学习成本增加）~~~ 预安装环境准备关于下面给出的 3 点安装环境要求不用深究，后文你会看到相关详细解释： Linux 系统需要包含 较高版本的 GNU Glibc 库（Centos7 以上）； 源码安装要求 Java_JDK 1.8 以上版本； Python 2.7 或 Python 3.3 以上版本； 为了支持分布式运算，TensorFlow 要求版本大于 0.8，V0.8 之前版本不支持分布式。 服务器操作系统选择关于搭建 TensorFlow 深度学习开发环境的服务器（Server）的操作系统的选择，选择一个合适的 OS 可以帮我们减少很多的麻烦。 👇👇👇 Centos/Ubuntu Server Select 👇👇👇 | &gt;&gt;&gt;&gt; 1. Centos Server For Building TensorFlow ↓↓↓↓↓↓↓ 如果选择 Centos Server，那么我们的 Centos 版本最好选择 Centos7。Centos6 因为版本较低，其操作系统内置的库无法很好兼容 TensorFlow。虽可以解决，但会为安装带来更多的麻烦（可以通过升级一些运行时库得以解决）。 当然对于操作系统为 Centos6 的既有服务器，且不可以更换操作系统的安装需求，后文会对解决方法做详细说明。 | &gt;&gt;&gt;&gt; 2. Ubuntu Server For Building TensorFlow ↓↓↓↓↓↓↓ 如果选择 Ubuntu Server（墙裂推荐），那么我们的 Ubuntu 版本最好是 Ubuntu 14.04/16.04/18.04。这里只是因为使用 Ubuntu14.04/16.04/18.04 的人较多，可以更好的帮我们解决安装以及使用 TensorFlow 过程中遇到的问题。 对于初学 TensorFlow 深度学习框架，仅仅想做做简单学习测试，强烈建议选择 Ubuntu！！！ 👇👇👇 Windows Platform 👇👇👇 一般情况下，Windows 平台下搭建 TensorFlow 深度学习框架仅作为简单学习使用，无法更高效利用软硬件资源。故，我们更应该关注基于 Liunx Server 搭建学习、开发环境。 安装场景说明实际搭建过程中，根据现有资源以及实际安装需求，你可能有两种选择: 安装以及配置全新的 Linux Server，部署 TensorFlow； 基于既有服务器环境，部署 Tensorflow 开发框架。 这一部分，我们分别介绍上述两种需求下 Linux Server 的注意事项 👇👇👇 1 &gt;&gt;&gt; 全新 Linux Server 基于全新 Linux Server 部署 Tensorflow 学习开发框架预准备（推荐 Ubuntu）： [1.1] &gt;&gt;&gt; Ubuntu Server 快速安装 ↓↓↓↓↓↓↓ 工具准备 ↓↓↓↓↓↓↓ 1234% I. Windows 操作系统电脑一台；% II. 官网或其它国内镜像站下载 Ubuntu IOS 镜像文件；% III. Windows 安装两款软件：PE 系统工具 &amp;&amp; UltraISO Linux U 盘启动盘制作工具；具体使用方法百度，不做赘述。% IV. U 盘 2 个：一个安装 PE 系统 U 盘启动盘，可以用来格式化 Server 机原有的磁盘分区，并设置 MBR（可防止 Linux 分区时磁盘柱头自动产生 1M 大小的空闲分区，无法引导）；另一个用来制作 Linux 系统 U 盘启动盘； ↓↓↓↓↓↓↓ Setup ↓↓↓↓↓↓↓ 使用上面制作好的 UltraISO Linux U 盘启动盘安装系统：安装方法见网络教程，网上有较为详细的安装教程，这里不做详细介绍。特别提到的是：安装系统时会进行系统分区。推荐手动分区，详细分区教程参考个人磁盘空间情况以及网络分区教程。 [1.2] &gt;&gt;&gt; Ubuntu Server 快速配置 关于 Ubuntu Server 的初始配置可参考： Ubuntu 基础配置参见 &gt;&gt;&gt;&gt; Ubuntu Server 快速配置指南。 2 &gt;&gt;&gt; 既有 Linux Server 对于在既有服务器搭建 TensorFlow 深度学习环境，需要明确当前服务器操作系统信息（Centos/Ubuntu）以及已部署环境信息： [2.1] &gt;&gt;&gt; 察看 Linux 操作系统版本信息 12345678$ lsb_release -a% 运行输出：LSB Version: :base-4.0-amd64:base-4.0-noarch:core-4.0-amd64:core-4.0-noarch:graphics-4.0-amd64:graphics-4.0-noarch:printing-4.0-amd64:printing-4.0-noarchDistributor ID: CentOSDescription: CentOS release 6.9 (Final)Release: 6.9Codename: Final [2.2] &gt;&gt;&gt; 察看 Linux 系统内核版本（包括 GCC 版本信息） 1234$ cat /proc/version% 运行输出：Linux version 2.6.32-696.10.1.el6.x86_64 (mockbuild@c1bl.rdu2.centos.org) (gcc version 4.4.7 20120313 (Red Hat 4.4.7-18) (GCC) ) #1 SMP Tue Aug 22 18:51:35 UTC 2017 需要注意的是 &gt;&gt;&gt;&gt; Centos6（7） 服务器环境下还可能需要如下准备（【Centos6/7 环境准备】&gt;&gt;&gt;&gt; 针对既有服务器），Ubuntu14.04（16.04/18.04…）服务器环境可以直接跳过下一小节内容（推荐阅读）。 Centos6/7 环境准备Centos 预安装环境准备（Ubuntu14.04 以上不需要）： 1 &gt;&gt;&gt; Python 版本问题 安装 TensorFlow 环境要求我们，Python 版本必须选择 2.7 以 3.3 以上版本。而 Centos6/7 中原生 Python 版本可能很老，所以需要我们在不影响到系统使用的前提下升级 Python。 12# 察看当前 Centos 中系统 Python 版本：$ python -V 例如我的服务器系统版本是 Centos6.9，通过查阅版本号发现：Centos 原生 Python 版本是 2.4.3，版本很旧了，升级系统 Python 版本是必须选择的。 👇👇👇 Python3.X &amp;&amp; Python2.X：Select 👇👇👇 Python3.X 和 Python2.X 的选择也很重要。我们知道 3.X 和 2.X 有很多不同，基于 Python3.X 和 Python2.X 的 Python 脚本不能很好互相兼容。这里我们推荐使用 Python3.X （原因不解释…）。于是，我们的一般想法是更新 Python 版本到 Python3.X，让其可以正常运行 Python3.X 的脚本。 Python 版本升级，引发如下问题 ↓↓↓↓↓↓ 目前我们的情况是 &gt;&gt;&gt;&gt; 原生 Unix/Linux 系统已经自带有一个版本的 Python2.4，但它不是我们需要的 Python 版本，我们想要编译安装满足我们期待的 Python 版本（Python3）。 此时，我们将面临一种选择：是在原有版本基础上 Update（2.x –&gt; 3.x） 呢？还是去 Setup 一个新版本的 Python（原生版本 Python 也保留）？ Update 存在的问题 &gt;&gt;&gt;&gt; 由于 Python 2.x 和 Python 3.x 兼容性问题，将 Python 2.x 直接升级到 Python 3.x 会产生一些问题（例如：Centos 系统下的很多很多基本的命令、软件包都要依赖系统默认原生的 Python 2.x 版本，例如 yum），直接升级后会导致相关依赖软件可能无法正常使用（尽管有繁琐的解决办法）。 Solution &gt;&gt;&gt;&gt; 事实上，一个系统中可以存在多个 Python 版本，也就是说新老版本 Python 是可以共存的（Python-Vers Management）。 所以，一般建议安装添加一个新版本的 Python（与系统原生 Python 版本共存），或者使用虚拟环境工具（Virtual Envs Tools）进行多版本管理（这里不用深究，Virtual Envs Tools 是一种优秀的 Python 多版本共存管理方案）。 | =============================================== Split Line ================================================== | 👇👇👇 正式开始 Python 更新 👇👇👇 [1] &gt;&gt;&gt;&gt; 更新 GCC linux 平台下安装 Python 通常使用源码编译的方式。 故，GCC 版本太低会导致新版本 Python 包编译不成功，需要更新系统 gcc 版本： 1$ yum -y install gcc [2] &gt;&gt;&gt;&gt; 下载 Python 安装包 以 Python-3.3.0 为例 1$ wget http://python.org/ftp/python/3.5.0/Python-3.5.0.tar.bz2 注意：按照上述命令下载的软件包会存放在你当前的工作目录下。链接中的数字对应的是 Python 版本号，你也可以把 3.5.0 换成你需要的版本。 [3] &gt;&gt;&gt;&gt; 解压已下载的二进制包并编译安装 1234567$ tar -jxvf Python-3.5.0.tar.bz2 $ cd Python-3.5.0 $ ./configure --prefix=/usr/local/python3.5$ make all $ make install $ make clean $ make distclean [4] &gt;&gt;&gt;&gt; 设置软链接 建立软连接指向到当前系统默认 Python 命令的 bin 目录，让系统使用新版本 Python： 先不要执行这里的操作，请 依照最终方案执行，这里还提供一种其它解决思路（不推荐，影响了系统原生环境） 12345678# 原始 Python 的版本为 2.4，所以为了保留 Python2.4，将原始 /usr/bin/python 改名为 Python2.4$ mv /usr/bin/python /usr/bin/python2.4# 将更新后的 python3.5 指向 /usr/bin/python，替换原始的 python2.4$ ln -s /usr/local/python3.5/bin/python3.5 /usr/bin/python# 查看当前默认 Python 版本 $ python -V 这样配置之后，系统默认的 Python 成功指向 Python3.5.0 。yum（依赖 Python2.4 的应用程序） 不能正常使用，还需要修改 yum 的配置文件。 下面我们给出如何通过修改相关配置文件来解决依赖 Python2.4 的应用程序无法正常调用的问题。以修改 yum 配置文件（其它应用程序类似）为例： 1$ vim /usr/bin/yum 把文件头部的 #!/usr/bin/python 改成 #!/usr/bin/python2.4 即可。 当然，很多同学可能回说：“那我怎么能知道都有哪些应用程序的配置文件需要修改呢（都影响了那些应用程序）？”。 👇👇👇 最终方案 👇👇👇 故为了更安全的使用升级后的 Python 版本，我们可以不覆盖原本的 /usr/bin/python，而是在 /usr/bin/ 下新建一个 python3.5 链接。如下： 1234567$ ln -s /usr/local/python3.5/bin/python3.5 /usr/bin/python3.5或者：# 为了防止覆盖问题（尽量不要在系统 /usr/bin 下进行覆盖），你可以:$ ln -s /usr/local/python3.5/bin/python3.5 /usr/local/bin/python3.5# 这里由于【/usr/local/bin/】 路径已在 PATH 中，故可以将 Python 解释器路径放于 `/usr/local/bin` 下。 这样，调用系统命令 python 时仍然指向的老版本的 Python2.4。当我们需要使用新版本的 Python 时，只需要使用 python3.5 即可实现调用。 2 &gt;&gt;&gt;GNU GLIBC 库版本问题 注意：此处更新有风险，升级需谨慎（一般不要随意升级内核运行库）！！！看到 Centos 上搭建 TensorFlow 的难度了吧~~~~ 服务器是 Centos6.X 系统，即使通过 pip 安装好了 TensorFlow，在运行 TF 样例时我们也会发现仍然会报 glibc 版本过低的错误。这是由于 Centos6 上 glibc 最多到 2.12 版本，而强行使用高版本的 glibc 会导致程序意外崩溃。 12# Error：import tensorflow 时提示 GLIBC_2.14 找不到importError: /lib64/libc.so.6: version `GLIBC_2.14' not found 你可以先跳过当期小节的学习，等后续测试 TF 样例时产生该问题再进行查看！！！ 👇👇👇 解决方法 👇👇👇 [1] &gt;&gt;&gt;&gt; 安装或更新 GCC 注意，由于在上文 Python 升级时我们安装或更新过 GCC，故可以直接跳过该节。否则首先需要完成 安装或更新 GCC。 首先察看当前系统的 gcc 版本: gcc –-version，然后 yum update gcc；如果没有 gcc 需要安装 gcc。后续 GLIBC 库升级需要使用 gcc 编译。 下面我们开始看如何更新系统中的 GNU GLIBC 库： [2] &gt;&gt;&gt;&gt; 查看当前 GLIBC 支持的版本 1234567891011121314151617[root]$ strings /lib64/libc.so.6 |grep GLIBC_GLIBC_2.2.5GLIBC_2.2.6GLIBC_2.3GLIBC_2.3.2GLIBC_2.3.3GLIBC_2.3.4GLIBC_2.4GLIBC_2.5GLIBC_2.6GLIBC_2.7GLIBC_2.8GLIBC_2.9GLIBC_2.10GLIBC_2.11GLIBC_2.12GLIBC_PRIVATE 可以看到，Centos6.9 自带的 Glibc 库最高版本是 2.12 ，所以需要对当前版本进行升级。 [3] &gt;&gt;&gt;&gt; 安装 GLIBC_2.17 123456789101112131415$ wget http://ftp.gnu.org/pub/gnu/glibc/glibc-2.17.tar.xz$ tar -zxvf glibc-2.17.tar$ cd glibc-2.17$ mkdir build$ cd build$ ../configure --prefix=/usr --disable-profile --enable-add-ons --with-headers=/usr/include --with-binutils=/usr/bin$ make -j4$ make install% 等待安装成功即可。 [4] &gt;&gt;&gt;&gt; 察看更新 12345678910111213141516171819202122[root]$ strings /lib64/libc.so.6 |grep GLIBC_GLIBC_2.2.5GLIBC_2.2.6GLIBC_2.3GLIBC_2.3.2GLIBC_2.3.3GLIBC_2.3.4GLIBC_2.4GLIBC_2.5GLIBC_2.6GLIBC_2.7GLIBC_2.8GLIBC_2.9GLIBC_2.10GLIBC_2.11GLIBC_2.12GLIBC_2.13GLIBC_2.14GLIBC_2.15GLIBC_2.16GLIBC_2.17GLIBC_PRIVATE 此时，我们发现 Centos6 中 glibc 库版本过低问题得以解决！如果升级不成功可以使用如下语句简单还原: 12$ rm -rf /lib64/libc.so.6$ LD_PRELOAD=/lib64/libc-2.12.so ln -s /lib64/libc-2.12.so /lib64/libc.so.6 | =============================================== Split Line ================================================== | 👇👇👇 可能引发的问题以及解决方法 👇👇👇 [1] &gt;&gt;&gt;&gt; GLIBC 升级失败导致系统崩溃 如果 GLIBC 升级后发生系统崩溃（使用命令会显示错误信息），可参见博文系列中 &gt;&gt;&gt;&gt; 【GLIBC 升级失败导致系统崩溃解决方法】。 [2] &gt;&gt;&gt;&gt; libstdc++.so.6 version `CXXABI_1.3.9’ not found 更新 GLIBC 后，在 import tensorflow 测试时可能还会产生一个问题：libstdc++.so.6: version 'CXXABI_1.3.9' not found (required by bin/opencv_test_core)? 这是由于 更新和安装 GCC 导致的。需要使用升级后的 gcc 的动态库去替换老版本的 gcc 动态库。 解决方法参见博文系列中 &gt;&gt;&gt;&gt; 【Libstdc++.so.6 Version ‘CXXABI_1.3.X’ Not Found】。 TensorFlow GPU 支持TensorFlow Only CPU 和 GPU enabled 版本区别： 当处理数据量较大时，支持 GPU 版本处理速度要比支持 CPU 版本运行速度更快。当数据量较小时，GPU 可能运行更慢。 👇👇👇 TensorFlow GPU 运算环境注意事项 👇👇👇 对于 TensorFlow GPU 环境，部署 CUDA/CuDNN 是必须的。 搭建基于 GPU 运算的 TensorFlow 深度学习环境时，需要根据服务器所搭载独立显卡的相关信息（GPU 型号、计算性能等），选择安装可相互兼容的显卡驱动（CUDA）、显卡加速包（CUDNN）以及相应的 TensorFlow 版本。 并且，只有在安装了特定（ CUDA &amp;&amp; CuDNN）版本的服务器环境（如：CUDA Toolkit 8.0（7.5） &amp;&amp; CuDNN v5.1（v4） 的 64 位 Ubuntu）下才可以通过 Pip 安装支持 GPU 的相应版本的 TensorFlow v1.0.0（1.1.0/1.2.0）。 ↓↓↓↓↓↓ 关于 CUDA &amp;&amp; CuDNN &amp;&amp; TensorFlow 版本的选择问题 ↓↓↓↓↓↓ 可以根据官方实测过的【Tensorflow &amp;&amp; NVIDIA 版本信息对照表】进行选择，如下： [1] &gt;&gt;&gt;&gt; For Linux/macOS &gt;&gt;&gt;&gt; 【TF CPU/GPU】 [2] &gt;&gt;&gt;&gt; For Windows &gt;&gt;&gt;&gt; 【TF CPU/GPU】 ↓↓↓↓↓↓ 关于 TensorFlow + CUDA + CuDNN 环境搭建 ↓↓↓↓↓↓ 所有 Ubuntu 下搭建 TensorFlow GPU + CUDA + CuDNN 运算环境的问题，可参见博文系列中 &gt;&gt;&gt;&gt; 【TensorFlow GPU 支持: Ubuntu16.04 + Nvidia GTX + CUDA + CUDNN】。 需要注意的是，最好先学习完 TensorFlow CPU 支持的环境搭建之后，再开始尝试 TensorFlow GPU 支持，TensorFlow 的安装方式都是一样的，唯一的区别在于 CUDA/CuDNN。 TensorFlow Setup准备好 TensorFlow 预安装环境之后，接下来我们正式来看官方提供的不同安装方式的实现（你可以根据实际需要选择不同的安装方法）： 使用原生 Pip 安装推荐指数：⭐️⭐️ 我们知道，PIP 是一种包管理工具（安装 Python 后自带），用于安装和管理 Python 丰富的类库。 同样的，通过 pip 可以安装已经打包好的 TensorFlow 应用以及 TensorFlow 所需要的依赖，可以较为方便地解决 Tensorflow 应用和其相关底层的依赖关系。 网络上，你可能查询到两种主流的使用原生 Pip 的方式安装 TensorFlow： pip install tensorflow_v_xxx.whl：通过特定版本（v_xxx）的 TensorFlow Whl 安装包进行安装，安装过程较为繁琐； pip install tensorflow from PIP-Sources：随着 TensorFlow 的流行，Pip 源中开始全面支持 TensorFlow 包的下载，之后你就可以像安装 Python 第三方类库一样安装 TensorFlow 框架了。 下面你可以分别看到上述两种安装方法的差异： PIP Install From Sources目前，Pip 源中已经开始全面支持 TensorFlow 包的下载了，你可以通过 Pip 安装 TensorFlow 框架就像安装其它 Python 第三方类库一样简单（以 TensorFlow 1.2 版本为例）： 1234567# For TensorFlow-CPU$ pip install tensorflow==1.2# 或：# For TensorFlow-GPUpip install tensorflow-gpu==1.2 可跳过当前小节~~~ 起初，Pip 无法管理 TensorFlow，需要通过 TensorFlow 官方提供的 .whl 包进行安装，安装过程受网络波动影响较大。 PIP Install TensorFlow.whl具体安装步骤如下（不再推荐，了解即可）： [1] &gt;&gt;&gt;&gt; Export TensorFlow.whl（CPU/GPU）URL 首先，我们给出一个 TensorFlow.whl 安装包下载地址（清华大学开源镜像站） ，提供了不同平台下、不同安装版本的 TensorFlow 安装包下载 URL，从这里我们可以获取到我们需要的 TensorFlow 版本。 然后，将 TensorFlow.whl URL 导入系统环境变量（TF_BINARY_URL）中，用于后续的下载： 1234567891011121314151617181920212223242526272829303132####### 寻找合适的 Tensorflow 安装包下载链接 ######## 环境变量 $TF_BINARY_URL 根据你的实际需求(想要下载的 Tensorflow 版本)进行设置，典型选项如下：# 注意，以下给出的 URL 均属于 Google 官方链接，下载时可能出现网络中断，你可以将其更换为清华大学开源镜像站 URL（目前可能已不再提供，Pip 源中已包含）。# Ubuntu/Linux 64-bit, CPU only, Python 2.7$ export TF_BINARY_URL=https://storage.googleapis.com/tensorflow/linux/cpu/tensorflow-0.12.1-cp27-none-linux_x86_64.whl# Ubuntu/Linux 64-bit, GPU enabled, Python 2.7# 需要 CUDA toolkit 8.0（7.5） and CuDNN v5（v4）.$ export TF_BINARY_URL=https://storage.googleapis.com/tensorflow/linux/gpu/tensorflow_gpu-0.12.1-cp27-none-linux_x86_64.whl# Ubuntu/Linux 64-bit, CPU only, Python 3.4$ export TF_BINARY_URL=https://storage.googleapis.com/tensorflow/linux/cpu/tensorflow-0.12.1-cp34-cp34m-linux_x86_64.whl# Ubuntu/Linux 64-bit, GPU enabled, Python 3.4# 需要 CUDA toolkit 8.0 and CuDNN v5.0 $ export TF_BINARY_URL=https://storage.googleapis.com/tensorflow/linux/gpu/tensorflow_gpu-0.12.1-cp34-cp34m-linux_x86_64.whl# Ubuntu/Linux 64-bit, CPU only, Python 3.5$ export TF_BINARY_URL=https://storage.googleapis.com/tensorflow/linux/cpu/tensorflow-0.12.1-cp35-cp35m-linux_x86_64.whl# Ubuntu/Linux 64-bit, GPU enabled, Python 3.5# Requires CUDA toolkit 8.0 and CuDNN v5. For other versions, see &quot;Installing from sources&quot; below.$ export TF_BINARY_URL=https://storage.googleapis.com/tensorflow/linux/gpu/tensorflow_gpu-0.12.1-cp35-cp35m-linux_x86_64.whl# Mac OS X, CPU only, Python 2.7:$ export TF_BINARY_URL=https://storage.googleapis.com/tensorflow/mac/cpu/tensorflow-0.12.1-py2-none-any.whl# Mac OS X, GPU enabled, Python 2.7:$ export TF_BINARY_URL=https://storage.googleapis.com/tensorflow/mac/gpu/tensorflow_gpu-0.12.1-py2-none-any.whl# Mac OS X, CPU only, Python 3.4 or 3.5:$ export TF_BINARY_URL=https://storage.googleapis.com/tensorflow/mac/cpu/tensorflow-0.12.1-py3-none-any.whl# Mac OS X, GPU enabled, Python 3.4 or 3.5: $ export TF_BINARY_URL=https://storage.googleapis.com/tensorflow/mac/gpu/tensorflow_gpu-0.12.1-py3-none-any.whl [2] &gt;&gt;&gt;&gt; Install TensorFlow By TF_BINARY_URL 上面我们已经选择了合适版本的 TensorFlow URL，运行如下命令可完成 TensorFlow 的安装： 12345# Python 2 环境 $ sudo pip install --upgrade $TF_BINARY_URL# Python 3 环境 $ sudo pip3 install --upgrade $TF_BINARY_URL 耐心，这是完成环境搭建的最后一步，过程中会出现 网络连接超时 等问题（外网服务器下载）。如果一次无法成功安装 $TF_BINARY_URL，并且你确定你所配置的网络或网络代理等都正常。那么，多试几次，不厌其烦，如果出现下面的信息，则表示你快要成功了： 123456789101112131415161718192021222324252627282930###### Python 3 成功运行记录如下 ######You are using pip version 7.1.0, however version 9.0.1 is available. You should consider upgrading via the 'pip install --upgrade pip' command. Processing ./tensorflow_gpu-0.12.1-cp27-none-linux_x86_64.whl Collecting mock&gt;=2.0.0 (from tensorflow-cpu==0.12.1) Using cached mock-2.0.0-py2.py3-none-any.whl Collecting protobuf&gt;=3.1.0 (from tensorflow-cpu==0.12.1) Downloading protobuf-3.1.0.post1-py2.py3-none-any.whl (347kB) 100% |████████████████████████████████| 348kB 164kB/s Collecting numpy&gt;=1.11.0 (from tensorflow-cpu==0.12.1) Downloading numpy-1.11.3.zip (4.7MB) 100% |████████████████████████████████| 4.7MB 34kB/s Collecting wheel (from tensorflow-cpu==0.12.1) Downloading wheel-0.29.0-py2.py3-none-any.whl (66kB) 100% |████████████████████████████████| 69kB 58kB/s Collecting six&gt;=1.10.0 (from tensorflow-cpu==0.12.1) Downloading six-1.10.0-py2.py3-none-any.whl Collecting funcsigs&gt;=1 (from mock&gt;=2.0.0-&gt;tensorflow-cpu==0.12.1) Downloading funcsigs-1.0.2-py2.py3-none-any.whl Collecting pbr&gt;=0.11 (from mock&gt;=2.0.0-&gt;tensorflow-cpu==0.12.1) Downloading pbr-1.10.0-py2.py3-none-any.whl (96kB) 100% |████████████████████████████████| 98kB 93kB/s Requirement already satisfied (use --upgrade to upgrade): setuptools in /usr/lib/python2.7/site-packages (from protobuf&gt;=3.1.0-&gt;tensorflow-cpu==0.12.1) Installing collected packages: funcsigs, six, pbr, mock, protobuf, numpy, wheel, tensorflow-cpu Found existing installation: six 1.9.0 Uninstalling six-1.9.0: Successfully uninstalled six-1.9.0 Running setup.py install for numpy Successfully installed funcsigs-1.0.2 mock-2.0.0 numpy-1.11.3 pbr-1.10.0 protobuf-3.1.0.post1 six-1.10.0 tensorflow-cpu-0.12.1 wheel-0.29.0 如果以上下载过程发生中断，重新执行命令即可。如果你一次成功，那么恭喜。否则此处需要耐性！！！如若上述一直不成功，这里还提供一种解决思路： 1234$ export TF_BINARY_URL=https://storage.googleapis.com/tensorflow/mac/tensorflow-0.8.0rc0-py2-none-any.whl# 然后，先 wget $TF_BINARY_URL（或浏览器）下载 tensorflow—xxx.whl 文件到本地；# 最后使用 pip install *.whl 进行本地安装。 Pip 方法评价以上安装过程在 Centos6.9(7) &amp;&amp; ubuntu14.04/16.04/18.04 服务器环境下已测试通过。 ↓↓↓↓↓↓ 优点 ↓↓↓↓↓↓ 使用 Python 中原生 Pip 的安装方式，应该是几种安装方法中最简单、最快的一种。 ↓↓↓↓↓↓ 缺点 ↓↓↓↓↓↓ 缺点很明显，不能灵活定制。并且，由于属于直接安装于服务器原生 Python 环境中（未隔离），对原生开发环境有较大影响，不推荐使用该方法。 如果是玩数据玩 ML 的同学，如果你还不知道 Anaconda，你就 out 啦！！！ Anaconda 是一个基于 Python 的科学计算平台，这个平台里包含有 Python、R、Scala 等相关的绝大部分主流的用于科学计算的包，这极大的方便了开发人员的使用。 使用 Anaconda 安装推荐指数：⭐️⭐️⭐️⭐️⭐️ Anaconda 是 Python 的一个发行版，如果把 Python 比作 Linux，那么 Anancoda 就是 CentOS 或者 Ubuntu。它通过 Conda 工具解决了 Python 开发者的两大痛点： 提供包管理 &gt;&gt;&gt; 功能类似于 pip，Windows 平台安装 Python 第三方包经常失败的场景得以解决； 提供虚拟环境管理 &gt;&gt;&gt; 功能类似于 Virtualenv，解决了多版本 Python 并存问题。 👇👇👇 通俗的讲 👇👇👇 使用 Anaconda 安装 TensorFlow 进行学习开发时，相当于将所有的 TensorFlow 底层依赖细节全部已经打包封装好了（包管理）！！！ 并且，Anaconda 还能创建独立、隔离的 TensorFlow 运算环境（虚拟环境管理），相当于将 TensorFlow 的环境与其他环境做了隔离，这样你就可以将 TensorFlow 随便玩，爱怎么玩怎么玩，也不用担心破坏之前的环境！！！ 像了解更多关于 Anaconda 的说明和使用方法，请关注博主相关博文系列中 &gt;&gt;&gt;&gt; 【一文了解数据科学神器 Anaconda】 Setup Anaconda要使用 Anaconda，首先要完成不同平台下 Anaconda 的安装与配置。 这里，我们先给出 Anaconda 官方网址 用于下载相应的安装包（下载较慢的话可以尝试前往 &gt;&gt;&gt;【清华大学开源软件镜像站】）。 关于 Anaconda 详细的安装以及配置教程，请关注博主相关博文系列 &gt;&gt;&gt;&gt; 【一文了解数据科学神器 Anaconda】中 &gt;&gt;&gt;&gt; 小节【How to setup Anaconda？】说明，这里不再赘述。 Conda ToolConda 是 Anaconda 下用于包管理和环境管理的命令行工具，是 Anaconda 的核心。其可以看作是 pip 和 Vitualenv 的组合。 Anaconda 安装、配置成功后 conda 会被加入到环境变量中，因此可直接在命令行窗口运行 conda 命令: 123456# 测试安装是否成功$ conda –V 或 which conda# 假如安装的是 Python 2.7 对应的版本,运行：$ python -V# 可以看到：Python 2.7.12 :: Anaconda 4.3.30 (64-bit)，说明安装成功。 1 &gt;&gt;&gt;&gt; Conda 虚拟环境管理 Conda 工具可以隔离出一个和当前系统 Python 环境分离、独立的虚拟环境，以实现多版本 Python 或 TensorFlow 环境切换： 1234567891011121314151617181920### [1] 创建虚拟环境 #### 基于 python3.6 创建一个名 Python3 的环境$ conda create --name Python3 python=3.5 # 基于 python2.7 创建一个名为 Python2 的环境$ conda create --name Python2 python=2.7# 删除环境$ conda remove -n Python2 --all### [2] 切换虚拟环境 #### 激活 Python3 环境$ activate Python3 # windows$ source activate Python3 # linux/mac# 退出 Python3 环境$ source deactivate# Python3 切换到 python2$ activate python2 2 &gt;&gt;&gt;&gt; Conda 包管理 Conda（类似于 Pip）的包管理功能是对 pip 包管理器的一种补充。 如果当前已经激活了某个 Python 虚拟环境，那么就可以在当前环境使用 conda 安装第三方扩展了。 对于那些用 pip 无法安装成功的模块你都可以尝试用 conda 来安装，如果用 conda 找不到相应的包，当然你继续选择 pip 来安装包也是没问题的。 事实上，使用 Anaconda 安装 TensorFlow 环境就是 &gt;&gt;&gt;&gt; 使用 Conda 创建一个独立、隔离的 Python 虚拟环境，然后将 TensorFlow 作为一个 Python 第三方包进行安装，以创建隔离于操作系统原生环境的虚拟 TensorFlow 深度学习环境。 关于 Conda Tool 更详细的说明，请关注博主相关博文系列 &gt;&gt;&gt;&gt; 【一文了解数据科学神器 Anaconda】中 &gt;&gt;&gt;&gt; 小节【Conda 包以及虚拟环境管理工具】说明，这里不再赘述。 Conda&amp;&amp;Pip Channels类似于 Pip 安装或更新失败，Anaconda 使用过程中如 conda install 创建环境失败或 conda update 更新失败等等，可能产生 HTTP error，如下： 1234567Fetching package metadata .......CondaHTTPError: HTTP 000 CONNECTION FAILED for url &lt;https://nanomirrors.tuna.tsinghua.edu.cn/anaconda/cloud/linux-64/rpodata.json&gt;Elapsed: -An HTTP error occurred when trying to retrieve this URL.HTTP errors are often intermittent, and a simple retry will get you on your way.ConnectTimeout(MaxRetryError(&quot;HTTPSConnectionPool(host='nanomirrors.tuna.tsinghua.edu.cn', port=443): Max retries exceded with url: /anaconda/cloud/linux-64/repodata.json (Caused by ConnectTimeoutError(&lt;requests.packages.urllib3.connecton.VerifiedHTTPSConnection object at 0x7fb6d340dcc0&gt;, 'Connection to nanomirrors.tuna.tsinghua.edu.cn timed out. (connct timeout=9.15)'))&quot;,),) 👇👇👇 产生原因以及解决方法 👇👇👇 和 PIP 一样，当需要安装或更新很多 Packages 时，你会发现 Conda 下载和更新速度有时很慢，最后导致崩掉。最主要原因是因为 Anaconda.org 的服务器在国外，网络时好时坏（波动较大）。 所幸的是，清华 TUNA、中科大等国内镜像源有 Anaconda 仓库的镜像，这意味着我们可以将默认 Anaconda 源换为 清华 TUNA 等国内镜像源（换源），以支持稳定的网络环境。 需要注意的是：国内镜像源需要获得 Anaconda 官方的授权才可以提供对外的镜像服务。2019 年清华、中科大由于暂时未获取到 Anaconda 授权，于 2019.05 月底暂停了很长一段时间的 Anaconda 镜像服务，目前已恢复！！！ 关于 Conda&amp;&amp;Pip Channels 更详细的说明，请关注博主相关博文系列 &gt;&gt;&gt;&gt; 【一文了解数据科学神器 Anaconda】中 &gt;&gt;&gt;&gt; 小节【Conda&amp;&amp;Pip Channels】说明，这里不再赘述。 Setup TensorFlow熟悉了 Anaconda 环境后，我们来看如何基于 Anaconda 虚拟环境来搭建 TensorFlow 深度学习环境： [1] &gt;&gt;&gt;&gt; CUDA &amp;&amp; CUDNN（GPU Support 版需要执行该步骤，CPU Support 跳过这一部分即可） Tensorflow 同 Caffe 一样，也是支持 CPU 和 GPU 两个版本。故也需要安装 CUDA &amp;&amp; CUDNN。根据版本对照表信息这里推荐安装 CUDA 版本为 8.0，CUDNN 版本为 5.1，TensorFlow 版本为 1.2.0。 搭建 TensorFlow GPU + CUDA + CuDNN 运算环境的问题，可参见博文系列中 &gt;&gt;&gt;&gt; 【TensorFlow GPU 支持: Ubuntu16.04 + Nvidia GTX + CUDA + CUDNN】。 [2] &gt;&gt;&gt;&gt; 为 TensorFlow 创建虚拟环境 Anaconda 的环境准备好了以后，接下来我们建立一个 Conda 的虚拟环境，给这个环境取名叫 for_tensorflow: 12345# Python 2.7$ conda create -n for_tensorflow python=2.7# Python 3.5$ conda create -n for_tensorflow python=3.5 如果发现，无法成功创建（换源？），不要灰心，多创建几次会成功的。 [3] &gt;&gt;&gt;&gt; 激活创建好的虚拟环境 12[root@localhost ~]# source activate tensorflow(for_tensorflow)[root@localhost ~]# 注意，激活 tensorflow 环境后会发现用户名前出现 (for_tensorflow) 的标识，之后 TensorFlow 会被安装到该虚拟环境中。 [4] &gt;&gt;&gt;&gt; 虚拟环境中使用 Pip 安装 TensorFlow 实际上，for_tensorflow 虚拟环境中使用 Pip 安装 TensorFlow，和使用系统原生 Pip 安装 TensorFlow 一模一样： pip install tensorflow_v_xxx.whl：通过特定版本（v_xxx）的 TensorFlow Whl 安装包进行安装，安装过程较为繁琐； pip install tensorflow from PIP-Sources：随着 TensorFlow 的流行，Pip 源中开始全面支持 TensorFlow 包的下载，之后你就可以像安装 Python 第三方类库一样安装 TensorFlow 框架了。 具体安装步骤不再进行赘述，请参看前文~~~ [5] &gt;&gt;&gt;&gt; Problem：Glibc Update &amp;&amp; libstdc++.so.6: version `CXXABI_1.3.9’ not found Centos6/7 下可能出现 Glibc 库升级失败 与 libstdc++.so.6: version 'CXXABI_1.3.9' not found 报错，而 Ubuntu 下安装不会出现该问题。 解决方法见 &gt;&gt;&gt;&gt; 【Centos6/7 环境准备】章节。 TF-Version Control类似于 Python 多版本共存管理方案，借鉴 Conda 管理工具 中 Conda 虚拟环境管理 使用方法，解决如何在一个 Anaconda 上装多个不同的 TensorFlow 版本。 我们可以通过为不同版本的 TensorFlow 分别创建不同的 Conda 虚拟环境，实现 TensorFlow 的多版本管理： 123456789# For TensorFlow v1.1.0 CPU$ conda create -n tensorflow_v1.1 python=3.5$ activate tensorflow_v1.1$ pip install tensorflow==1.1# For TensorFlow v1.2.0 CPU$ conda create -n tensorflow_v1.2 python=3.5$ activate tensorflow_v1.2$ pip install tensorflow==1.2 这样，你可以随时测试不同 TensorFlow 版本的差异，或适应不同工程项目对 TensorFlow 版本的要求。 Anaconda 激活环境困扰每次运行 TensorFlow 程序前，都需要相应的虚拟环境中运行，你可以： [1] &gt;&gt;&gt;&gt; 设置 TensorFlow 永久环境（开机自启） 每次运行 tensorflow 环境都需要启动环境，如何设置永久环境（写入用户配置文件）： 12$ printf './root/anaconda3/bin/activate tensorflow-3.5' &gt;&gt;~/.bashrc$ source ~/.bashrc [2] &gt;&gt;&gt;&gt; 快捷启动 TensorFlow 环境 不想设置永久环境（影响其他人使用），但每次启动 TensorFlow 环境时命令太长，如何设置命令别名： 1234## entertf 启动：tensorflow-py35 环境$ printf '\\nalias entertf=&quot;source /root/anaconda3/bin/activate tensorflow-py3.5&quot;' &gt;&gt;~/.bashrc## exittf 退出环境$ printf '\\nalias exittf=&quot;source deactivate&quot;' &gt;&gt;~/.bashrc TF-Services SupportTensorflow 程序作为某工程项目（Python/JAVA/…）一部分，以提供算法支持，那么如何被调用？： 你可以很容易想到 &gt;&gt;&gt;&gt; 可以提供了一个 Python/Java 通过调用 shell 命令实现启动 TensorFlow 运算环境并执行目标程序的接口。 事实上，这不是一个好的方法。更多的 &gt;&gt;&gt;&gt; 将 TensorFlow 封装成一个 Python 微服务（例如：Flask 框架）&gt;&gt;&gt;&gt; 通过网络调用来交互，确保各程序之间的独立性。 Anaconda 方法评价以上安装过程在 Centos6.9(7) &amp;&amp; ubuntu14.04/16.04/18.04 服务器环境下已测试通过。 ↓↓↓↓↓↓ 优点 ↓↓↓↓↓↓ 引入独立、隔离的虚拟环境管理，灵活定制，支持 TensorFlow 多版本管理。 ↓↓↓↓↓↓ 缺点 ↓↓↓↓↓↓ 唯一代价就是引入一定的学习成本，但学习 DeepLearning 你还能不接触 Anaconda？！！ 使用 VirtualEnv 安装关于 VirtualEnv 工具的使用说明，详情可参见 &gt;&gt;&gt;&gt; 【Pythoner 神器之 virtualenv】。 事实上，VirtualEnv 类似于 Conda 虚拟环境管理功能，也是创建出一个个独立、隔离的虚拟环境，以实现与原生环境的分离，且达到多版本管理的目的。 但 Anaconda 是一个生态圈，其功能远远大于 VirtualEnv，推荐使用 Anaconda。 使用 TF 源码编译安装使用 TensorFlow 源代码编译安装的过程，就是将 TensorFlow 源代码编译成 Pip 安装包并完成安装的过程。 👇👇👇 全过程 👇👇👇 首先将 TensorFlow 源代码编译成 Pip 所使用的 wheel 文件 &gt;&gt;&gt;&gt; 然后使用 pip install 进行安装即可。 另外，你还需要准备 TensorFlow 源代码，JDK8 以上，Bazel 编译工具。如果想要支持 GPU，还需要部署 CUDA &amp;&amp; CuDNN。 使用 TF 源码编译安装可以使用最新源码，并且编译得到的是支持本地 CPU/GPU 优化适配的版本，且支持灵活定制 TensorFlow。 使用 Docker 安装Docker 是新一代的虚拟化技术，让开发者可以打包他们的应用以及相关依赖包到一个可移植的容器中，然后发布到任何流行的 Linux（内核版本高于 3.10）机器上。 Docker 支持大部分的操作系统：Linux[ubuntu/Centos/Debian/Red Hat/…]、Windows7 以上，以及 Mac OS 等。它可以将 TensorFlow 以及 TensorFlow 的所有依赖关系统一到 Docker 镜像中，从而大大简化安装过程。 当你通过 Docker 安装和运行 TensorFlow 时，它与你机器上之前已安装的软件包实现完全隔离。 未完待续~~~~ Docker 极其适合在大量相同环境机器构成的集群上，批量部署独立、隔离的 TensorFlow 环境。 TF-Envs TestTensorFlow 深度学习环境安装、部署完成之后，这里我们将通过一个样例来测试是否安装成功： 123456789101112131415(tensorflow-3.5) root@ubuntu-Lenovo-Product:~# pythonPython 3.5.4 | packaged by conda-forge | (default, Dec 18 2017, 06:30:33) [GCC 4.8.2 20140120 (Red Hat 4.8.2-15)] on linuxType &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.&gt;&gt;&gt; import tensorflow as tf&gt;&gt;&gt; hello = tf.constant('Hello, TensorFlow!')&gt;&gt;&gt; sess = tf.Session()&gt;&gt;&gt; print (sess.run(hello))b'Hello, TensorFlow!'&gt;&gt;&gt; a = tf.constant(10)&gt;&gt;&gt; b = tf.constant(32)&gt;&gt;&gt; print (sess.run(a+b))42&gt;&gt;&gt; 样例结果与上述输出信息一致则表示 TensorFlow 安装成功！！！ | ============================================= Possible Problems ========================================== | 👇👇👇 import tensorflow as tf 导入问题 👇👇👇 ↓↓↓↓↓↓ 1. Protocol Versions ↓↓↓↓↓↓ 1234TypeError: Descriptors cannot not be created directly.If this call came from a _pb2.py file, your generated code is out of date and must be regenerated with protoc &gt;= 3.1.0If you cannot immediately regenerate your protos, some other possible workarounds are:1. Downgrade the protobuf package to 3.20.x or lower.2. Set PROTOCOL_BUPFERS_PYTHON_iMPLEMENTATION=python (but this will use pure-Python parsing and will be mch slower ,More information: https://developers. google.com/protocol-buffers/docs/news/2022-05-06#python-updates 仔细阅读报错信息就会发现，报错的主要原因是因为 protobuf 的版本太高而导致编译错误。你只需要按照编译器提示的信息在当前环境中下载 3.19.0 对应的版本即可： 1$ pip install protobuf==3.19.0 ↓↓↓↓↓↓ 2. NumPy Versions ↓↓↓↓↓↓ 1FutureWarning: Passing (type, 1) or '1type' as a synonym of type is deprecated; in a future version of numpy, it will be understood as (type, (1,)) / '(1,)type'.FutureWarning: Passing (type, 1) or '1type' as a synonym of type is deprecated; in a future version of numpy, it will be understood as (type, (1,)) / '(1,)type'. 仔细阅读报错信息就会发现，报错的主要原因是因为 numpy 的版本太高而导致的警告信息，并不会引发报错。你可以在当前环境中降低其版本： 1$ pip install numpy==1.16.0 | ================================================== Split Line =============================================== | 👇👇👇 如果 tf.Session() 时遇到问题 👇👇👇 1I tensorflow/core/platform/cpu_feature_guard.cc:137] Your CPU supports instructions that this TensorFlow binary was not compiled to use:SSE4.1 SSE4.2 AVX 上述输出是不影响 TensorFlow 使用的，可能你觉得这看起来也太难受了。解决方法如下: 123456# 1. 在代码开始导入：&gt;&gt;&gt;import os&gt;&gt;&gt;os.environ['TF_CPP_MIN_LOG_LEVEL']='2'&gt;&gt;&gt;import tensorflow as tf# 2. 使用 TensorFlow 源码编译安装 TensorFlow","link":"/2018/04/01/yi-wen-xiang-jie-quan-ping-tai-tensorflow-shen-du-xue-xi-kuang-jia-zai-xian-da-jian-cpu-gpu-zhi-chi/"},{"title":"GLIBC 升级失败导致系统崩溃解决方法","text":"在较为老旧版本的 Centos 中搭建 TensorFlow 深度学习开发环境时（例如：Centos6.9），由于 GNU GLIBC 库（内核运行库）版本比较低，我们需要对其进行更新以满足 TensorFlow 的安装需求。 更新时，执行误操作只要不断开远程连接还有挽回的余地，但远程异常断开连接之后很多人就没有辙了，准备抢救数据&amp;文件，重装系统。事实上，我们先不要急着重装系统，来试一试是否可以 Rescue ！ 场景GNU GLIBC 库（内核运行库）升级失败导致系统崩溃，导致终端下使用命令会显示错误信息。 主要是因为当前系统中使用到 Glibc 库的应用程序是用旧版 Glibc 编译的，而在安装新版 Glibc 库时却在安装时出了错（或者库是安装成功了，但不兼容），导致安装没成功，却把旧版的库给替换了（也可能是没有替换只是链接给覆盖掉了），这就进入了死循环了，导致系统所有命令几乎都执行不了。 👇👇👇核心解决办法：👇👇👇 只能是进入到不依赖于当前系统中 Glibc 库的终端中去把 Glibc 库的链接（或文件）还原成原来的备份版，这只能使用光盘镜像的方式实现了。 如果当前没有光盘，可以尝试在开机时直接切换到恢复模式进入 Shell（关于如何进入到恢复模式下的 Shell 可见后文），看下面的关键命令是否可用，如果可用就直接解决了： 12$ rm -rf /lib64/libc.so.6$ LD_PRELOAD=/lib64/libc-2.12.so ln -s /lib64/libc-2.12.so /lib64/libc.so.6 如果不行的话，只能用光盘镜像进行恢复了。下面我们来看如何基于光盘镜像进行 rescue： Rescue具体步骤如下： [1] &gt;&gt;&gt;&gt; Rescue installed system 首先准备好系统安装盘，进入 BIOS，使用系统镜像安装盘进行启动，选择 Rescue installed system。如下： 注意，选择恢复模式之后，可能还需要选择 语言和键盘。保持默认的就好。 [2] &gt;&gt;&gt;&gt; Setup Networking 上述操作完成后会询问 是否设置网络，一般来说网络没问题就不用设置了，这里我们选择 No。如下： [3] &gt;&gt;&gt;&gt; Rescue 设置网络后，我们需要设置 Rescue 选项。界面如下所示： ↓↓↓↓↓↓ 选项参数说明 ↓↓↓↓↓↓ Continue 选项：此选项下，救援模式程序会自动查找系统中已有的文件系统，并把他们挂载到 /mnt/sysimage 目录下； Read-Only 选项：此选项下，表示以只读的方式挂载已有的文件系统； Skip 选项：表示想要手动挂载 ； Advanced 选项：高级选项就不作说明了。 这里，我们选择 Continue 选项。 [4] &gt;&gt;&gt;&gt; Root for rescue 我们知道，原系统会被挂载到 /mnt/sysimage 路径下。 设置好 Rescue 选项之后，会提醒我们如果想获得原系统的 root 环境，通过执行 chroot /mnt/sysimage 即可。如下： [5] &gt;&gt;&gt;&gt; Start shell 这里，可以执行 fakd 诊断。当然我们选择直接进入恢复模式下的 shell： [6] &gt;&gt;&gt;&gt; Solution 由于 /usr/lib64/libc-2.12.so &amp; libc.so.6 -&gt; libc-2.12.so 的问题，我们发现执行 chroot /mnt/sysimage 会产生报错： 123Starting shell...bash-4.1# chroot /mnt/sysimage/bin/sh: error while loading shared libraries: libc.so.6 cannot open ... file: no such file or directory 此时不要害怕，执行： 12$ cp /lib64/libc-2.12.so /mnt/sysimage/lib64/libc-2.12.so$ cp /lib64/libc.so.6 /mnt/sysimage/lib64/libc.so.6 这是因为在升级 Glibc 添加软连接指向 libc.so.6 时出错所以将软连接删除，更换为以前系统的glibc-2.12 指向的软连接，再次执行: 1bash-4.1# chroot /mnt/sysimage 发现可以正常切换，没有再出现错误的提示。现在可以重启系统，设置后开机就没问题。","link":"/2018/04/01/glibc-yun-xing-ku-sheng-ji-shi-bai-dao-zhi-xi-tong-beng-kui-jie-jue-fang-fa/"},{"title":"Libstdc++.so.6 Version &#39;CXXABI_1.3.X&#39; Not Found","text":"在基于 Centos6.9 + Anaconda 搭建 TensorFlow 深度学习环境成功后，在导入 import TensorFlow 时，可能会产生如下报错：/usr/lib/libstdc++.so.6:version ‘CXXBAI_1.3.9’not found...，怎么办？！！ 通过查阅相关资料，发现问题是由于升级了 GCC，却没有将升级后的 GCC 的动态库去替换老版本的 GCC 动态库所致，本文我们会给出相关的解决办法。 👇👇👇 详细步骤说明 👇👇👇 [1] &gt;&gt;&gt;&gt; 查看动态库 12345$ strings /usr/lib64/libstdc++.so.6 | grep CXXABI1.CXXABI_1.32.CXXABI_1.3.13.CXXABI_1.3.24.CXXABI_1.3.3 这里可以发现，CXXABI 最高版本只有 1.3.3，没有 1.3.9 的。这就说明出现这些问题，是因为升级 gcc 时，生成的动态库没有替换老版本 gcc 的动态库。 接下来查看 gcc 动态库链接情况：接下来查看 gcc 动态库链接情况： 12$ ls -l /usr/lib64/libstdc++.so.6lrwxrwxrwx. 1 rootroot 19 Apr 7 17:57 $ /usr/lib/libstdc++.so.6 -&gt;libstdc++.so.6.0.13 我们发现，libstdc++.so.6 是个软连接，被链接到了 libstdc++.so.6.0.13 上，而 libstdc++.so.6.0.13 是老版本的动态库。 所以接下来我们要做的就是将 libstdc++.so.6 连接到新版本的动态库上去。 [2] &gt;&gt;&gt;&gt; 查找编译 GCC 时生成的最新动态库 123456789101112131415$ sudo find / -name &quot;libstdc++.so.*&quot;/usr/lib64/libstdc++.so.6.0.13/usr/lib64/libstdc++.so.6/root/anaconda2/x86_64-conda_cos6-linux-gnu/sysroot/lib/libstdc++.so.6.0.24/root/anaconda2/x86_64-conda_cos6-linux-gnu/sysroot/lib/libstdc++.so.6/root/anaconda2/lib/libstdc++.so.6.0.24/root/anaconda2/lib/libstdc++.so.6/root/anaconda2/envs/tensorflow/x86_64-conda_cos6-linux-gnu/sysroot/lib/libstdc++.so.6.0.24/root/anaconda2/envs/tensorflow/x86_64-conda_cos6-linux-gnu/sysroot/lib/libstdc++.so.6/root/anaconda2/envs/tensorflow/lib/libstdc++.so.6.0.24/root/anaconda2/envs/tensorflow/lib/libstdc++.so.6/root/anaconda2/pkgs/libstdcxx-ng-7.2.0-hdf63c60_3/x86_64-conda_cos6-linux-gnu/sysroot/lib/libstdc++.so.6.0.24/root/anaconda2/pkgs/libstdcxx-ng-7.2.0-hdf63c60_3/x86_64-conda_cos6-linux-gnu/sysroot/lib/libstdc++.so.6/root/anaconda2/pkgs/libstdcxx-ng-7.2.0-hdf63c60_3/lib/libstdc++.so.6.0.24/root/anaconda2/pkgs/libstdcxx-ng-7.2.0-hdf63c60_3/lib/libstdc++.so.6 其中 /root/anaconda2/x86_64-conda_cos6-linux-gnu/sysroot/lib/libstdc++.so.6 就是我们新版本的动态库。 [3] &gt;&gt;&gt;&gt; 备份原生 /usr/lib64/libstdc++.so.6 12$ cp /usr/lib64/libstdc++.so.6 /usr/lib64/libstdc++.so.6.bak$ rm /usr/lib64/libstdc++.so.6 [4] &gt;&gt;&gt;&gt; 重新链接 libstdc++.so.6 1$ ln –s /root/anaconda2/x86_64-conda_cos6-linux-gnu/sysroot/lib/libstdc++.so.6 /usr/lib64/libstdc++.so.6 [5] &gt;&gt;&gt;&gt; 默认动态库升级完成，重新运行以下命令检查动态库 123456789101112131415$ strings /usr/lib64/libstdc++.so.6 | grep CXXABICXXABI_1.3CXXABI_1.3.1CXXABI_1.3.2CXXABI_1.3.3CXXABI_1.3.4CXXABI_1.3.5CXXABI_1.3.6CXXABI_1.3.7CXXABI_1.3.8CXXABI_1.3.9CXXABI_1.3.10CXXABI_1.3.11CXXABI_TM_1CXXABI_FLOAT128 可以看到，确实是链接到新的动态库上去了。完成！！！ 👇👇👇 实际环境安装过程如下 👇👇👇 123456789101112131415161718192021222324252627282930313233343536373839[root@localhost lib64]# find / -name &quot;libstdc++.so.*&quot;/root/anaconda3/envs/tensorflow/x86_64-conda_cos6-linux-gnu/sysroot/lib/libstdc++.so.6.0.24/root/anaconda3/envs/tensorflow/x86_64-conda_cos6-linux-gnu/sysroot/lib/libstdc++.so.6/root/anaconda3/envs/tensorflow/lib/libstdc++.so.6.0.24/root/anaconda3/envs/tensorflow/lib/libstdc++.so.6/root/anaconda3/x86_64-conda_cos6-linux-gnu/sysroot/lib/libstdc++.so.6.0.24/root/anaconda3/x86_64-conda_cos6-linux-gnu/sysroot/lib/libstdc++.so.6/root/anaconda3/lib/libstdc++.so.6.0.24/root/anaconda3/lib/libstdc++.so.6/root/anaconda3/pkgs/libstdcxx-ng-7.2.0-h7a57d05_2/x86_64-conda_cos6-linux-gnu/sysroot/lib/libstdc++.so.6.0.24/root/anaconda3/pkgs/libstdcxx-ng-7.2.0-h7a57d05_2/x86_64-conda_cos6-linux-gnu/sysroot/lib/libstdc++.so.6/root/anaconda3/pkgs/libstdcxx-ng-7.2.0-h7a57d05_2/lib/libstdc++.so.6.0.24/root/anaconda3/pkgs/libstdcxx-ng-7.2.0-h7a57d05_2/lib/libstdc++.so.6/usr/lib64/libstdc++.so.6/usr/lib64/libstdc++.so.6.0.13/usr/share/gdb/auto-load/usr/lib64/libstdc++.so.6.0.13-gdb.pyo/usr/share/gdb/auto-load/usr/lib64/libstdc++.so.6.0.13-gdb.pyc/usr/share/gdb/auto-load/usr/lib64/libstdc++.so.6.0.13-gdb.py/usr/share/gdb/auto-load/usr/lib/libstdc++.so.6.0.13-gdb.pyo/usr/share/gdb/auto-load/usr/lib/libstdc++.so.6.0.13-gdb.pyc/usr/share/gdb/auto-load/usr/lib/libstdc++.so.6.0.13-gdb.py[root@localhost lib64]# cp /usr/lib64/libstdc++.so.6 /usr/lib64/libstdc++.so.6.bak[root@localhost lib64]# rm /usr/lib64/libstdc++.so.6rm: remove symbolic link `/usr/lib64/libstdc++.so.6'? y[root@localhost lib64]# ln -s /root/anaconda3/x86_64-conda_cos6-linux-gnu/sysroot/lib/libstdc++.so.6 /usr/lib64/libstdc++.so.6[root@localhost lib64]# source activate tensorflow(tensorflow) [root@localhost lib64]# pythonPython 3.5.4 |Anaconda, Inc.| (default, Nov 20 2017, 18:44:38) [GCC 7.2.0] on linuxType &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.&gt;&gt;&gt; import tensorflow&gt;&gt;&gt;","link":"/2018/04/01/libstdc-so-6-version-cxxabi-1-3-x-not-found/"},{"title":"TensorFlow GPU 支持: Ubuntu16.04 + Nvidia GTX + CUDA + CUDNN","text":"Update：之前为了 TensorFlow 学习使用配置的 TensorFlow 深度学习环境（CPU Support）计算性能较差，已经不再适合现阶段学习开发使用了。故最近准备升级一下深度学习服务器，重新配置支持 GPU 显卡加速计算的 TensorFlow 深度学习开发环境。 配置过程中参考了网络上很多的相关博文，也遇到过很多坑，为了感谢配置过程中各位大佬的帮助以及方便本人下次配置或者升级，整理以作此文。 更多 TensorFlow 框架搭建相关内容，请关注博主相关博文系列 ↓↓↓↓↓ 之一 &gt;&gt;&gt;&gt; 一文详解全平台 TensorFlow 深度学习框架在线搭建 (CPU&amp;GPU 支持) 之二 &gt;&gt;&gt;&gt; TensorFlow GPU 支持: Ubuntu16.04 + Nvidia GTX + CUDA + CUDNN Before ReadingTensorFlow GPU Support 配置须知： 服务器硬件要求↓↓↓↓↓↓ 关于 内存（Memory）↓↓↓↓↓↓ 16GB 以上。 推荐：条件允许，尽可能大一点。 ↓↓↓↓↓↓ 关于 CPU ↓↓↓↓↓↓ 不同于 TensorFlow For CPU Support 深度学习环境的搭建，GPU Support 环境主要使用 GPU 独立显卡进行计算加速，CPU 的核心数并不重要，只要拥有相对较高的主频就可以，因此对 CPU 的要求其实并不是很高。 推荐：具体根据实际情况进行选择，有条件的可以选择性能更好一点的，可以更好的兼容 TensorFlow For GPU Support 环境。 ↓↓↓↓↓↓ 关于 GPU ↓↓↓↓↓↓ 独立显卡是主角，TensorFlow For GPU Support 深度学习环境的核心计算都是依托于 GPU 进行运算的，故独立显卡的性能直接影响深度学习环境计算能力！！！ 👇👇👇 并不是所有类型的独立显卡（GPU）都可以支持搭建 TensorFlow 深度学习环境 👇👇👇 我们需要能够 支持 CUDA 平台（一种由 NVIDIA 推出的通用并行计算架构）的 GPU 才行，故常见的深度学习独立显卡都选择【NVIDIA 显卡（也就是我们常说的 N 卡）】。 实际上，也并不是所有的 NVIDIA 显卡都支持此功能，NVIDIA 官方提供了 &gt;&gt;&gt;&gt; 【不同显卡系列的支持列表查询】 &lt;&lt;&lt;&lt; 同时你可以查看到相应 GPU 的计算能力。 如果你手头刚好有一块在支持列表内的独立显卡，那么恭喜你可以跳过本小节下面的内容开始后续的教程了~~~ | ============================================ 选购性价比 GPU？ =============================================== | 如果你想要选购一块成本效益最佳的 GPU，推荐参考 Tim Dettmers 博客给出的 &gt;&gt;&gt;&gt; 【NVIDIA 卡分析与推荐–持续更新】 &lt;&lt;&lt;&lt; Tim Dettmers`s Experience and Advice for Using GPUs in Deep Learning。 这里给出博主测试出的主流显卡成本效益图，可供你参考选择： 本文我是基于手头现有的最好的设备进行搭建的，争取早日攒一台更好的服务器出来~~~ 你应该了解你的 GPU这里，你应该已经有了一块可以使用的 GPU 了。但在搭建基于 GPU 显卡加速运算的 TensorFlow【TensorFlow For GPU Support】深度学习环境之前，你首先应该做的就是： 先明确预使用的独立显卡（GPU ）的详细信息（包括显卡型号、显存、计算性能等等）。 这是因为，TensorFlow 不仅对显卡类型（支持 CUDA）有要求，而且有些 TensorFlow 模型需要较大的 GPU 内存，或更多的 GPU 计算核心（即更强的计算能力，加速模型运算），了解预搭载独立显卡（GPU）的详细信息可以更好的帮助我们使用 GPU 进行 TensorFlow 计算加速。 CUDA &amp;&amp; CUDNN &amp;&amp; TFTensorFlow 要想使用 GPU 进行计算加速（相较于 CPU），那么就必须部署 CUDA 和 CUDNN。 👇👇👇 先了解一下什么是 CUDA &amp;&amp; CUDNN ？ 👇👇👇 CUDA &gt;&gt;&gt;&gt; 显卡厂商 NVIDIA 推出的通用并行计算平台，它使得 GPU 能够解决并行的、复杂的计算问题。 CUDNN（ cuDNN） &gt;&gt;&gt;&gt; CUDA DNN 的缩写，它是 CUDA 平台深度神经网络的计算库。想要在 CUDA 上运行深度神经网络，就要安装 cuDNN。 ↓↓↓↓↓↓ 这里，需要注意一个问题（很重要）↓↓↓↓↓↓ 我们知道 TensorFlow 提供有丰富的版本支持，但 某一版本的 TensorFlow 只兼容特定版本的 CUDA 和 CUDNN。也就是说，我们选择安装的显卡并行计算平台（CUDA）、深度神经网络 GPU 计算库（CUDNN）以及 TensorFlow 的版本要相互兼容。 ↓↓↓↓↓↓ 关于 CUDA &amp;&amp; CuDNN &amp;&amp; TensorFlow 版本的选择问题 ↓↓↓↓↓↓ 可以根据官方实测过的【Tensorflow &amp;&amp; NVIDIA 版本信息对照表】进行选择，如下： [1] &gt;&gt;&gt;&gt; For Linux/macOS &gt;&gt;&gt;&gt; 【TF CPU/GPU】 [2] &gt;&gt;&gt;&gt; For Windows &gt;&gt;&gt;&gt; 【TF CPU/GPU】 关于服务器操作系统选择关于搭建 TensorFlow 深度学习开发环境的服务器（Server）的操作系统的选择，选择一个合适的 OS 可以帮我们减少很多的麻烦。 👇👇👇 Centos/Ubuntu Server Select 👇👇👇 | &gt;&gt;&gt;&gt; 1. Centos Server For Building TensorFlow ↓↓↓↓↓↓↓ 如果选择 Centos Server，那么我们的 Centos 版本最好选择 Centos7。Centos6 因为版本较低，其操作系统内置的库无法很好兼容 TensorFlow。虽可以解决，但会为安装带来更多的麻烦（可以通过升级一些运行时库得以解决）。 当然对于操作系统为 Centos6 的既有服务器，且不可以更换操作系统的安装需求，TF-CPU 中已经对解决方法做详细说明。 | &gt;&gt;&gt;&gt; 2. Ubuntu Server For Building TensorFlow ↓↓↓↓↓↓↓ 如果选择 Ubuntu Server（墙裂推荐），那么我们的 Ubuntu 版本最好是 Ubuntu 14.04/16.04/18.04。这里只是因为使用 Ubuntu14.04/16.04/18.04 的人较多，可以更好的帮我们解决安装以及使用 TensorFlow 过程中遇到的问题。 对于初学 TensorFlow 深度学习框架，仅仅想做做简单学习测试，强烈建议选择 Ubuntu！！！ 👇👇👇 Windows Platform 👇👇👇 一般情况下，Windows 平台下搭建 TensorFlow 深度学习框架仅作为简单学习使用，无法更高效利用软硬件资源。故，我们更应该关注基于 Liunx Server 搭建学习、开发环境。 Environment Lists基于以上，这里给出我的预安装环境准备： [1] &gt;&gt;&gt;&gt; 硬件环境说明 搭载 Nvidia GeForce GTX 970 独立显卡联想 ThinkCentre 商业主机； 搭载 3TB 硬盘用于存储数据以及 32GB（4 * 8GB）内存条； 四核心 Inter CORE I7 CPU； ThinkCentre 商用主机。 –&gt; 联想 ThinkCentre 商用主机搭载 Nvidia GTX 970 独立显卡时问题： 电源提供接口不够，购买电源转接线电源口 IDE 大 4D 芯一分二（4 pin公转母），显卡 6pin 转双大 4D。电源接线不够时，建议升级较大功率电源。 机箱主板空间较小无法安装索泰（ZOTAC）Nvidia GTX 970 独立显卡，购买 PCI-E 16X 显卡延长线。 购买 DVI 转 VGA24+5 Pin（显卡显示器高清视频转换接头）。 [2] &gt;&gt;&gt;&gt; 搭建环境说明 Ubuntu16.04 + Nvidia GeForce GTX 970 + CUDA8.0 + CUDNN5.1 + Tensorflow1.2.0 从这里开始，正式开始【TensorFlow GPU Support】深度学习环境的配置： 点亮 GPU &amp;&amp; Ubuntu首先，毋庸置疑的是可以成功点亮 &gt;&gt;&gt;&gt; 搭载了 GPU 独立显卡的 Ubuntu 服务器。 关于服务器操作系统，我们选择安装的是：Ubuntu16.04，具体的安装过程不赘述，网上有很多。 这里，有个需要注意的地方（很重要）&gt;&gt;&gt;&gt; 安装 Ubuntu16.04 系统时是否搭载（连接）GPU？！！ 也就是说，这里我们有两种安装方式可供选择： 第一种：直接在主板上搭载 GPU，显示器接 GPU 输出接口，然后完成 Ubuntu16.04 系统的点亮； 第二种：不搭载 GPU（拔掉）安装好 Ubuntu16.04 系统（此时显示器接主机 VGA 接口），关机后安装好 GPU 并将显示器接 GPU 输出接口。 👇👇👇 重点来了 👇👇👇 通常使用的是第一种安装方式，但默认的前提是 Ubuntu16.04 安装引导系统能够正常识别 GPU（系统中默认显卡驱动支持该型号 GPU）。否则，你会发现：使用 U 盘启动盘安装系统时无法进入 Ubuntu 安装引导界面，怎么重启都没用。 而一旦拔掉 GPU，显示器转接主机 VGA 接口后，重启可成功进入安装引导界面（集显正常）。此时，你就需要考虑第二种方法了。 没看懂，不要着急~~~ 故，搭建 TensorFlow [GPU Support] 环境第一步就是要解决系统显卡驱动问题： 显卡驱动根据安装 Ubuntu16.04 系统时是否搭载（连接）GPU，分为两种显卡驱动安装方式： [1] &gt;&gt;&gt;&gt; 搭载式安装 &lt;&lt;&lt;&lt; 对应上述第一种安装方式 [2] &gt;&gt;&gt;&gt; 非搭载式安装（推荐） &lt;&lt;&lt;&lt; 对应上述第二种安装方式 下面将针对上述两种安装方法，给出其显卡驱动安装的具体步骤。 查询系统显卡信息首先，你需要查询当前系统显卡信息，以获取显卡详细信息，检查显卡驱动版本是否合适 CUDA 运算。具体检测过程如下： 1 &gt;&gt;&gt;&gt; 搭载式安装（第一种） 如果直接搭载 GPU 独显的服务器使用 U 盘启动安装 Ubuntu16.04，成功点亮了系统（显示器接 GPU 显示引导界面），那么恭喜你，当前系统默认显卡驱动支持你的 GPU。（如果无法成功，请移步至【2 &gt;&gt;&gt;&gt; 非搭载式安装（第二种) 】） 成功点亮系统后，我们可以直接查询当前系统中 GPU 的详细信息： [1] &gt;&gt;&gt;&gt; 查询本机的显卡型号 因显卡一般接 PCI 接口，可以通过 lspci 查询显卡相关信息。一般我们可以查看到两种类型显卡：一块时集显；一块是独显。 1234567891011121314$ sudo lspci -vnn |grep VGA -A 1201:00.0 VGA compatible controller [0300]: NVIDIA Corporation GM206 [GeForce GTX 970] [10de:1401] (rev a1) (prog-if 00 [VGA controller]) Subsystem: ZOTAC International (MCO) Ltd. GM206 [GeForce GTX 970] [19da:1379] Flags: bus master, fast devsel, latency 0, IRQ 124 Memory at f6000000 (32-bit, non-prefetchable) [size=16M] Memory at e0000000 (64-bit, prefetchable) [size=256M] Memory at f0000000 (64-bit, prefetchable) [size=32M] I/O ports at e000 [size=128] Expansion ROM at 000c0000 [disabled] [size=128K] Capabilities: [60] Power Management version 3 Capabilities: [68] MSI: Enable+ Count=1/1 Maskable- 64bit+ Capabilities: [78] Express Legacy Endpoint, MSI 00 Capabilities: [100] Virtual Channel Capabilities: [258] L1 PM Substates | ================================= ↓↓↓↓↓ 显卡信息 ↓↓↓↓↓ ============================== | 独立显卡： 硬件厂商 NAVIDA（N卡）；型号名称 GM206（GeForce GTX 970） 集成显卡：这里由于直接是搭载 GPU 的服务器安装系统，无法查看到集显信息 | ================================================================================ | [2] &gt;&gt;&gt;&gt; 确认本机显卡驱动是否正常加载 12345678910111213$ sudo lshw -C display *-display description: VGA compatible controller product: GM206 [GeForce GTX 970] vendor: NVIDIA Corporation physical id: 0 bus info: pci@0000:01:00.0 version: a1 width: 64 bits clock: 33MHz capabilities: pm msi pciexpress vga_controller bus_master cap_list rom configuration: driver=nouveau latency=0 resources: irq:124 memory:f6000000-f6ffffff memory:e0000000-efffffff memory:f0000000-f1ffffff ioport:e000(size=128) memory:c0000-dffff 输出信息 configuration 字段中，如果 driver=“驱动名称” 不为空，说明系统支持该显卡的驱动。 我们可以看出，Ubuntu 系统支持 GTX 970 显卡且自动安装有一个默认的显卡驱动：nouveau（Linux 开源的显卡驱动）。 事实上，nouveau 驱动开发是很不完善的，我们需要重新安装适合显卡的（这里是 GTX960） Nvidia 显卡驱动才可以正常使用 TensorFlow 深度学习显卡加速。 到这里，你可以直接跳转到【Nvidia 显卡驱动安装】小节，接着完成后续的过程。 2 &gt;&gt;&gt;&gt; 非搭载式安装（第二种） 如果你采用第一种直接搭载 GPU 独显的服务器使用 U 盘启动安装 Ubuntu16.04，发现：无法进入 Ubuntu 安装引导界面，怎么重启都没用。而一旦拔掉 GPU，显示器转接主机 VGA 接口后，重启可成功进入安装引导界面。 此时，我们首先需要先拔掉 GPU，后将显示器转接主机 VGA 接口，安装 Ubuntu16.04。 成功点亮系统后，我们可以查询当前系统中 GPU（集显）的详细信息： [1] &gt;&gt;&gt;&gt; 查询本机的显卡型号 因显卡一般是 PCI 接口，可以通过 lspci 查询显卡相关信息。一般我们可以查看到两种类型显卡：一块时集显；一块是独显。 123456789101112deeplearning@ThinkCentre-M910s-N000:~$ lspci -vnn|grep VGA -A 1200:02.0 VGA compatible controller [0300]: Intel Corporation HD Graphics 630 [8086:5912] (rev 04) (prog-if 00 [VGA controller]) DeviceName: Onboard IGD Subsystem: Lenovo Device [17aa:3107] Flags: bus master, fast devsel, latency 0, IRQ 124 Memory at f6000000 (64-bit, non-prefetchable) [size=16M] Memory at e0000000 (64-bit, prefetchable) [size=256M] I/O ports at f000 [size=64] [virtual] Expansion ROM at 000c0000 [disabled] [size=128K] Capabilities: &lt;access denied&gt; Kernel driver in use: i915 Kernel modules: i915 这里只能查询到一块集显（未搭载独显）： | ================================= ↓↓↓↓↓ 显卡信息 ↓↓↓↓↓ ============================== | 集成显卡: 硬件厂商 Intel，型号名称 Corporation HD Graphics 630 | ================================================================================ | [2] &gt;&gt;&gt;&gt; 确认本机显卡驱动是否正常加载 1234567891011121314deeplearning@ThinkCentre-M910s-N000:~$ sudo lshw -C display[sudo] password for deeplearning: *-display description: VGA compatible controller product: HD Graphics 630 vendor: Intel Corporation physical id: 2 bus info: pci@0000:00:02.0 version: 04 width: 64 bits clock: 33MHz capabilities: pciexpress msi pm vga_controller bus_master cap_list rom configuration: driver=i915 latency=0 resources: irq:124 memory:f6000000-f6ffffff memory:e0000000-efffffff ioport:f000(size=64) memory:c0000-dffff 输出信息 configuration 字段中，如果 driver=“i915” 不为空，系统中集显驱动为：“i915”。 此时，先不要着急关机搭载 GPU！！！（如果你尝试关机后搭载 GPU，并将显示器接 GPU 输出接口同样会发现无法进入安装引导界面（系统中默认显卡驱动是不支持该型号 GPU的），故无法正常输出信号到显示器）。 ↓↓↓↓↓↓ 解决办法 ↓↓↓↓↓↓ 我们需要在安装好的系统中安装一个支持该型号 GPU 的先看驱动，接下文【Nvidia 显卡驱动安装】。 Nvidia 显卡驱动安装下面我们来看，如何为特定型号的 GPU 安装合适版本的 Nvidia 显卡驱动： 1 &gt;&gt;&gt;&gt; 查询适合的 Nvidia 驱动 首先打开以及登陆 &gt;&gt;&gt; Nvidia Driver 官网 &lt;&lt;&lt; 根据独立显卡型号查询适合自己显卡的驱动（以 GTX 980 Ti 为例）： 点击 SEARCH，查询显卡驱动信息： 2 &gt;&gt;&gt;&gt; 安装 Nvidia 驱动 查询到适用的 Nvidia 驱动版本后，开始安装 Nvidia 驱动 390.25： [1] &gt;&gt;&gt;&gt; 使用 PPA 安装 ↓↓↓↓↓↓ 1. 首先需要添加 ppa 仓库 ↓↓↓↓↓↓ 1$ sudo add-apt-repository ppa:graphics-drivers/ppa 第一次运行会出现如下的警告： 123456789101112131415161718Fresh drivers from upstream, currently shipping Nvidia.## Current StatusWe currently recommend: `nvidia-361`, Nvidia's current long lived branch.For GeForce 8 and 9 series GPUs use `nvidia-340`For GeForce 6 and 7 series GPUs use `nvidia-304`## What we're working on right now:- Normal driver updates- Investigating how to bring this goodness to distro on a cadence.- ## WARNINGS:This PPA is currently in testing, you should be experienced with packaging before you dive in here. Give us a few days to sort out the kinks.Volunteers welcome! See also: https://github.com/mamarley/nvidia-graphics-drivers/http://www.ubuntu.com/download/desktop/contribute更多信息： https://launchpad.net/~graphics-drivers/+archive/ubuntu/ppa按回车继续或者 Ctrl+c 取消添加 –&gt;【Enter】后继续： 12345678910# Enter 后显示如下信息表示添加成功：gpg: keyring `/tmp/tmp7b1tsfut/secring.gpg' createdgpg: keyring `/tmp/tmp7b1tsfut/pubring.gpg' createdgpg: requesting key 1118213C from hkp server keyserver.ubuntu.comgpg: /tmp/tmp7b1tsfut/trustdb.gpg: trustdb createdgpg: key 1118213C: public key &quot;Launchpad PPA for Graphics Drivers Team&quot; importedgpg: no ultimately trusted keys foundgpg: Total number processed: 1gpg: imported: 1 (RSA: 1)OK | ================================= ↓↓↓↓↓ 添加 PPA 仓库报错 ↓↓↓↓↓ ============================== | 如果添加 PPA 仓库报错的话，可以先 remove 掉，然后重新尝试： 12$ sudo add-apt-repository --remove ppa:graphics-drivers/ppa$ sudo add-apt-repository ppa:graphics-drivers/ppa | ======================================================================================== | ↓↓↓↓↓↓ 2. 更新本地 apt-get 源 ↓↓↓↓↓↓ 添加完 PPA 仓库，需要更新一下本地 apt-get 源，以检测添加的 PPA 仓库： 1$ sudo apt-get update ↓↓↓↓↓↓ 3. 识别显卡模型和查看源中推荐的驱动程序 ↓↓↓↓↓↓ 添加 PPA 仓库并且更新源后，先来识别显卡模型和查看源中推荐的驱动程序（如果采用非搭载式安装的话跳过）： 12345678910111213$ ubuntu-drivers devices== /sys/devices/pci0000:00/0000:00:01.0/0000:01:00.0 ==modalias : pci:v000010DEd00001401sv000019DAsd00001379bc03sc00i00model : GM206 [GeForce GTX 970]vendor : NVIDIA Corporationdriver : nvidia-415 - third-party freedriver : nvidia-384 - distro non-freedriver : nvidia-396 - third-party freedriver : nvidia-418 - third-party freedriver : nvidia-410 - third-party freedriver : xserver-xorg-video-nouveau - distro free builtindriver : nvidia-390 - third-party freedriver : nvidia-430 - third-party free recommended 为什么采用非搭载式安装的话跳过这里？？？非搭载式没有 GPU，查询无效，可直接选择【1 &gt;&gt;&gt;&gt; 查询适合的 Nvidia 驱动】中查询到的显卡驱动版本。 ↓↓↓↓↓↓ 4. 安装源中推荐的驱动程序 ↓↓↓↓↓↓ 首先你可以看到，PAA 仓库中提供有我们之前查询到的 390 版本的 Nvidia 驱动，你可以安装此版本。 当然，你也可以根据源中推荐的 Nvidia 版本进行安装（Recommended）。这里我的 GPU 为：GTX 970，故选择了 nvidia-384，它是支持 GTX 970 的一个稳定版本。 12345$ sudo apt-get install nvidia-384# 安装一些可能的依赖插件：$ sudo apt-get install mesa-common-dev$ sudo apt-get install freeglut3-dev 推荐阅读： 安装 Nvidia 驱动还有其它方法，但推荐使用 PPA 仓库安装 Nvidia 驱动，这是最简单的驱动安装方式。关于使用官方的驱动进行手动安装这里就不介绍了。 [2] &gt;&gt;&gt;&gt; 使显卡驱动生效 针对搭载式安装，直接重启： 1$ sudo reboot 如果采用非搭载式安装的话，上述驱动安装完成后，直接关机，然后搭载 GPU 并将显示器接 GPU 输出接口，便可发现已经可以进入系统了。 | =============================================== Split Line ================================================== | 安装好显卡驱动后就可以进行驱动测试了： [3] &gt;&gt;&gt;&gt; 确认安装的显卡驱动是否正常加载 12345678910111213$ sudo lshw -C display *-display description: VGA compatible controller product: GM206 [GeForce GTX 970] vendor: NVIDIA Corporation physical id: 0 bus info: pci@0000:01:00.0 version: a1 width: 64 bits clock: 33MHz capabilities: pm msi pciexpress vga_controller bus_master cap_list rom configuration: driver=nvidia latency=0 resources: irq:127 memory:f6000000-f6ffffff memory:e0000000-efffffff memory:f0000000-f1ffffff ioport:e000(size=128) memory:c0000-dffff 可以发现，driver=nvidia 表明安装成功。 [4] &gt;&gt;&gt;&gt; 查看显卡运行状态 123456789101112131415161718192021222324$ watch -n -1 nvidia-smi# 显示如下信息表示显卡驱动安装成功（Ctrl + c 可退出查看状态）： Sat Jun 2 17:03:40 2018 +-----------------------------------------------------------------------------+| NVIDIA-SMI 384.130 Driver Version: 384.130 ||-------------------------------+----------------------+----------------------+| GPU Name Persistence-M| Bus-Id Disp.A | Volatile Uncorr. ECC || Fan Temp Perf Pwr:Usage/Cap| Memory-Usage | GPU-Util Compute M. ||===============================+======================+======================|| 0 GeForce GTX 970 Off | 00000000:01:00.0 On | N/A || 36% 45C P8 11W / 120W | 3863MiB / 4036MiB | 3% Default |+-------------------------------+----------------------+----------------------+ +-----------------------------------------------------------------------------+| Processes: GPU Memory || GPU PID Type Process name Usage ||=============================================================================|| 0 1143 G /usr/lib/xorg/Xorg 94MiB || 0 2070 G compiz 42MiB || 0 18635 G /usr/lib/firefox/firefox 1MiB || 0 29337 C ...naconda3/envs/tensorflow-3.5/bin/python 3710MiB |+-----------------------------------------------------------------------------+ Nvidia 驱动升级对于已经安装了 Nvidia 显卡驱动的服务器，但其驱动版本过低。或者前面安装了不合适的 Nvidia 显卡驱动，无法正常使用新版本的 CUDA。 故，我们一般会将 Nvidia 显卡驱动更新到一个较新的版本。 前面我们已经知道如何安装全新的 Nvidia 显卡驱动，这里来看如何快速卸载服务器原有的显卡驱动程序： 1$ sudo apt-get --purge remove nvidia* 上述我们已经卸载了系统中的 Nvidia 显卡驱动，注意 &gt;&gt;&gt;&gt; 此时千万不能重启，重新电脑可能会导致无法进入系统，安装好新驱动后再重启！ 接下来我们需要根据章节【Nvidia 驱动驱动安装】完成新的 Nvidia 显卡驱动的安装。 Summary好奇么？驱动安装不是都已经结束了，怎么还有一小节？？？黑脸？！！、 –&gt; 总结一下： 前面我们知道了如何基于搭载 GPU 独显的服务器安装 Ubuntu16.04 ，然后安装适合版本的显卡驱动（搭载式）。 另外，我们还同时说明了非搭载式安装方法：先把 GPU 拿掉，然后在只有集显的服务器上先安装 Ubuntu16.04 ，接着按照章节【Nvidia 驱动驱动安装】安装 Nvidia 显卡驱动，然后 shutdown 关机安装上 GPU 后重启即可。 事实上，非搭载式安装方法可以帮助我们避免驱动安装中的很多麻烦。 👇👇👇 部署 CUDA &amp;&amp; cuDNN 👇👇👇 在开始 CUDA 和 cuDNN 的部署之前，你需要通过查看 Tensorflow &amp;&amp; NVIDIA 版本信息对照表 &gt;&gt;&gt; 见【CUDA &amp;&amp; CUDNN &amp;&amp; TF】中说明，选择和预安装和 TensorFlow [GPU Support] 版本兼容的 CUDA &amp;&amp; cuDNN 版本。 版本清单 &gt;&gt;&gt;&gt; TensorFlow v1.2.0 &amp;&amp; CUDA Toolkit v8.0 &amp;&amp; CuDNN v5.1。 部署 CUDA 8.0我选择使用的 TensorFlow 版本是：TensorFlow-gpu-1.2.0，所以需要安装 CUDA 8.0。 在安装 CUDA 之前，Google 了一下，发现在 Ubuntu 下安装 CUDA 8.0 非常常见，支持 GTX 970。 下面我们将以 CUDA 8.0 的安装为样例（其它版本 CUDA 安装类似）： 环境检测安装 CUDA 8.0 之前，请先确认系统中是否已安装有默认的 CUDA 版本？！！执行如下命令查看系统 CUDA 版本： 1234567891011$ nvcc -V# 输出如下信息表示当前系统已安装有 CUDA，安装目录见：/usr/local/nvcc: NVIDIA (R) Cuda compiler driverCopyright (c) 2005-2016 NVIDIA CorporationBuilt on Tue_Jan_10_13:22:03_CST_2017Cuda compilation tools, release 8.0, V8.0.61# 没有的话输出如下：The program 'nvcc' is currently not installed. You can install it by typing:sudo apt install nvidia-cuda-toolkit 如果有，可以跳转至【CUDA 卸载】章节，先卸载掉系统中已安装的 CUDA 版本，再开始下面的步骤。 Download CUDA下载 CUDA 需要注册和登陆 NVIDIA 开发者账号，CUDA8 下载页面提供了很详细的系统选择和安装说明。 这里，我们首先提供 &gt;&gt;&gt; 【CUDA 8.0 下载地址】，并且选择做如下平台设置（其它版本戳 这里）: 这里选择了 Ubuntu16.04 系统 Runfile 安装方案，千万不要选择 deb 方案，否则前方无数坑。 配置好平台设置后，进入下载界面。如下： 这里，只需下载 cuda_8.0.27_linux.run(1.4GB) 即可。 下载好的 cuda_8.0.27_linux.run 有 1.4G。下面按照 Nvidia 官方给出的方法安装 CUDA8： Setup CUDA1$ sudo sh cuda_8.0.27_linux.run --tmpdir=/opt/temp/ 这里加了 --tmpdir 主要是因为直接运行 sudo sh cuda_8.0.27_linux.run 可能会提示空间不足的错误（如下）。实际上是全新的电脑主机，硬盘足够大的（当报错后，你知道如何解决即可）。 1234Not enough space on parition mounted at /.Need 5091561472 bytes.Disk space check has failed. Installation cannot continue. –&gt; 执行 sh cuda_8.0.27_linux.run 后会有一系列提示让你确认，非常非常非常关键的地方是是否安装 361 这个低版本的驱动： 1Install NVIDIA Accelerated Graphics Driver for Linux-x86_64 361.62 ? 答案必须是 n，否则之前为 GTX960 安装的 nvidia-384 驱动就白费了，而且后续问题多多。 👇👇👇 详细安装步骤如下 👇👇👇 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061Logging to /opt/temp//cuda_install_6583.logUsing more to view the EULA.End User License Agreement--------------------------Preface-------The following contains specific license terms and conditionsfor four separate NVIDIA products. By accepting thisagreement, you agree to comply with all the terms andconditions applicable to the specific product(s) includedherein.Do you accept the previously read EULA?accept/decline/quit: acceptInstall NVIDIA Accelerated Graphics Driver for Linux-x86_64 361.62?(y)es/(n)o/(q)uit: nInstall the CUDA 8.0 Toolkit?(y)es/(n)o/(q)uit: yEnter Toolkit Location[ default is /usr/local/cuda-8.0 ]:Do you want to install a symbolic link at /usr/local/cuda?(y)es/(n)o/(q)uit: yInstall the CUDA 8.0 Samples?(y)es/(n)o/(q)uit: yEnter CUDA Samples Location[ default is /home/textminer ]:Driver: Not SelectedInstalling the CUDA Toolkit in /usr/local/cuda-8.0 ...Installing the CUDA Samples in /home/textminer ...Copying samples to /home/textminer/NVIDIA_CUDA-8.0_Samples now...Finished copying samples.============ Summary ============Driver: Not SelectedToolkit: Installed in /usr/local/cuda-8.0Samples: Installed in /home/textminerPlease make sure that- PATH includes /usr/local/cuda-8.0/bin- LD_LIBRARY_PATH includes /usr/local/cuda-8.0/lib64, or, add /usr/local/cuda-8.0/lib64 to /etc/ld.so.conf and run ldconfig as rootTo uninstall the CUDA Toolkit, run the uninstall script in /usr/local/cuda-8.0/binPlease see CUDA_Installation_Guide_Linux.pdf in /usr/local/cuda-8.0/doc/pdf for detailed information on setting up CUDA.***WARNING: Incomplete installation! This installation did not install the CUDA Driver. A driver of version at least 361.00 is required for CUDA 8.0 functionality to work.To install the driver using this installer, run the following command, replacing with the name of this run file:sudo .run -silent -driverLogfile is /opt/temp//cuda_install_6583.log 安装完成之后，不要清空终端！不要清空终端！不要清空终端！后面有用处。 👇👇👇 配置环境变量 👇👇👇 安装完毕后，需要再声明一下环境变量，并将其写入到 ~/.bashrc 的尾部: 12export PATH=/usr/local/cuda-8.0/bin:$PATHexport LD_LIBRARY_PATH=/usr/local/cuda-8.0/lib64:$LD_LIBRARY_PATH 更新 ~/.bashrc 配置文件： 1$ source ~/.bashrc 注意：如果是已经安装了 NVIDIA 和 CUDA 的云服务器环境，还需要添加环境变量才可以使用。 | =============================================== Split Line ================================================== | 如果环境变量设置错误，导致 系统PATH 值被覆盖了，这会导致 ls、make 等基本命令都用不了，提示 xxx: command not found。后来查阅资料，通过输入以下语句，可还原 PATH 变量值进行恢复（恢复至默认 PATH 值）： 1export PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin:/root/bin 至此，CUDA8.0 的部署其实已经完成了！！！但是请注意安装过程中这里可能有报错（missing recommended）： 👇👇👇 Problem：Missing Recommended 👇👇👇 123Driver: Not SelectedToolkit: Installed in /usr/local/cuda-8.0Samples: Installed in /home/textminer, but missing recommended 知道上面为什么不清空终端了吧~~~ 不会报错，不注意的话，会导致后续 CUDA 测试（ nbody 样例），如下： 123$ cd ~/NVIDIA_CUDA-8.0_Samples/5_Simulations/nbody $ make $ ./nbody 即在 CUDA 上运行 nbody 样例，make 部分发生报错： 1234567891011&gt;&gt;&gt; WARNING - libGLU.so not found, refer to CUDA Getting Started Guide for how to find and install them. &lt;&lt;&lt;&gt;&gt;&gt; WARNING - libX11.so not found, refer to CUDA Getting Started Guide for how to find and install them. &lt;&lt;&lt;&gt;&gt;&gt; WARNING - gl.h not found, refer to CUDA Getting Started Guide for how to find and install them. &lt;&lt;&lt;&gt;&gt;&gt; WARNING - glu.h not found, refer to CUDA Getting Started Guide for how to find and install them. &lt;&lt;&lt;&gt;&gt;&gt; WARNING - Xlib.h not found, refer to CUDA Getting Started Guide for how to find and install them. &lt;&lt;&lt;[@] /usr/local/cuda-8.0/bin/nvcc -ccbin g++ -I../../common/inc -m64 -ftz=true -gencode arch=compute_20,code=sm_20 -gencode arch=compute_30,code=sm_30 -gencode arch=compute_35,code=sm_35 -gencode arch=compute_37,code=sm_37 -gencode arch=compute_50,code=sm_50 -gencode arch=compute_52,code=sm_52 -gencode arch=compute_60,code=sm_60 -gencode arch=compute_60,code=compute_60 -o bodysystemcuda.o -c bodysystemcuda.cu[@] /usr/local/cuda-8.0/bin/nvcc -ccbin g++ -I../../common/inc -m64 -ftz=true -gencode arch=compute_20,code=sm_20 -gencode arch=compute_30,code=sm_30 -gencode arch=compute_35,code=sm_35 -gencode arch=compute_37,code=sm_37 -gencode arch=compute_50,code=sm_50 -gencode arch=compute_52,code=sm_52 -gencode arch=compute_60,code=sm_60 -gencode arch=compute_60,code=compute_60 -o nbody.o -c nbody.cpp[@] /usr/local/cuda-8.0/bin/nvcc -ccbin g++ -I../../common/inc -m64 -ftz=true -gencode arch=compute_20,code=sm_20 -gencode arch=compute_30,code=sm_30 -gencode arch=compute_35,code=sm_35 -gencode arch=compute_37,code=sm_37 -gencode arch=compute_50,code=sm_50 -gencode arch=compute_52,code=sm_52 -gencode arch=compute_60,code=sm_60 -gencode arch=compute_60,code=compute_60 -o render_particles.o -c render_particles.cpp[@] /usr/local/cuda-8.0/bin/nvcc -ccbin g++ -m64 -gencode arch=compute_20,code=sm_20 -gencode arch=compute_30,code=sm_30 -gencode arch=compute_35,code=sm_35 -gencode arch=compute_37,code=sm_37 -gencode arch=compute_50,code=sm_50 -gencode arch=compute_52,code=sm_52 -gencode arch=compute_60,code=sm_60 -gencode arch=compute_60,code=compute_60 -o nbody bodysystemcuda.o nbody.o render_particles.o -L/usr/lib/nvidia-367 -lGL -lGLU -lX11 -lglut[@] mkdir -p ../../bin/x86_64/linux/release[@] cp nbody ../../bin/x86_64/linux/release ↓↓↓↓↓↓ 解决方案 ↓↓↓↓↓↓ 从 make 报错信息中得知，缺少了一些编译库，下面我们来安装这些库文件： 123$ sudo apt-get install freeglut3-dev build-essential libx11-dev libxmu-dev libxi-dev libgl1-mesa-glx libglu1-mesa libglu1-mesa-dev libglfw3-dev libgles2-mesa-dev$ GLPATH=/usr/lib make –&gt; 成功之后会显示： 12345678910&gt; Windowed mode&gt; Simulation data stored in video memory&gt; Single precision floating point simulation&gt; 1 Devices used for simulationgpuDeviceInit() CUDA Device [0]: &quot;GeForce GTX 970&gt; Compute 6.1 CUDA device: [GeForce GTX 1080]number of bodies = 256000256000 bodies, total time for 10 iterations: 2291.469 ms= 286.000 billion interactions per second= 5719.998 single-precision GFLOP/s at 20 flops per interaction Test CUDA[1] &gt;&gt;&gt;&gt; 输出 CUDA 版本信息 1$ nvcc –V 信息显示如下： [2] &gt;&gt;&gt;&gt; 查询 GPU 信息 –&gt; 进入 cd NVIDIA_CUDA-8.0_Sample/1_Utilities/deviceQuery 目录： –&gt; 执行：make； –&gt; 执行：./deviceQuery 结果如下： [3] &gt;&gt;&gt;&gt; nbody 测试 nbody 测试见【Problem：Missing Recommended】中相关说明。 恭喜你~~~~ 至此，CUDA 部署已经完成！！！ Remove CUDA通过前面的介绍，我们了解了如何在服务器上安装 CUDA 应用。事实上，很多时候我们的服务器本身已经默认安装了某个版本的 CUDA，而搭建 TensorFlow For GPU Support 环境要求安装特定版本的 CUDA。 如果你无法确认系统中是否存在使用当前版本 CUDA 的应用时，不推荐卸载，为了尽量降低对原始系统的影响，你可以跳转至【CUDA 多版本管理】来解决问题。 ↓↓↓↓↓↓ 对于有卸载需求的，我们来看如何卸载服务器中已安装的 CUDA ↓↓↓↓↓↓ 分别针对 .deb 和 .run 两种不同的安装方式（卸载方法不同），这里提供两种方式来卸载系统原有的 CUDA： [1] &gt;&gt;&gt;&gt; .run 方法卸载 执行如下命令进行自动卸载（以 cuda-8.0 卸载为例）： 1$ sudo /usr/local/cuda-8.0/bin/uninstall_cuda-8.0.pl 有上述卸载文件 uninstall_cuda-8.0.pl 就说明是之前是用 .run 文件安装的，没有则是用 .deb 文件安装的，可以使用第二种方法进行卸载： [2] &gt;&gt;&gt;&gt; .deb 方法卸载 12345$ sudo apt-get remove cuda$ sudo apt-get autoclean$ sudo apt-get remove cuda* ↓↓↓↓↓↓ 清空残留文件 ↓↓↓↓↓↓ 最后，将当前目录切换至 /usr/local/ 下，查看是否还残留有未删除干净的 CUDA 相关文件： 12345$ cd /usr/local/$ ls% 存在残留文件则删除：sudo rm -rf cuda-8.0 接着来看 CUDNN 的下载与安装： 部署 CUDNN 5.1CUDNN 全称 CUDA Deep Neural Network library，是 NVIDIA 专门针对深度神经网络设计的一套 GPU 计算加速库，被广泛用于各种深度学习框架，例如 Caffe, TensorFlow, Theano, Pytorch, CNTK 等。 Download CuDNN从 Nvidia 官方 CuDNN 地址 下载链接选择一个期望版本，不过下载 cuDNN 前同样需要注册登录甚至填写一个简单的调查问卷，链接界面如下： 从中你可以选择适合操作系统的 CUDNN 计算加速库。 Setup CuDNN安装 CuDNN 比较简单，解压后把相应的文件拷贝到对应的 CUDA 目录下即可： 123456789101112$ tar -zxvf cudnn-8.0-linux-x64-v5.1.tgzcuda/include/cudnn.hcuda/lib64/libcudnn.socuda/lib64/libcudnn.so.5cuda/lib64/libcudnn.so.5.0.5cuda/lib64/libcudnn_static.a$ sudo cp cuda/include/cudnn.h /usr/local/cuda/include/$ sudo cp cuda/lib64/libcudnn* /usr/local/cuda/lib64/$ sudo chmod a+r /usr/local/cuda/include/cudnn.h$ sudo chmod a+r /usr/local/cuda/lib64/libcudnn* 可以发现，cuDNN 中的 5 个文件（全部），在 /usr/local/cuda/include/ &amp;&amp; /usr/local/cuda/lib64/ 中找不到相同文件： 12$ ls /usr/local/cuda/lib64/ |grep libcudnn$ ls /usr/local/cuda/include/ |grep cudnn 也就意味着：CuDNN 其实就是 CUDA 的扩展计算库，把 cuDNN 相关库文件添加 CUDA 里，不会对 CUDA 造成其他影响，即所谓的 插入式设计。这保证了当前系统环境中可以存在多个版本的 cuDNN。 CuDNN 的插入式设计 &gt;&gt;&gt;&gt; 帮助我们简单、快捷的实现 CuDNN 的升级或多版本管理： Update CuDNN这里，假设一下：上面我们已经完成了 cuDNN v5.1 for CUDA8.0 的安装。事实上，我们需要的是 cuDNN v6.0 for CUDA8.0 计算加速包，那么我们如何将 cuDNN 版本升级到 cuDNN v6.0 呢？？？ 其实很简单。下载 cuDNN v6.0 安装包 cudnn-8.0-linux-x64-v6.0.tgz、解压以及使用 cuDNN v6.0 库文件覆盖 CUDA 中的 cuDNN v5.1 库文件即可。详细步骤如下： 123456789101112131415$ tar -zxvf cudnn-8.0-linux-x64-v6.0.tgzcuda/include/cudnn.hcuda/lib64/libcudnn.socuda/lib64/libcudnn.so.6cuda/lib64/libcudnn.so.6.0.6cuda/lib64/libcudnn_static.a$ rm /usr/local/cuda/include/cudnn.h$ rm /usr/local/cuda/lib64/libcudnn*$ sudo cp cuda/include/cudnn.h /usr/local/cuda/include/$ sudo cp cuda/lib64/libcudnn* /usr/local/cuda/lib64/$ sudo chmod a+r /usr/local/cuda/include/cudnn.h$ sudo chmod a+r /usr/local/cuda/lib64/libcudnn* 至此，CUDA 8.0 以及 CUDNN 5.1 安装完成！！！接下来就可以开始 Tensorflow GPU Enabled 的安装了。 部署 TensorFlow-GPU这里，我们使用 Anaconda 的方式来部署 TensorFlow-GPU 深度学习环境。 1 &gt;&gt;&gt;&gt; Conda Envs install TensorFlow 通过 Anaconda 安装 Tensorflow 详细过程参见博文 &gt;&gt;&gt; 一文详解全平台 TensorFlow 深度学习框架在线搭建 (CPU&amp;GPU 支持) &lt;&lt;&lt; 【使用 Anaconda 安装】小节，篇幅原因不赘述。 对于其它方式的 TensorFlow 部署，可以参见博文中的其它章节。 2 &gt;&gt;&gt;&gt; TensorFlow 导入测试 正常情况，如果安装的 Python、TensorFlow、CUDA 、CUDNN 版本正确，import tensorflow as tf 时，无报错。 | ========================= ↓↓↓↓↓ CUDA &amp; CUDNN 与不相容版本的 TensorFlow 问题 ↓↓↓↓↓ ========================= | 以安装 tensorflow-gpu1.3 为例： 1libcudnn.so.6:cannot open sharedobjectfile:No such file or directory 根据错误代码，应该是找不到 libcudnn.so.6。 到指定文件夹下发现只有 5.0 和 8.0 的版本，没有 6.0，查找原因是因为当前已经是 1.3 版本，而 tensorflow-gpu1.3 已经开始去找 cudnn6 了（也就是说是用 cudnn6 编译的）… 故，需要换到 tensorflow-gpu1.2 版本，就解决问题了： 1234567891011# 先卸载掉之前安装的错误版本的 TensorFlow 环境，然后重新安装 ：$ pip uninstall tensorflow-gpu==1.3$ pip install tensorflow-gpu==1.2#或者# 直接移除整个 conda 虚拟环境，然后重新安装：$ conda remove –n tensorflow-3.5 –all$ conda create –n tensorflow-3.5 python=3.5$ source activate tensorflow-3.5$ pip install tensorflow-gpu==1.2 | ================================================================================================== | 3 &gt;&gt;&gt;&gt; GPU 运算测试 这里以一个简单的向量加法为例来测试 TensorFlow [GPU Support] 环境，测试代码如下（gpu_test.py）： 12345678910import tensorflow as tfa = tf.constant([1.0,2.0,3.0], shape=[3], name=”a”)b = tf.constant([1.0,2.0,3.0], shape=[3], name=”b”)result = a + b# 通过 log_device_placement 参数来输出运行每一个运算的设备：sess = tf.Session(config=tf.ConfigProto(log_device_placement=True))print (sess.run(result)) 结果输出信息如下： [3.1] &gt;&gt;&gt;&gt; 在没有 GPU 的机器上运行上述代码，可以得到如下输出： 1234Device mapping: no known devicesadd :/job:localhost/replica:0/task:0/cpu:0a : /job:localhost/replica:0/task:0/cpu:0b : /job:localhost/replica:0/task:0/cpu:0 [3.2] 配置好 GPU 环境的 TensorFlow 中，没有明确制定运行设备的话，TensorFlow 会优先选择 GPU 设备运行，会得到如下结果： 123456789101112Device mapping:/job:localhost/replica:0/task:0/gpu:0 -&gt; device: 0, name: GeForce GTX 960, pci bus id: 0000:01:00.02018-02-04 13:01:33.343286: I tensorflow/core/common_runtime/direct_session.cc:265] Device mapping:/job:localhost/replica:0/task:0/gpu:0 -&gt; device: 0, name: GeForce GTX 960, pci bus id: 0000:01:00.0add: (Add): /job:localhost/replica:0/task:0/gpu:02018-02-04 13:01:33.343948: I tensorflow/core/common_runtime/simple_placer.cc:847] add: (Add)/job:localhost/replica:0/task:0/gpu:0b: (Const): /job:localhost/replica:0/task:0/gpu:02018-02-04 13:01:33.343980: I tensorflow/core/common_runtime/simple_placer.cc:847] b: (Const)/job:localhost/replica:0/task:0/gpu:0a: (Const): /job:localhost/replica:0/task:0/gpu:02018-02-04 13:01:33.343997: I tensorflow/core/common_runtime/simple_placer.cc:847] a: (Const)/job:localhost/replica:0/task:0/gpu:0[2. 4. 6.] 自此，我们就完成了 Ubuntu16.04 + Nvidia GTX 970 + CUDA8.0 + CUDNN + Anaconda3 + Tensorflow1.2 深度学习环境搭建。 You Need Know More扩展阅读部分： NVIDIA 显卡相关[1] &gt;&gt;&gt;&gt; nvidia-smi 英伟达系统管理接口（NVIDIA System Management Interface, 简称 nvidia-smi），属于命令行管理组件，旨在帮助管理和监控 NVIDIA GPU 设备。 执行 nvidia-smi 命令可以查看当前系统安装的 NVIDIA 驱动信息以及 GPU 使用情况，显示如下： 12345678910111213141516171819$ root@Ubuntu:~# nvidia-smiThu Feb 28 15:50:39 2019 +-----------------------------------------------------------------------------+| NVIDIA-SMI 390.46 Driver Version: 390.46 ||-------------------------------+----------------------+----------------------+| GPU Name Persistence-M| Bus-Id Disp.A | Volatile Uncorr. ECC || Fan Temp Perf Pwr:Usage/Cap| Memory-Usage | GPU-Util Compute M. ||===============================+======================+======================|| 0 Tesla P4 On | 00000000:00:07.0 Off | 0 || N/A 30C P8 7W / 75W | 0MiB / 7611MiB | 0% Default |+-------------------------------+----------------------+----------------------+ +-----------------------------------------------------------------------------+| Processes: GPU Memory || GPU PID Type Process name Usage ||=============================================================================|| No running processes found |+-----------------------------------------------------------------------------+ 可以看出：驱动版本（NVIDIA-SMI 390.46）、显卡型号（Tesla P4）、内存（7611MiB：8G）以及 GPU 使用率（GPU-Util Compute M.： 0% Default）等。 nvidia-smi 配合 watch -n 一起使用，可用于查看 GPU 的实时动态使用情况： 1$ watch -n -1 nvidia-smi [2] &gt;&gt;&gt;&gt; lspci 查看服务器集成显卡信息： 12$ lspci | grep VGA00:02.0 VGA compatible controller: Cirrus Logic GD 5446 查看服务器 NVIDIA 显卡信息： 12$ lspci | grep NVIDIA00:07.0 3D controller: NVIDIA Corporation Device 1bb3 (rev a1) [3] &gt;&gt;&gt;&gt; 集显与独显的切换 NVIDIA 还提供了用于切换显卡的命令。例如，查看当前使用的显卡： 1$ sudo prime-select query 如何切换 nvidia 显卡： 1$ sudo prime-select nvidia 如何切换 intel 显卡： 1$ sudo prime-select intel CUDA 多版本管理事实上，很多情况下我们需要多个 CUDA 版本兼容存在于服务器系统中，并且可以很容易地在不同版本之间进行迅速切换。 请参见如下场景： 场景一 &gt;&gt;&gt; 多人共享使用当前服务器，由于使用的 TensorFlow 框架版本不同，所需要的 CUDA 版本也不同。此时，系统需要存在多个版本的 CUDA。 场景二 &gt;&gt;&gt; 之前搭建 TensorFlow 环境使用的是 CUDA8.0 和 cuDNN5.1，当我们需要在 TensorFlow 环境中兼容其它深度学习环境时（比如搭建 TensorFlow + Pytorch 环境），Pytroch GPU Support 可能需要更高版本的 CUDA 以及 cuDNN。此时，升级 CUDA 以及 cuDNN 版本以适应 TensorFlow + Pytorch 环境是必要的。 怎么办？？？卸载重装？？？ 这一章节，我们会以同时部署 cuda-8.0 和 cuda-9.0 版本为例进行说明： CUDA 多版本共存对于 cuda-8.0 和 cuda-9.0，无论先安装哪个版本，都一样。 上面已经安装过 cuda-8.0 了，这里，我们将扩展安装 cuda-9.0 版本： 1 &gt;&gt;&gt;&gt; Download &amp;&amp; Setup CUDA9.0 下载 CUDA 需要注册和登陆 NVIDIA 开发者账号。这里，我们首先给出 &gt;&gt;&gt; CUDA 版本库地址 &lt;&lt;&lt; 供选择下载期望版本的 CUDA 安装包，版本库页面如下： 通过 CUDA 版本库地址进入 CUDA9.0 下载页面： 可以看到这里提供了很详细的系统选择和安装说明，这里选择了 Ubuntu16.04 系统 Runfile 安装方案（千万不要选择 deb 方案，否则前方无数坑）。 下载完成之后，进入到 CUDA9.0 安装包（cuda_9.0.176_384.81_linux.run）所在目录运行如下命令即可开始进行安装，详细安装过程讲解如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071$ sudo sh cuda_9.0.176_384.81_linux.runUsing more to view the EULA.End User License Agreement--------------------------Preface-------The following contains specific license terms and conditionsfor four separate NVIDIA products. By accepting thisagreement, you agree to comply with all the terms andconditions applicable to the specific product(s) includedherein.# 接受安装协议：Do you accept the previously read EULA?accept/decline/quit: accept# 询问是否重新安装显卡驱动，这里一定要选择 `n`，否则最初安装的显卡驱动会被覆盖产生出错：Install NVIDIA Accelerated Graphics Driver for Linux-x86_64 384.81?(y)es/(n)o/(q)uit: nInstall the CUDA 9.0 Toolkit?(y)es/(n)o/(q)uit: y# 定义安装目录（一般默认回车即可，即安装在 `/usr/local/cuda-9.0` 目录下）,Enter Toolkit Location[ default is /usr/local/cuda-9.0 ]: # 询问是否将 `cuda-9.0` 安装目录通过软连接的方式 link 到 `/usr/local/cuda`？【 yes or no 】 均可。# 系统当前启用的 `cuda` 为哪个版本？取决于哪个版本的 CUDA 安装目录被链接到 `/usr/local/cuda` 上。# 对于首次安装 CUDA，肯定是需要建立软连接的（yes）；对于安装额外版本的 CUDA，【 yes or no 】 需要根据是否启动新版本 CUDA 决定。Do you want to install a symbolic link at /usr/local/cuda? (y)es/(n)o/(q)uit: n# 询问是否安装样例，可用于后续检测是否安装成功：Install the CUDA 9.0 Samples?(y)es/(n)o/(q)uit: n# 定义样例安装目录：Enter CUDA Samples Location[ default is /root ]: /home/textminer# *** 安装信息显示 **** #Driver: Not SelectedInstalling the CUDA Toolkit in /usr/local/cuda-9.0 ...Installing the CUDA Samples in /home/textminer ...Copying samples to /home/textminer/NVIDIA_CUDA-9.0_Samples now...Finished copying samples.============ Summary ============Driver: Not SelectedToolkit: Installed in /usr/local/cuda-9.0Samples: Installed in /home/textminerPlease make sure that- PATH includes /usr/local/cuda-9.0/bin- LD_LIBRARY_PATH includes /usr/local/cuda-9.0/lib64, or, add /usr/local/cuda-9.0/lib64 to /etc/ld.so.conf and run ldconfig as rootTo uninstall the CUDA Toolkit, run the uninstall script in /usr/local/cuda-9.0/binPlease see CUDA_Installation_Guide_Linux.pdf in /usr/local/cuda-9.0/doc/pdf for detailed information on setting up CUDA.***WARNING: Incomplete installation! This installation did not install the CUDA Driver. A driver of version at least 361.00 is required for CUDA 9.0 functionality to work.To install the driver using this installer, run the following command, replacing with the name of this run file:sudo .run -silent -driverLogfile is /opt/temp//cuda_install_6583.log 安装过程中是否创建 symbolic link 是关键。首次安装，选【yes】；安装额外的版本，选【no】。 2 &gt;&gt;&gt;&gt; 配置 CUDA 环境变量 在当前用户配置文件 ~/.bashrc 末尾添加如下内容： 123export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/cuda/lib64export PATH=$PATH:/usr/local/cuda/binexport CUDA_HOME=$CUDA_HOME:/usr/local/cuda 需要注意的是，这里配置的 CUDA 目录并不是特指 CUDA9.0 的安装目录，而是一个特殊的 CUDA 目录（不管 CUDA8.0/9.0/…）。这样做的好处你可以参见下一小节【CUDA 版本实时切换】。 自此，我们已经成功完成了 cuda-8.0 和 cuda-9.0 的安装。 下面我们来看如何迅速完成 CUDA 版本的切换： CUDA 版本实时切换通过上文可知，当我们安装了多个版本的 CUDA 之后，CUDA 一般会被安装到 /usr/local/ 目录（或你自己的自定义目录）下。查看一下当前目录下的文件： 123$ cd /usr/local$ lsbin cuda cuda-8.0 cuda-9.0 etc games ...... 上述 cuda-8.0 和 cuda-9.0 是系统中已安装的 CUDA 版本，而 cuda 就是我们上面创建的 symbolic link。 cuda 指向系统当前正在启用的 CUDA 版本 &gt;&gt;&gt; 方便了我们切换 CUDA 版本，可以让我们不用每次都去 ~/.bashrc 修改环境变量的值（cuda-8.0/-9.0/...）。 我们先来查看当前 cuda 软链接指向的哪个 cuda 版本: 123456789$ stat cuda File: 'cuda' -&gt; '/usr/local/cuda-8.0' Size: 19 Blocks: 0 IO Block: 4096 symbolic linkDevice: 807h/2055d Inode: 133904 Links: 1Access: (0777/lrwxrwxrwx) Uid: ( 0/ root) Gid: ( 0/ root)Access: 2019-02-28 10:44:36.494902702 +0800Modify: 2018-02-03 10:52:47.543432671 +0800Change: 2018-02-03 10:52:47.543432671 +0800 Birth: - 可以看到，cuda' -&gt; '/usr/local/cuda-8.0，此时系统当前正在启用的 CUDA 版本为 cuda-8.0。 那么，我们如何快速完成 cuda-9.0 的版本呢？其实很简单： 1234567891011121314151617# 1. 查看系统当前启用的 CUDA 版本：$ nvcc -Vnvcc: NVIDIA (R) Cuda compiler driverCopyright (c) 2005-2016 NVIDIA CorporationBuilt on Tue_Jan_10_13:22:03_CST_2017Cuda compilation tools, release 8.0, V8.0.61# 2. 从 `cuda8.0` 切换到 `cuda9.0`: $ rm -rf /usr/local/cuda$ sudo ln -s /usr/local/cuda-9.0/ /usr/local/cuda/# 查看切换后的CUDA 版本：$ nvcc --versionnvcc: NVIDIA (R) Cuda compiler driverCopyright (c) 2005-2016 NVIDIA CorporationBuilt on Tue_Jan_10_13:22:03_CST_2018Cuda compilation tools, release 9.0, V9.0.176 CUDNN 多版本管理事实上，关于 CUDNN 多版本共存和实时切换的问题，在【部署 CUDNN 5.1】章节中 &gt;&gt;&gt;&gt; 【Update CuDNN】小节以及解决，请参考上文。","link":"/2018/04/02/tensorflow-gpu-zhi-chi-ubuntu16-04-nvidia-gtx-cuda-cudnn/"},{"title":"How to Enable or Disable Memory Compression in Win10&#x2F;11","text":"Windows10 中 Memory Compression（内存压缩）进程内存占用过高，如何关闭内存压缩功能，降低内存占用？？？ 👇👇👇 The Operation Procedure Is As Follows 👇👇👇 Open an elevated PowerShell window（Run as an administrator）. To check if memory Compression is enabled or disabled, execute the following command: 1C:\\WINDOWS\\system32&gt; Get-MMAgent output info: If you see true against memory compression, it means that it is enabled. If you see false, it means that it is disabled. Execute the following command to disable Memory Compression: 1C:\\WINDOWS\\system32&gt; Disable-MMAgent -mc Execute the following command to enable Memory Compression: 1C:\\WINDOWS\\system32&gt; Enable-MMAgent –mc Hope this helps.","link":"/2017/05/07/how-to-enable-or-disable-memory-compression-in-win10-11/"},{"title":"Python 数据分析之 NumPy 数学计算库","text":"NumPy 是 Numerical Python 的缩写，它是 Python 语言的一个第三方数值计算库，用于弥补 Python 对多维数组和矩阵运算的支持。其地位斐然，是 Python 进行科学计算、数据分析以及机器学习的基础包，必须掌握不可！！！ 话不多说，一睹为快~~~ 更多 Python 数据分析扩展相关内容，请关注博主相关博文系列 ↓↓↓↓↓ 之一 &gt;&gt;&gt;&gt; Python 数据分析之 NumPy 数学计算库 之二 &gt;&gt;&gt;&gt; Python 数据分析之 Pandas 数据分析库 之三 &gt;&gt;&gt;&gt; Python 数据分析之 Matplotlib 数据可视化库 之四 &gt;&gt;&gt;&gt; Python 数据分析之 SciPy 科学计算化库 IntroductionNumPy（Numerical Python）是 Python 语言的一个扩展数值计算库，支持多维数组和矩阵运算，此外针对数组运算提供了大量的数学函数支持。再加上其底层主要用 C 语言编写，因此可以高速地执行数组与矩阵的数值计算。 见面知义，NumPy 是专门面向 Python 的数值计算库，其特点就在于 &gt;&gt;&gt; 扩充了 Python 对多维数组和矩阵运算的支持，提供了更丰富的数学函数。 👇👇👇 数组（Array）VS 矩阵（Matrix） 👇👇👇 ↓↓↓↓↓↓ 数组（Array） ↓↓↓↓↓↓ 数组（Array）是有限个、数据类型相同的元素，组成的元素序列； 数组（Array）中的每个元素都是数组的一个分量，都有一个对应的下标（索引）； ↓↓↓↓↓↓ 矩阵（Matrix） ↓↓↓↓↓↓ 矩阵（Matrix）是一个由实数或复数元素排列而成的长方阵列； 矩阵（Matrix）最早来自于方程组的系数以及常数构成的方阵。 ↓↓↓↓↓↓ 数组和矩阵的区别 ↓↓↓↓↓↓ 矩阵（Matrix）中的元素只能是数字，而数组（Array）中的元素还可以是字符串等； 矩阵（Matrix）是二维的，而数组（Array）可以是一维的、多维的； 矩阵（Matrix）显示时，元素之间无逗号；而数组（Array）显示时，元素之间用逗号隔开。 | =============================================== Split Line ================================================= | 👇👇👇 应用场景 👇👇👇 NumPy 通常与 SciPy（科学计算或算法库）、Pandas（数据分析库）和 Matplotlib（数据可视化库）一起使用，该组合广泛用于替代 MatLab，进行数据分析以及机器学习任务。 NumPy 知识点思维导图一览： Setup &amp;&amp; Import我们知道，NumPy 是 Python 的第三方扩展包，不包含在 Python 的内置库中，因此需要单独安装它。 ↓↓↓↓↓↓ 1. Setup ↓↓↓↓↓↓ NumPy 的安装方式也比较简单，直接使用 Python 的包管理器 pip 进行安装即可： 1$ pip install numpy 由于 NumPy 通常与 SciPy &amp;&amp; Pandas &amp;&amp; Matplotlib 库组合使用，它们均可以使用包管理器 pip 直接安装： 123$ pip install scipy$ pip install pandas$ pip install matplotlib 需要注意的是，Windows 下直接使用 pip install scipy 可能会发生依赖项报错问题，所以不推荐直接使用 Python 原生 pip 安装 SciPy 程序包。 推荐使用 Anaconda 科学计算平台提供的 Conda 工具进行安装（很好的解决 Windows 平台安装第三方包经常失败的场景），详情可参见 &gt;&gt;&gt; 【一文了解数据科学神器 Anaconda】。 ↓↓↓↓↓↓ 2. Import ↓↓↓↓↓↓ NumPy 使用前，可以根据使用情况选择 numpy 包的导入方式： 123456# 将整个模块导入import numpy# 方便模块使用（常用）import numpy as npfrom numpy import *from numpy import array, sin 之后的学习中，你可能还会在 Jupyter（或 IPython）中看到如下导入方式（Magic 指令）： 1234# 不推荐该导入方式：%pylabUsing matplotlib backend: &lt;object object at 0x000002849FB94E60&gt;Populating the interactive namespace from numpy and matplotlib 根据日志信息，发现该魔法指令同时导入了 numpy &amp;&amp; matplotlib，如何理解？！！官网有这样一段描述： 1pylab is a convenience module that bulk imports matplotlib.pyplot (for plotting) and numpy (for mathematics and working with arrays) in a single name space. Although many examples use pylab, it is no longer recommended. 这是 stackoverflow 上的解释 &gt;&gt;&gt; 【What is the difference between pylab and pyplot?】。 NumPy Ndarray 数组为什么说 NumPy 数组是对 Python 多维数组的扩展？？？Python 内建对象中，数组的两种形式： 列表：[1, 2, 3] 元组：(1, 2, 3, 4, 5) 可见，Python 标准类针对数组的直接处理局限于 1 维~~~ NumPy 数值计算库的核心特性 就是 &gt;&gt;&gt;&gt; 定义了一个 n 维数组对象，ndarray 对象。NumPy 数组也就是 ndarray 多维数组 &lt;&lt;&lt;&lt; 区别于 Python 标准库，NumPy 拥有对高维数组的直接处理能力。 Ndarray 对象结构解析通俗的来说： ndarray 数组是 &gt;&gt;&gt; 由 相同数据类型的元素 组成的元素序列，且每个元素均有一个对应下标（索引机制）。数组的索引机制将 元素序列都映射到内存块（连续的内存空间） 中，并按照一定的 布局方式（C-Order：行优先 &amp;&amp; Fortran-Order：列优先）对内存块进行排列。 你可以结合 ndarray 的内存布局示意图理解： 其中： dtype：数据类型 &gt;&gt;&gt; 指定了数组中每个元素占用多少个字节，这几个字节怎么解释（例如：int32、float32 等 NumPy 数据类型）； ndim（dim count）：数组维度（数值） &gt;&gt;&gt; 数组有多少维； shape（dimensions）：数组形状（元组） &gt;&gt;&gt; 每个维度上的元素数量； strides：维间距或步幅（元组） &gt;&gt;&gt; 到达当前维下一个相邻数据需要前进的字节数； data：数组所对应的元素序列（数据） &gt;&gt;&gt; 存放于连续的 Memory Block 中。 篇幅原因，关于 ndarray 对象的更进一步说明，可参见 &gt;&gt;&gt;&gt; 【一文解析 NumPy ndarray 多维数组结构设计】。 在创建 ndarray 多维数组之前，需要先了解一下数组中元素数值的数据类型支持，才能更合理、高效的创建和使用 NumPy 数组： NumPy 数据类型支持作为专门的数值计算库，NumPy 支持比 Python 更加丰富的数值类型（Number）： Num 数据类型 描述 1 bool_ 布尔型数据类型（True 或者 False），1 字节 2 int_ 默认整数类型，类似于 C 语言中的 long，取值为 int32 或 int64 3 intc 和 C 语言的 int 类型一样，一般是 int32 或 int 64 4 intp 用于索引的整数类型（类似于 C 的 ssize_t，通常为 int32 或 int64） 5 int8 代表 1 字节（8bit）整数（-128 ~ 127） 6 int16 代表 2 字节（16it）的整数 （-32768 ~ 32767） 7 int32 代表 4 字节（32bit）整数（-2147483648 ~ 2147483647） 8 int64 代表 8 字节（64bit）整数（-9223372036854775808 ~ 9223372036854775807） 9 uint8 代表 1 字节（8bit）无符号整数（0 ~ 255） 10 uint16 代表 2 字节（16it）无符号整数（0 ~ 65535） 11 uint32 代表 4 字节（32it）无符号整数（0 ~ 4294967295） 12 uint64 代表 8 字节（64it）无符号整数（0 ~ 18446744073709551615） 13 float_ float64 类型简写 14 float16 半精度浮点数，包括：1 个符号位，5 个指数位，10 个尾数位 15 float32 单精度浮点数，包括：1 个符号位，8 个指数位，23 个尾数位 16 float64 双精度浮点数，包括：1 个符号位，11 个指数位，52 个尾数位 17 complex_ complex128 类型简写 18 complex64 表示实部和虚部共享 32 位的复数 19 complex128 表示实部和虚部共享 64 位的复数 19 str_ 字符串类型 20 string_ 字节串类型 dtype Object事实上，上述所有的数据类型，均属于 NumPy 数据类型对象（Data Type Object）的实例，也称为 dtype Object 实例。 dtype 对象主要用来描述数组中元素的数据类型（整型、浮点或者 Python 对象）、数据大小（占用多少字节），以及字节顺序等。可以为 ndarray 数组中元素数值指定数据类型。其构建语法如下： 1numpy.dtype(object) 来看一个实例： 12345678910# 导入 NumPy 模块：import numpy as np# 构建一个 dtype 对象：dt= np.dtype(np.int64) # 或 dt= np.dtype('int64')print(dt) # 输出：dtype('int64')# 为一个 ndarray 对象指定数据类型（np.array 函数使用可参见后文）：a = np.array([1, 2, 3], dtype=dt) # np.array 函数的 dtype 参数可用于指定创建数组时的数据类型print(a) # 输出：array([1, 2, 3], dtype=int64) ↓↓↓↓↓↓ 如何检查 ndarray 数组的数据类型 ↓↓↓↓↓↓ NumPy 数组对象（ndarray）提供有一个名为 dtype 的属性，可返回 ndarray 数组的数据类型 12345import numpy as npa = np.array([1, 2, 3], dtype=np.int64)# 用于查看数组中元素的数据类型print(a.dtype) # 输出：dtype('int64') 数据类型字符标识Numpy 中数据类型都提供有一个唯一对应的 &gt;&gt;&gt;&gt; 字符标识码，码表如下： 字符 对应类型 b 代表布尔型 i 代表符号整型 u 代表无符号整型 f 代表浮点型 c 代表复数浮点型 m 代表时间间隔（timedelta） M 代表日期时间（datatime） O 代表 Python 对象 S,a 代表字节串 U 代表 Unicode 字符串 V 原始数据（void） 使用数据类型对应的字符标识码（字符标识码 + 字节数），可以更快捷地创建 dtype Object。如下（以 Int 为例，其它类似）： 12345678910111213141516171819import numpy as np# 等价于 dt = np.dtype(np.int32)dt = np.dtype('i4')# 甚至等价于 dt = np.dtype('int32')print(dt)# 输出：dtype('int32')# 等价于 dt = np.dtype(np.int64)dt = np.dtype('i8')# 甚至等价于 dt = np.dtype('int64')print(dt)# 输出：dtype('int64')# 等价于 dt = np.dtype(np.float32)dt = np.dtype('f4')# 甚至等价于 dt = np.dtype('float32')print(dt)# 输出：dtype('float32') 结构化数据类型先来看一个样例： 1234567891011import numpy as np# 使用 NumPy 内置数据类型 np.int64 创建 ndarray 数组：a = np.array([1, 2, 3], dtype=np.int64)print(a.dtype) # 输出：dtype('int64')b = np.array([4, 5, 6], dtype='float32')print(b.dtype) # 输出：dtype('float32')c = np.array([7, 8, 9], dtype='u2')print(c.dtype) # 输出：dtype('uint16') 最开始的实例中，我们使用 numpy.dtype 对象来为 ndarray 数组指定数据类型。而本节样例中发现可以使用更便捷的方式指定数组中元素的数据类型。 那么，这里产生一个问题 &gt;&gt;&gt;&gt; 使用 dtype 对象会使得 ndarray 数组的创建复杂度进一步提高。 事实上，我们更多的使用 dtype 对象在 定义结构化数据类型 的场景。 通过情况下， 结构化数据使用字段的形式来描述某个对象的特征。例如描述一位老师的姓名、年龄、工资的特征，该结构化数据（老师）其包含以下字段： name：string 字段 age：int 字段 salary：float 字段 那么，如何基于 dtype 对象 来定义上述结构化数据类型？！！如下（字段名 + 字段数据类型）： 1234567891011121314import numpy as np# 构造结构化数据类型 teacher：teacher = np.dtype([('name', 'S20'), ('age', 'i1'), ('salary', 'f4')])# teacher = np.dtype([('name', 'a20'), ('age', 'i1'), ('salary', 'f4')])print(teacher)# 输出：[('name', 'S20'), ('age', 'i1'), ('salary', '&lt;f4')]# 应用于 ndarray 数组对象：b = np.array([('ycs', 32, 6357.50),('jxe', 28, 6856.80)], dtype = teacher)print(b)# 输出：[(b'ycs', 32, 6357.5) (b'jxe', 28, 6856.8)]print(b.dtype)# 输出：dtype([('name', 'S20'), ('age', 'i1'), ('salary', '&lt;f4')]) ↓↓↓↓↓↓↓ 使用字段名获取数组中所有元素当前字段值列表 ↓↓↓↓↓↓↓ 123456789101112import numpy as npdt = np.dtype([('score','i1')])print(dt)# 输出：[('score', 'i1')]a = np.array([(60,), (75), (90)], dtype=dt)print(a)# 输出：[(60,) (75,) (90,)]print(a.dtype)# 输出：[('score', 'i1')]print(a['score'])# 输出：[60 75 90] 数据类型转换ndarray 数组对象提供了一个 astype 函数，用于创建数组副本，并将参数指定为数组副本的数据类型。 实例如下： 12345678910111213141516171819import numpy as nparr = np.array([1.1, 2.2, 3.3])print(arr.dtype)# float64newarr = arr.astype('i')print(newarr)# [1 2 3]print(newarr.dtype)# int32# 其它形式：newarr = arr.astype(np.int8)print(newarr.dtype)# int8newarr = arr.astype(np.dtype('int16'))print(newarr.dtype)int16 如果数组（列表、元组）中元素存在的字符串均为数值型字符串，是可以使用数值类型进行 ndarray 对象创建的，并且可以进行数值类型转化。 123456789import numpy as nparr_a = np.array([1.1, 2.2, 3.3, '5'], dtype='float32')print(arr_a)# [1.1 2.2 3.3 5. ]print(arr_a.dtype)# float32# ValueError: arr_a = np.array([1.1, 2.2, 3.3, 'a'], dtype='float32') 需要注意的是 &gt;&gt;&gt; 当占用字节较多的数据（int32）类型转化为较少字节数据（int8）类型时，如果数值超过小字节数据类型时，会被截断。 👇👇👇 关于 dtype Object 字节序 👇👇👇 字节顺序取决于数据类型的前缀是 &lt; 还是 &gt;。其中（看开口）： &lt; : 小端序(Small-Endian)：低地址存放低字节，高地址存放高字节； &gt; : 大端序(Big-Endian)：高地址存放低字节，低地址存放高字节. 来看一个实例： 1234567import numpy as npa = np.array([1, 2, 3], dtype='&gt;f4')print(a)# [1. 2. 3.]&gt;&gt;&gt; print(a.dtype)# &gt;f4 Ndarray 数组创建NumPy 中创建 ndarray 类型的方法主要有五类（常用高亮）： 从 Python 数组结构列表，元组等转换； 使用 NumPy 原生方法，例如：numpy.empty &amp;&amp; np.ones &amp;&amp; np.zeros &amp;&amp; np.arange 等； 从存储空间读取数组，例如文本或二进制文件； 使用字符串或缓冲区从原始字节中创建； 使用特殊函数，如 random。 下面分别来看这些常用的创建方法： 使用 Python 内置类型构建NumPy 中提供了一个 numpy.array 函数，可以将列表（List）或元组（Tuple）转化为 ndarray 数组。其语法格式如下： 1numpy.array(object, dtype=None, copy=True, order=None, subok=False, ndmin=0) 其中，参数（常用高亮）： object：列表、元组、矩阵； dtype：数组元素的数据类型（如果没有给出，将被确定为保持序列中的对象所需的最小类型）； ndmin：生成的数组应具有的最小维数，可根据需要预先设置维度； order：数组的内存布局，常见为 C-Order（行优先） &amp;&amp; Fortran-Order（列优先）；默认为 K，以尽可能接近数组元素在内存中出现的顺序； copy：布尔类型，默认 True，表示复制对象；否则，只有当 __array__ 返回副本，obj 是嵌套序列，或者需要副本来满足任何其他要求（dtype，顺序等）时，才会进行复制； subok：布尔类型，表示子类是否被传递，True 为（传递）；否则不传递，返回的数组将被强制为基类数组（默认）。 实例： 1234567891011121314151617181920212223242526272829303132333435&gt;&gt;&gt; import numpy as np# 一维数组：&gt;&gt;&gt; np.array([1, 2, 3])array([1, 2, 3])# 二维数组：&gt;&gt;&gt; np.array([[1, 2, 3], [4, 5, 6]])array([[1, 2, 3], [4, 5, 6]])&gt;&gt;&gt; np.array([(1, 2, 3), (4, 5, 6)])array([[1, 2, 3], [4, 5, 6]])# 最小维度为 2：&gt;&gt;&gt; np.array([1, 2, 3], ndmin=2)array([[1, 2, 3]])# 指定类型：&gt;&gt;&gt; np.array([1, 2, 3], dtype=np.float32)array([1., 2., 3.], dtype=float32)# 结构化类型数据：&gt;&gt;&gt; np.array([(1, 2), (3, 4)], dtype=np.dtype([('a', 'i1'), ('b', 'i4')]))array([(1, 2), (3, 4)], dtype=[('a', 'i1'), ('b', '&lt;i4')])&gt;&gt;&gt; np.array([(5, 6), (7, 8)], dtype=[('a', 'i1'), ('b', 'i4')])array([(5, 6), (7, 8)], dtype=[('a', 'i1'), ('b', '&lt;i4')])# 从子类创建数组（是否传递子类）：&gt;&gt;&gt; np.array(np.mat('1 2; 3 4'))array([[1, 2], [3, 4]])&gt;&gt;&gt; np.array(np.mat('1 2; 3 4'), subok=True)matrix([[1, 2], [3, 4]]) | ============================================== numpy.asarray ============================================== | 类似于 numpy.array，numpy.asarray 函数，也是将列表（List）或元组（Tuple）等序列转化为 ndarray 数组. 但其使用更为简单。语法格式如下： 1numpy.asarray(sequence，dtype=None，order=None) 其中，参数： sequence：列表、元组、嵌套列表或元组； dtype：数组元素的数据类型； order：数组的内存布局，参上。 实例如下： 123456789101112131415161718192021222324252627&gt;&gt;&gt; import numpy as np# Use List：&gt;&gt;&gt; list1 = [1, 2, 3, 4, 5]&gt;&gt;&gt; arr = np.asarray(list1)&gt;&gt;&gt; type(arr)&lt;class 'numpy.ndarray'&gt;&gt;&gt;&gt; arrarray([1, 2, 3, 4, 5])# Use Tuple：&gt;&gt;&gt; tuple1 = (6, 7, 8, 9, 0)&gt;&gt;&gt; arr = np.asarray(tuple1)&gt;&gt;&gt; type(arr)&lt;class 'numpy.ndarray'&gt;&gt;&gt;&gt; arrarray([6, 7, 8, 9, 0])&gt;&gt;&gt; list_tp = [(1, 2), (3, 4), (5, 6)]&gt;&gt;&gt; arr = np.asarray(list_tp)&gt;&gt;&gt; type(arr)&lt;class 'numpy.ndarray'&gt;&gt;&gt;&gt; arrarray([[1, 2], [3, 4], [5, 6]]) 👇👇👇 其它 as 方法 👇👇👇 NumPy 中还提供有其它以 as 开头的构建方法，可以将特定输入转化为数组、矩阵、标量等： asanyarray(a，dtype，order)：将特定输入转换为 ndarray； asfarray(a，dtype)：将特定输入转换为 float 类型的数组； asarray_chkfinite(a，dtype，order)：将特定输入转换为数组，并检查元素 NaN 或 infs； asmatrix(data，dtype)：将特定输入转换为矩阵； asscalar(a)：将大小为 1 的数组转换为标量。 使用 Numpy 原生方法构建根据生成数组中的元素是否有规律，将要介绍的原生方法分为三类： 通用数组：numpy.zeros &amp;&amp; numpy.ones &amp;&amp; numpy.full &amp;&amp; numpy.empty； 特殊数组：numpy.eye； 区间数组：numpy.arange &amp;&amp; numpy.linspace &amp;&amp; numpy.logspace。 1 &gt;&gt;&gt;&gt; 通用数组构建 ↓↓↓↓↓↓ 1.numpy.zeros ↓↓↓↓↓↓ numpy.zeros 函数用于 快速创建数值全部为 0 的多维数组（可同时指定数组的形状和类型），其语法格式如下： 1numpy.ones(shape, dtype=float, order='C') 其中，shape 是指数组的形状，即每一维度上的元素数量。默认类型为 float64，其它参数见上文说明。 实例： 123456789101112131415161718&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; arr = np.zeros((3, 2))# 默认类型为：`float64`&gt;&gt;&gt; arr.dtypedtype('float64')# 数组中元素值被初始化为：0&gt;&gt;&gt; arrarray([[0., 0.], [0., 0.], [0., 0.]])# 也可以使用自定义的数据类型构建：&gt;&gt;&gt; arr = np.zeros((3, 2), dtype=[('x', 'i1'), ('y', 'i1')])&gt;&gt;&gt; arrarray([[(0, 0), (0, 0)], [(0, 0), (0, 0)], [(0, 0), (0, 0)]], dtype=[('x', 'i1'), ('y', 'i1')]) ↓↓↓↓↓↓ 2.numpy.ones ↓↓↓↓↓↓ numpy.ones 函数和 numpy.zeros非常相似，唯一区别在于数组元素的初始值为 1，其语法格式如下： 1numpy.ones(shape, dtype=float, order='C') 参数说明见上文，实例如下： 12345678910111213141516&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; arr = np.ones((3, 2))# 默认类型为：`float64`&gt;&gt;&gt; arr.dtypedtype('float64')&gt;&gt;&gt; arrarray([[1., 1.], [1., 1.], [1., 1.]])# 也可以使用自定义的数据类型构建：&gt;&gt;&gt; arr = np.ones((2, 2), dtype=[('x', 'i1'), ('y', 'i1')])&gt;&gt;&gt; arrarray([[(1, 1), (1, 1)], [(1, 1), (1, 1)]], dtype=[('x', 'i1'), ('y', 'i1')]) ↓↓↓↓↓↓ 3.numpy.full ↓↓↓↓↓↓ 类似于 numpy.ones &amp;&amp; numpy.zeros，可用于 快速创建数值全部为 某固定值（fill_value）的多维数组（可同时指定数组的形状和类型），其语法格式如下： 1numpy.full(shape, fill_value, dtype=None, order='C') 参数说明见上文，实例如下： 1234567&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; arr = np.full((3, 2), 2)&gt;&gt;&gt; arrarray([[2, 2], [2, 2], [2, 2]]) ↓↓↓↓↓↓ 4.numpy.empty ↓↓↓↓↓↓ 类似于 numpy.ones &amp;&amp; numpy.zeros，区别是 &gt;&gt;&gt; 不会初始化数组中元素（垃圾值，无意义），它要求用户人为地给数组中的每一个元素赋值（谨慎使用）。 其语法格式如下： 1numpy.empty(shape, dtype=float, order='C') 参数说明见上文，实例如下： 123456789101112131415161718192021&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; arr = np.empty((2, 2))# 默认类型为：`float64`&gt;&gt;&gt; arr.dtypedtype('float64')&gt;&gt;&gt; arrarray([[0., 0.], [0., 0.]])# 指定数据类型：&gt;&gt;&gt; arr = np.empty((2, 2), dtype=int)&gt;&gt;&gt; arrarray([[-1036147843, -454467914], [ 740955874, 58203889]])# 指定类型为 Python 对象时，元素为 None&gt;&gt;&gt; arr = np.empty((2, 2), dtype=list)&gt;&gt;&gt; arrarray([[None, None], [None, None]], dtype=object) | =============================================== Split Line ================================================= | 2 &gt;&gt;&gt;&gt; 特殊数组构建 ↓↓↓↓↓↓ 1.numpy.eye ↓↓↓↓↓↓ numpy.eye 可用于创建一个特殊的二维数组，特点是 &gt;&gt;&gt; k 对角线上的值为 1，其余值全部为 0 &lt;&lt;&lt; 可理解为单位矩阵。 其语法格式如下： 1numpy.eye(N, M=None, k=0, dtype=&lt;type 'float'&gt;, order='C') 其中，参数：N 构造数组的行数；M 是构造数组的列数；而 k 是指主对角线上的值（默认为 1）。 123456&gt;&gt;&gt; arr = np.eye(4, 4)&gt;&gt;&gt; arrarray([[1., 0., 0., 0.], [0., 1., 0., 0.], [0., 0., 1., 0.], [0., 0., 0., 1.]]) | =============================================== Split Line ================================================= | 3 &gt;&gt;&gt;&gt; 区间数组构建 所谓的区间数组，是指 &gt;&gt;&gt;&gt; 数组元素的取值位于某个范围内，从而呈现一定的规律。 &lt;&lt;&lt;&lt; 例如：等比数列、递增、递减等。 ↓↓↓↓↓↓ 1.numpy.arange ↓↓↓↓↓↓ numpy.arange 函数的功能是 &gt;&gt;&gt; 按照步幅，在给定区间内创建一系列均匀间隔的值（前闭后开的）的 一维 等差数组。其语法格式如下： 1numpy.arange(start, stop, step, dtype=None) 其中，参数：start &amp;&amp; stop 表示元素区间取值范围（前闭后开 &gt;&gt;&gt; [start, stop)）；step 表示步长，值间隔。 实例如下： 123456789101112131415161718&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; arr = np.arange(8)# 默认数组类型是：int32&gt;&gt;&gt; arr.dtypedtype('int32')&gt;&gt;&gt; arr# 默认起始范围从 0 开始array([0, 1, 2, 3, 4, 5, 6, 7])&gt;&gt;&gt; arr = np.arange(1, 10, 2)&gt;&gt;&gt; arrarray([1, 3, 5, 7, 9])# 指定数组类型：&gt;&gt;&gt; arr = np.arange(1, 10, 2, np.float32)&gt;&gt;&gt; arrarray([1., 3., 5., 7., 9.], dtype=float32) ↓↓↓↓↓↓ 2.numpy.linspace ↓↓↓↓↓↓ numpy.linspace 函数的功能是 &gt;&gt;&gt; 按照分隔份数，返回均匀间隔的 一维 线性等分数组（等差），默认分隔为 50 份。语法格式如下： 1numpy.linspace(start, stop, num=50, endpoint=True, retstep=False, dtype=None) 其中，参数： start &amp;&amp; stop 用于表示元素区间取值范围起始； num 表示要生成的元素数量（份数）； endpoint：表示数列是否包含 stop 终止值（后闭？），默认为 True； retstep：表示生成的数组中是否显示公差项，默认为 False。 实例如下： 12345678910111213141516&gt;&gt;&gt; import numpy as np# 生成包含 10 个元素的一维等差数组：&gt;&gt;&gt; arr = np.linspace(1, 10, 10)&gt;&gt;&gt; arrarray([ 1., 2., 3., 4., 5., 6., 7., 8., 9., 10.])# 设置后开：&gt;&gt;&gt; arr = np.linspace(1, 10, 10, endpoint=False)&gt;&gt;&gt; arrarray([1. , 1.9, 2.8, 3.7, 4.6, 5.5, 6.4, 7.3, 8.2, 9.1])# 设置显示公差：&gt;&gt;&gt; arr = np.linspace(1, 2, 5, retstep=True)&gt;&gt;&gt; arr(array([1. , 1.25, 1.5 , 1.75, 2. ]), 0.25) ↓↓↓↓↓↓ 3.numpy.logspace ↓↓↓↓↓↓ 类似于 numpy.linspace，numpy.logspace 函数的功能是 &gt;&gt;&gt; 按照分隔份数，返回 一维 对数等分数组（等比），默认分隔为 50 份。语法格式如下： 1numpy.logspace(start, stop, num=50, endpoint=True, base=10.0, dtype=None) 其中，参数： start &amp;&amp; stop 用于表示元素区间取值范围起始； num 表示要生成的元素数量（份数）； endpoint：表示数列是否包含 stop 终止值（后闭？），默认为 True； base：设置 log 底值（公比），默认以 10 为底。 实例如下： 1234567891011121314&gt;&gt;&gt; import numpy as np# 生成包含 10 个元素的等比一维数组：&gt;&gt;&gt; arr = np.logspace(1.0, 2.0, num=10)&gt;&gt;&gt; arrarray([ 10. , 12.91549665, 16.68100537, 21.5443469 , 27.82559402, 35.93813664, 46.41588834, 59.94842503, 77.42636827, 100. ])# 生成包含 10 个元素的，公比为 2 的一维等比数组：&gt;&gt;&gt; arr = np.logspace(1, 10, num=10, base=2)&gt;&gt;&gt; arrarray([ 2., 4., 8., 16., 32., 64., 128., 256., 512., 1024.]) 使用其它方法构建NumPy 中还支持从字符串或缓冲区、文件以及函数中创建 ndarray 数组： fromstring(string, dtype, count, sep) &gt;&gt;&gt; 从字符串中创建 1 维数组； frombuffer(buffer) &gt;&gt;&gt; 将缓冲区转换为 1 维数组； fromiter(iterable, dtype, count) &gt;&gt;&gt; 从可迭代对象创建 1 维数组； fromfunction(function, shape) &gt;&gt;&gt; 通过函数返回值来创建多维数组； fromfile(file, dtype, count, sep) &gt;&gt;&gt; 从文本或二进制文件中构建多维数组。 Ndarray 数组属性了解了 ndarray 数组的数据类型支持以及常用构建方法之后，我们需要重新认识一下 ndarray 数组的常用属性。 开始前，首先构建一个二维 ndarray 数组，以便查看其属性： 12345678&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; arr = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])# 打印：&gt;&gt;&gt; arrarray([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) ↓↓↓↓↓↓ 数组元素数据类型 ↓↓↓↓↓↓ 12&gt;&gt;&gt; arr.dtypedtype('int32') ↓↓↓↓↓↓ 数组元素的实虚部 ↓↓↓↓↓↓ 1234567891011# 实部&gt;&gt;&gt; arr.realarray([[1, 2, 3], [4, 5, 6], [7, 8, 9]])# 虚部&gt;&gt;&gt; arr.imagarray([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) ↓↓↓↓↓↓ 数组元素总数 ↓↓↓↓↓↓ 12&gt;&gt;&gt; arr.size9 ↓↓↓↓↓↓ 数组每个元素所占字节数 ↓↓↓↓↓↓ 12&gt;&gt;&gt; arr.itemsize4 ↓↓↓↓↓↓ 数组中元素总字节数 ↓↓↓↓↓↓ 123456&gt;&gt;&gt; arr.nbytes36# 或者：&gt;&gt;&gt; arr.size * arr.itemsize36 ↓↓↓↓↓↓ 数组维度 ↓↓↓↓↓↓ 12&gt;&gt;&gt; arr.ndim2 ↓↓↓↓↓↓ 数组的形状 ↓↓↓↓↓↓ 数组的形状，是数组各维度上的元素个数： 12&gt;&gt;&gt; arr.shape(3, 3) ↓↓↓↓↓↓ 数组的维间距 ↓↓↓↓↓↓ 数组的维间距（步幅），到达当前维下一个相邻数据需要前进的字节数： 12&gt;&gt;&gt; arr.strides(12, 4) ↓↓↓↓↓↓ 数组的转置 ↓↓↓↓↓↓ 12345678910&gt;&gt;&gt; arr.Tarray([[1, 4, 7], [2, 5, 8], [3, 6, 9]])# 同 transpose 函数：&gt;&gt;&gt; arr.transpose()array([[1, 4, 7], [2, 5, 8], [3, 6, 9]]) ↓↓↓↓↓↓ 数组的内存信息 ↓↓↓↓↓↓ 返回 ndarray 数组的内存信息，例如：ndarray 数组的存储方式，以及是否是其他数组的副本等。 1234567891011&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; x = np.array([1, 2, 3, 4])&gt;&gt;&gt; x.flags C_CONTIGUOUS : True F_CONTIGUOUS : True OWNDATA : True WRITEABLE : True ALIGNED : True WRITEBACKIFCOPY : False UPDATEIFCOPY : False 篇幅原因，关于 ndarray 对象属性的更进一步说明，可参见 &gt;&gt;&gt;&gt; 【一文解析 NumPy ndarray 多维数组结构设计】。 Ndarray 数组维度和形状NumPy ndarray 数组中非常的重要的两个属性是 &gt;&gt;&gt; 数组的维度（N Dimensions） &amp;&amp; 形状（Shape）。 下面给出 1 至 3 维的 ndarray 数组的视图： 其中，1 维数组可以被看作数学中的向量（行向量/列向量），2 维数组可以看作是矩阵，而 3 维数组则是一个数据立方。 123456789101112131415161718&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; one_dim_arr = np.array([1, 2, 3, 4])&gt;&gt;&gt; one_dim_arrarray([1, 2, 3, 4])&gt;&gt;&gt; two_dim_arr = np.array([[1, 2, 3], [4, 5, 6]])&gt;&gt;&gt; two_dim_arrarray([[1, 2, 3], [4, 5, 6]])&gt;&gt;&gt; three_dim_arr = np.array([[[1, 2, 3], [3, 4, 5]], [[5, 6, 7], [7, 8, 9]]])&gt;&gt;&gt; three_dim_arrarray([[[1, 2, 3], [3, 4, 5]], [[5, 6, 7], [7, 8, 9]]]) 可以发现，对于多维数组（N）的显示结果和与列表（List）相同，每多嵌套一层，就代表多一个维度（凭借此你可以很轻易的判断出某个 ndarray 数组的维度）。 通过 shape 属性查看 NumPy ndarray 数组的形状： 12&gt;&gt;&gt; one_dim_arr.shape, two_dim_arr.shape, three_dim_arr.shape((4,), (2, 3), (2, 2, 3)) | ========================================= 👇👇👇 数组重塑 👇👇👇 =========================================== | 和类型一样，ndarray 数组构建之后，数组的维度和形状也是可变的 &gt;&gt;&gt; 数组重塑。 通常，我们所说的数组重塑，更多的指的是 &gt;&gt;&gt; 数组形状的变化 &lt;&lt;&lt; 维度可变，但少变（研究特定问题时）。 NumPy 中提供了一个简单的 numpy.ndarray.reshape 函数用于重塑 ndarray 数组的形状，其语法格式如下： 12345numpy.reshape(array, newShape, order='C')# 或：# 同理于 NumPy 中 reshape 方法，但更加方便：numpy.ndarray.reshape(newShape, order='C') 实例如下： 123456789101112131415161718&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; arr = np.array([1, 2, 3, 4, 5, 6])&gt;&gt;&gt; arrarray([1, 2, 3, 4, 5, 6])# Reshape &gt;&gt;&gt; (6, 1) -&gt; (3, 2)&gt;&gt;&gt; newarr = arr.reshape(3, 2)&gt;&gt;&gt; newarrarray([[1, 2], [3, 4], [5, 6]])# Reshape &gt;&gt;&gt; (6, 1) -&gt; (2, 3)&gt;&gt;&gt; newarr = arr.reshape(2, 3)&gt;&gt;&gt; newarrarray([[1, 2, 3], [4, 5, 6]]) 需要注意的是 &gt;&gt;&gt; 修改 ndarray 数组形状的时候， 不能改变数组中元素的个数。如上面数组的形状是 6 * 1（6），可以修改成 3 * 2（6） &amp;&amp; 2 * 3（6），修改后仍是 6 个。否则报错： 1ValueError: cannot reshape array of size 6 into shape (3,3) 关于数组维度的变化，等后续了解了多维数组轴（axis）之后再进行学习（将会在后续章节进行说明）。 Ndarray 数组索引和切片NumPy Ndarray 数组完整集成了 Python 对于数组的索引语法 array[obj] &gt;&gt;&gt; 并且，随着 obj 的不同，我们可以实现：元素访问、数组切片，以及其它 高级索引 功能。 数组索引类似于 Python List 的索引方式，你可以通过索引值（从 0 开始依次）来访问 Ndarray 中的特定位置的单个元素，也可以访问多维数组中的行、列、页。 👇👇👇 一维数组索引 👇👇👇 先来构建一个一维数组： 1234&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; arr1 = np.array([1, 2, 3, 4])&gt;&gt;&gt; arr1array([1, 2, 3, 4]) ↓↓↓↓↓↓ Picking an element ↓↓↓↓↓↓ 此时，你可以通过类似于 List &amp;&amp; Tuple 索引的方式，来获取单个元素的值： 123456# 获取第一个元素的值：&gt;&gt;&gt; arr1[0]1# 获取第三个元素的值：&gt;&gt;&gt; arr1[2]3 | =============================================== Split Line ================================================= | 👇👇👇 二维数组索引 👇👇👇 先来构建一个二维数组： 1234567&gt;&gt;&gt; arr2 = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])&gt;&gt;&gt; arr2array([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) ↓↓↓↓↓↓ Picking an element ↓↓↓↓↓↓ 二维数组可以看作一个矩阵（Matrix），矩阵中元素的位置由它所处的行（Row）和列（Column）组成。故，你需要通过索引 (Row, Col) 来获取数组中的单个元素： 1234567# 获取第 3 行，第 2 列对应的值：&gt;&gt;&gt; arr2[2, 1]8# 获取第 1 行，第 3 列对应的值：&gt;&gt;&gt; arr2[0, 2]3 ↓↓↓↓↓↓ Picking a row or column ↓↓↓↓↓↓ If we can supply a single index, it will pick a row (Row value) ： 123# 返回第三行元素组成的数组：&gt;&gt;&gt; arr2[2]array([7, 8, 9]) Numpy allows us to select a single columm as well: 123# 返回第二列元素组成的数组：&gt;&gt;&gt; arr2[:, 1]array([2, 5, 8]) 获取列的方法，要使用到切片（: &gt;&gt;&gt; is a full slice, from start to end）。 | =============================================== Split Line ================================================= | 👇👇👇 三维数组索引 👇👇👇 先来构建一个三维数组： 123456789101112131415&gt;&gt;&gt; arr3 = np.array([[[10, 11, 12], [13, 14, 15], [16, 17, 18]], [[20, 21, 22], [23, 24, 25], [26, 27, 28]], [[30, 31, 32], [33, 34, 35], [36, 37, 38]]])&gt;&gt;&gt; arr3array([[[10, 11, 12], [13, 14, 15], [16, 17, 18]], [[20, 21, 22], [23, 24, 25], [26, 27, 28]], [[30, 31, 32], [33, 34, 35], [36, 37, 38]]]) 三维数组，可以看作是由几个矩阵组成的堆（Stack），每一个矩阵均可看作是三维数组的页（Page）。 故数组中元素的位置由它所处的页（Page）、行（Row）和列（Column）组成。故，你需要通过索引 (Page, Row, Col) 来获取数组中的单个元素： 1234567# 获取第 3 页中，矩阵的第 1 行，第 2 列对应的值：&gt;&gt;&gt; arr3[2, 0, 1]31# 获取第 2 页中，矩阵的第 2 行，第 3 列对应的值：&gt;&gt;&gt; arr3[1, 1, 2]25 也就是说，第一个 index 选中某个矩阵，后两个 index 表示从选中的矩阵中确定某个元素。 ↓↓↓↓↓↓ Picking a row or column ↓↓↓↓↓↓ You can access any row or column in a 3D array. There are 3 cases： Case 1 - specifying the first two indices. In this case, you are choosing the page value (the matrix), and the row value (the row). This will select a specific row. In this example we are selecting row 2 from matrix 1: 123# 获取第 2 页中，矩阵的第 3 行：&gt;&gt;&gt; arr3[1, 2]array([26, 27, 28]) Case 2 - specifying the page value (the matrix), and the col value (the column), using a full slice (:) for the row value (the row). This will select a specific column. In this example we are selecting column 1 from matrix 0: 123# 获取第 1 页中，矩阵的第 2 列：&gt;&gt;&gt; arr3[0, : , 1]array([11, 14, 17]) Case 3 - specifying the j value (the row), and the k value (the column), using a full slice (:) for the i value (the matrix). This will create a row by taking the same element from each matrix. In this case we are taking row 1, column 2 from each matrix: 123# 获取由不同页（Page：1~3）中某位置（第 2 行，第 3 列）处元素组成的数组：&gt;&gt;&gt; arr3[:, 1, 2]array([15, 25, 35]) ↓↓↓↓↓↓ Picking a matrix ↓↓↓↓↓↓ Case 1 - If we only specify the page index, numpy will return the corresponding matrix. In this example we will request matrix 2: 12345# 获取第 3 页的矩阵：&gt;&gt;&gt; arr3[2]array([[30, 31, 32], [33, 34, 35], [36, 37, 38]]) Case 2 - if we specify just the row value (using a full slice for the page values) we will obtain a matrix made from the selected row taken from each plane. In this example we will take row 1: 12345# 获取由不同页（Page：1~3）中第 2 行元素组成的矩阵：&gt;&gt;&gt; arr3[:, 1]array([[13, 14, 15], [23, 24, 25], [33, 34, 35]]) Case 3 - if we specify just the k value (using full slices for the i and j values) we will obtain a matrix made from the selected column taken from each plane. In this example we will take column 0（取到的元素以行的形式排列）: 12345# 获取由不同页（Page：1~3）中第 3 列元素组成的矩阵：&gt;&gt;&gt; arr3[:, :, 0]array([[10, 13, 16], [20, 23, 26], [30, 33, 36]]) 对于四维以上的多维数组的索引方式同理，这里就不再介绍。 数组切片You can slice a numpy array is a similar way to slicing a list - except you can do it in more than one dimension. 👇👇👇 一维数组切片 👇👇👇 Slicing a 1D numpy array is almost exactly the same as slicing a list: 1234567&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; arr1 = np.array([1, 2, 3, 4, 5])# 切片获取索引为 2 ~ 4 直接的所有元素：&gt;&gt;&gt; b = arr1[1:4]&gt;&gt;&gt; barray([2, 3, 4]) The only thing to remember if that (unlike a list) arr1 and b are both looking at the same underlying data (b is a view of the data). So if you change an element in b, arr1 will be affected (and vice versa): 12345&gt;&gt;&gt; b[1] = 10&gt;&gt;&gt; barray([ 2, 10, 4])&gt;&gt;&gt; arr1array([ 1, 2, 10, 4, 5]) | =============================================== Split Line ================================================= | 👇👇👇 二维数组切片 👇👇👇 You can slice a 2D array in both axes to obtain a rectangular subset of the original array. For example: 123456789101112&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; arr2 = np.array([[10, 11, 12, 13, 14], [15, 16, 17, 18, 19], [20, 21, 22, 23, 24], [25, 26, 27, 28, 29]])# 切片获取第 2 行后所有行，且第 3 ~ 4 列的元素组成的数组：&gt;&gt;&gt; arr2[1:, 2:4]array([[17, 18], [22, 23], [27, 28]]) This selects rows 1: (1 to the end of bottom of the array) and columns 2:4 (columns 2 and 3). | =============================================== Split Line ================================================= | 👇👇👇 三维数组切片 👇👇👇 You can slice a 3D array in all 3 axes to obtain a cuboid subset of the original array: 123456789101112&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; arr3 = np.array([[[10, 11, 12], [13, 14, 15], [16, 17, 18]], [[20, 21, 22], [23, 24, 25], [26, 27, 28]], [[30, 31, 32], [33, 34, 35], [36, 37, 38]]])# 切片获取 0 ~ 1 页中，第 2 行后所有行，且第 1 ~ 2 列的元素组成的数组：&gt;&gt;&gt; arr3[:2, 1:, :2]array([[[13, 14], [16, 17]], [[23, 24], [26, 27]]]) This selects: page :2 (the first 2 planes) ；rows 1: (the last 2 rows) ；columns :2 (the first 2 columns). 数组高级索引NumPy 中还提供了使用高级索引方式：整数数组索引、布尔索引，以及花式索引。 需要注意的是 &gt;&gt;&gt; 高级索引返回的是数组的副本（深拷贝），而切片操作返回的是数组视图（浅拷贝）！！！副本和视图的概念可参考【一文解析 NumPy ndarray 多维数组结构设计】。 高级索引中，最常见的就是整数数组索引： 👇👇👇 整数数组索引 👇👇👇 依次看一下一维、二维数组的整数数组索引方式，然后推导 N 维数组： ↓↓↓↓↓↓ 1D Array ↓↓↓↓↓↓ 使用整数数组索引可以同时获取多个索引的元素值： 1234&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; arr1 = np.arange(10)&gt;&gt;&gt; arr1array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) 相较于单个元素索引方式 &gt;&gt;&gt; 多加了一层 []，使用逗号隔开 12&gt;&gt;&gt; arr1[[1, 3, 5]]array([1, 3, 5]) ↓↓↓↓↓↓ 2D Array ↓↓↓↓↓↓ 二维数组获取普通索引值和一维不太一样，由两个维度（Row, Col）构成。 故访问二维 Ndarray 中的多个元素值，需要多加一个 []，分别表示行索引数组、列索引数组： 123456789101112&gt;&gt;&gt; arr2 = np.array([[ 0, 1, 2, 3, 4], [ 5, 6, 7, 8, 9], [10, 11, 12, 13, 14], [15, 16, 17, 18, 19]])&gt;&gt;&gt; arr2array([[ 0, 1, 2, 3, 4], [ 5, 6, 7, 8, 9], [10, 11, 12, 13, 14], [15, 16, 17, 18, 19]])&gt;&gt;&gt; arr2[[1, 2, 3], [0, 2, 4]]array([ 5, 12, 19]) 其中，行索引数组：[1, 2, 3] &amp;&amp; 列索引数组：[0, 2, 4]。将行、列索引组合会得到 (1, 0) &amp;&amp; (2, 2) &amp;&amp; (3, 4)，它们分别对应着输出元素值在原数组中的索引位置。 完成实例：获取上述 4*5 数组中的四个角上元素，它们对应的行索引是 [0,0] 和 [3,3]，列索引是 [0,4] 和 [0,4]: 123456789&gt;&gt;&gt; row_two = np.array([[0, 0], [3, 3]])&gt;&gt;&gt; col_two = np.array([[0, 4], [0, 4]])&gt;&gt;&gt; arr2[row_two, col_two]array([[ 0, 4], [15, 19]])# 或者：&gt;&gt;&gt; arr2[[0, 0, 3, 3], [0, 4, 0, 4]]array([ 0, 4, 15, 19]) 更复杂一点，你可以将切片使用的 : 或省略号 ... 与整数数组索引结合使用： 1234567891011121314151617181920212223242526272829import numpy as np&gt;&gt;&gt; arr2 = np.array([[ 0, 1, 2],... [ 3, 4, 5],... [ 6, 7, 8],... [ 9, 10, 11]])&gt;&gt;&gt; arr2array([[ 0, 1, 2], [ 3, 4, 5], [ 6, 7, 8], [ 9, 10, 11]])# 2D Slice：&gt;&gt;&gt; arr2[1:4, 1:3]array([[ 4, 5], [ 7, 8], [10, 11]])# 行使用基础索引，对列使用高级索引&gt;&gt;&gt; arr2[1:4, [1, 2]]array([[ 4, 5], [ 7, 8], [10, 11]])# 对行使用省略号&gt;&gt;&gt; arr2[..., 1:]array([[ 1, 2], [ 4, 5], [ 7, 8], [10, 11]]) ↓↓↓↓↓↓ 3D Array ↓↓↓↓↓↓ 思考一下，三维数组的整数数组高级索引是什么情况？？？ 先分析，我们知道 3D 数组通过索引 (Page, Row, Col) 来获取数组中的单个元素。 故，相较于二维数组，需要多加一个 []，分别表示 &gt;&gt;&gt; 页索引数组、行索引数组、列索引数组，测试一下： 12345678910111213&gt;&gt;&gt; arr3 = np.arange(12).reshape(3, 2, 2)&gt;&gt;&gt; arr3array([[[ 0, 1], [ 2, 3]], [[ 4, 5], [ 6, 7]], [[ 8, 9], [10, 11]]])&gt;&gt;&gt; arr3[[0, 1], [0, 1], [0, 1]]array([0, 7]) 果然~~~ ↓↓↓↓↓↓ ND Array ↓↓↓↓↓↓ 所以，对于更高维的数组，多一层维度就加一个 []，表示新增维度。 | =============================================== Split Line ================================================= | 👇👇👇 布尔数组索引 👇👇👇 我们可以通过建立一个布尔数组来索引目标数组，通过数组的逻辑运算作为索引，以此找出与布尔数组中值为 True 所对应目标数组中的数据。 以一个二维数组为例来看具体应用： 12345678910111213141516171819&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; arr = np.array([[ 0, 1, 2],[ 3, 4, 5],[ 6, 7, 8],[ 9, 10, 11]])&gt;&gt;&gt; arrarray([[ 0, 1, 2], [ 3, 4, 5], [ 6, 7, 8], [ 9, 10, 11]])# 数组的逻辑运算结果：&gt;&gt;&gt; arr &gt; 6array([[False, False, False], [False, False, False], [False, True, True], [ True, True, True]])# 查找出满足逻辑运算结果为 True 的索引，所对应的数组元素：&gt;&gt;&gt; arr[arr &gt; 6]array([ 7, 8, 9, 10, 11]) 具体的应用场景 &gt;&gt;&gt; ↓↓↓↓↓↓ 匹配筛选 ↓↓↓↓↓↓ 布尔索引可以实现 &gt;&gt;&gt; 通过列向量中的每个元素的布尔型数值对一个与列向量有着同样行数的矩阵进行符合匹配。而这样的作用，其实是把列向量中布尔值为 True 的相应行向量给抽取了出来。 1234567891011121314151617181920212223&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; names = np.array(['Bob', 'Joe', 'Will', 'Bob', 'Will', 'Joe', 'Joe'])&gt;&gt;&gt; namesarray(['Bob', 'Joe', 'Will', 'Bob', 'Will', 'Joe', 'Joe'], dtype='&lt;U4')&gt;&gt;&gt; print(names == 'Joe')[False True False False False True True]&gt;&gt;&gt; data = np.random.randn(7, 4)&gt;&gt;&gt; dataarray([[ 1.37105726, 0.643821 , -0.04952524, 0.87843288], [-0.73402717, 1.16743508, 1.96971901, -0.961953 ], [ 0.52256989, 1.09314884, -1.05628438, 0.61548645], [ 0.80319287, 0.7778842 , 0.64672434, -0.07293975], [ 1.19837729, 0.37055356, 0.7436583 , 1.43116524], [-0.95453104, 0.01908647, -0.19713538, -0.86226891], [-1.23236429, 1.60928 , 1.27864806, 1.85035932]])# 通过数组的逻辑运算作为索引，筛选出布尔值为 True 所对应目标数组中的数据：&gt;&gt;&gt; data[names == 'Joe']array([[-0.73402717, 1.16743508, 1.96971901, -0.961953 ], [-0.95453104, 0.01908647, -0.19713538, -0.86226891], [-1.23236429, 1.60928 , 1.27864806, 1.85035932]]) ↓↓↓↓↓↓ 布尔型数组的切片用法 ↓↓↓↓↓↓ 1234567&gt;&gt;&gt; data[names == 'Joe', 2:]array([[ 1.96971901, -0.961953 ], [-0.19713538, -0.86226891], [ 1.27864806, 1.85035932]])&gt;&gt;&gt; data[names == 'Joe', 3]array([-0.961953 , -0.86226891, 1.85035932]) ↓↓↓↓↓↓ 布尔条件否定用法 ↓↓↓↓↓↓ 如果要选择除 Joe 以外的其他值，可以使用 != 或 ~ 对逻辑运算条件进行否定： 1234567891011121314&gt;&gt;&gt; names != 'Joe'array([ True, False, True, True, True, False, False])&gt;&gt;&gt; data[names != 'Joe']array([[ 1.37105726, 0.643821 , -0.04952524, 0.87843288], [ 0.52256989, 1.09314884, -1.05628438, 0.61548645], [ 0.80319287, 0.7778842 , 0.64672434, -0.07293975], [ 1.19837729, 0.37055356, 0.7436583 , 1.43116524]])&gt;&gt;&gt; data[~(names == 'Joe')]array([[ 1.37105726, 0.643821 , -0.04952524, 0.87843288], [ 0.52256989, 1.09314884, -1.05628438, 0.61548645], [ 0.80319287, 0.7778842 , 0.64672434, -0.07293975], [ 1.19837729, 0.37055356, 0.7436583 , 1.43116524]]) ↓↓↓↓↓↓ 多布尔条件用法 ↓↓↓↓↓↓ 用 &amp; , 或用 | 来选择满足多个布尔条件（Python 中的 and 和 or 在布尔数组中无效）: 12345678910&gt;&gt;&gt; mask = (names == 'Bob') | (names == 'Joe')&gt;&gt;&gt; maskarray([ True, True, False, True, False, True, True])&gt;&gt;&gt; data[mask]array([[ 1.37105726, 0.643821 , -0.04952524, 0.87843288], [-0.73402717, 1.16743508, 1.96971901, -0.961953 ], [ 0.80319287, 0.7778842 , 0.64672434, -0.07293975], [-0.95453104, 0.01908647, -0.19713538, -0.86226891], [-1.23236429, 1.60928 , 1.27864806, 1.85035932]]) ↓↓↓↓↓ 修改满足布尔条件数组的值 ↓↓↓↓↓↓ 12345678910111213141516171819&gt;&gt;&gt; data[data &lt; 0] = 0&gt;&gt;&gt; dataarray([[1.37105726, 0.643821 , 0. , 0.87843288], [0. , 1.16743508, 1.96971901, 0. ], [0.52256989, 1.09314884, 0. , 0.61548645], [0.80319287, 0.7778842 , 0.64672434, 0. ], [1.19837729, 0.37055356, 0.7436583 , 1.43116524], [0. , 0.01908647, 0. , 0. ], [0. , 1.60928 , 1.27864806, 1.85035932]])&gt;&gt;&gt; data[names != 'Bob'] = 8&gt;&gt;&gt; dataarray([[1.37105726, 0.643821 , 0. , 0.87843288], [8. , 8. , 8. , 8. ], [8. , 8. , 8. , 8. ], [0.80319287, 0.7778842 , 0.64672434, 0. ], [8. , 8. , 8. , 8. ], [8. , 8. , 8. , 8. ], [8. , 8. , 8. , 8. ]]) | =============================================== Split Line ================================================= | 👇👇👇 花式索引 👇👇👇 花式索引也可以理解为整数数组索引，但是它们之间又略有不同。实例代码如下： 123456789101112131415161718192021222324252627282930313233343536&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; arr = np.arange(32).reshape((8, 4))&gt;&gt;&gt; arrarray([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11], [12, 13, 14, 15], [16, 17, 18, 19], [20, 21, 22, 23], [24, 25, 26, 27], [28, 29, 30, 31]])# 索引数组的元素值与被索引数组的每一行相对应：&gt;&gt;&gt; arr[[4, 2, 1, 7]]array([[16, 17, 18, 19], [ 8, 9, 10, 11], [ 4, 5, 6, 7], [28, 29, 30, 31]])# 倒序索引数组（取行）：&gt;&gt;&gt; arr[[-4, -2, -1, -7]]array([[16, 17, 18, 19], [24, 25, 26, 27], [28, 29, 30, 31], [ 4, 5, 6, 7]])# 多个索引数组的情况下，需要使用 `np.ix_`&gt;&gt;&gt; arr[np.ix_([1, 5, 7, 2], [0, 3, 1, 2])]array([[ 4, 7, 5, 6], [20, 23, 21, 22], [28, 31, 29, 30], [ 8, 11, 9, 10]])# 其中 [1,5,7,2] 代表行索引，而 [0,3,1,2] 表示与行索引相对应的列索引值，也就是行中的元素值会按照列索引值排序。# 比如，第一行元素，未排序前的顺序是 [4,5,6,7]，经过列索引排序后变成了 [4,7,5,6]。 自此，你已经完成了 NumPy ndarray 多维数组的基础部分内容学习。在开始后续的学习之前，强烈建议阅读 &gt;&gt;&gt;&gt;【一文解析 NumPy ndarray 多维数组结构设计】一文，可以帮助你更好的理解 ndarray 数组，方便后续内容的学习。 Ndarray 数组遍历类似于 Python 内置数组（Tuple &amp;&amp; List…）遍历，你也可以遍历访问 Ndarray 数组中元素： 通用遍历方法同样类似于 Python 中 List 等序列的遍历方法，使用 for 循环实现 Ndarray 数组元素的遍历： 👇👇👇 一维数组 👇👇👇 12345678910111213&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; one_arr = np.arange(5)&gt;&gt;&gt; one_arrarray([0, 1, 2, 3, 4])&gt;&gt;&gt; for item in one_arr:... print(item)...01234 可见，for 循环遍历一维数组中所有元素进行输出。 | ================================================== Split Line =============================================== | 👇👇👇 二维数组 👇👇👇 同样的，可以对二维数组进行遍历： 12345678910&gt;&gt;&gt; two_arr = np.arange(6).reshape(2, 3)&gt;&gt;&gt; two_arrarray([[0, 1, 2], [3, 4, 5]])&gt;&gt;&gt; for r in two_arr:... print(r)...[0 1 2][3 4 5] 可见，单层 for 循环会将每行元素组成的一维数组作为一个二维数组的元素，输出三个一维数组。故你可以使用多重循环来遍历输出每一个元素： 123456789101112131415161718192021&gt;&gt;&gt; for r in two_arr: # row... for c in r: # col... print(c)...012345# 如果你仅仅想查看数组中的元素，你可以先将多维数组平铺成一维数组，然后进行遍历查看：&gt;&gt;&gt; for item in two_arr.flatten():... print(item)...012345 | ================================================== Split Line =============================================== | 👇👇👇 N 维数组 👇👇👇 推测一下 &gt;&gt;&gt;&gt; 单层 for 循环遍历多维数组时，会依次输出最高层次 axis 轴（axis=0）上的元素！！！ 123456789101112131415&gt;&gt;&gt; three_arr = np.arange(12).reshape(2, 2, 3)&gt;&gt;&gt; three_arrarray([[[ 0, 1, 2], [ 3, 4, 5]], [[ 6, 7, 8], [ 9, 10, 11]]])&gt;&gt;&gt; for item in three_arr:... print(item)...[[0 1 2] [3 4 5]][[ 6 7 8] [ 9 10 11]] 可以看出，对于高维数组（&gt; 2-Dims）中元素的遍历访问是很繁琐的（多重 for 循环）。 迭代器方法事实上，NumPy 中提供了一个 nditer 迭代器 方法 numpy.nditer()，可以配合 for 循环完成对数组中所有元素的遍历： 123456789101112&gt;&gt;&gt; arr = np.arange(12).reshape(2, 2, 3)&gt;&gt;&gt; arrarray([[[ 0, 1, 2], [ 3, 4, 5]], [[ 6, 7, 8], [ 9, 10, 11]]])&gt;&gt;&gt; for item in np.nditer(arr):... print(item, end=' ')...0 1 2 3 4 5 6 7 8 9 10 11 ↓↓↓↓↓↓ 关于 C/F-Order ↓↓↓↓↓↓ 我们知道，Ndarray 数组中元素有两种布局方式：C-order（行优先顺序）&amp;&amp; Fortrant-order（列优先顺序）。 那么，nditer 迭代器又是如何处理具有特定布局方式的数组呢？？？ &gt;&gt;&gt;&gt; 无须考虑布局（仅解释方式），Memory Block 中元素顺序遍历！！！ 12345678910111213141516&gt;&gt;&gt; arr = np.arange(6).reshape((2, 3), order=&quot;F&quot;)&gt;&gt;&gt; arrarray([[0, 2, 4], [1, 3, 5]])# 和布局方式无关：&gt;&gt;&gt; for item in np.nditer(arr):... print(item, end=&quot; &quot;)...0 1 2 3 4 5# 转置：&gt;&gt;&gt; for item in np.nditer(arr.T):... print(item, end=&quot; &quot;)...0 1 2 3 4 5 | ================================================== Split Line =============================================== | 👇👇👇 指定遍历顺序 👇👇👇 那么，如何通过指定的顺序（C/F-Order）访问 Ndarray 数组元素？？？可以通过 nditer 迭代器方法的 order 参数来指定： 12345678910111213141516&gt;&gt;&gt; arr = np.arange(6).reshape((2, 3))&gt;&gt;&gt; arrarray([[0, 1, 2], [3, 4, 5]])# C-Order&gt;&gt;&gt; for item in np.nditer(arr, order='C'):... print(item, end=&quot; &quot;)...0 1 2 3 4 5# F-Order&gt;&gt;&gt; for item in np.nditer(arr, order='F'):... print(item, end=&quot; &quot;)...0 3 1 4 2 5 | ================================================== Split Line =============================================== | 👇👇👇 遍历时修改元素值 👇👇👇 nditer 迭代器方法中提供有一个 op_flags 参数，可用于能否在遍历数组时对元素进行修改。有三种模式： readonly：只读模式（默认），默认情况下不可更改； readwrite：读写模式； writeonly：只写模式。 实例代码如下： 12345678910111213141516171819&gt;&gt;&gt; arr = np.arange(6).reshape((2, 3))&gt;&gt;&gt; arrarray([[0, 1, 2], [3, 4, 5]])&gt;&gt;&gt; for item in np.nditer(arr):... item[...] = item * 2...# 默认情况下为 `read-only` 模式，不可修改：Traceback (most recent call last): File &quot;&lt;stdin&gt;&quot;, line 2, in &lt;module&gt;ValueError: assignment destination is read-only# 指定为可读写模式后，修改元素：&gt;&gt;&gt; for item in np.nditer(arr, op_flags=[&quot;readwrite&quot;]):... item[...] = item * 2...&gt;&gt;&gt; arrarray([[ 0, 2, 4], [ 6, 8, 10]]) | ================================================== Split Line =============================================== | 👇👇👇 同时迭代多数组 👇👇👇 如果多个数组之间可以被广播（Broadcast），那么 nditer 迭代器就可以同时对它们迭代。 关于数组的广播机制可参见下一章节~~~ 实例代码如下： 123456789101112&gt;&gt;&gt; a_arr = np.arange(6).reshape(2, 3)&gt;&gt;&gt; a_arrarray([[0, 1, 2], [3, 4, 5]])&gt;&gt;&gt; b_arr = np.arange(3)&gt;&gt;&gt; b_arrarray([0, 1, 2])&gt;&gt;&gt; for x,y in np.nditer([a_arr, b_arr]):... print (&quot;%d-%d&quot; % (x,y),end=&quot;,&quot;)...0-0,1-1,2-2,3-0,4-1,5-2 其中，数组 a_arr 的形状是 (2, 3)，而数组 b_arr 的形状是 (3,) &lt;&lt;&lt;&lt; 维度较小的数组 b_arr 可以被广播到数组 a_arr 中。 Ndarray Broadcast当操作两个形状不同的数组运算时，会引发 NumPy 中的广播机制。 NumPy 中的广播机制（Broadcast）旨在 &gt;&gt;&gt;&gt; 解决 不同形状数组之间 的算术运算问题。 广播原则这里，我们首先要了解广播机制的核心原则： 如果两个数组的后缘维度（Trailing Dimension，即从末尾开始算起的维度）的轴长度（相应轴上的元素个数，与 Shape 对应）相符，或其中至少一方的长度为 1，则认为它们是广播兼容的。 广播会在 &gt;&gt;&gt;&gt; 缺失和（或）长度为 1 的维度上对较小的数组进行扩展。 结合下面的广播应用理解其核心原则。 广播的应用广播原则体现三种情况的应用： 两个数组的维数不相等，但它们的后缘维度的轴长相符； 两个数组的维数相等，但至少有一方轴的长度为 1； 上述两种情况的结合。 👇👇👇 数组维度不同，后缘维度的轴长相符 👇👇👇 通过如下样例进行说明： 123456789import numpy as np&gt;&gt;&gt; arr1 = np.array([[0, 0, 0],[1, 1, 1],[2, 2, 2], [3, 3, 3]]) #arr1.shape = (4, 3)&gt;&gt;&gt; arr2 = np.array([1, 2, 3]) # arr2.shape = (3,)&gt;&gt;&gt; print(arr1 + arr2)[[1 2 3] [2 3 4] [3 4 5] [4 5 6]] 如上，Shape 不同的数组 arr1 和 arr2 可以通过广播原则执行加法运算。进一步解析 &gt;&gt;&gt; 数组 arr1 &amp;&amp; arr2 的维度不同：前者为二维的，而后者是一维的。但两个数组的后缘维度相等，会将较小的数组 arr2 沿着缺失的 0 轴进行扩展。 你可以认为 &gt;&gt;&gt;&gt; 较小数组的 shape，“截取” 自较大数组 shape 的尾部 &lt;&lt;&lt;&lt; 较小数组的 shape 刚好是某个后缘维度。 上述示例的广播示意图如下： ↓↓↓↓↓↓ 样例二 ↓↓↓↓↓↓ 再来思考一下 arr3（3, 4, 2）&amp;&amp; arr4（4, 2）的情况 &gt;&gt;&gt;&gt; arr3 为 3 维，arr4 为 2 维，但其后缘维度相同（4, 2），axis=0 轴缺失。 其广播示意图如下： 可见，对于较小的数组 arr4 将沿着缺失的 0 轴进行了扩展： 1234567891011121314151617181920212223242526272829303132333435363738&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; arr3 = np.arange(24).reshape([3, 4, 2])&gt;&gt;&gt; arr3array([[[ 0, 1], [ 2, 3], [ 4, 5], [ 6, 7]], [[ 8, 9], [10, 11], [12, 13], [14, 15]], [[16, 17], [18, 19], [20, 21], [22, 23]]])&gt;&gt;&gt; arr4 = np.ones([4, 2])&gt;&gt;&gt; arr4array([[1., 1.], [1., 1.], [1., 1.], [1., 1.]])&gt;&gt;&gt; print(arr3 + arr4)[[[ 1. 2.] [ 3. 4.] [ 5. 6.] [ 7. 8.]] [[ 9. 10.] [11. 12.] [13. 14.] [15. 16.]] [[17. 18.] [19. 20.] [21. 22.] [23. 24.]]] 同理，（4, 2, 3）和（2, 3）是兼容的，（4, 2, 3）还和（3,）是兼容的，后者需要在两个轴上面进行扩展。 | ================================================== Split Line =============================================== | 👇👇👇 数组维度相同，其中至少有一个轴为 1 👇👇👇 通过如下样例进行说明： 12345678910111213141516171819&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; arr1 = np.array([[0, 0, 0], [1, 1, 1], [2, 2, 2], [3, 3, 3]])&gt;&gt;&gt; arr1array([[0, 0, 0], [1, 1, 1], [2, 2, 2], [3, 3, 3]])&gt;&gt;&gt; arr2 = np.array([[1], [2], [3], [4]])&gt;&gt;&gt; arr2array([[1], [2], [3], [4]])&gt;&gt;&gt; print(arr1 + arr2)[[1 1 1] [3 3 3] [5 5 5] [7 7 7]] arr1 的 shape 为（4, 3），arr2 的 shape 为 （4, 1），它们都是二维的。并且，数组 arr2 在 axis=1 轴上的轴长度为 1，故其可以沿着该轴进行广播，其示意图如下： 当前情况下，两个数组的维度相同，较小数组的某个轴长度为 1，这样就会沿着长度为 1 的轴进行扩展。 同理，（4, 6）和（1, 6）是兼容的，（3, 5, 6）和（1, 5, 6）、（3, 1, 6）、（3, 5, 1）是兼容的，后面三个数组分别会沿着 0 轴，1 轴，2 轴进行广播。 | ================================================== Split Line =============================================== | 👇👇👇 上述两种情况的结合 👇👇👇 还有上面两种结合的情况： 如（3, 5, 6）和（1, 6）/（1, 1, 6）是可以相兼容的。 在 TensorFlow 当中计算张量的时候也是用广播机制，并且和 NumPy 的广播机制是一样的。 Ndarray 数组基本操作NumPy 中包含了一些处理数组的常用方法，大致可分为以下几类： 数组重塑操作； 数组换轴操作； 数组变维操作； 数组扩展和压缩操作； 数组连接与分割操作； 数组的增删改查操作； 数组的排序操作。 下面分别对它们进行介绍： 数组重塑关于数组的简单变形操作涉及到几个常用函数：numpy.ndarray.reshape &amp;&amp; numpy.ndarray.resize &amp;&amp; numpy.ndarray.flat &amp;&amp; numpy.ndarray.flatten &amp;&amp; numpy.reval 等。 关于 numpy.ndarray.reshape 方法的用法，可参见上文关于【Ndarray 数组维度和形状】中说明，这里不再进行赘述。 ↓↓↓↓↓↓ 1. numpy.ndarray.resize ↓↓↓↓↓↓ 该函数可用于重塑 ndarray 数组的形状，其语法格式如下： 12345numpy.resize(array, newShape)# 或：# 同理于 NumPy 中 reshape 方法，但更加方便：numpy.ndarray.resize(newShape) 实例如下： 123456789&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; arr = np.arange(8)&gt;&gt;&gt; arrarray([0, 1, 2, 3, 4, 5, 6, 7])&gt;&gt;&gt; arr.resize(2, 4)&gt;&gt;&gt; arrarray([[0, 1, 2, 3], [4, 5, 6, 7]]) 需要注意的是 &gt;&gt;&gt; 修改 ndarray 数组形状（尺寸）的时候， 不能改变数组中元素的个数。如上面数组的形状是 8 * 1（8），可以修改成 2 * 4（8） &amp;&amp; 4 * 2（8），修改后仍是 8 个。否则报错： 1ValueError: cannot resize this array: it does not own its data 区别于 reshape 在于 是否影响原数组。reshape 在改变形状时，不会影响原数组，相当于对原数组做了一份拷贝；而 resize 则是对原数组执行操作。 | ================================================== Split Line =============================================== | ↓↓↓↓↓↓ 2. numpy.ndarray.flat ↓↓↓↓↓↓ 类似于 numpy.nditer，该函数可用于返回一个数组迭代器（numpy.flatiter），可以配合 for 循环遍历数组中的每一个元素： 12345678910111213141516&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; arr = np.arange(9).reshape(3, 3)&gt;&gt;&gt; for row in arr:... print(row)...[0 1 2][3 4 5][6 7 8]&gt;&gt;&gt; for ele in arr.flat:... print(ele, end=&quot;, &quot;)...0, 1, 2, 3, 4, 5, 6, 7, 8,&gt;&gt;&gt; type(arr.flat)&lt;class 'numpy.flatiter'&gt; ↓↓↓↓↓↓ 3. numpy.ndarray.flatten ↓↓↓↓↓↓ 使数组扁平，该函数将以一维数组的形式（扁平处理）返回一份数组的副本（Copy），对副本的操作不会影响到原数组。 其语法格式如下： 1numpy.ndarray.flatten(order='C') 实例代码如下： 12345678910111213141516171819&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; arr = np.arange(9).reshape(3, 3)&gt;&gt;&gt; arrarray([[0, 1, 2], [3, 4, 5], [6, 7, 8]])&gt;&gt;&gt; flatten_of_arr = arr.flatten()&gt;&gt;&gt; flatten_of_arrarray([0, 1, 2, 3, 4, 5, 6, 7, 8])# 数据所有者：&gt;&gt;&gt; flatten_of_arr.flags.owndataTrue# 行优先展开&gt;&gt;&gt; arr.flatten(order=&quot;F&quot;)array([0, 3, 6, 1, 4, 7, 2, 5, 8]) | ================================================== Split Line =============================================== | ↓↓↓↓↓↓ 4. numpy.ndarray.ravel ↓↓↓↓↓↓ 使数组扁平，该函数将以一维数组的形式（扁平处理）返回视图（View），如果修改会影响到原数组。 其语法格式如下： 1numpy.ravel(order='C') 实例代码如下： 1234567891011121314151617&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; arr = np.arange(9).reshape(3, 3)&gt;&gt;&gt; arrarray([[0, 1, 2], [3, 4, 5], [6, 7, 8]])&gt;&gt;&gt; ravel_of_arr = arr.ravel()&gt;&gt;&gt; ravel_of_arrarray([0, 1, 2, 3, 4, 5, 6, 7, 8])# 非数据所有者（引用）：&gt;&gt;&gt; ravel_of_arr.flags.owndataFalse# 列优先展开：&gt;&gt;&gt; arr.ravel(order=&quot;F&quot;)array([0, 3, 6, 1, 4, 7, 2, 5, 8]) | ================================================== Split Line =============================================== | ↓↓↓↓↓↓ 5. numpy.fliplr &amp;&amp; numpy.flipud ↓↓↓↓↓↓ NumPy 中还提供有直接对数组进行翻转的方法： numpy.fliplr(arr)：左右翻转数组； numpy.flipud(arr)：上下翻转数组。 实例代码如下： 1234567891011121314151617&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; arr = np.arange(16).reshape(4, 4)&gt;&gt;&gt; arrarray([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11], [12, 13, 14, 15]])&gt;&gt;&gt; np.fliplr(arr)array([[ 3, 2, 1, 0], [ 7, 6, 5, 4], [11, 10, 9, 8], [15, 14, 13, 12]])&gt;&gt;&gt; np.flipud(arr)array([[12, 13, 14, 15], [ 8, 9, 10, 11], [ 4, 5, 6, 7], [ 0, 1, 2, 3]]) 数组换轴关于数组的换轴操作涉及到几个常用函数：numpy.moveaxis &amp;&amp; numpy.swapaxes &amp;&amp; numpy.transpose &amp;&amp; numpy.ndarray.T 等。 ↓↓↓↓↓↓ 1. numpy.moveaxis ↓↓↓↓↓↓ 轴移动，该函数可用于将 Ndarray 数组的某个轴移动到特定位置，其语法格式如下： 1numpy.moveaxis(arr, source, destination) 其中，参数 arr 表示某个数组，参数 source 表示要移动的轴的原始位置，参数 destination 表示要移动到的目标位置。 实例代码如下： 123456789&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; x = np.zeros((3, 4, 5))# 将 axis=0 移动到最后：&gt;&gt;&gt; np.moveaxis(x, 0, -1).shape(4, 5, 3)# 将 axis=2 移动到开始：&gt;&gt;&gt; np.moveaxis(x, -1, 0).shape(5, 3, 4) ↓↓↓↓↓↓ 2. numpy.swapaxes ↓↓↓↓↓↓ 轴交换，不同于 moveaxis 的是，该可以用于实现 Ndarray 数组轴的交换。其语法格式如下： 1numpy.swapaxes(arr, axis1, axis2) 其中，参数 arr 表示某个数组，参数 axis1 表示需要交换的轴 1 的位置，参数 destination 表示需要交换的轴 2 的位置。 实例代码如下： 12345678&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; x = np.zeros((3, 4, 5))# 交换第一个和最后一个轴的位置：&gt;&gt;&gt; np.swapaxes(arr, 0, 2).shape(5, 4, 3)&gt;&gt;&gt; np.swapaxes(arr, 0, -1).shape(5, 4, 3) | ================================================== Split Line =============================================== | ↓↓↓↓↓↓ 3. numpy.transpose ↓↓↓↓↓↓ 轴调换，该函数可用于自由调换 Ndarray 数组的多个轴，其语法格式如下： 12345numpy.transpose(arr, axes=None)# 或：# 同理于 NumPy 中 transpose 方法，但更加方便：numpy.ndarray.transpose(*axes) 其中，参数 axes 表示调换后各轴顺序的元组或列表，当 axes=None（默认）时表示数组转置，等同于二维数组的 numpy.ndarray.T。 实例代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; arr = np.arange(12).reshape(3, 4)&gt;&gt;&gt; arrarray([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11]])&gt;&gt;&gt; arr.Tarray([[ 0, 4, 8], [ 1, 5, 9], [ 2, 6, 10], [ 3, 7, 11]])# 等同于 arr.T&gt;&gt;&gt; arr.transpose(1, 0)array([[ 0, 4, 8], [ 1, 5, 9], [ 2, 6, 10], [ 3, 7, 11]])&gt;&gt;&gt; arr.transpose()array([[ 0, 4, 8], [ 1, 5, 9], [ 2, 6, 10], [ 3, 7, 11]])&gt;&gt;&gt; three_arr = arr.reshape(3, 2, 2)&gt;&gt;&gt; three_arrarray([[[ 0, 1], [ 2, 3]], [[ 4, 5], [ 6, 7]], [[ 8, 9], [10, 11]]])&gt;&gt;&gt; three_arr.transpose(2, 0, 1)array([[[ 0, 2], [ 4, 6], [ 8, 10]], [[ 1, 3], [ 5, 7], [ 9, 11]]])&gt;&gt;&gt; three_arr.transpose(2, 0, 1).shape(2, 3, 2) 事实上，你可以非常灵活的实现数组的换轴操作： 1234567891011&gt;&gt;&gt; x = np.zeros((3, 4, 5))&gt;&gt;&gt; np.moveaxis(x, 0, -1).shape(4, 5, 3)&gt;&gt;&gt; np.transpose(x).shape(5, 4, 3)&gt;&gt;&gt; np.swapaxes(x, 0, -1).shape(5, 4, 3)&gt;&gt;&gt; np.moveaxis(x, [0, 1], [-1, -2]).shape(5, 4, 3)&gt;&gt;&gt; np.moveaxis(x, [0, 1, 2], [-1, -2, -3]).shape(5, 4, 3) 关于数组换轴后，数组中数据排布情况，可参见 &gt;&gt;&gt;【一文解析 NumPy ndarray 多维数组结构设计】博文中【Ndarray 属性详解】小节关于轴和形状的说明。 数组变维NumPy 中还提供了形如 atleast_Xd 的函数，支持将输入数据的维度直接视为 X（1/2/3）维。其语法格式如下： 123numpy.atleast_1d()numpy.atleast_2d()numpy.atleast_3d() 实例代码如下： 1234567891011&gt;&gt;&gt; np.atleast_1d([1, 2, 3])array([1, 2, 3])&gt;&gt;&gt; np.atleast_2d([4, 5, 6])array([[4, 5, 6]])&gt;&gt;&gt; np.atleast_2d([[1, 2, 3], [4, 5, 6]])array([[1, 2, 3], [4, 5, 6]])&gt;&gt;&gt; np.atleast_3d([7, 8, 9])array([[[7], [8], [9]]]) 关于既有数组的变维操作，可以参见前文介绍过的 numpy.ndarray.reshape &amp;&amp; numpy.ndarray.resize 函数。 数组扩展和压缩关于数组的扩展和压缩操作涉及到几个常用函数：numpy.broadcast &amp;&amp; numpy.broadcast_to &amp;&amp; numpy.expand_dims &amp;&amp; numpy.squeeze 等。 ↓↓↓↓↓↓ 1. numpy.broadcast ↓↓↓↓↓↓ 该函数用于生成一个模拟广播的对象（broadcast object），其返回一个广播对象，同样拥有 shape/ndim/size 等属性。 实例代码如下： 12345678&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.array([[1], [2], [3]])&gt;&gt;&gt; b = np.array([4, 5, 6])# 对 b 广播 a，这里数组的顺序，就是广播对象中相应数组的顺序（仅影响查看）&gt;&gt;&gt; d = np.broadcast(a, b)&gt;&gt;&gt; d&lt;numpy.broadcast object at 0x000001CFFA44B960&gt; 既然是一个广播对象，我们无法直接查看其细节信息。广播对象提供了一个 iters 属性可用于迭代输出信息： 1234567891011121314&gt;&gt;&gt; row, col = d.iters# 查看广播对象中，相应行、列位置处，两个数组的元素情况：&gt;&gt;&gt; for idx in range(d.size):... print(next(row), next(col))...1 41 51 62 42 52 63 43 53 6 可见，对于数组 a 沿着轴为 1 的方向进行了扩展，而数组 b 沿着缺失的轴进行了扩展。 使用 broadcast 来完成 a+b 过程： 1234567891011121314# 先给出 a + b 的结果：&gt;&gt;&gt; a + barray([[5, 6, 7], [6, 7, 8], [7, 8, 9]])# 使用 broadcast 来完成 a + b：&gt;&gt;&gt; e = np.broadcast(a, b)&gt;&gt;&gt; f = np.empty(e.shape)&gt;&gt;&gt; f.flat = [x + y for (x, y) in e]&gt;&gt;&gt; farray([[5., 6., 7.], [6., 7., 8.], [7., 8., 9.]]) ↓↓↓↓↓↓ 2. numpy.broadcast_to ↓↓↓↓↓↓ 很多时候，我们想要查看对于某个数组广播到某个 Shape 时的细节，怎么办？！！ NumPy 中提供了 numpy.broadcast_to 方法可以返回数组广播到新形状上的一个只读视图，其语法格式如下： 1numpy.broadcast_to(array, shape) 实例代码如下： 123456789# 查看上面实例中的数组 `a` &amp;&amp; `b` 广播后的数组细节：&gt;&gt;&gt; np.broadcast_to(a, (3, 3))array([[1, 1, 1], [2, 2, 2], [3, 3, 3]])&gt;&gt;&gt; np.broadcast_to(b, (3, 3))array([[4, 5, 6], [4, 5, 6], [4, 5, 6]]) 需要注意的是，如果新形状不符合 NumPy 的广播规则，则会抛出 ValueError 异常。 | ================================================== Split Line =============================================== | ↓↓↓↓↓↓ 3. numpy.expand_dims ↓↓↓↓↓↓ 该函数可以在数组中指定轴位置插入新的轴，从而扩展数组的维度。其语法格式如下: 1numpy.expand_dims(arr, axis) 其中，参数 axis 表示新轴插入的位置。 实例代码如下： 123456789101112131415&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; x = np.array(([1,2],[3,4]))&gt;&gt;&gt; xarray([[1, 2], [3, 4]])&gt;&gt;&gt; x.shape(2, 2)&gt;&gt;&gt; y = np.expand_dims(x, axis=0)&gt;&gt;&gt; yarray([[[1, 2], [3, 4]]])&gt;&gt;&gt; y.shape(1, 2, 2) ↓↓↓↓↓↓ 4. numpy.squeeze ↓↓↓↓↓↓ 维度有扩展就有压缩，该函数可以删除数组中周长度为 1 的维度。例如，一个数组的 shape 是 (5, 1)，经此函数后，shape 变为 (5,) 。其函数语法格式如下： 1numpy.squeeze(arr, axis) 其中，参数 axis 取值为整数或整数元组，用于指定需要删除的维度所在轴，其所指向的轴长必须为 1，否则会报错！！！若为 None，则删除数组中所有轴长为 1 的维度。 实例代码如下： 12345678910111213&gt;&gt;&gt; arr = np.array([[[0], [1], [2]]])&gt;&gt;&gt; arr.shape(1, 3, 1)# 删除所有：&gt;&gt;&gt; np.squeeze(arr).shape(3,)# 删除轴 `axis=0`&gt;&gt;&gt; np.squeeze(arr, axis=(0,)).shape(3, 1)# 删除轴 `axis=2`&gt;&gt;&gt; np.squeeze(arr, axis=(2,)).shape(1, 3) 数组连接与拆分关于数组的连接与分割操作涉及到几个常用函数：numpy.concatenate &amp;&amp; numpy.stack &amp;&amp; numpy.hstack &amp;&amp; numpy.vstack numpy.dstack &amp;&amp; numpy.column_stack() &amp;&amp; numpy.split &amp;&amp; numpy.hsplit &amp;&amp; numpy.vsplit &amp;&amp; numpy.dsplit 等。 👇👇👇 数组连接 👇👇👇 numpy.concatenate 函数可以将多个数组沿指定轴连接在一起。其语法格式如下： 1numpy.concatenate((arr1, arr2, ...), axis=0) 其中，参数 (arr1, arr2, ...) 表示待连接的数组列表，参数 axis 表示指定的连接轴，默认为 0 轴。 实例代码如下： 1234567891011&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.array([[1, 2], [3, 4], [5, 6]])&gt;&gt;&gt; b = np.array([[7, 8], [9, 10]])&gt;&gt;&gt; c = np.array([[11, 12]])&gt;&gt;&gt; np.concatenate((a, b, c), axis=0)array([[ 1, 2], [ 3, 4], [ 5, 6], [ 7, 8], [ 9, 10], [11, 12]]) 需要注意的是，需要保证连接处的维度一致！！！例如你可以尝试沿着横轴连接： 123456789&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.array([[1, 2], [3, 4], [5, 6]])&gt;&gt;&gt; b = np.array([[7, 8, 9]])# 为了保证连接处维度一致，需要对数组 b 进行转置&gt;&gt;&gt; np.concatenate((a, b.T), axis=1)array([[1, 2, 7], [3, 4, 8], [5, 6, 9]]) 👇👇👇 数组堆叠 👇👇👇 NumPy 中提供了以下方法，可用于数组的堆叠： numpy.stack(arrays，axis)：沿着新轴连接数组的序列以实现堆叠； numpy.column_stack()：将 1 维数组作为列堆叠到 2 维数组中； numpy.hstack()：按水平方向堆叠数组； numpy.vstack()：按垂直方向堆叠数组 numpy.dstack()：按深度方向堆叠数组。 下面分别来看其区别： ↓↓↓↓↓↓ 1. numpy.stack ↓↓↓↓↓↓ 该函数会 创建一个新轴（新维度）来实现数组的堆叠。这里我们将通过一个样例来看数组的堆叠方法： 123456&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.arange(1, 7).reshape((2, 3))&gt;&gt;&gt; b = np.arange(7, 13).reshape((2, 3))&gt;&gt;&gt; c = np.arange(13, 19).reshape((2, 3))&gt;&gt;&gt; d = np.arange(19, 25).reshape((2, 3)) 四个用于堆叠的数组如下： 12345678910111213# 均为（2, 3）的二维数组：&gt;&gt;&gt; aarray([[1, 2, 3], [4, 5, 6]])&gt;&gt;&gt; barray([[ 7, 8, 9], [10, 11, 12]])&gt;&gt;&gt; carray([[13, 14, 15], [16, 17, 18]])&gt;&gt;&gt; darray([[19, 20, 21], [22, 23, 24]]) 接下来分别来看不同轴/维度上的堆叠实验： [1] &gt;&gt;&gt;&gt; axis=0 123456789101112131415&gt;&gt;&gt; np.stack([a, b, c, d], axis=0)array([[[ 1, 2, 3], [ 4, 5, 6]], [[ 7, 8, 9], [10, 11, 12]], [[13, 14, 15], [16, 17, 18]], [[19, 20, 21], [22, 23, 24]]])&gt;&gt;&gt; np.stack([a, b, c, d], axis=0).shape(4, 2, 3) 形象理解 &gt;&gt;&gt; axis 等于几就在哪个维度上进行堆叠。当 axis=0 时（会创建一个新轴），意味着每个数组都是一个整体，即（2, 3）的数组。故对于 0 维堆叠，相当于简单的数组罗列 &lt;&lt;&lt; 比如四个数组分别表示 4 张图像矩阵，进行 0 维堆叠就是将它们按照顺序排放起来，形成一个（4, 2, 3）的三维数组。 [2] &gt;&gt;&gt;&gt; axis=1 12345678910111213&gt;&gt;&gt; np.stack([a, b, c, d], axis=1)array([[[ 1, 2, 3], [ 7, 8, 9], [13, 14, 15], [19, 20, 21]], [[ 4, 5, 6], [10, 11, 12], [16, 17, 18], [22, 23, 24]]])&gt;&gt;&gt; np.stack([a, b, c, d], axis=1).shape(2, 4, 3) 形象理解 &gt;&gt;&gt; axis 等于几就在哪个维度上进行堆叠。当 axis=1 时（会创建一个新轴），意味着第一个维度，即数组的每一行。故对于 1 维堆叠，会从 4 个（2, 3）的数组中，各自拿出自己的第一行元素进行堆叠形成 3 维数组的第一 “行”；各自拿出自己的第二行数据进行堆叠形成 3 维数组的第二 “行”，最终堆叠成一个（2, 4, 3）的三维数组。&lt;&lt;&lt; 比如四个数组分别表示对同一张图像进行不同图像处理后的数组，进行 1 维堆叠可以这些不同处理方式的数据有条理的堆叠形成一个数组，方便后续的统一处理。 [3] &gt;&gt;&gt;&gt; axis=2 1234567891011&gt;&gt;&gt; np.stack([a, b, c, d], axis=2)array([[[ 1, 7, 13, 19], [ 2, 8, 14, 20], [ 3, 9, 15, 21]], [[ 4, 10, 16, 22], [ 5, 11, 17, 23], [ 6, 12, 18, 24]]])&gt;&gt;&gt; np.stack([a, b, c, d], axis=2).shape(2, 3, 4) 形象理解 &gt;&gt;&gt; axis 等于几就在哪个维度上进行堆叠。当 axis=1 时（会创建一个新轴），意味着第二个维度，即数组的每一行中的更深一层的维度（单个元素）。注意这里不要理解为 2 维堆叠是对每一列拿出来进行堆叠！！！故对于 2 维堆叠，会从 4 个（2, 3）的数组中，各自拿出自己每个元素，在对应的位置，进行堆叠。&lt;&lt;&lt; 比如四个数组分别一个图像的 R、G、B 数据（为了更加形象，图像应该是 3 个像素矩阵），进行 2 维堆叠后，不就构成了图像的 RGB 三通道的数组了嘛。 更形象的理解 &gt;&gt;&gt; 对于三维立方体数组，进行 2 维堆叠后，之前每个数组都是三维立方体数组的一个竖截面~~~ 显而易见的是，你可以发现数组堆叠（stack）和数组连接（concatenate）的区别 &gt;&gt;&gt; 是否形成新的维度？！！ | ================================================== Split Line =============================================== | ↓↓↓↓↓↓ 2. numpy.hstack ↓↓↓↓↓↓ 函数原型：hstack(tup) ，参数 tup 可以是元组，列表，或者 ndarray，其返回一个堆叠后的数组。从实例代码体会其含义： 123456789101112131415161718192021222324252627282930313233343536373839&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = [[1], [2], [3]]&gt;&gt;&gt; b = [[4], [5], [6]]&gt;&gt;&gt; np.hstack([a, b])array([[1, 4], [2, 5], [3, 6]])&gt;&gt;&gt; c = np.arange(13, 19).reshape((2, 3))&gt;&gt;&gt; d = np.arange(19, 25).reshape((2, 3))&gt;&gt;&gt; np.hstack([c, d])array([[13, 14, 15, 19, 20, 21], [16, 17, 18, 22, 23, 24]])# 三维数组水平堆叠&gt;&gt;&gt; arr1 = np.arange(0, 8).reshape(2, 2, 2)&gt;&gt;&gt; arr2 = np.arange(8, 16).reshape(2, 2, 2)&gt;&gt;&gt; arr1array([[[0, 1], [2, 3]], [[4, 5], [6, 7]]])&gt;&gt;&gt; arr2array([[[ 8, 9], [10, 11]], [[12, 13], [14, 15]]])&gt;&gt;&gt; np.hstack((arr1, arr2))array([[[ 0, 1], [ 2, 3], [ 8, 9], [10, 11]], [[ 4, 5], [ 6, 7], [12, 13], [14, 15]]]) 可见，水平堆叠就是将数组沿【水平/横轴/列顺序】方向进行堆叠。 ↓↓↓↓↓↓ 3. numpy.vstack ↓↓↓↓↓↓ 函数原型：vstack(tup) ，参数 tup 可以是元组，列表，或者 ndarray，其返回一个堆叠后的数组。从实例代码体会其含义： 1234567891011121314151617181920212223242526272829303132&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = [[1], [2], [3]]&gt;&gt;&gt; b = [[4], [5], [6]]&gt;&gt;&gt; np.vstack((a, b))array([[1], [2], [3], [4], [5], [6]])&gt;&gt;&gt; c = np.arange(13, 19).reshape((2, 3))&gt;&gt;&gt; d = np.arange(19, 25).reshape((2, 3))&gt;&gt;&gt; np.vstack((c, d))array([[13, 14, 15], [16, 17, 18], [19, 20, 21], [22, 23, 24]])# 三维数组垂直堆叠：&gt;&gt;&gt; np.vstack([arr1, arr2])array([[[ 0, 1], [ 2, 3]], [[ 4, 5], [ 6, 7]], [[ 8, 9], [10, 11]], [[12, 13], [14, 15]]]) 可见，垂直堆叠就是将数组按 垂直（行顺序）进行堆叠。 ↓↓↓↓↓↓ 4. numpy.column_stack ↓↓↓↓↓↓ 函数原型：column_stack(tup) ，参数 tup 可以是元组，列表，或者 ndarray，其返回一个堆叠后的数组。从实例代码体会其含义： 12345678910&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.arange(1, 7).reshape((2, 3))&gt;&gt;&gt; aarray([[1, 2, 3], [4, 5, 6]])&gt;&gt;&gt; e = [7, 8]&gt;&gt;&gt; np.column_stack((a, e))array([[1, 2, 3, 7], [4, 5, 6, 8]]) 可见，该函数会将一个 1 维数组作为列堆叠到 2 维数组中。 理解 &gt;&gt;&gt; 数组堆叠是沿轴进行的，数组拆分是垂直于轴进行分割的！！！ &lt;&lt;&lt; 可以帮助你加深数组堆叠和拆分的理解。 👇👇👇 数组拆分 👇👇👇 类似于数组堆叠（stack），NumPy 中也提供了以下方法，可用于数组的拆分： numpy.split(arr，indices_or_sections，axis=0)：沿指定的轴将数组均匀分割为多个子数组； numpy.hsplit(arr，indices_or_sections)：按水平方向将数组拆分成多个子数组； numpy.vsplit(arr，indices_or_sections)：按垂直方向将数组拆分成多个子数组； numpy.dsplit(arr，indices_or_sections)：按深度方向将数组拆分成多个子数组； numpy.array_split(arr, indices_or_sections, axis=0)：沿指定的轴将数组近似均匀分割为多个子数组。 数组拆分之后返回的结果是一个列表（list），列表中的每一项元素均为一个子数组（array），类似于如下： 12345[array(...), array(...), array(...), array(...), ... ] 下面分别来看其区别： ↓↓↓↓↓↓ 1. numpy.split ↓↓↓↓↓↓ 该函数，可以沿指定的轴将数组均匀分割为多个子数组。其语法格式如下： 1numpy.split(arr，indices_or_sections，axis) 其中，参数 arr 表示待拆分的数组；参数 indices_or_sections &gt;&gt;&gt; 如果是一个 1-D 数组，代表沿轴切分的位置（看作多个索引对，左开右闭）；如果是一个整数，表示平均切分的份数（必须均分，否则报错：ValueError: array split does not result in an equal division）。参数 axis 表示要沿着哪个轴进行切分，默认为 0，二维数组中表示横向切分，为 1 时表示纵向切分。 实例代码如下： 12345678910111213141516&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; arr = np.arange(9)# int &gt;&gt;&gt; sections&gt;&gt;&gt; np.split(arr, 3)[array([0, 1, 2]), array([3, 4, 5]), array([6, 7, 8])]# 无法均分时会产生报错：&gt;&gt;&gt; np.split(arr, 4)Traceback (most recent call last):ValueError: array split does not result in an equal division# 1-D array &gt;&gt;&gt; indices (左开右闭)&gt;&gt;&gt; arr = np.arange(8)&gt;&gt;&gt; np.split(arr, [3, 5, 6, 10])[array([0, 1, 2]), array([3, 4]), array([5]), array([6, 7]), array([], dtype=int32)] 常见机器学习用法 &gt;&gt;&gt;&gt; indices 为 (3,) 123456789101112131415161718192021222324252627&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; a = np.arange(8)# 在第三、四列之间进行分隔：&gt;&gt;&gt; np.split(a, (3,))[array([0, 1, 2]), array([3, 4, 5, 6, 7])]# 机器学习中的用法说明：# axis=1（代表列），是要把 data 数据集中的所有数据按第三、四列之间分割为 X 集和 Y 集。x, y = np.split(data, (3,), axis=1)# ↓↓↓↓↓↓ 样例 ↓↓↓↓↓↓# 假设数组 arr 中每一行为一个样本数据（行中最后一个元素为样本对应的真实值）：&gt;&gt;&gt; arr = np.arange(20).reshape(4, 5)&gt;&gt;&gt; arrarray([[ 0, 1, 2, 3, 4], [ 5, 6, 7, 8, 9], [10, 11, 12, 13, 14], [15, 16, 17, 18, 19]])# 划分出样本值 X 和真实值 Y 的数组：&gt;&gt;&gt; np.split(arr, (4,), axis=1)[array([[ 0, 1, 2, 3], [ 5, 6, 7, 8], [10, 11, 12, 13], [15, 16, 17, 18]]), array([[ 4], [ 9], [14], [19]])] | ================================================== Split Line =============================================== | ↓↓↓↓↓↓ 2. numpy.array_split ↓↓↓↓↓↓ 不同于 numpy.split 的强制均匀分割，array_split 函数，可以沿指定的轴将数组 近似均匀分割 为多个子数组。其语法格式如下： 1numpy.array_split(arr, indices_or_sections, axis=0) 数组近似拆分原则：前 L % n 个组的大小是（L // n + 1），剩下组的大小是（L // n）。其中 // 表示下取整（即 np.floor()），n 代表划分后数组的个数。 实例代码如下： 123456789101112131415&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; arr = np.arange(8)# 默认垂直 axis=0 轴近似分割数组：&gt;&gt;&gt; np.array_split(arr, 3)[array([0, 1, 2]), array([3, 4, 5]), array([6, 7])]&gt;&gt;&gt; arr1 = np.arange(14).reshape(2, 7)&gt;&gt;&gt; arr1array([[ 0, 1, 2, 3, 4, 5, 6], [ 7, 8, 9, 10, 11, 12, 13]])# 垂直 axis=1 轴近似分割数组：&gt;&gt;&gt; np.array_split(arr1, 2, axis=1)[array([[ 0, 1, 2, 3], [ 7, 8, 9, 10]]), array([[ 4, 5, 6], [11, 12, 13]])] | ================================================== Split Line =============================================== | ↓↓↓↓↓↓ 3. numpy.hsplit &amp;&amp; numpy.vsplit ↓↓↓↓↓↓ 垂直于 水平/竖直 轴拆分数组，要遵循均匀分割原则，否则报错。实例代码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455# ↓↓↓↓↓↓ 水平分割 ↓↓↓↓↓↓ #&gt;&gt;&gt; a = [[1], [2], [3]]&gt;&gt;&gt; b = [[4], [5], [6]]&gt;&gt;&gt; res = np.hstack([a, b])&gt;&gt;&gt; resarray([[1, 4], [2, 5], [3, 6]])# 拆分水平堆叠后的数组：&gt;&gt;&gt; np.hsplit(res, (1,))[array([[1], [2], [3]]), array([[4], [5], [6]])]&gt;&gt;&gt; c = np.arange(13, 19).reshape((2, 3))&gt;&gt;&gt; d = np.arange(19, 25).reshape((2, 3))&gt;&gt;&gt; res = np.hstack([c, d])&gt;&gt;&gt; np.hsplit(res, (3,))[array([[13, 14, 15], [16, 17, 18]]), array([[19, 20, 21], [22, 23, 24]])]# ↓↓↓↓↓↓ 垂直分割 ↓↓↓↓↓↓ #&gt;&gt;&gt; a = [[1], [2], [3]]&gt;&gt;&gt; b = [[4], [5], [6]]&gt;&gt;&gt; res = np.vstack((a, b))&gt;&gt;&gt; resarray([[1], [2], [3], [4], [5], [6]])# 拆分垂直堆叠后的数组：&gt;&gt;&gt; np.vsplit(res, (3,))[array([[1], [2], [3]]), array([[4], [5], [6]])]&gt;&gt;&gt; c = np.arange(13, 19).reshape((2, 3))&gt;&gt;&gt; d = np.arange(19, 25).reshape((2, 3))&gt;&gt;&gt; res = np.vstack((c, d))&gt;&gt;&gt; resarray([[13, 14, 15], [16, 17, 18], [19, 20, 21], [22, 23, 24]])&gt;&gt;&gt; np.vsplit(res, (2,))[array([[13, 14, 15], [16, 17, 18]]), array([[19, 20, 21], [22, 23, 24]])] 数组的增删改查NumPy 中提供了对 Ndarray 数组中元素执行增、删、改、查等操作的方法，下面将分别介绍这些用法： 👇👇👇 数组删除 👇👇👇 ↓↓↓↓↓↓ 1. numpy.delete ↓↓↓↓↓↓ numpy.delete 方法，可用于沿特定轴，删除数组中指定的子数组，返回一个新数组。其语法格式如下： 1numpy.delete(arr, obj, axis) 其中，参数 obj 可以为整数、整数数组或切片，表示要被删除的数组元素或子数组。参数 axis 表示沿着哪条轴删除子数组，需要注意的是 &gt;&gt;&gt; 若不提供 axis 参数，数组 arr 会先被展开为一维数组，然后进行删除。 实例代码如下： 123456789101112131415161718192021&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; arr = np.arange(12).reshape(3,4)&gt;&gt;&gt; arrarray([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11]])# 不提供 axis 参数情况下，删除了第 4 个元素（一维）：&gt;&gt;&gt; np.delete(arr, 3)array([ 0, 1, 2, 4, 5, 6, 7, 8, 9, 10, 11])# 删除第 3 列元素：&gt;&gt;&gt; np.delete(arr, 2, axis=1)array([[ 0, 1, 3], [ 4, 5, 7], [ 8, 9, 11]])# 删除经切片后的数组：&gt;&gt;&gt; arr_slice = np.delete(arr, np.s_[::2])&gt;&gt;&gt; arr_slicearray([ 1, 3, 5, 7, 9, 11]) ↓↓↓↓↓↓ 2. numpy.unique ↓↓↓↓↓↓ 该函数，可用于删除数组中重复的元素。其语法格式如下： 1numpy.unique(arr, return_index=False, return_inverse=False, return_counts=False, axis=None) 其中，参数 return_index 为 True 时，返回新数组元素在原数组中的位置（索引）；参数 return_inverse 为 True 时，返回原数组元素在新数组中的位置（索引）；参数 return_counts 为 True 时，返回去重后的数组元素在原数组中出现的次数。 关于参数 axis=None（默认），会将多维数组平铺为一维，然后输出其中的重复元素。实例代码如下： 1234567891011121314151617181920212223242526&gt;&gt;&gt; arr = np.array([5, 2, 6, 2, 7, 5, 6, 8, 2, 9])# 默认去重：&gt;&gt;&gt; np.unique(arr)array([2, 5, 6, 7, 8, 9])# 新数组元素在原数组中的索引：&gt;&gt;&gt; u, indices = np.unique(arr, return_index=True)&gt;&gt;&gt; uarray([2, 5, 6, 7, 8, 9])&gt;&gt;&gt; indicesarray([1, 0, 2, 4, 7, 9], dtype=int64)# 原数组元素在新数组中的索引：&gt;&gt;&gt; u, indices = np.unique(arr, return_inverse=True)&gt;&gt;&gt; uarray([2, 5, 6, 7, 8, 9])&gt;&gt;&gt; indicesarray([1, 0, 2, 0, 3, 1, 2, 4, 0, 5], dtype=int64)# 新数组对应原数组中的元素重复次数：&gt;&gt;&gt; u, indices = np.unique(arr, return_counts=True)&gt;&gt;&gt; uarray([2, 5, 6, 7, 8, 9])&gt;&gt;&gt; indicesarray([3, 2, 2, 1, 1, 1], dtype=int64) 而当 axis=0/1/2/... 时，会沿着相应的轴，删除轴上的重复元素（注意轴上的元素，并不是数组中的元素）： 1234&gt;&gt;&gt; arr = np.array([[1, 0, 0], [1, 0, 0], [2, 3, 4], [1, 0, 0]])&gt;&gt;&gt; np.unique(arr, axis=0)array([[1, 0, 0], [2, 3, 4]]) 👇👇👇 数组增加 👇👇👇 关于增加数组元素，可分为插入和附加： ↓↓↓↓↓↓ 1. numpy.insert ↓↓↓↓↓↓ 类似于 delete 用法，该函数可以沿指定的轴，在给定索引值的前一个位置进行插入（行前插入）。其语法格式如下： 1numpy.insert(arr, obj, values, axis) 可以看到和 delete 的区别在于，需要在第三个参数位置设置需要插入的数组对象，并且 axis 用法同上。 实例代码如下： 1234567891011121314151617181920212223&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; arr = np.array([[1,2],[3,4],[5,6]])# 不提供 axis 参数情况下，在第 3 个元素前插入（一维）：&gt;&gt;&gt; np.insert(arr, 2, [11,12])array([ 1, 2, 11, 12, 3, 4, 5, 6])# 沿轴 0 方向插入一行（广播原则）：&gt;&gt;&gt; np.insert(arr, 1, 11, axis = 0)array([[ 1, 2], [11, 11], [ 3, 4], [ 5, 6]])# 传入数组需要满足广播原则条件，否则报错：&gt;&gt;&gt; np.insert(arr, 1, [11, 12, 13], axis = 0)Traceback (most recent call last):ValueError: could not broadcast input array from shape (1,3) into shape (1,2)# 沿轴 1 方向插入一列：&gt;&gt;&gt; np.insert(arr, 1, 11, axis = 1)array([[ 1, 11, 2], [ 3, 11, 4], [ 5, 11, 6]]) ↓↓↓↓↓↓ 2. numpy.append ↓↓↓↓↓↓ 该函数可以沿指定的轴，在轴的末尾进行添加（不再需要位置参数）。其语法格式如下： 1numpy.append(arr, values, axis=None) 其中，需要关注的参数是 axis，默认为 None，返回一个一维数组；对于二维数组，axis=0 追加的值会被添加到行，axis=1 恰好相反。 实例代码如下： 1234567891011121314151617&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; arr = np.array([[1,2,3],[4,5,6]])# 默认 axis=None 的情况下：&gt;&gt;&gt; np.append(arr, [7,8,9])array([1, 2, 3, 4, 5, 6, 7, 8, 9])# 沿轴 0 方向，末尾添加一行：&gt;&gt;&gt; np.append(arr, [[7,8,9]], axis = 0)array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])# 沿轴 1 方向，末尾添加三列&gt;&gt;&gt; np.append(arr, [[5,5,5],[7,8,9]], axis = 1)array([[1, 2, 3, 5, 5, 5], [4, 5, 6, 7, 8, 9]]) 需要注意的是 &gt;&gt;&gt; 你需要保证添加轴上的维度一致！！！否则会产生报错。 👇👇👇 数组元素查询 👇👇👇 NumPy 中还提供了一些在数组内执行 搜索功能的 方法，以 了解数组内元素的细节情况。 这里比较简单，不进行赘述了。列举如下（使用时查表即可）： numpy.nonzero(arr)：返回数组中非 0 元素的索引； numpy.flatnonzero(arr)：平铺数组，并返回数组中非 0 元素的索引； numpy.argmax(arr, axis, out)：返回数组中指定轴上的最大值的索引； numpy.nanargmax(arr, axis)：返回数组中指定轴上的最大值的索引，忽略 NaN； numpy.argmin(arr, axis, out)：返回数组中指定轴上的最小值的索引； numpy.nanargmin(arr, axis)：返回数组中指定轴上的最小值的索引，忽略 NaN； numpy.where(condition, [x, y])：根据指定条件，从指定行、列返回元素； numpy.argwhere(arr)：返回数组中非 0 元素的索引，索引会按元素分组（表示一个非零元素）； numpy.extract(condition, arr)：返回满足某些条件的数组的元素； numpy.count_nonzero(arr, axis=None, keepdims=False)：统计数组中非 0 元素的数量。 实例代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122&gt;&gt;&gt; import numpy as np# ↓↓↓↓↓↓ 1. nonzero &amp;&amp; flatnonzero &amp;&amp; argwhere ↓↓↓↓↓↓ #&gt;&gt;&gt; x = np.array([[3, 0, 0], [0, 4, 0], [5, 6, 0]])&gt;&gt;&gt; xarray([[3, 0, 0], [0, 4, 0], [5, 6, 0]])# 获取非零元素索引&gt;&gt;&gt; np.nonzero(x)(array([0, 1, 2, 2]), array([0, 1, 0, 1]))# 获取非零元素：&gt;&gt;&gt; x[np.nonzero(x)]array([3, 4, 5, 6])# 非零元素索引分组：&gt;&gt;&gt; np.transpose(np.nonzero(x))array([[0, 0], [1, 1], [2, 0], [2, 1]])# 分组返回非零元素索引&gt;&gt;&gt; np.argwhere(x)array([[0, 0], [1, 1], [2, 0], [2, 1]], dtype=int64)# 获取数组平铺后的非零元素索引&gt;&gt;&gt; np.flatnonzero(x)array([0, 4, 6, 7], dtype=int64)# 获取非零元素：&gt;&gt;&gt; x.ravel()[np.flatnonzero(x)]array([3, 4, 5, 6])# ↓↓↓↓↓↓ 2. argmin &amp;&amp; nanargmin ↓↓↓↓↓↓ #&gt;&gt;&gt; x = np.array([[3,4,7], [8,2,1], [5,9,6]])&gt;&gt;&gt; xarray([[3, 4, 7], [8, 2, 1], [5, 9, 6]])# 获取数组平铺后的最小元素索引&gt;&gt;&gt; np.argmin(x)5# 获取最小元素：&gt;&gt;&gt; x.ravel()[np.argmin(x)]1&gt;&gt;&gt; np.argmin(x, axis=0)array([0, 1, 1], dtype=int64)&gt;&gt;&gt; np.argmin(x, axis=1)array([0, 2, 0], dtype=int64)# ↓↓↓↓↓↓ 3. argmax &amp;&amp; nanargmax ↓↓↓↓↓↓ #&gt;&gt;&gt; x = np.array([[3,4,7], [8,2,1], [5,9,6]])&gt;&gt;&gt; xarray([[3, 4, 7], [8, 2, 1], [5, 9, 6]])# 获取数组平铺后的最大元素索引&gt;&gt;&gt; np.argmax(x)7# 获取最大元素：&gt;&gt;&gt; x.ravel()[np.argmax(x)]9&gt;&gt;&gt; np.argmax(x, axis=0)array([1, 2, 0], dtype=int64)&gt;&gt;&gt; np.argmax(x, axis=1)array([2, 0, 1], dtype=int64)# ↓↓↓↓↓↓ 4. where ↓↓↓↓↓↓ ## An array with elements from `x` where `condition` is True,# and elements from `y` elsewhere.&gt;&gt;&gt; a = np.arange(8).reshape(2, 4)&gt;&gt;&gt; aarray([[0, 1, 2, 3], [4, 5, 6, 7]])&gt;&gt;&gt; np.where(a&lt;5, a, a*5)array([[ 0, 1, 2, 3], [ 4, 25, 30, 35]])# 默认情况下，返回满足条件的索引值：&gt;&gt;&gt; a = np.arange(8, 16).reshape(2, 4)&gt;&gt;&gt; aarray([[ 8, 9, 10, 11], [12, 13, 14, 15]])&gt;&gt;&gt; np.where(a&gt;10)(array([0, 1, 1, 1, 1], dtype=int64), array([3, 0, 1, 2, 3], dtype=int64))&gt;&gt;&gt; a[np.where(a&gt;10)]array([11, 12, 13, 14, 15])# ↓↓↓↓↓↓ 5. extract ↓↓↓↓↓↓ #&gt;&gt;&gt; arr = np.arange(12).reshape((3, 4))&gt;&gt;&gt; arrarray([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11]])&gt;&gt;&gt; condition = np.mod(arr, 3)==0&gt;&gt;&gt; conditionarray([[ True, False, False, True], [False, False, True, False], [False, True, False, False]])# 返回数组中使得条件为 True 的元素的值：&gt;&gt;&gt; np.extract(condition, arr)array([0, 3, 6, 9])# ↓↓↓↓↓↓ 6. count_nonzero ↓↓↓↓↓↓ #&gt;&gt;&gt; a = np.array([[0, 1, 7, 0],... [3, 0, 2, 19]])&gt;&gt;&gt; np.count_nonzero(a)5# 沿着轴 0 统计非零元素数目：&gt;&gt;&gt; np.count_nonzero(a, axis=0)array([1, 1, 2, 1])# 沿着轴 1 统计非零元素数目：&gt;&gt;&gt; np.count_nonzero(a, axis=1)array([2, 3])# 统计时，保留数组维度信息：&gt;&gt;&gt; np.count_nonzero(a, axis=1, keepdims=True)array([[2], [3]], dtype=int64) 数组的排序NumPy 中还提供了一个对数组内元素进行排序的方法，返回一个数组副本（Copy）。其语法格式如下： 1numpy.sort(arr, axis=-1, kind='quicksort', order=None) 其中，参数 axis 表示要排序的轴，默认 -1 表示沿最后一个轴进行排序；如果为 None，表示排序前要将数组铺平。参数 kind 表示要采用的排序算法，有三种模式 {‘quicksort’（快速排序），’mergesort’（归并排序），’heapsort’（堆排序）}。参数 order 表示，如果数组设置了字段，则 order 表示要排序的字段。 实例代码如下： 12345678910111213141516171819202122232425&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; arr = np.array([[3,7],[9,1]])&gt;&gt;&gt; arrarray([[3, 7], [9, 1]])# 默认情况下，沿着最后的轴（axis=1）进行排序：&gt;&gt;&gt; np.sort(arr)array([[3, 7], [1, 9]])# 沿着轴 0 进行排序：&gt;&gt;&gt; np.sort(arr, axis = 0)array([[3, 1], [9, 7]])# 若数组设置了 `name` &amp;&amp; `age` 字段：&gt;&gt;&gt; dt = np.dtype([('name', 'S10'),('age', int)])&gt;&gt;&gt; arr = np.array([(&quot;raju&quot;, 21),(&quot;anil&quot;, 25),(&quot;ravi&quot;, 17), (&quot;amar&quot;, 27)], dtype = dt)&gt;&gt;&gt; arrarray([(b'raju', 21), (b'anil', 25), (b'ravi', 17), (b'amar', 27)], dtype=[('name', 'S10'), ('age', '&lt;i4')])# 按照年龄字段进行排序：&gt;&gt;&gt; np.sort(arr, order = 'age')array([(b'ravi', 17), (b'raju', 21), (b'anil', 25), (b'amar', 27)], dtype=[('name', 'S10'), ('age', '&lt;i4')]) 其它排序方法 &gt;&gt;&gt; numpy.argsort(arr , axis=-1, kind=None, order=None)：沿指定的轴，对数组的元素值进行排序，返回排序后的元素 索引数组； numpy.lexsort(keys, axis)：按 键序列 对数组进行排序，返回一个已排序的 索引数组。 实例代码如下： 123456789101112131415161718&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; arr = np.array([90, 29, 89, 12])# 获取排序后数组元素索引数组：&gt;&gt;&gt; np.argsort(arr)array([3, 1, 2, 0], dtype=int64)# 排序后数组：&gt;&gt;&gt; arr[np.argsort(arr)]array([12, 29, 89, 90])&gt;&gt;&gt; a = [1,5,1,4,3,4,4] # First column&gt;&gt;&gt; b = [9,4,0,4,0,2,1] # Second column&gt;&gt;&gt; ind = np.lexsort((b,a)) # Sort by a, then by b&gt;&gt;&gt; indarray([2, 0, 4, 6, 5, 3, 1])&gt;&gt;&gt; [(a[i],b[i]) for i in ind][(1, 0), (1, 9), (3, 0), (4, 1), (4, 2), (4, 4), (5, 4)] NumPy 随机数NumPy 中还提供了一个随机功能模块（numpy.random），以提供随机数功能。基本的随机函数如下： ↓↓↓↓↓↓ 1. numpy.random.rand ↓↓↓↓↓↓ 该方法用于，指定一个给定维度的数组（(d0, d1, ..., dn)），并使用 [0, 1) 区间随机数据填充，数据均匀分布。其语法格式如下： 1numpy.random.rand(d0, d1, ..., dn) 实例代码如下： 1234567&gt;&gt;&gt; import numpy as np# 生成一个元素值区间在 `[0, 1)` 的二维的，形状为（3, 2）的数据均匀分布的数组： &gt;&gt;&gt; np.random.rand(3, 2)array([[0.9766812 , 0.38515738], [0.59869254, 0.26848813], [0.98355621, 0.51861994]]) ↓↓↓↓↓↓ 2. numpy.random.randn ↓↓↓↓↓↓ 不同于 numpy.random.rand 的，该函数会生成一个元素值满足标准正态分布的数组。其语法格式同 rand： 1numpy.random.randn(d0, d1, ..., dn) 实例代码如下： 12345678910&gt;&gt;&gt; import numpy as np# 生成一个元素值满足标准正态分布的，其形状为（2, 4）的二维数组:&gt;&gt;&gt; np.random.randn(2, 4)array([[ 0.28689859, 0.62225787, -0.74514634, -1.28207413], [ 0.08684388, 0.4530653 , -1.61979964, -1.17046996]])# 你还可以：&gt;&gt;&gt; 1 + 2.5 * np.random.randn(2, 4)array([[ 0.04701047, -1.93698022, 0.2829873 , 1.74470424], [ 0.37269291, 1.13634982, 0.05891712, -0.78763252]]) | ================================================== Split Line =============================================== | ↓↓↓↓↓↓ 3. numpy.random.randint ↓↓↓↓↓↓ 该函数会生成一个元素值位于特定区间的，随机整数数组。其语法格式如下： 1numpy.random.randint(low, high=None, size=None, dtype=int) 其中，前两个参数表示区间的上下限 [low, high) &lt;&lt;&lt; 前闭后开的；参数 size 用来指定数组尺寸。 实例代码如下： 12345&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; np.random.randint(5, 10, size=(2, 4))array([[7, 7, 7, 8], [6, 6, 6, 8]]) ↓↓↓↓↓↓ 4. numpy.random.random_sample ↓↓↓↓↓↓ 该函数会生成一个元素值位于 [0, 1) 的，指定大小（size）的，随机浮点数数组。其语法格式如下： 1numpy.random.random_sample(size=None) 实例代码如下： 1234567891011&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; np.random.random_sample()0.9886997552147712# 生成一个一维数组：&gt;&gt;&gt; np.random.random_sample((5,))array([0.70472921, 0.63700827, 0.58702326, 0.95931205, 0.25185975])# 生成一个形状为（2, 4）的二维数组：&gt;&gt;&gt; np.random.random_sample((2, 4))array([[0.50799584, 0.92990624, 0.8807129 , 0.20741762], [0.93899597, 0.74072453, 0.60292363, 0.50895451]]) 还有三个类似于 numpy.random.random_sample 的方法，如下： numpy.random.random([size]) numpy.random.sample([size]) numpy.random.ranf([size]) | ================================================== Split Line =============================================== | ↓↓↓↓↓↓ 5. numpy.random.choice ↓↓↓↓↓↓ 随机抽样生成 &gt;&gt;&gt; 该函数会 从给定的数组里随机抽取几个值，生成指定大小（size）的，随机抽样数组。其语法格式如下： 1numpy.random.choice(arr, size=None, replace=True, p=None) 其中，参数 arr 表示给定的或随机抽样的数组或整数，整数时同理于 np.arange(arr)；参数 replace 表示数组中的元素是否可以多次重复抽样；参数 p 用于指定数组元素关联的概率，不设定的话表示数组 arr 中元素均匀分布。 实例代码如下： 12345678910&gt;&gt;&gt; import numpy as np# np.arange(5) 中 3 出现的概率为 0.6：&gt;&gt;&gt; np.random.choice(5, 3, p=[0.1, 0, 0.3, 0.6, 0])array([3, 3, 0]) # random&gt;&gt;&gt; aa_milne_arr = ['pooh', 'rabbit', 'piglet', 'Christopher']&gt;&gt;&gt; np.random.choice(aa_milne_arr, 5, p=[0.5, 0.1, 0.1, 0.3])array(['pooh', 'pooh', 'pooh', 'Christopher', 'piglet'], # random dtype='&lt;U11') 👇👇👇 概率密度分布 👇👇👇 NumPy 还提供了大量的满足特定概率密度分布的样本生成方法，使用和上述方法类似，使用时查表即可。如下： numpy.random.beta(a，b，size)：从 Beta 分布中生成随机数； numpy.random.binomial(n, p, size)：从二项分布中生成随机数； numpy.random.chisquare(df，size)：从卡方分布中生成随机数； numpy.random.dirichlet(alpha，size)：从 Dirichlet 分布中生成随机数； numpy.random.exponential(scale，size)：从指数分布中生成随机数； numpy.random.f(dfnum，dfden，size)：从 F 分布中生成随机数； numpy.random.gamma(shape，scale，size)：从 Gamma 分布中生成随机数； numpy.random.geometric(p，size)：从几何分布中生成随机数； numpy.random.gumbel(loc，scale，size)：从 Gumbel 分布中生成随机数； numpy.random.hypergeometric(ngood, nbad, nsample, size)：从超几何分布中生成随机数； numpy.random.laplace(loc，scale，size)：从拉普拉斯双指数分布中生成随机数； numpy.random.logistic(loc，scale，size)：从逻辑分布中生成随机数； numpy.random.lognormal(mean，sigma，size)：从对数正态分布中生成随机数； numpy.random.logseries(p，size)：从对数系列分布中生成随机数； numpy.random.multinomial(n，pvals，size)：从多项分布中生成随机数； numpy.random.multivariate_normal(mean, cov, size)：从多变量正态分布绘制随机样本； numpy.random.negative_binomial(n, p, size)：从负二项分布中生成随机数； numpy.random.noncentral_chisquare(df，nonc，size)：从非中心卡方分布中生成随机数； numpy.random.noncentral_f(dfnum, dfden, nonc, size)：从非中心 F 分布中抽取样本； numpy.random.normal(loc，scale，size)：从正态分布绘制随机样本； numpy.random.pareto(a，size)：从具有指定形状的 Pareto II 或 Lomax 分布中生成随机数； numpy.random.poisson(lam，size)：从泊松分布中生成随机数； numpy.random.power(a，size)：从具有正指数 a-1 的功率分布中在 0，1 中生成随机数； numpy.random.rayleigh(scale，size)：从瑞利分布中生成随机数； numpy.random.standard_cauchy(size)：从标准 Cauchy 分布中生成随机数； numpy.random.standard_exponential(size)：从标准指数分布中生成随机数； numpy.random.standard_gamma(shape，size)：从标准 Gamma 分布中生成随机数； numpy.random.standard_normal(size)：从标准正态分布中生成随机数； numpy.random.standard_t(df，size)：从具有 df 自由度的标准学生 t 分布中生成随机数； numpy.random.triangular(left，mode，right，size)：从三角分布中生成随机数； numpy.random.uniform(low，high，size)：从均匀分布中生成随机数； numpy.random.vonmises(mu，kappa，size)：从 Von Mises 分布中生成随机数； numpy.random.random.wald(mean，scale，size)：从 Wald 或反高斯分布中生成随机数； numpy.random.weibull(a，size)：从威布尔分布中生成随机数； numpy.random.zipf(a，size)：从 Zipf 分布中生成随机数。 NumPy 数学函数Python 自带的运算符只能完成一些基本的数组运算，对于更加复杂的数学计算就显得捉襟见肘。 显而易见的，NumPy 为我们提供了更多的数学函数，以帮助我们更好地完成复杂的数值计算！！！ Numpy 代数支持 参考链接： https://blog.csdn.net/a1097304791/article/details/120901716https://www.runoob.com/numpy/numpy-ndarray-object.htmlhttp://c.biancheng.net/https://blog.csdn.net/weixin_44330492/article/details/100126774https://blog.csdn.net/csdn15698845876/article/details/73380803","link":"/2018/01/20/python-shu-ju-fen-xi-zhi-numpy-shu-xue-ji-suan-ku/"},{"title":"一文解析 NumPy ndarray 多维数组结构设计","text":"从 NumPy ndarray 的内存布局以及设计哲学，深入浅析 ndarray 多维数组的结构设计，以及相关属性。 What is NumPy?官方描述 &gt;&gt;&gt; NumPy provides an N-dimensional array type, the ndarray, which describes a collection of “items” of the same type. The items can be indexed using for example N integers. ndarray 是 NumPy 中的 多维数组，由 数据类型相同 的元素组成的元素序列，且可以被 索引。 如下所示： 1234567891011121314151617181920212223242526272829303132&gt;&gt;&gt; import numpy as np# 定义一个三维数组：&gt;&gt;&gt; arr = np.array([[[0, 1, 2], [3, 4, 5]], [[6, 7, 8], [9, 10 ,11]]])&gt;&gt;&gt; arrarray([[[ 0, 1, 2], [ 3, 4, 5]], [[ 6, 7, 8], [ 9, 10, 11]]])&gt;&gt;&gt; type(arr)&lt;class 'numpy.ndarray'&gt;# 数组元素类型：&gt;&gt;&gt; arr.dtypedtype('int32')# 数组维度：&gt;&gt;&gt; arr.ndim3# 数组形状：&gt;&gt;&gt; arr.shape(2, 2, 3)# 数组维间距（步幅）：&gt;&gt;&gt; arr.strides(24, 12, 4)# 索引：&gt;&gt;&gt; arr[0, 1, 1]4&gt;&gt;&gt; arr[0, 0]array([0, 1, 2]) NumPy 数值计算库的核心特性 &gt;&gt;&gt; 定义了一个 n 维数组对象，ndarray 对象（NumPy 数组也就是 ndarray 多维数组），拥有丰富的数学函数，以及对高维数组的直接处理能力。 Ndarray 的内存布局首先给出 ndarray 的内存布局示意图： 可大致划分成 2 部分 &gt;&gt;&gt;数据部分和解释方式： raw array data ：为一个连续的 Memory Block，存储着原始数据，以类似 C 或 Fortran 中的数组进行连续存储； metadata ：对上面内存块的解释方式。 其中，metadata 包含如下信息： dtype：数据类型 &gt;&gt;&gt; 指定了数组中每个元素占用多少个字节，这几个字节怎么解释（例如：int32、float32 等 NumPy 数据类型）； ndim（dim count）：数组维度（数值） &gt;&gt;&gt; 数组有多少维； shape（dimensions）：数组形状（元组） &gt;&gt;&gt; 每个维度上的元素数量； strides：维间距或步幅（元组） &gt;&gt;&gt; 到达当前维下一个相邻数据需要前进的字节数； 以上 4 个信息构成了 ndarray 的 indexing schema &gt;&gt;&gt; 如何索引到指定位置的数据，以及这个数据该怎么解释。 除此之外的信息还有：字节序（大端小端）、读写权限、C-order（行优先存储） or Fortran-order（列优先存储）等，如下所示: 12345678&gt;&gt;&gt; arr.flags C_CONTIGUOUS : True F_CONTIGUOUS : False OWNDATA : True WRITEABLE : True ALIGNED : True WRITEBACKIFCOPY : False UPDATEIFCOPY : False 可以很清晰看出，Ndarray 内存设计 &gt;&gt;&gt; 将数组的 数据部分 &amp;&amp; 解释方式 进行了分离。 Ndarray 的设计哲学事实上， Ndarray 数组的设计哲学就在于 数据存储 &amp;&amp; 与其解释方式 的分离，或者说 &gt;&gt;&gt; 副本（copy） &amp;&amp; 视图（view） 分离。这种分离方式，让尽可能多的操作发生在 解释方式（view）上，而尽量少地操作实际存储数据的内存区域。 简单来说，副本和视图是使用原数组的两种不同方式。先来看一个样例： 1234567891011121314151617181920212223242526272829&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; arr = np.arange(4)&gt;&gt;&gt; print(arr)[0 1 2 3]# 整数数组索引：&gt;&gt;&gt; print(arr[[1, 2]])[1 2]# 切片（Slice）&gt;&gt;&gt; print(arr[1:3])[1 2]# base 属性：&gt;&gt;&gt; print(arr.base)None&gt;&gt;&gt; print(arr[[1, 2]].base)None&gt;&gt;&gt; print(arr[1:3].base)[0 1 2 3]# flags.owndata 属性：&gt;&gt;&gt; print(arr.flags.owndata)True&gt;&gt;&gt; print(arr[[1, 2]].flags.owndata)True&gt;&gt;&gt; print(arr[1:3].flags.owndata)False 样例分析：虽然 a[[1, 2]] 和 a[1:3] 的输出结果相同，但从 base &amp;&amp; flags.owndata 属性的输出结果来看，两者是有差别的。这是因为，a[[1, 2]] 得到的是原数组的副本（copy），而 a[1:3] 得到的是原数组的视图（view）。 那么 base &amp;&amp; flags.owndata 属性到底代表数组的什么？！！ | ==================================== 👇👇👇 base &amp;&amp; flags.owndata 👇👇👇 ==================================== | 我们提到过，Numpy 数组的内部结构包括：数据部分（数据存储区）&amp;&amp; 解释方式（数据结构信息区）。 数据存储区是用于存储数组的数据 &gt;&gt;&gt; Numpy 数组中的数据可以指向其它数组中的数据，这样多个数组可以共用同一个数据（数据共享）。 ndarray.base：用于判断数组中的数据是否来自于别的数组； ndarray.flags.owndata：用于判断数组是否是数据的所有者； 就上例而言，arr.base 和 arr[[1, 2]].base 返回的都是 None，说明两个数组中的数据均来自于自生。而 arr.flags.owndata 和 arr[[1, 2]].flags.owndata 返回的都是 True，说明两个数组都是数据的所有者。 我们再使用 ndarray.ctypes.data 属性来查看一下数组中数据（Memory Block）的物理地址验证一下： 12345678910111213&gt;&gt;&gt; arr.ctypes.data2302028351600# 原始数组 arr 中数据 Memory Block 的物理地址范围：&gt;&gt;&gt; print('data buff address from {0} to {1}'.format(arr.ctypes.data, arr.ctypes.data + arr.nbytes))data buff address from 2302028351600 to 2302028351616# 仍位于 arr 的数据块中，共享数据，是原数组的视图（view）&gt;&gt;&gt; arr[1:3].ctypes.data2302028351604# 已不在 arr 的数据块中，拥有自己的数据块，是原数组的副本（copy）&gt;&gt;&gt; arr[[1, 2]].ctypes.data2302028205472 | ================================================== Split Line =============================================== | 重新来看：a[[1, 2]] 得到的是原数组的副本（copy），而 a[1:3] 得到的是原数组的视图（view）？ 视图是对原数组的引用，或者自身没有数据，与原数组共享数据； 副本是对原数组的完整拷贝，虽然由原数组中数据拷贝而来，但是它相对于原数组是独立的； 视图（View）NumPy 中满足如下可产生原数组的视图（View）： 对原数组的引用； 自身没有数据，与原数组共享数据； 如下所示： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; arr = np.arange(12)&gt;&gt;&gt; arrarray([ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])### =========== 1. 赋值引用 =========== ###&gt;&gt;&gt; cite_of_arr = arr&gt;&gt;&gt; cite_of_arrarray([ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])# 内存地址相同（id），为同一数组，只是一个别名：&gt;&gt;&gt; id(arr)1910433736304&gt;&gt;&gt; id(cite_of_arr)1910433736304# 既然是同一个数组，故：&gt;&gt;&gt; print(arr.base)None&gt;&gt;&gt; print(cite_of_arr.base)None&gt;&gt;&gt; print(arr.flags.owndata)True&gt;&gt;&gt; print(cite_of_arr.flags.owndata)True### ================================= ###### =========== 2. view() 函数 =========== ###&gt;&gt;&gt; view_of_arr = arr.view()&gt;&gt;&gt; view_of_arr.shape = (3, 4)&gt;&gt;&gt; view_of_arrarray([[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11]])&gt;&gt;&gt; print(arr.base)None# view_of_arr 数组不是其数据的所有者，数据共享于 arr：&gt;&gt;&gt; print(view_of_arr.base)[ 0 1 2 3 4 5 6 7 8 9 10 11]&gt;&gt;&gt; print(arr.flags.owndata)True&gt;&gt;&gt; print(view_of_arr.flags.owndata)False# ndarray.view() 操作产生的是 view 视图，只是对数据的解释方式发生变化（形状变化），数据物理地址相同：&gt;&gt;&gt; arr.ctypes.data1910429914608&gt;&gt;&gt; view_of_arr.ctypes.data1910429914608### ===================================== ###### =========== 3. reshape 操作 =========== ###&gt;&gt;&gt; reshape_of_arr = arr.reshape(4, 3)&gt;&gt;&gt; reshape_of_arrarray([[ 0, 1, 2], [ 3, 4, 5], [ 6, 7, 8], [ 9, 10, 11]])&gt;&gt;&gt; print(arr.base)None# reshape_of_arr 数组不是其数据的所有者，数据共享于 arr：&gt;&gt;&gt; print(reshape_of_arr.base)[ 0 1 2 3 4 5 6 7 8 9 10 11]&gt;&gt;&gt; print(arr.flags.owndata)True&gt;&gt;&gt; print(reshape_of_arr.flags.owndata)False# reshape 操作产生的是 view 视图，只是对数据的解释方式发生变化（形状变化），数据物理地址相同：&gt;&gt;&gt; arr.ctypes.data1910429914608&gt;&gt;&gt; reshape_of_arr.ctypes.data1910429914608### ======================================= ###### =========== 4. ndarray.T 转置操作 =========== ###&gt;&gt;&gt; transpose_of_arr = reshape_of_arr.T&gt;&gt;&gt; transpose_of_arrarray([[ 0, 3, 6, 9], [ 1, 4, 7, 10], [ 2, 5, 8, 11]])# reshape_of_arr 数组不是其数据的所有者，数据共享于 arr：&gt;&gt;&gt; print(transpose_of_arr.base)[ 0 1 2 3 4 5 6 7 8 9 10 11]&gt;&gt;&gt; print(transpose_of_arr.flags.owndata)False# Transpose 转置操作产生的是 view 视图，只是对数据的解释方式发生变化（形状变化），数据物理地址相同：&gt;&gt;&gt; transpose_of_arr.ctypes.data1910429914608 视图原理剖析示意图 &gt;&gt;&gt; 可见，view() 函数 &amp;&amp; reshape 操作 &amp;&amp; transpose &amp;&amp; Slice 操作生成的是原数组视图（view），共用原数组 arr 数据存储区中的数据，但由于它们都有属于自己的数据结构信息区，因此可以将 arr 数组中的原始数据以自己的方式进行表达（指定不同的形状、dtype 等）。 view 机制的好处显而易见，省内存，同时速度快~~~ 副本（Copy）副本是对原数组的完整拷贝，虽然由原数组中数据拷贝而来，但是它相对于原数组是独立的。 使用 copy() 函数 &amp;&amp; 数组高级索引方法，均可以返回数组的副本（Copy）。 如下所示： 123456789101112131415161718192021222324252627282930&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; arr = np.arange(12)&gt;&gt;&gt; arrarray([ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])# copy 函数生成副本：&gt;&gt;&gt; copy_of_arr = arr.copy()&gt;&gt;&gt; copy_of_arrarray([ 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])# # copy_of_arr 数组是其数据的所有者，拷贝但独立于 arr：&gt;&gt;&gt; print(arr.base)None&gt;&gt;&gt; print(copy_of_arr.base)None&gt;&gt;&gt; print(arr.flags.owndata)True&gt;&gt;&gt; print(copy_of_arr.flags.owndata)True# &gt;&gt;&gt; arr.ctypes.data1910429914608# 原始数组 arr 中数据 Memory Block 的物理地址范围：&gt;&gt;&gt; print('data buff address from {0} to {1}'.format(arr.ctypes.data, arr.ctypes.data + arr.nbytes))data buff address from 1910429914608 to 1910429914656# 可见，ndarray.copy() 操作产生的是 copy 副本，数据物理地址不相同：&gt;&gt;&gt; copy_of_arr.ctypes.data1910429916208 副本图原理剖析示意图 &gt;&gt;&gt; 由于副本和原数组是相互独立的，改变副本或者原数组中的元素值，相对应的原数组和副本中的元素值并不会发生改变！！！ 设计的优异性为什么 ndarray 可以这样设计？！！ 由于 ndarray 是为数组和矩阵运算服务的，ndarray 数组中的所有数据都是同一种类型（设计核心依据）（如 int32 &amp;&amp; float64...），其稠密地排列在一起（元素序列）。取出时根据 dtype 现 copy 一份数据组装成 scalar 对象输出。 这样极大地节省了空间，scalar对象中除了数据之外的域没必要重复存储，同时因为连续内存的原因，可以按秩访问，速度也要快得多。 👇👇👇 Ndarray 性能优势 👇👇👇 这里，可以将 ndarray 与 Python 中的 list 对比一下 &gt;&gt;&gt;&gt; List 可以容纳不同类型的对象，像 string、int、tuple 等都可以放在一个 List 里。故 List 中存放的是对象的引用，再通过引用找到具体的对象，这些对象所在的物理地址并不是连续的，如下所示： 所以相对 ndarray &gt;&gt;&gt; List 访问到数据需要多跳转 1 次，List 只能做到对对象引用的按秩访问，对具体的数据并不是按秩访问，所以效率上 ndarray 比 List 要快得多； 空间上，ndarray 只把数据紧密存储，而 List 需要把每个对象的所有域值都存下来，所以 ndarray 比 List 要更省空间。 ndarray 设计机制的好处显而易见，省内存，同时速度快~~~ N-Darray 的理解如何合理的想象多维数组？？？ 以图书馆来举例： 一维数组 &gt;&gt;&gt; 一条线（一个行/列向量） 二维数组 &gt;&gt;&gt; 一页纸 三维数组 &gt;&gt;&gt; 一本书（多页纸） 四维数组 &gt;&gt;&gt; 书架（多本书） 五维数组 &gt;&gt;&gt; 图书室 2201（多个书架） 六维数组 &gt;&gt;&gt; 图书馆某一层，2楼/3楼（多个图书室） 七维数组 &gt;&gt;&gt; 整个图书馆 … … 第 N 维数组 &gt;&gt;&gt; … 宇宙 … | ================================================== Split Line =============================================== | 👇👇👇 关于 Ndarray 中的一维行向量、列向量的理解 👇👇👇 你可能听过这样的说法：“写数组的时候是横着写的，而其实数组是列向量（更直观）”。 许久以来都有一个疑问 &gt;&gt;&gt; NumPy 中的一维向量究竟是 行向量 还是 列向量 呢？？？ ↓↓↓↓↓↓ 测试思路（向量点乘维度要对应的特性） ↓↓↓↓↓↓ 构建一个 4*2 的数组 arr 和一个一维的长度为 2 的 Numpy 向量 vec； 使用 arr 点乘 vec &gt;&gt;&gt; 点乘 np.dot(arr, vec) 不报错，说明一维向量为 2*1 的列向量；如果报错，说明向量肯定不是列向量。 如果不报错，先将 vec 转置，然后继续使用点乘 np.dot(arr, vec) &gt;&gt;&gt; 如果还不报错，说明一维向量 vec 既可以当做列向量也可以当做行向量。 先来进行第 1 &amp;&amp; 2 步测试： 12345678910111213141516171819&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; arr = np.array([[1, 1, 1, 1], [1, 1, 1, 1]]).T&gt;&gt;&gt; arrarray([[1, 1], [1, 1], [1, 1], [1, 1]])&gt;&gt;&gt; arr.shape(4, 2)&gt;&gt;&gt; vec = np.array([2, 3])&gt;&gt;&gt; vecarray([2, 3])&gt;&gt;&gt; vec.shape(2,)&gt;&gt;&gt; np.dot(arr, vec)array([5, 5, 5, 5]) 可见，一维向量 vec 可以作为列向量与矩阵 arr 相乘。 继续进行第 3 步测试： 1234567891011121314151617&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; arr = np.array([[1, 1, 1, 1], [1, 1, 1, 1]]).T&gt;&gt;&gt; arrarray([[1, 1], [1, 1], [1, 1], [1, 1]])&gt;&gt;&gt; arr.shape(4, 2)&gt;&gt;&gt; vec = np.array([2, 3]).T&gt;&gt;&gt; vecarray([2, 3])&gt;&gt;&gt; vec.shape(2,)&gt;&gt;&gt; np.dot(arr, vec)array([5, 5, 5, 5]) 居然也可以进行点乘，Amazing！！！说明 NumPy 中的一维向量既可以作为行向量，也可以作为列向量存在。 总结下来，可以得到如下结论： [1] &gt;&gt;&gt;&gt; 一维数组的转置仍是自己本身，这点根据上述实验的一维向量 vec 的 shape 就能看出来，vec.T（转置后）维度不变。 [2] &gt;&gt;&gt;&gt; NumPy 中的一维向量，可以认为它既不是行向量也不是列向量，只是一个长度为 2 的一维向量。也可以把理解为它既可以做行向量同时也能做列向量，具体是行向量还是列向量根据与他进行点乘的矩阵而定。 [3] &gt;&gt;&gt;&gt; NumPy 一维向量既可以做行向量也可以做列向量，对于任意一个给定的一维向量，你无法确定它到底是行向量还是列向量。故，习惯上用二维矩阵而不是一维矩阵来表示行向量和列向量，因为二维必定能够确定他是行向量还是列向量。 对于 3，见下例： 1234567891011121314# 行向量：&gt;&gt;&gt; row_vec = np.array([[2, 3]])&gt;&gt;&gt; row_vecarray([[2, 3]])&gt;&gt;&gt; row_vec.shape(1, 2)# 列向量：&gt;&gt;&gt; col_vec = np.array([[2], [3]])&gt;&gt;&gt; col_vecarray([[2], [3]])&gt;&gt;&gt; col_vec.shape(2, 1) Ndarray 属性详解这一章节，我们将深入了解 Ndarray 数组中行列优先、维度、轴、形状，以及维间距等… C/F Order前面提到过，Ndarray 数组中有一个 order 属性，是指数组的内存布局，常见的有：C-Order(行优先) &amp;&amp; Fortran-Order（列优先）。 其中，C-Order 是指类似于 C 语言中数组内存布局，而 Fortran-Order 是指类似于 Fortran 语言数组内存布局。 那么 &gt;&gt;&gt;&gt; Fortran 的列优先是什么含义，与 C 语言行优先有何区别？？？ | ================================================== Split Line =============================================== | Fortran 也好，C 也好，操作的数组都存在于内存中，而 内存中是没有行列概念的。一维/二维/三维数组，都是 “一条线（序列）” 一样的存储在内存中。在这个层面上，Fortran 与 C 没有区别。 如下范例，内存中存储了 8 个数据：1，2，3，4，5，6，7，8（蓝色框）。 假设（真实地址相似） &gt;&gt;&gt; 由于数组中元素数据类型相同，每个元素所占的字节数固定（int32 &amp;&amp; float32），为 4 个字节。它们对应内存中的地址为（连续内存区）： 10x0041F100 , 0x0041F104 , 0x0041F108 ...... 0x0041F11C 不同的是，Fortran 和 C 会以不同的命名习惯来对内存中的数据进行 “命名” 以实现索引，并通过各自的习惯来寻找对应的地址（索引）。 这是由于高级语言通常不会直接访问内存地址，所以 Fortran 和 C 使用数组来 “命名” 这些内存地址，并且通过（数组 + 下标）的索引方式来访问这些内存地址。 1D-Ndarray &gt;&gt;&gt; 如果把这一段内存地址视为 8 元素的一维数组，Fortran 和 C 的规则差别不大，Fortran 默认以 1 开头，而 C 则以 0 开头（索引）&lt;&lt;&lt;&lt; Ndarray 都是从零开始。 2D-Ndarray &gt;&gt;&gt; 如果把这一段内存地址视为 2*4 元素的二维数组，则 Fortran 和 C 还有另一个差异（结合示意图理解）： Fortran 会先变化前面的维度，即顺序为 a(1,1) , a(2,1) .... 前面的 1 先变化为 2，后面维度始终保持为 1。直到循环完毕后，再将后面的维度加一，即 a(1,2) , a(2,2).....； C 语言则相反，会先变化后面的维度，即顺序为 a[0][0] , a[0][1] .... 后面的 0 先变化为 1，前面维度始终保持为 0。直到循环完毕后，再将前面的维度加一，即 a[1][0] , a[1][1].....。 因此，对于二维数组来说，Fortran 的 a(m, n) 默认情况下，对应于 C 语言的 a[n-1][m-1]。 从 Ndarray 设计哲学来看，C/F Order 是对于 Memory Block 中数据的一种解释方式~~~ 可见，对于数组中行列的说法很容易混淆。并且，对于高维数组是不存在真正的行和列的，轴（axis）才是始终有意义的表达方式。 维度/轴（Axis）事实上，对于 Ndarray 轴和维度的概念是通用的。 以三维数组为例，其包含列（Row）、行（Col）、页（Page）三个维度 &gt;&gt;&gt; 再来看其轴（axis），它包括 0、1、2 三个轴（即 axis=0 &amp;&amp; axis=1 &amp;&amp; axis=2）。其中，axis=0 代表的是页（Page）这一维；axis=1 代表的是列（Row）这一维；axis=2 代表的是行（Col）这一维。 也就是说，axis 越小，其代表的层次（维度）越高。 你应该记得，前面我们说过：对于多维数组（N-Dim）的显示结果和与列表（List）相同，每多嵌套一层，就代表多一个维度（凭借此你可以很轻易的判断出某个 ndarray 数组的维度）。 简单来说，就是 “最外面的括号代表着 axis=0，依次往里的括号对应的 axis 的计数就依次加 1”。 | ================================================== Split Line =============================================== | ↓↓↓↓↓↓ 2D Ndarray ↓↓↓↓↓↓ 举个例子，假设二维 ndarray 数组：[[0, 1], [2, 3]]，其 axis 的对应方式就是： 相应轴上的求和（sum）运算推理（确认各轴上元素，求和），先以二维数组为例： 各轴元素对应情况解析 &gt;&gt;&gt; 代码验证上述推论过程： 1234567891011&gt;&gt;&gt; x = np.arange(4).reshape(2, 2)&gt;&gt;&gt; xarray([[0, 1], [2, 3]])# Axis 0:&gt;&gt;&gt; np.sum(x, axis=0)array([2, 4])# Axis 1:&gt;&gt;&gt; np.sum(x, axis=1)array([1, 5]) 哎？！！貌似出来的结果比我们推导的结果的括号要少一些。这是因为诸如 np.sum 这种函数中有一个参数叫 keepdims，其默认值是 False，此时它会把多余的括号给删掉。假如我们把它设为 True 的话，就可以得到和推导中一致的结果了： 123456&gt;&gt;&gt; np.sum(x, axis=0, keepdims=True)array([[2, 4]])&gt;&gt;&gt; np.sum(x, axis=1, keepdims=True)array([[1], [5]]) | ================================================== Split Line =============================================== | ↓↓↓↓↓↓ 3D Ndarray ↓↓↓↓↓↓ 下面来看一个更 “高维” 一点的样例（三维）： 代码验证上述推论过程： 1234567891011121314151617181920&gt;&gt;&gt; x = np.arange(8).reshape((2, 2, 2))&gt;&gt;&gt; xarray([[[0, 1], [2, 3]], [[4, 5], [6, 7]]])# Axis 0:&gt;&gt;&gt; np.sum(x, axis=0)array([[ 4, 6], [ 8, 10]])# Axis 1:&gt;&gt;&gt; np.sum(x, axis=1)array([[ 2, 4], [10, 12]])# Axis 2:&gt;&gt;&gt; np.sum(x, axis=2)array([[ 1, 5], [ 9, 13]]) 以及： 12345678910111213141516# Axis 0:&gt;&gt;&gt; np.sum(x, axis=0, keepdims=True)array([[[ 4, 6], [ 8, 10]]])# Axis 1:&gt;&gt;&gt; np.sum(x, axis=1, keepdims=True)array([[[ 2, 4]], [[10, 12]]])# Axis 2:&gt;&gt;&gt; np.sum(x, axis=2, keepdims=True)array([[[ 1], [ 5]], [[ 9], [13]]]) 形状（Shape）通过对 Ndarray 维度/轴的认识，我们已经知道 &gt;&gt;&gt;&gt; 哪个 axis 对应于数组中的哪些元素。 接下来，通过 ndarray.transpose 转置函数来认识一下数组形状（Shape）的本质。 从纸面上来看，如果一个高维数组 arr 的 shape 是 (2, 3, 4)，那么 transpose 的作用就是把这个 shape 中各个数的顺序改一改。如下： 123456789101112131415&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; arr = np.arange(24).reshape((2, 3, 4))&gt;&gt;&gt; arrarray([[[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11]], [[12, 13, 14, 15], [16, 17, 18, 19], [20, 21, 22, 23]]])&gt;&gt;&gt; arr.shape(2, 3, 4)&gt;&gt;&gt; arr.transpose(1, 0, 2).shape(3, 2, 4) 可以看到 &gt;&gt;&gt;&gt; 数组 shape 中的各个数就是对应 axis 上的元素个数（层次由高到低）。 如上述实例中数组 arr，其示意图如下： ↓↓↓↓↓↓ 换一种思路理解 ↓↓↓↓↓↓ 数组 arr 中共有 24 个元素 &gt;&gt;&gt;&gt; 在 axis=0 轴上，只有两个元素（橙色矩阵）。可以理解为：在 axis=0 这个 axis 上，每隔 24 / 2 = 12 个数就跳一下。 在 axis=1 轴上，由于一个橙色矩阵中只有 24 / 2 = 12 个数。可以理解为：在 axis=1 这个 axis 上，每隔 12 / 3 = 4 个数就跳一下。 在 axis=2 轴上，由于一个蓝色向量中只有 12 / 3 = 4 个数。可以理解为：在 axis=2 这个 axis 上，每隔 4 / 4 = 1 个数就跳一下。 哎，我们得到一个元组 &gt;&gt;&gt; (12, 4, 1) &lt;&lt;&lt; 这就是维间距/步幅（Strides） &lt;&lt;&lt; 记录了每个 axis 上跳过的数。 | ================================================== Split Line =============================================== | 激动人心的时刻到了： transpose 的本质，其实就是对 axis/shape/strides 中各个数的顺序进行调换（换轴）。如上实例： 123456789&gt;&gt;&gt; x.transpose(1, 0, 2)array([[[ 0, 1, 2, 3], [12, 13, 14, 15]], [[ 4, 5, 6, 7], [16, 17, 18, 19]], [[ 8, 9, 10, 11], [20, 21, 22, 23]]]) 在 transpose(1, 0, 2) 后，相应的 strides 会变成 (4, 12, 1)。而从上图可以看出，transpose 的结果确实满足： axis=0 的 axis 上，每隔 4 个数跳一下； axis=1 的 axis 上，每隔 12 个数跳一下； axis=2 的 axis 上，每隔 1 个数跳一下。 👇👇👇 需要注意 👇👇👇 有没有同学计算之后，认为换轴后 strides 会变成 (8, 4, 1)？？？ 你需要注意的是，数组中数据元素是在一个连续的 Memory Block（[0, 1, 2, 3, 4, ..., 23]）存储的，而 transpose 仅是数据的一种解释行为，数据元素序列是不会变化的！！！ 以 axis=0 轴为例，每隔 4 个数跳一下，指的是 &gt;&gt;&gt; 元素序列上元素每隔 4 个数跳一下，即跳到 axis=0 轴下一个元素 &gt;&gt;&gt; [0, 1, 2, 3] --&gt; [4, 5, 6, 7] --&gt;[8, 9, 10, 11]。 维间距/步幅（Strides）我们知道的是，执行换轴操作（transpose）后，会同时引发数组形状（Shape）和步幅（Strides）的变化，这是必然的！！！ 代码验证上述推论过程： 1234567891011121314151617181920&gt;&gt;&gt; import numpy as np&gt;&gt;&gt; x = np.arange(24).reshape([2, 3, 4])&gt;&gt;&gt; xarray([[[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11]], [[12, 13, 14, 15], [16, 17, 18, 19], [20, 21, 22, 23]]])&gt;&gt;&gt; x.shape(2, 3, 4)&gt;&gt;&gt; x.transpose(1, 0, 2).shape(3, 2, 4)&gt;&gt;&gt; x.strides(48, 16, 4)&gt;&gt;&gt; x.transpose(1, 0, 2).strides(16, 48, 4) 哎，怎么和上面实例提到的 Strides 不一样啊？！！ 事实上，维间距/步幅（Strides）记录的是 &gt;&gt;&gt;&gt; 每个 axis 轴上跳过的字节数（Bytes）。 所以，你需要在上面的基础上乘以每个元素的字节大小，验证一下： 123456789&gt;&gt;&gt; x.itemsize4&gt;&gt;&gt; before_strides = [int(item / x.itemsize) for item in (x.strides)]&gt;&gt;&gt; before_strides[12, 4, 1]&gt;&gt;&gt; before_strides = [int(item / x.itemsize) for item in (x.transpose(1, 0, 2).strides)]&gt;&gt;&gt; before_strides[4, 12, 1] 👇👇👇 总结一下 👇👇👇 数组 x 以 96(24 个值 * 4 = 96) 个字节的形式存储在内存中，一个接一个(连续内存块)。数组的维间距/步幅告诉我们 &gt;&gt;&gt; 要沿着某个轴移到下一个位置，需要在内存中跳过多少个字节。 偏移量（Offset）有时候，你会见到元素偏移量的说法，这里也来简单认识一下。 对于数组元素偏移量 &gt;&gt;&gt;&gt; 当前数组元素的地址 与 数组首地址 的差值。 &lt;&lt;&lt;&lt; 相对于首元素的偏移 ↓↓↓↓↓↓ 一维数组：A[N] ↓↓↓↓↓↓ 对于一维数组，索引即偏移。 ↓↓↓↓↓↓ 二维数组：A[M][N] ↓↓↓↓↓↓ 对于任一元素 A[i][j] 的偏移量的计算方法就是：i*N+j。 ↓↓↓↓↓↓ 三维数组：A[O][M][N] ↓↓↓↓↓↓ 对于任一元素 A[i][j][k] 的偏移量的计算方法就是：i*M*N + j*N + k。 很好理解，不多解释~~~ 参考链接： https://blog.csdn.net/zengmingen/article/details/106894280https://www.cnblogs.com/shine-lee/p/12293097.htmlhttps://zhuanlan.zhihu.com/p/199615109https://blog.csdn.net/doubleguy/article/details/121566140https://blog.csdn.net/qq_34035425/article/details/123251659https://blog.csdn.net/pql925/article/details/84583236https://blog.csdn.net/qq_43320208/article/details/121509309","link":"/2018/01/20/yi-wen-jie-xi-numpy-ndarray-duo-wei-shu-zu-jie-gou-she-ji/"},{"title":"TensorFlow 入门之 TF 基本工作原理","text":"前面，我们已经成功搭建了基于 TensorFlow 的深度学习框架环境，并完成一个简单的向量加法实例。本篇我们将正式开始 TenosorFLow 相关概念的学习。 配置过程中参考了网络上很多的相关博文，也遇到过很多坑，为了感谢配置过程中各位大佬的帮助以及方便本人下次配置或者升级，整理以作此文。 更多 TensorFlow 框架学习相关内容，请关注博主相关博文系列 ↓↓↓↓↓ 之一 &gt;&gt;&gt;&gt; 一文详解全平台 TensorFlow 深度学习框架在线搭建 (CPU&amp;GPU 支持) 之二 &gt;&gt;&gt;&gt; TensorFlow GPU 支持: Ubuntu16.04 + Nvidia GTX + CUDA + CUDNN 之三 &gt;&gt;&gt;&gt; TensorFlow 入门之 TF 基本工作原理 之四 &gt;&gt;&gt;&gt; TensorFlow 入门之深度学习和深层神经网络 之五 &gt;&gt;&gt;&gt; TensorFlow 入门之 MNIST 手写体数字识别问题 之六 &gt;&gt;&gt;&gt; TensorFlow 入门之图像识别和卷积神经网络（CNN） | ================================================== Split Line =============================================== | 本篇，我们将通过两部分内容详细介绍 TensorFlow 的基本工作原理： 第一部分 &gt;&gt;&gt; 分别通过 TensorFlow 的 计算模型（Graph：计算图）、数据模型（Tensor：张量）以及运行模型（Session：会话），帮助我们对 TensorFlow 的工作原理有一个基本的了解； 第二部分 &gt;&gt;&gt; 我们将简单介绍神经网络的基本概念，主要计算流程，以及如何通过 TensorFlow 来实现神经网络计算过程。 TF 基本工作原理TensorFlow 见名知义：Tensor（张量） 和 Flow（流），表达了它最重要的两个概念： 第一个词 Tensor，就是张量（属于数学或物理中的概念，这里不强调其本身的含义），可以被简单理解为多维数组，表达了 TensorFlow 的数据模型；第二个词 Flow，就是流（数据的流动或转化）它直观的表达了数据（张量）之间通过计算相互转换的过程。 TF 计算模型（Graph：计算图）计算图（Graph）是 TensorFlow 中最基本的一个概念。 Tensorflow 是一个通过计算图的形式表述计算的编程系统，也就是说，所有的 TensorFlow 程序都可以通过计算图的形式来表示。 更深入的理解是 &gt;&gt;&gt; TensorFlow 程序中的所有计算都会被转化为计算图上的节点，计算图中的每一个节点就表示一个计算。计算图中节点之间的边描述了计算之间的依赖关系。 基于上述，下图展示了通过 TensorFlow 可视化工具 TensorBoard 画出的两个向量相加程序样例的计算图： 图中的每一个节点都代表了一个计算 &gt;&gt;&gt; 如 a 节点、b 节点 (TensorFlow 会将常量转化成一种永远输出固定值的运算)以及 add 节点（加法运算）；节点之间的边表示了计算之间的依赖关系，如 add 运算的输入依赖于 a 和 b 运算的输出，而 a 和 b 两个常量不依赖于任何计算。 计算图的使用TensorFlow 程序一般分为两个阶段： 第一阶段 &gt;&gt;&gt;&gt; 需要定义计算图中的所有需要执行的运算； 第二阶段 &gt;&gt;&gt;&gt; 执行定义好的运算（Session）。 首先来看如何定义 TensorFlow 程序（计算图上）中的所有计算： 这里，首先给出 TensorFlow 向量加法程序样例中，定义计算图中计算节点（a，b，result）的方法： 12345678# 导入 TensorFlow 模块：import tensorflow as tf# 定义 TF 常量节点 a &amp;&amp; ba = tf.constant([1.0, 2.00], name=&quot;a&quot;)b = tf.constant([3.0, 4.00], name=&quot;b&quot;)# 定义加法运算节点：result = a + b 注意，这里仅仅是定义了相关的运算节点，但程序并未进行计算，需要通过后面章节的 Session 会话进行运行。 | ================================================== Split Line =============================================== | [1] &gt;&gt;&gt; 默认计算图机制 你可能比较疑惑：上面的样例中，并没有看到任何和计算图定义有关的语句，怎么就使用到计算图（Graph）了？！！ 事实上，TensorFlow 程序中，系统会自动为其维护一个默认的计算图（Default Graph），TensorFlow 会自动将定义好的计算转化为 Default 计算图上的节点。如上述向量加法样例中 a、b、以及 result 节点所属计算图即为默认计算图。 ↓↓↓↓↓↓ 如何查看 TF 默认、以及某运算节点所属的计算图信息？？？ ↓↓↓↓↓↓ Tensor.graph：通过张量（Tensor）的 graph 属性可查看其所属的计算图； tensorflow.get_default_graph：通过（获取默认计算图方法）可获取到程序当前默认的计算图信息； 样例如下： 123456# 查看节点 a 所属的计算图：print (a.graph)# 查看程序默认的计算图：print (tf.get_default_graph())# 判断节点 a 是否属于默认计算图中定义节点：print (a.graph is tf.get_default_graph()) 样例语句输出: 123&lt;tensorflow.python.framework.ops.Graph object at 0x00000204B01969E8&gt;&lt;tensorflow.python.framework.ops.Graph object at 0x00000204B01969E8&gt;True [2] &gt;&gt;&gt; 如何自定义计算图 TensorFlow 中支持通过 tf.Graph() 函数来自定义一个新的计算图。实例代码如下： 12345678910import tensorflow as tfg = tf.Graph()print(g)# &lt;tensorflow.python.framework.ops.Graph object at 0x0000020206621F48&gt;print(tf.get_default_graph())# &lt;tensorflow.python.framework.ops.Graph object at 0x000002020662D308&gt;print(g is tf.get_default_graph())# False 可见，我们已经定义了一个新的，区别于默认计算图的 Graph：g。 计算图的意义TensorFlow 中计算图的引用是具有非常重要的意义的： [1] &gt;&gt;&gt; Graph 隔离张量和计算 在不同的计算图上的张量和运算不会共享，故 Graph 可以用来隔离张量和计算。 样例程序如下所示： 123456789101112131415161718192021222324252627282930313233343536373839import tensorflow as tf### 1. 定义计算图中的所有需要执行的运算 ###g1 = tf.Graph()# 在计算图 g1 中定义变量 'v'，并初始化为 0 ：with g1.as_default(): # Old Version Error: # v = tf.get_variable( # &quot;v&quot;, initializer=tf.zeros_initializer(shape=[1])) # New Version: v = tf.get_variable(&quot;v&quot;, initializer=tf.zeros_initializer()(shape=[1]))g2 = tf.Graph()# 在计算图 g2 中定义变量 'v'，并初始化为 1 ：with g2.as_default(): v = tf.get_variable(&quot;v&quot;, initializer=tf.ones_initializer()(shape=[1])) ### 2. 执行定义好的运算 #### 在计算图 g1 中读取变量 ‘v’的取值：with tf.Session(graph=g1) as sess: # Old Version Error: # tf.initializer_all_variables().run() # AttributeError: module 'tensorflow' has no attribute 'initializer_all_variables' # New Version: tf.global_variables_initializer().run() with tf.variable_scope(&quot;&quot;, reuse=True): # 在计算图 g1 中，变量 'v' 的取值应该为 0，所以这里输出: [0.] print (sess.run(tf.get_variable('v')))# 在计算图 g2 中读取变量 ‘v’的取值：with tf.Session(graph=g2) as sess: tf.global_variables_initializer().run() with tf.variable_scope(&quot;&quot;, reuse=True): # 在计算图 g2 中，变量 'v' 的取值应该为 1，所以这里输出: [1.] print (sess.run(tf.get_variable('v'))) 样例执行结果如下： 12[0.][1.] 这里，你需要注意 g = tf.Graph() &amp;&amp; g.as_default() 和 tf.Session(graph=g) 的用法。 | ================================================== Split Line =============================================== | [2] &gt;&gt;&gt; Graph 管理运算以及资源 TensorFlow 中的 Graph 不仅仅可以用来隔离张量和计算，还提供了管理张量和计算的机制。 ↓↓↓↓↓↓ 管理张量和计算 ↓↓↓↓↓↓ 例如，计算图可以通过 tf.Graph.device() 函数来指定执行运算的设备： 12345678910111213# TensorFlow 还提供了对 GPU 的支持，来加速计算。# 具体使用 GPU 的办法随后章节会介绍，这里我们知道 TensorFlow 支持 GPU 加速的机制即可。g = tf.Graph()with g.as_default(): a = tf.constant([1.0, 2.0], name='a') b = tf.constant([2.0, 3.0], name='b')with g.device('/gpu:0'): result = a + bwith tf.Session(graph=g) as sess: print (sess.run(result)) 注意，tf.Graph().device() 就是 图.device()，可以为某个计算图指定运算的设备。 ↓↓↓↓↓↓ 管理程序资源 ↓↓↓↓↓↓ 除了管理计算之外，Graph 还能有效管理 TensorFlow 程序中的资源（资源可以是张量、变量或者程序运行时的队列资源等）。 例如：在一个计算图中，可以通过集合（collection）来管理不同类别的资源。比如：通过 tf.add_to_collection(coll_name, var_value) 函数将资源加入到一个或多个集合中； 通过 tf.get_collection(key) 函数来获取一个集合中的所有资源。 为了使用方便，TensorFlow 自动管理了一些常用的集合，如下图所示的几个 TensorFlow 自动维护的集合： 集合名称 集合内容 使用场景 tf.GraphKeys.VARIABLES 所有变量 持久化 TensorFlow 模型 tf.GraphKeys.TRAINABLE_VARIABLES 可学习的变量(一般指神经网络中的参数) 模型训练、生成模型可视化内容 tf.GraphKeys.SUMMARIES 日志生成相关的张量 TensorFlow 计算可视化 tf.GraphKeys.QUEUE_RUNNERS 处理输入的 QueueRunner 输入处理 tf.GraphKeys.MOVING_AVERAGE_VARIABLES 所有计算了滑动平均值的变量 计算变量的滑动平均值 关于上述集合的具体使用不需要深究，在后续相关内容部分会进行说明。 这一小节，我们来介绍 TensorFlow 中另一个重要的基本概念：Tensor。 TF 数据模型（Tensor：张量）张量（Tensor）是 TensorFlow 管理数据的形式，在 TensorFlow 程序中，所有的数据都通过张量的形式表示。 从功能角度来看，张量可以被简单理解为多维数组：零阶张量表示标量（scalar），也就是一个数；第一阶张量表示向量（vector），也就是一个一维数组；第 n 阶张量可以理解为一个 n 维数组。 但是我们要明白，“可以被理解为” 并不是 “实际上就是”！实际上，张量在 TensorFlow 中的实现并不是直接采用数组的形式，它只是一个对 TensorFlow 运算结果的引用，张量中并没有存储真正的数值，它保存的一个运算的过程。 如何理解？？？来看下面的代码，运行后并不会得到加法的结果，而是对结果的一个引用： 123456789101112import tensorflow as tfa = tf.constant([1.0, 2.0], name=&quot;a&quot;)b = tf.constant([3.0, 4.0], name=&quot;b&quot;)result = a + bprint(a)# Tensor(&quot;a:0&quot;, shape=(2,), dtype=float32)print(b)# Tensor(&quot;b:0&quot;, shape=(2,), dtype=float32)print(result)# Tensor(&quot;add:0&quot;, shape=(2,), dtype=float32) 可以看出：TensorFlow 中的张量和 Numpy 中的数组是不同的，不是一个数组，不存储数值，而是一个张量结构。 根据上面样例输出的张量，接下来我们来看张量结构： 张量结构从上述结果中可以看出，一个张量结构主要保存了三个属性：名字（name）、维度（shape）以及 类型（dtype）。 [1] &gt;&gt;&gt; 名字（name） 名字，不仅是张量的唯一标识，也给出了张量是如何计算出来的。 我们知道：TensorFlow 程序都可以通过计算图模型来建立，而计算图中的每一个节点都代表的是一个个的计算，计算结果的引用就存储在张量中，所有张量和计算图中的节点是对应的。 这样张量的命名就可以通过 node_name:src_output 的形式给出。 &lt;&lt;&lt; node_name: 表示当前张量对应节点的名称；src_output: 表示当前张量来至对应节点的第几个输出。 例如上面示例中：add:0 表示 result 这个张量是加法节点 add 输出的第一个结果（编号从 0 开始）。 | ================================================== Split Line =============================================== | [2] &gt;&gt;&gt; 维度（shape） 维度，描述了一个张量的维度信息。维度是张量的一个重要属性，围绕维度 TensorFlow 给出了很多有用的运算，后面我们会涉及到部分相关运算。 例如：shape=(2,) 表示 result 这个张量是一个一维数组，数组的长度为 2。 | ================================================== Split Line =============================================== | [3] &gt;&gt;&gt; 类型（dtype） 类型，每个张量会有一个 唯一 的类型，TenosorFlow 会对所有参与运算的张量进行类型检查。一旦发现类型不匹配时会报错，如下代码： 12345import tensorflow as tfa = tf.constant([1.0, 2.0], name=&quot;a&quot;)b = tf.constant([3, 4], name=&quot;b&quot;) # 去掉数值后的小数点，会使 b 的类型变为整型result = a + b 执行上述代码报错：TypeError: Input 'y' of 'Add' Op has type int32 that does not match type float32 of argument 'x'。 Why？！！这是由于 &gt;&gt;&gt;&gt; TensorFlow 中，如果不指定类型，TensorFlow 会给出默认的类型： 不带小数点的数会被默认为 int32； 带小数点的数会被默认为 float32。 由于使用默认类型可能导致潜在的类型不匹配问题，所以 一般建议通过 dtype 属性来明确指出变量或常量类型。如下： 12345import tensorflow as tfa = tf.constant([1.0, 2.0], dtype=tf.float32, name=&quot;a&quot;)b = tf.constant([3.0, 4.0], dtype=tf.float32, name=&quot;b&quot;)result = a + b 👇👇👇 TensorFlow 中支持的数据类型 👇👇👇 实数型：tf.float32、tf.float64 ；整数型：tf.int8、tf.int16、tf.int32、tf.int64、tf.unit8 ；布尔型：tf.bool ；复数型：tf.complex64、tf.complex128。 张量的意义张量（Tensor）的主要使用用途： [1] &gt;&gt;&gt; 对中间结果的引用 直接计算向量和，可读性较差： 1result2 = tf.constant([1.0, 2.0], name='a') + tf.constant([1.0, 2.0], name='b') 使用张量记录中间结果，增强代码可读性： 123a = tf.constant([1.0, 2.0], name=&quot;a&quot;)b = tf.constant([3.0, 4.0], name=&quot;b&quot;)result = a + b 除了提高代码可读性，这还使得我们的计算更加方便与灵活： 12345# 如卷积神经网络中，我们卷积层和池化层都有可能改变张量维度，通过中间结果的引用，我们可以随时查看计算维度的变化:print (result.shape)# (2,)print (result.get_shape())# (2,) 张量还可以通过自身属性字段，查看其属性值： 1234print(result.name)# add:0print(result.dtype)# &lt;dtype: 'float32'&gt; [2] &gt;&gt;&gt; 用来获取计算结果 张量本身没有存储具体数值（计算结果对我们来说是重要的），但它是对计算结果的引用。 但，我们可以通过 sess = tf.Session() ; sess.run(result) 来取得张量所对应的计算结果。 123456789import tensorflow as tfa = tf.constant([1.0, 2.0], dtype=tf.float32, name=&quot;a&quot;)b = tf.constant([3.0, 4.0], dtype=tf.float32, name=&quot;b&quot;)result = a + bsess = tf.Session()sess.run(result)# array([4., 6.], dtype=float32) 可以发现，其计算结果是一个数组。 TF 运行模型（Session：会话）在计算图部分我们提到过 &gt;&gt;&gt;TensorFlow 程序可以分为两个阶段：1）定义计算图中所有的计算；2）执行定义好的计算（Session）。正如前面两节介绍了 TensorFlow 如何组织数据和运算。 这一小节，我们来看 TensorFlow 中的 会话（Session） 是如何来执行定义好的运算的： 会话用来执行计算图中定义好的运算； 会话拥有并管理 TensorFlow 程序运行时的所有资源； 计算完成后需要关闭会话来帮助系统回收资源，否则会出现资源泄漏问题。 相信，看到这里你应该明白了 TF 中会话机制存在的一部分意义了~~~ 由于会话的使用可能导致资源泄漏问题的出现，这里衍生出了会话的两种使用模式： 两种会话使用模式[1] &gt;&gt;&gt; 明确调用会话生成函数和关闭函数 1234567891011121314import tensorflow as tfa = tf.constant([1.0, 2.0], dtype=tf.float32, name=&quot;a&quot;)b = tf.constant([3.0, 4.0], dtype=tf.float32, name=&quot;b&quot;)result = a + b# 创建一个会话，用于执行运算：sess = tf.Session()# 使用创建好的会话，得到我们关心的运算结果 result ：sess.run(result)# 计算完成后，关闭会话回收系统资源，防止资源泄露：sess.close() 尽管我们可以明确调用关闭函数来释放资源占用，但这种模式仍然是不安全的！！！ 风险场景 &gt;&gt;&gt; 当所有计算完成之后，我们需要程序明确调用 tf.Session.close() 来关闭会话并释放资源。然而，当程序因为异常而退出，导致关闭会话函数不会被执行而导致资源泄露。 基于此，TensorFlow 支持通过 Python 上下文管理器来使用会话： [2] &gt;&gt;&gt; 通过 Python 上下文管理器使用会话 123456# 创建一个会话，并通过 Python 上下文管理器管理这个会话：with tf.Session() as sess: # 使用创建好的会话，得到我们关心的运算结果 result ： sess.run(result) # 不需要再明确调用 tf.Session.close() 函数来关闭会话了，当上下文退出时会自动关闭会话和完成资源释放。 通过 Python 上下文管理器机制，我们只需要将需要执行的运算放在 with 内部就可以。不用担心因为忘记关闭会话或程序异常退出导致的资源泄露问题。 默认会话机制在计算图的使用部分，我们提到过 TensorFlow 会自动生成一个默认的计算图，如果没有特殊指定，运算会被自动加入到默认的计算图。 TensorFlow 会话也有类似的机制，但 TensorFlow 不会自动生成默认的会话，需要我们去手动指定（想想这也是合理的）。当会话被指定被指定为默认会话后，我们可以使用默认会话的一些相关函数方法： 12345678# 当默认会话被指定后，可以通过 tf.Tensor.eval() 函数来直接获得计算结果：sess = tf.Session()with sess.as_default(): print(result.eval()) # 是不是很方便 # [4. 6.]sess.close() 注意，以下代码也可完成相同功能： 123456789sess = tf.Session()# 下面两个指令功能相同：print(sess.run(result))# [4. 6.]print(result.eval(session=sess)) # 并非只有在默认会话中才可以使用，但此时你需要传入会话# [4. 6.]sess.close() 为了交互式测试环境下更方便的使用默认会话，TensorFlow 提供了一种 交互式 下直接构建默认会话的函数：tf.InteractiveSession() ,它会自动生成会话并注册为默认会话： 12345sess = tf.InteractiveSession()print(result.eval())sess.close() 会话的配置在执行会话时，我们还可以通过 ConfigProto 来配置需要生成的会话。 通过 tf.ConfigProto() 函数可以配置类似并行的线程数、GPU 分配策略、运算超时等参数，最常使用的有两个： 123456config = tf.ConfigProto(allow_soft_placement=True, log_device_placement=True)# 不管使用什么方式创建会话都可以进行配置：sess1 = tf.InteractiveSession(config=config)sess2 = tf.Session(config=config) | ================================================== 参数说明 =============================================== | [1] &gt;&gt;&gt; allow_soft_placement: 布尔型参数 当 allow_soft_placement = True 时，在以下任意一个条件成立时，GPU 运算可以放到 CPU 上进行： 运算无法在 GPU 上执行（GPU 上不支持该类型数值运算）； 没有 GPU 资源（比如运算被指定在第二个 GPU 上运行，当机器只有第一个 GPU资源）； 运算输入包含对 CPU 计算结果的引用。 allow_soft_placement 参数默认为 False，但为了使得代码的移植性更强（可以同时适应 GPU 和 CPU 环境），一般会将其设置为 True。并且不同 GPU 驱动版本可能对计算的支持有略微差别，当某些运算无法被当前 GPU 支持时，可以自动调整到 CPU，而不是报错。 [2] &gt;&gt;&gt; log_device_placement: 布尔型参数 当 log_device_placement = True 时，日志中会记录每个节点被安排在哪个设备上以便调试。而在生产环境将其设置为 False 可以减少日志量（如下）。 1234567Device mapping:add: (Add): /job:localhost/replica:0/task:0/device:CPU:02023-05-09 20:55:04.597829: I tensorflow/core/common_runtime/placer.cc:1059] add: (Add)/job:localhost/replica:0/task:0/device:CPU:0a: (Const): /job:localhost/replica:0/task:0/device:CPU:02023-05-09 20:55:04.598370: I tensorflow/core/common_runtime/placer.cc:1059] a: (Const)/job:localhost/replica:0/task:0/device:CPU:0b: (Const): /job:localhost/replica:0/task:0/device:CPU:02023-05-09 20:55:04.598836: I tensorflow/core/common_runtime/placer.cc:1059] b: (Const)/job:localhost/replica:0/task:0/device:CPU:0 推荐阅读！！！这里是为了快速引入神经网络（Neural Network）的 TensorFlow 实现。关于神经网络（Neural Network）更系统、全面的介绍，你可以参考博文系列【Deep Learning (深度学习) 】来进行快速学习。 这一部分，我们将简单介绍神经网络（Neural Network）的基本概念，主要计算流程，以及如何通过 TensorFlow 来实现神经网络计算。 初识神经网络在正式开始学习神经网络之前，你必须对神经网络的基本结构 &gt;&gt;&gt;&gt; 神经元模型 有一定的了解： 神经元模型首先我们给出人工神经网络中，神经元模型的示意图： 从上图看出，一个神经元有多个输入和一个输出。每个神经元的输入既可以是其他神经元的输出，也可以是整个神经网络的输入（非神经元节点）。 严格来说 &gt;&gt;&gt;&gt; 神经网络中除了输入层之外的所有节点都代表了一个神经元结构。 很多文档会将输入节点也看作是神经元，所以输入层有时也被看作一层神经网络层（这也是很多时候将一个只有一层隐藏层和输出层的神经网络称为三层神经网络的原因，严格来说，应该是两层神经网络结构）。 根据神经元模型可知 &gt;&gt;&gt; 神经元的输出就是其所有输入的加权和以及偏置项，并通过一个激活函数得到。而不同的输入权重以及神经元节点的偏置就是神经元的参数，神经网络的优化（训练）过程就是优化（训练）神经元中参数的过程。 神经网络结构所谓的神经网络结构：是指 不同神经元之间的连接方式。 本篇，我们将以 三层全连接神经网络结构（Full-Connection Neural Network，FCNN，相邻两层之间任意两个神经元节点之间都有连接）为样例解读神经网络的实现（如下图中网络结构）。 后面的博文系列中，你还会继续学习卷积神经网络（CNN）、循环神经网络（RNN）、残差神经网络等等其它经典神经网络结构。 👇👇👇 TF 游乐场以及神经网络实现流程 👇👇👇 你可以通过 TensorFlow 游乐场工具来快速认识神经网络的整体工作流程 &gt;&gt;&gt;【TensorFlow 游乐场】 &lt;&lt;&lt; 它是一个通过网页浏览器就可以训练的简单神经网络，并实现了可视化训练过程的工具。下图给出了 TensorFlow 游乐场工具页面示意图： 详细操作教程见网络【TensorFlow 游乐场教程】，由于篇幅原因，这里不做介绍。 神经网络通用流程有了上面的认识，这里我们首先给出使用神经网络解决经典分类/回归问题的主要流程： 从给出的原始数据提取实体的特征向量作为神经网络的输入； 定义神经网络结构，以及神经网络的前向传播算法（从输入到输出）； 定义损失函数以及反向传播优化算法，并通过训练优化神经网络参数； 使用训练好的神经网络模型来预测未知数据类型； 关于输入的原始数据特征向量，取决于数据集，这里不过多介绍。先分别来看其它部分内容： 前向传播算法（FP）简单地说，定义神经网络连接结构，以及如何从输入得到输出的过程，就是 &gt;&gt;&gt; 定义神经网络的前向传播（Forward-Propagation）算法的过程（从输入到输出）。 不同结构的神经网络前向传播的方式是不相同的，但大体上是相似的。 以上面的三层全连接神经网络（FCNN）结构的前向传播算法为例进行说明 &gt;&gt;&gt;&gt; 由上图可知：神经网络前向传播算法需要三部分信息(W 上标表示神经网络层数)： 神经网络输入层； 神经网络连接结构（全连接），隐藏层 &amp;&amp; 输出层； 各层神经元个数以及参数（为了简化理解，这里仅指权重，不包含偏置项，不使用激活函数）。 故，我们需要依次计算神经元节点 a_11、a_12、a_13 以及 Y 的输出结果（即神经网络如何进行前向传播！！！）。 | ================================================== Split Line =============================================== | 👇👇👇 矩阵运算表示 👇👇👇 实际上，我们可以把同属一个网络层的所有节点的计算过程表示为矩阵运算。 假设我们要求隐藏层所有节点的值 a^(1) = [a_11, a_12, a_13] 以及输出层节点的值 Y = [y]，前向传播计算过程如下： 首先表示输入的特征向量（一维数组）： $$ x = [x_1, x_2] $$ 隐藏层的权重矩阵为： $$ W^{(1)} = \\left[ \\begin{array} {cccc}W_{1,1}^{(1)} &amp; W_{1,2}^{(1)} &amp; W_{1,3}^{(1)}\\\\W_{2,1}^{(1)} &amp; W_{2,2}^{(1)} &amp; W_{2,3}^{(1)}\\end{array} \\right] $$ 权重矩阵中的每一行元素，都表示和输入层某个节点 x_i 的全连接边上的权重（对应三条边）。 矩阵运算过程如下，展示了节点 a^(1) 的整个前传播计算过程： $$ a^{(1)} = [a_{11}, a_{12}, a_{13}] = xW^{(1)} = [x_1, x_2]\\left[ \\begin{array} {cccc}W_{1,1}^{(1)} &amp; W_{1,2}^{(1)} &amp; W_{1,3}^{(1)}\\\\W_{2,1}^{(1)} &amp; W_{2,2}^{(1)} &amp; W_{2,3}^{(1)}\\\\\\end{array} \\right] \\\\ = [W_{1,1}^{(1)}x_1+W_{2,1}^{(1)}x_2, W_{1,2}^{(1)}x_1+W_{2,2}^{(1)}x_2, W_{1,3}^{(1)}x_1+W_{2,3}^{(1)}x_2] $$ 类似的，输出层节点的输出可以表示为： $$ Y = [y] = a^{(1)}W^{(2)} = [a_{11}, a_{12}, a_{13}]\\left[ \\begin{array} {cccc} W_{1,1}^{(2)}\\\\ W_{2,1}^{(2)}\\\\ W_{3,1}^{(2)}\\\\end{array} \\right] = [W_{1,1}^{(2)}a_{11} + W_{2,1}^{(2)}a_{12} + W_{3,1}^{(2)}a_{13}] $$ 这样，就将前向传播算法通过矩阵乘法的方式给出了~~~ 不知道你发现了没有 &gt;&gt;&gt;&gt; 对于权重矩阵而言，当前网络层（Layer）每增加一个神经元节点，其权重矩阵就增加一列！！！ 并且，对于多个样本数据（N）的特征向量，可以将其分别以行的形式添加到 x 样本的下面，构成（N × 2）的样本输入特征向量矩阵。最终生成（N * 2）×（2 * 3）×（3 * 1）&gt;&gt;&gt;（N × 1）的结果数组。 | ================================================== Split Line =============================================== | 👇👇👇 TensorFlow 实现 👇👇👇 TensorFlow 中矩阵乘法（Matrix Multiply-ication）是很容易实现的，我们通过 TensorFlow 来表示 FCNN 的前向传播计算过程： $$ a^{(1)} = tf.matmul(x, W^{(1)}) $$ $$ y = tf.matmul(a^{(1)}, W^{(2)}) $$ 这里为了简化说明，我们简化了神经元模型中的偏置项（Bias）、激活函数（Activation-Function）等神经元结构，以及更加复杂的神经网络结构（RNN、CNN、Resnet）等的前向传播过程说明。后续博文系列中将会不断的完善，先上车后补票~~~ 这一部分目的上是为了给出上文 FCNN 前向传播算法的 TensorFlow 具体实现。由于涉及到了 TensorFlow 变量的相关内容（内容较多），故设立一个新节进行说明，将其看作上一小节的补充即可。 TF 变量和网络参数表示上文我们通过矩阵乘法，讲解了 FCNN 前向传播算法的实现原理，我们知道神经网络中的参数（权重）就是一个个的矩阵（数组）。 那么，TensorFlow 中如何组织以及存储神经网络中的参数？？？&lt;&lt;&lt;&lt; TF 变量 登场！！！ | ================================================== Split Line =============================================== | TF 变量定义TensorFlow 中提供了一个 tf.Variable(initial_value) 函数用来定义变量，来保存和更新神经网络中的参数。 和其它编程语言类似，TensorFlow 中的变量在声明时也需要指定初始值，对变量进行初始化。 TensorFlow 中变量的初始值可以设置为： 随机数 常数 其它变量的的初始值 下面我们将会分别介绍上述几种初始化方法： [1] &gt;&gt;&gt; 随机数生成器赋值 在神经网络中，给参数赋予随机初始值最为常见，所以一般使用随机数给 TensorFlow 中的变量进行初始化。 这里给出一个 TensorFlow 中声明一个 (2, 3) 的权重矩阵变量，并采用满足标准正态的值进行初始化的方法： 123456weights = tf.Variable(tf.random_normal([2, 3], stddev=2))# tf.random_normal([2, 3], stddev=2) 函数：# 会产生一个 Shape 为（2, 3）的矩阵，矩阵中的元素是 &gt;&gt;&gt; 满足正态分布，均值为 `0`，标准差（Standard Deviation）为 `2` 的随机数。# 参数 mean 用来指定均值（默认为 0）: `tf.random_normal([2, 3], stddev=2， mean=0)`# random_normal() 中也支持设置随机种子 seed。 代码中调用了 TF 变量的声明函数 tf.Variable()。并且在声明函数中给出了变量的随机数初始化函数 tf.random_normal()。 ↓↓↓↓↓↓ TensorFlow 中支持的几种常用随机数生成器 ↓↓↓↓↓↓ 函数名称 随机分布 主要参数 tf.random_normal 正态分布 平均值、标准差、取值类型 tf.truncated_normal 截断正态分布 平均值、标准差、取值类型 tf.random_uniform 均匀分布 最小、最大取值，取值类型 tf.random_gamma Gamma分布 形状参数 alpha、尺度参数 beta、取值类型 其中，截断正态分布表示（比较常用）：如果随机出来的值偏离平均值超过 2 个标准差，会重写随机数。 使用推荐 &gt;&gt;&gt;&gt; 随机数初始化，通常用来给神经网络的权重（Weight）参数进行初始化！！！ [2] &gt;&gt;&gt; 常量赋值 正如前面向量加法样例中展示的，TensorFlow 中也支持通过常数来初始化 TF 变量。 TensorFlow 中支持的几种常用的常数初始化方法： 函数名称 随机分布 样例 tf.zeros 产生全为 0 的数组 tf.zeros([2,3], int32) -&gt; [[0,0,0],[0,0,0]] tf.ones 产生全为 1 的数组 tf.ones([2,3], int32) -&gt; [[1,1,1],[1,1,1]] tf.fill 产生一个全部为给定数字的数组 tf.fill([2,3],9) -&gt; [[9,9,9],[9,9,9]]) tf.constant 产生一个给定值的常量 tf.constant([1,2,3]) -&gt; [1,2,3] 如果你熟悉 NumPy 数组的话，对上面的用法应该不会刚到陌生。 使用推荐 &gt;&gt;&gt;&gt; 神经网络中的偏置项（Bias）通常会使用常数的形式来进行初始化！！！ 123biases = tf.Variable(tf.zeros([3]))print (biases)# &lt;tf.Variable 'Variable:0' shape=(3,) dtype=float32_ref&gt; [3] &gt;&gt;&gt; 其它变量赋值 TensorFlow 也支持通过其它变量的初始值来初始化新变量，如下： 12weight1 = tf.Variable(tf.random_normal([2,3], stddev=2, dtype=tf.float32))weight2 = tf.Variable(weight1.initialized_value()) 需要注意的是 &gt;&gt;&gt;&gt; 该方法不太常用！！！ | ================================================== Split Line =============================================== | 👇👇👇 tf.Variable 操作会添加一些额外的 Op 到 Graph 👇👇👇 一个 Variable 操作，用于存放变量的值； 一个将变量设置为初始值的操作，它是一个 tf.assign 操作； 一个 初始化操作，例如：zeros or ones 等； … 你可以通过如下语句来查看当前计算图（Graph）上的所有节点： 1[tensor.name for tensor in tf.get_default_graph().as_graph_def().node] TF 变量的使用上面你已经了解了 TF 变量如何声明以及初始化(事实上并没有真正被执行，仅在计算图上定义了一个计算节点)。 并且，你需要注意的是 &gt;&gt;&gt;&gt; TensorFlow 中，TF 变量在被使用之前，这个 变量初始化的过程必须被明确调用后，才可以使用！！！否则报错： 1Attempting to use uninitialized value XXXX 如何理解？！！来看一个矩阵乘法样例： 1234567891011&gt;&gt;&gt; import tensorflow as tf# 这里输入必须是二维的（1, 2），否则无法进行矩阵乘法运算：&gt;&gt;&gt; x = tf.constant([[1, 2]], dtype=tf.float32)&gt;&gt;&gt; w = tf.Variable(tf.random_normal([2, 3], stddev=1))&gt;&gt;&gt; y = tf.matmul(x, w)&gt;&gt;&gt; sess = tf.InteractiveSession()&gt;&gt;&gt; sess.run(y)# 这里会产生变量未初始化报错：Attempting to use uninitialized value XXXX# 这是由于在计算 y 时，会使用到 TF 变量 `w`，其未明确的进行初始化调用！！！ 故，TF 变量使用前必须要明确进行初始化的调用( sess.run(w_TF_Variable.initializer) )： 123456# 明确进行初始化调用：&gt;&gt;&gt; sess.run(w.initializer)&gt;&gt;&gt; sess.run(y)array([[-0.17434047, -3.660441 , 1.0128452 ]], dtype=float32)&gt;&gt;&gt; sess.close() | ================================================== Split Line =============================================== | 👇👇👇 引发的一个问题 👇👇👇 上面的样例中，我们在使用变量 w 之前需要明确调用其初始化，完成最终的初始化。 虽然这看上去是一个可行的方案，但你有没有想过：当我们的模神经网络的变量数目增多（通常会有几万，甚至几十、几百万的参数），或者变量之间存在依赖关系时，你还会去一个个的为每个变量做明确初始化调用么？当然不会！！！太麻烦了~~~ TensorFlow 提供了一种更便捷的方法来一步完成所有变量的初始化调用。如下所示： 123456789101112# New Version:init_op = tf.global_variables_initializer().run()# 你可能还会看见这样的表达：init_op = tf.initializer_all_variables().run()# Old Version（新版本下会报错，已弃用）：---------------------------------------------------------------------------AttributeError Traceback (most recent call last)&lt;ipython-input-75-2501d5753001&gt; in &lt;module&gt;() 1 # Old Version(新版本下会报错)：----&gt; 2 init_op = tf.initializer_all_variables().run()AttributeError: module 'tensorflow' has no attribute 'initializer_all_variables' TF 变量属性类似张量（Tensor），维度（shape）和类型（dtype）也是变量最重要的两个属性。 👇👇👇 [1] &gt;&gt;&gt; 类型（dtype） 👇👇👇 类似于强类型语言，一个变量一旦构建之后，变量的类型就不能再改变。 如上面给出的前向传播样例中，w 类型为 tf.random_normal 函数结果的默认类型 tf.float32，那么它就不能被赋予其它类型的值，如下代码所示： 123456w1 = tf.Variable(tf.random_normal([2,3], stddev=1, name=&quot;w1&quot;))w2 = tf.Variable(tf.random_normal([2,3], dtype=tf.float64, stddev=1, name=&quot;w2&quot;))# w2 赋值给 w1：tf.assign(w1, w2) # 等同于下面# w1.assign(w2) 执行上述程序语句将报错：TypeError: Input 'value' of 'Assign' Op has type float64 that does not match type float32 of argument 'ref'。 这类似于张量，TensorFlow 会自动对变量的类型进行类型检查！！！ | ================================================== Split Line =============================================== | 👇👇👇 [2] &gt;&gt;&gt; 维度（shape） 👇👇👇 维度是变量另外一个重要的属性。和类型不大一致，维度在 TF 程序中是可变的，但需要通过参数 validate_shape=False（固定形状）设置。 如下样例： 1234567891011&gt;&gt;&gt; import tensorflow as tf&gt;&gt;&gt; w1 = tf.Variable(tf.random_normal([2,3], stddev=1, name=&quot;w1&quot;))&gt;&gt;&gt; w2 = tf.Variable(tf.random_normal([2,2], stddev=1, name=&quot;w2&quot;))# tf.assigh(w1,w2)# ValueError: Shape (2,3) and (2,2) are not compatible# 这样才可以执行：&gt;&gt;&gt; tf.assign(w1,w2, validate_shape=False)&lt;tf.Tensor 'Assign:0' shape=(2, 2) dtype=float32_ref&gt; 当然，TensorFlow 支持改变变量维度的用法在实践中比较罕见。 | ================================================== Split Line =============================================== | 👇👇👇 [3] &gt;&gt;&gt; trainable &amp;&amp; collections 👇👇👇 计算图中提到过，TensorFLow 中可以通过集合（Collection）来管理运行时的各种资源，并且它自动维护一些默认集合。 例如，所有的变量都会被自动加入到 tf.GraphKeys.VARIABLES/ 集合，你可以通过 tf.all_variables() 函数可以拿到当前计算图上所有的变量以便 TF 持久化TensorFlow 整个计算图的运行状态 tf.Variable() 变量有一个 collections 属性可用于指定新变量所属的集合，默认为 [GraphKeys.GLOBAL_VARIABLES]，支持指定新的集合（例如 loss）。 另外，当构建机器学习模型时，我们需要不断优化参数以获得最佳的模型，可以通过变量声明函数中的 trainable 属性来区分需要优化的参数（神经网络中的参数）和其他参数（迭代轮数）： 1如果声明变量时参数 `trainable` 为 `True`（默认），那么这个变量会被加入到 `tf.GraphKeys.TRAINABLE_VARIABLES` 集合。 你可以在 TF 中可以通过 tf.trainable_variables() 函数得到所有需要优化的参数。并且 TensorFlow 中提供的神经网络优化算法会将 tf.GraphKeys.TRAINABLE_VARIABLES 集合中的变量作为默认的优化对象。 Variables VS Tensor前面，我们提到：TensorFlow 中所有的数据都是通过 Tensor 来组织和管理的，这一小节我们又介绍了通过 TensorFlow 变量来保存和更新参数。 那么，张量和变量是什么关系呢？！！ TensorFlow 中，变量（Variables）的声明函数是一个运算，而张量（Tensor）是对运算结果的引用个。 所以不难看出，这个张量就是我们这一小节所说的变量，也就是说 变量是一种特殊的张量。 TF 实现前向传播算法结合上面的知识储备，我们给出 FCNN 的前向前向传播算法的 TensorFlow 实现： 1234567891011121314151617181920212223import tensorflow as tf# 定义一个变量用于作为神经网络输入，暂时将输入特征向量(即一个样本的特征向量)定义为一个常量(1 * 2 的矩阵)：input_x = tf.constant([[0.7,0.9]], dtype=tf.float32)# 声明两个权重变量：w1、w2（这里还通过 seed 设置了随机种子，可以保证每次运行得到的结果一样）w1 = tf.Variable(tf.random_normal([2, 3], stddev=1, seed=1))w2 = tf.Variable(tf.random_normal([3, 1], stddev=1, seed=1))# 通过前向传播算法原理获得神经网络的输出 Y：a = tf.matmul(input_x, w1)y = tf.matmul(a, w2)# 创建会话来执行定义好的运算：sess = tf.Session()# 使用变量 w1、w2 之前,需要明确调用变量的初始化才可以使用：sess.run(tf.global_variables_initializer())# 执行运算，获取最终结果：print (sess.run(y))sess.close() # 关闭会话，释放资源 样例结果输出：[[3.957578]]。 神经网络模型优化上面我们给出了一个样例来完成 FCNN 的前向传播过程。但是，这个样例中所有变量（参数）的初始取值都是随机的。 事实上，在使用神经网络来解决实际的分类/回归问题时，我们需要 &gt;&gt;&gt;&gt; 使用样本数据，不断训练神经网络模型优化模型参数（不断拟合数据集，发现其潜在规律），以获取到更好的参数取值，以获取最佳的神经网络模型。 这一小节将介绍如何使用监督学习（Supervised Learning）的方式，并且结合训练算法（反向传播算法，Back Propagation，BP）来更合理的设置参数取值。 优化神经网络中参数的过程，就是神经网络的训练过程，只有经过有效训练的神经网络模型才可以真正解决分类/回归问题。 监督学习最重要的思想 就是 &gt;&gt;&gt;&gt; 在已知答案（标签，Label）的标注数据集上，使模型给出的预测结果要尽可能接近真实标记。通过 BP 算法调整神经网络中的参数对训练数据的拟合，可以使得模型对未知样本提供预测能力。 反向传播算法（BP）在神经网络优化算法中，最常用的方法就是反向传播算法（BP）。这里，我们先简单了解一下反向传播算法（Back Propagation，BP）的概念，后续会做深入介绍。 BP 是训练神经网络的核心算法，它可以 &gt;&gt;&gt; 根据定义好的损失函数（Loss Function）来不断迭代优化神经网络中参数的取值，从而使得神经网络模型在训练数据集上的损失函数达到一个较小值。反向传播算法训练神经网络模型的流程图（迭代过程）： 如图可见，反向传播算法本质是实现了一个迭代的过程。 ↓↓↓↓↓↓ 训练第一阶段：FP ↓↓↓↓↓↓ 每次迭代开始，首先需要读取一部分训练数据（来源于训练数据集），这一小部分数据称为一个 batch。然后这个 batch 的数据通过前向传播算法得到其在神经网络模型的预测结果。 ↓↓↓↓↓↓ 训练第二阶段：BP ↓↓↓↓↓↓ 此时，由于训练数据都是有正确答案标注（Label）的，所有可以计算出当前神经网络模型的预测答案和正确答案的差距（通过损失函数来定义）。最后，反向传播算法会根据这个差距更新神经网络的参数，使得预测结果要尽可能接近真实标记。 可见，反向传播算法核心：计算 Loss &amp;&amp; 更新参数。 TF占位符和 Batch 表达TF 实现反向传播算法之前，我们需要了解一下 TF 如何从训练数据集读取一个 batch 的数据，在 TensorFlow 中进行表达。 前面，我们在实现 FCNN 的前向传播算法样例中，曾经使用过用常量来表达一个样本数据： 1input_x = tf.constant([[0.7,0.9]], dtype=tf.float32) ↓↓↓↓↓↓ 引发一个问题 ↓↓↓↓↓↓ 如果每次迭代中选取的数据都要通过常量来创建，那么 TensorFlow 的计算图将会太大。 因为每生成一个常量，TensorFlow 都会在计算图中增加一个计算节点。一般来说，一个神经网络的训练过程会经过几百万轮甚至几亿轮数的迭代，这样计算图就会非常大，而且利用率很低。 👇👇👇 解决办法 👇👇👇 为了避免这个问题，TensorFlow 提供了一个占位符机制（placeholder）用于提供输入数据。placeholder 相当于定义了一个位置（占位），这个位置中的数据在程序运行时再指定（必须），运行时只需要将读入的数据通过 placeholder 传入 TF 计算图即可。 也就是说，我们通过 placeholder 告诉 TF 程序，这里有一个“空间”，我们会在执行程序时再给定这个 “空间” 的取值以供计算图使用。 [1] &gt;&gt;&gt; placeholder 占位符 先来给出占位符的函数形式： 1tf.placeholder(dtype, shape=None, name=None) 占位符中，数据类型（dtype）是需要指定的，而且和其它张量一样，类型是不可更改的；维度信息可以根据提供的数据自动推导得出，所以不一定要给出。 这里，给出将 placeholder 引入全连接神经网络的前向传播算法实现中的样例： 1234567891011121314151617181920212223import tensorflow as tf# placeholder 的使用：input_x = tf.placeholder(tf.float32, shape=(1, 2), name=&quot;input_x&quot;)# 声明两个权重变量：w1、w2（这里还通过 seed 设置了随机种子，可以保证每次运行得到的结果一样）w1 = tf.Variable(tf.random_normal([2, 3], stddev=1, seed=1))w2 = tf.Variable(tf.random_normal([3, 1], stddev=1, seed=1))# 通过前向传播算法原理获得神经网络的输出 Y：a = tf.matmul(input_x, w1)y = tf.matmul(a, w2)# 创建会话来执行定义好的运算：sess = tf.Session()# 使用变量 w1、w2 之前,需要明确调用变量的初始化才可以使用：sess.run(tf.global_variables_initializer())# 执行运算，获取最终结果：print (sess.run(y))sess.close() # 关闭会话，释放资源 我们发现，直接执行 sess.run(y) 会发生报错： InvalidArgumentError (see above for traceback): You must feed a value for placeholder tensor 'input_x_1' with dtype float and shape [1,2]。 WTF ？？？ 哦，想到了：占位之后，在程序运行时必须为 “占位空间” 传入数据值~~~ 上面仅仅是在计算图中创建了一个占位符，但是运行时（sess.run(y)）我们并没有给 placeholder 传入数据。 [2] &gt;&gt;&gt; 神奇的 feed_dict TensorFlow 中可以使用 feed_dict（feed 字典）来为运行时的 placeholder 空间 feed（喂养）样本数据，feed_dict 字典中需要给出每个用到的 placeholder 取值（一个 batch 的数据）。 实例代码如下： 12345678910111213141516171819202122232425import tensorflow as tf# placeholder 的使用（定义了一个（3, 2）的空间）：input_x = tf.placeholder(tf.float32, shape=(3,2), name=&quot;input&quot;)# 声明两个权重变量：w1、w2（这里还通过 seed 设置了随机种子，可以保证每次运行得到的结果一样）w1 = tf.Variable(tf.random_normal([2,3], stddev=1, seed=1))w2 = tf.Variable(tf.random_normal([3,1], stddev=1, seed=1))# 通过前向传播算法原理获得神经网络的输出 Y：a = tf.matmul(input_x, w1)y = tf.matmul(a, w2)# 创建会话来执行定义好的运算：sess = tf.Session()# 明确调用变量init_op = sess.run(tf.global_variables_initializer())# 执行运算会报错：# print (sess.run(y))# batch 中含有 3 个样本（当然可以包含多个）：print (sess.run(y, feed_dict={input_x: [[0.7,0.9], [0.1,0.4], [0.5,0.8]]}))sess.close() # 关闭会话，释放资源 样例运行结果如下（每一行都是一个样本的前向传播结果）： 123[[3.957578 ] [1.1537654] [3.1674924]] Loss Function &amp;&amp; Optimizer前面说过，反向传播算法实现的核心： 计算 Loss：通过定义损失函数，计算当前神经网络模型的预测答案和正确（期望）答案的差距； 更新参数：向着预测和期望差距更小的方向（Loss 更小），更新神经网络的参数。 也就是说 &gt;&gt;&gt;&gt; BP 实现需要 &gt;&gt;&gt;&gt; [1] &gt;&gt;&gt; 定义一个合适损失函数（Loss Function）来刻画当前预测值和期望值之间的差距； [2] &gt;&gt;&gt; 然后通过合适的参数优化器（Optimizer）来调整神经网络参数取值使得差距逐渐被缩小。 下面我们给出一个简单的反向传播算法模型的定义： 12345# 定义交叉熵损失函数：cross_entropy = -tf.reduce_mean(y_ * tf.log(tf.clip_by_value(y, 1e-10, 1.0)))# 定义反向传播算法的优化器（Ada）：train_op = tf.train.AdamOptimizer(learning_rate).minimize(cross_entropy) 除了定义合适的损失函数外，我们还需要根据实际问题采用合理的反向传播优化器以更新参数（更新参数对我们来说是关键的）。TF 中支持的三种常用优化器：tf.train.GradientDescentOptimizer()、tf.train.AdamOptimier()、tf.train.MomentumOptimizer()。 这里关于损失函数和反向传播算法优化器的选择，你不用深究，下一篇博文会给出如何针对特定的问题选择合适的 Loss Function &amp;&amp; Optimizer。 | ================================================== Split Line =============================================== | 👇👇👇 如何执行反向传播算法 👇👇👇 上面在定义了 BP 之后，直接通过运行 sess.run(train_op) 就可以对所有在 tf.GraphKeys_TRAINABLE_VARIABLES() 集合中的变量进行自动优化，使得神经网络模型在当前 batch 的损失函数更小。 TF 实现的 FCNN 模型优化实例综上所述，这一小节我们将在一个模拟数据集上训练全连接神经网络模型来解决经典的二分类问题。 由于没有数据集，这里我们使用了 Numpy 随机模块模拟了一个带标签的包含 128 个样本数据的训练数据集。 完整实例代码如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071### TF 实现的 FCNN 模型优化实例 ###import tensorflow as tffrom numpy.random import RandomState# 定义训练数据 batch 的大小batch_size = 8# 待输入的样本特征向量以及标注的占位符：# Shape 设置 None 方便自适应不同的 batch 大小input_x = tf.placeholder(dtype=tf.float32, shape=(None, 2), name=&quot;input_x&quot;)input_y = tf.placeholder(dtype=tf.float32, shape=(None, 1), name=&quot;input_y&quot;)# 定义全连接神经网络的参数w1 = tf.Variable(tf.random_normal([2, 3], stddev=1, seed=1))w2 = tf.Variable(tf.random_normal([3, 1], stddev=1, seed=1))# 定义神经网络的前向传播：a = tf.matmul(input_x, w1)y = tf.matmul(a, w2)# 定义神经网络模型的反向传播算法：# 1）定义损失函数：cross_entropy = -tf.reduce_mean(input_y * tf.log(tf.clip_by_value(y, 1e-10, 1.0)))# 2）定义反向传播的优化器：learning_rate = 0.001train_op = tf.train.AdamOptimizer(learning_rate).minimize(cross_entropy)# 通过随机数生成一个模拟数据集：rdm = RandomState(1)dataset_size = 128 # 训练数据集样本数目X = rdm.rand(dataset_size, 2)# 定义规则给出样本的标签（x1+x2&lt;1 认为是正样本）：Y = [ [int(x1+x2 &lt; 1)] for (x1, x2) in X ]# 下面创建一个会话来运行程序：with tf.Session() as sess: # 明确调用变量初始化： init_op = sess.run(tf.global_variables_initializer()) # 打印训练之前的神经网络参数： print(&quot;| ============= Parameters Before Training ============ |&quot;) print(&quot;Weight1 &gt;&gt;&gt;&quot;, &quot;\\r\\n&quot;, sess.run(w1)) print(&quot;Weight2 &gt;&gt;&gt;&quot;, &quot;\\r\\n&quot;, sess.run(w2)) print(&quot;| ===================================================== |&quot;) # 开始训练： # 定义训练轮数： STEPS = 5000 for i in range(STEPS): # 每次选取一个 batch 的数据进行训练： start = (i * batch_size) % dataset_size end = min(start + batch_size, dataset_size) # 够着 feed dict，用于给 placeholder 传入数据： data_feed = feed_dict = {input_x: X[start:end], input_y: Y[start:end]} # 训练神经网络参数 sess.run(train_op, data_feed) # 每迭代 1000 次输出一次在所有数据上的交叉熵损失： if i % 1000 == 0: total_cross_entropy = sess.run(cross_entropy, feed_dict={input_x: X, input_y:Y}) print (&quot;After %d training step(s), cross entropy on all data is %g&quot; % (i, total_cross_entropy)) # 打印训练之后的神经网络参数： print(&quot;| ============= Parameters After Training ============ |&quot;) print(&quot;Weight1 &gt;&gt;&gt;&quot;, &quot;\\r\\n&quot;, sess.run(w1)) print(&quot;Weight2 &gt;&gt;&gt;&quot;, &quot;\\r\\n&quot;, sess.run(w2)) print(&quot;| ===================================================== |&quot;) 样例程序输出日志信息如下： 1234567891011121314151617181920212223| ============= Parameters Before Training ============ |Weight1 &gt;&gt;&gt; [[-0.8113182 1.4845988 0.06532937] [-2.4427042 0.0992484 0.5912243 ]]Weight2 &gt;&gt;&gt; [[-0.8113182 ] [ 1.4845988 ] [ 0.06532937]]| ===================================================== |After 0 training step(s), cross entropy on all data is 0.0674925After 1000 training step(s), cross entropy on all data is 0.0163385After 2000 training step(s), cross entropy on all data is 0.00907547After 3000 training step(s), cross entropy on all data is 0.00714436After 4000 training step(s), cross entropy on all data is 0.00578471| ============= Parameters After Training ============ |Weight1 &gt;&gt;&gt; [[-1.9618274 2.582354 1.6820377] [-3.4681718 1.0698233 2.11789 ]]Weight2 &gt;&gt;&gt; [[-1.8247149] [ 2.6854665] [ 1.418195 ]]| ===================================================== | 可见，随着训练迭代的过程，FCNN 模型在所有数据上的交叉熵损失是逐步降低的~~~ 也就也意味着，随着 FCNN 的训练，模型越来越拟合数据集。","link":"/2018/04/03/tensorflow-ru-men-zhi-tf-ji-ben-gong-zuo-yuan-li/"},{"title":"TensorFlow 入门之深度学习和深层神经网络","text":"上一篇博文中，我们介绍了 TensorFlow 的基本工作原理，并且给出了一个完整的 TF 样例来优化一个简单的三层全连接神经网络模型。本章我们将进一步介绍如何更加合理的设计和优化神经网络，使得学得的模型能够更好的对未知样本进行更加精确的预测。 配置过程中参考了网络上很多的相关博文，也遇到过很多坑，为了感谢配置过程中各位大佬的帮助以及方便本人下次配置或者升级，整理以作此文。 更多 TensorFlow 框架学习相关内容，请关注博主相关博文系列 ↓↓↓↓↓ 之一 &gt;&gt;&gt;&gt; 一文详解全平台 TensorFlow 深度学习框架在线搭建 (CPU&amp;GPU 支持) 之二 &gt;&gt;&gt;&gt; TensorFlow GPU 支持: Ubuntu16.04 + Nvidia GTX + CUDA + CUDNN 之三 &gt;&gt;&gt;&gt; TensorFlow 入门之 TF 基本工作原理 之四 &gt;&gt;&gt;&gt; TensorFlow 入门之深度学习和深层神经网络 之五 &gt;&gt;&gt;&gt; TensorFlow 入门之 MNIST 手写体数字识别问题 之六 &gt;&gt;&gt;&gt; TensorFlow 入门之图像识别和卷积神经网络（CNN） 提纲本篇，我们总共安排了五个章节来进一步的进行神经网络的学习： [1] &gt;&gt;&gt;&gt; 针对神经网络结构，介绍深层神经网络 (DNN) 的概念，并给出一个样例来说明深层网络可以解决部分浅层网络解决不了的问题； [2] &gt;&gt;&gt;&gt; 针对损失函数，将介绍如何设定神经网络的优化目标（损失函数）。分别给出分类/回归问题中比较常用的几种经典的损失函数，以及 TF 中如何自定义损失函数，使得神经网络优化的目标更加接近实际问题的需求； [3] &gt;&gt;&gt;&gt; 针对反向传播算法以及优化器算法，将更加明确的介绍模型训练时参数的更新方式； [4] &gt;&gt;&gt;&gt; 将给出一个 TensorFlow 实现神经网络模型训练（优化）的通用框架； [5] &gt;&gt;&gt;&gt; 针对神经网络模型优化（训练）过程，将介绍在优化（训练）过程中经常遇到的几个问题，并给出解决方案。 深度学习和深层神经网络维基百科中，对深度学习的精确定义为： 一类通过 多层非线性变换，对高复杂性数据进行建模 的算法合集。 由于 深层神经网络是实现 “多层非线性” 最常用的一种方法。所以在实际中，基本上可以认为 深度学习就是深层神经网络的代名词。 从上面的描述中，不难看出深度学习（或深层神经网络）的两个重要的特性： 多层 和 非线性 。为什么要强调这两个性质呢？！！ 下面我们将通过具体样例，来说明这两点特性在对复杂性问题进行建模时是缺一不可的： 线性模型的局限性既然强调是非线性变换，那么线性变换对于处理复杂性问题存在什么问题？？？ 认识线性模型在线性模型中，模型的输出为输入的加权和。假设一个模型的输出 y 和输入 x_i 满足以下关系，那么这个模型就是一个线性模型： $$ y = \\sum_{i=0}w_ix_i + b $$ 在一个线性模型中，通过输入 x_i 得到输出 y 的函数，就称之为一个 线性变换（上述公式就是一个线性变换）。 线性模型的最大特点就是 &gt;&gt;&gt;&gt; 任意线性模型的组合仍然还是线性模型。 | ================================================== Split Line =============================================== | 我们来看前面博文中实现的三层全连接网络的前向传播过程，其 FP 的计算公式： $$ a^{(1)} = xW^{(1)}, y = a^{(1)}W^{(2)} $$ 其中 x 为输入，W 为参数矩阵。由上述关系可以推导得： $$ y = (xW^{(1)}W^{(2)}) = x(W^{(1)}W^{(2)}) = xW’ $$ 可见，推导过程中 W^(1) W^(2) 被表示为一个新的参数（权重矩阵） W'，计算过程如下: $$ W’ = W^{(1)}W^{(2)} = \\left[ \\begin{array} {cccc}W_{1,1}^{(1)} &amp; W_{1,2}^{(1)} &amp; W_{1,3}^{(1)}\\\\W_{2,1}^{(1)} &amp; W_{2,2}^{(1)} &amp; W_{2,3}^{(1)}\\\\\\end{array} \\right]\\left[ \\begin{array} {cccc} W_{1,1}^{(2)}\\\\ W_{2,1}^{(2)}\\\\ W_{3,1}^{(2)}\\\\end{array} \\right] = \\left[ \\begin{array} {cccc} W_{1,1}^{(2)}W_{1,1}^{(2)}+W_{1,2}^{(1)}W_{2,1}^{(2)}+W_{1,3}^{(1)}W_{3,1}^{(2)}\\\\ W_{2,1}^{(2)}W_{1,1}^{(2)}+W_{2,2}^{(1)}W_{2,1}^{(2)}+W_{2,3}^{(1)}W_{3,1}^{(2)}\\end{array} \\right] \\= \\left[ \\begin{array} {cccc} W_1’\\\\ W_2’\\end{array} \\right] $$ 这样输入和输出的关系就可以表示为： $$ y = xW’ = \\left[ \\begin{array} {cccc} x_1 &amp; x_2\\end{array} \\right]\\left[ \\begin{array} {cccc} W_1’\\\\ W_2’\\end{array} \\right] = \\left[ \\begin{array} {cccc} W_1’x_1+W_2’x_2\\end{array} \\right] $$ 可见，上篇 FCNN 的前向传播算法完全符合线性模型的定义（两个线性模型的组合）。虽然这个神经网络有两层（不算输入层，输入层节点为非神经元节点），但它和单层的神经网络并没有本质区别。 | ================================================== Split Line =============================================== | 由此，我们可以类推出 &gt;&gt;&gt;&gt; 只通过线性变换，任意层的全连接神经网络和单层神经网络模型的表达能力没有任何区别，而且线性模型能够解决的问题是有限的（只能解决线性可分问题）！！！ 下面通过 TF 游乐场样例来看，为什么说线性模型解决的问题是有限的？？？： 线性可分问题还记得上一篇博文中我们 PLAY 过的【TensorFlow 游乐场】么？！！ 你将默认设置下，网页顶部激活函数（Activation）一栏选择为线性（Linear），这就和我们实现的三层全连接神经网络结构是基本一致了。 然后开始训练，你会发现 &gt;&gt;&gt;&gt; 当前设置下的线性模型是无法解决这个二分类任务的！！！ 此时，如果你将默认数据集更换成第三个（线性可分数据集），重新开始训练，便可以对数据集做区分了（样本分类）。 这也就是说，线性模型表达能力有限，只能解决有限的线性可分问题！！！ 高复杂性问题深度学习中为什么强调高复杂问题建模？！！ &gt;&gt;&gt;&gt; 数据至少是无法通过直线（或者高维平面：线性模型中，当输入为 n 个时，x 和 y 就会形成 n+1 维空间中的一个平面）划分的问题。 这是由于现实生活中，实际问题往往都是复杂，甚至高复杂性的问题（非线性可分）。 故，深度学习定义中，对 “非线性”、“高复杂问题” 的强调其实是很有道理的！！！既然线性模型存在上述的局限性，那么如何解决这个问题呢？！！ 也就是说 &gt;&gt;&gt;&gt; 如何对神经网络结构的中的神经元节点，进行 “去线性化” 处理，以支持复杂性的现实问题？！！ 激活函数去线性化前面，通过 TensorFlow 游乐场你已经看到了激活函数（Activation Function）的神奇作用。 事实上，对神经元节点添加了激活函数处理的神经网络结构，更加符合生物学上的神经网络特征。这一小节，我们来介绍人工神经网络中的激活函数如何工作 &gt;&gt;&gt;&gt; 我们知道，人工神经元结构的输出为所有输入的加权和，这导致了整个神经网络是一个线性模型。如何对线性模型去线性化，将其转化为非线性模型？！！ 其实很简单，我们只需要让每个神经元的输出再通过一个非线性函数（激活函数），那么整个神经网络模型就不再是线性的了！！！ 翻出前面博文中给出的神经元结构示意图： 可见，除了激活函数外，还增加了一个新的参数–偏置项（Bias）。偏置项也是神经元中非常用的一种结构（模拟神经元的一般敏感性），对应线性模型中的平移变换，可以帮助模型更好的拟合数据集。 下面我们来看加入 Activation Function &amp;&amp; Biases 之后的神经网络的前向传播算法实现原理： $$ A_1 = [a_{11},a_{12},a_{13}] = f(xW^{(1)} + b) = f([x_1, x_2]\\left[ \\begin{array} {cccc}W_{1,1}^{(1)} &amp; W_{1,2}^{(1)} &amp; W_{1,3}^{(1)}\\\\W_{2,1}^{(1)} &amp; W_{2,2}^{(1)} &amp; W_{2,3}^{(1)}\\\\end{array} \\right] + \\left[ \\begin{array} {cccc} b_1 &amp; b_2 &amp; b_3\\end{array} \\right] )\\\\ = f([W_{1,1}^{(1)}x_1+W_{2,1}^{(1)}x_2+b_1, W_{1,2}^{(1)}x_1+W_{2,2}^{(1)}x_2+b_2, W_{1,3}^{(1)}x_1+W_{2,3}^{(1)}x_2]+b_3) \\\\ = [f([W_{1,1}^{(1)}x_1+W_{2,1}^{(1)}x_2+b_1), f(W_{1,2}^{(1)}x_1+W_{2,2}^{(1)}x_2+b_2), f(W_{1,3}^{(1)}x_1+W_{2,3}^{(1)}x_2]+b_3)] $$ 其中，f() 为激活函数，[b_1, b_2, b_3] 表示隐藏层各节点上的偏置（神经元的敏感性）。 | ================================================== Split Line =============================================== | 👇👇👇 常用非线性激活函数图像 👇👇👇 TensorFlow 提供了对上述非线性激活函数的支持：tf.nn.relu() &amp;&amp; tf.sigmoid() &amp;&amp; tf.tanh()。除此之外 TensorFlow 还支持自定义激活函数。 以下代码展示了 TF 使用 Relu 激活函数实现三层神经网络的前向传播算法： $$ a = tf.nn.relu( tf.matmul(x, w1) + biases1)\\\\y = tf.nn.relu( tf.matmul(w1, w2) + biases2) $$ 关于神经网络中激活函数的选择问题，你可以参考博文【深入了解 Relu 非线性激活函数】。 深层网络学习上面我们说明了深度学习中非线性变换的重要性，这一部分我们将通过实际问题来强调深度学习的另一个重要特性：深层（多层）网络。 多层网络解决异或运算在神经网络的发展史上，一个很重要的问题就是异或问题。 何为异或问题？！！ &gt;&gt;&gt;&gt; 直观来说就是如果两个输入的符号相同时（同时为正或同时为负），输出 0；否则（一正一负）输出 1。 | ================================================== Split Line =============================================== | 起初，人工神经网络的理论模型是由 Warren McCulloch 和 Walter Pitts 于 1943 年提出，并在 1958 年由 Frank Tosenblatt 提出了 感知机模型，从数学上完成了对神经网络的精确建模。 感知机模型 &gt;&gt;&gt;&gt; 可以简单理解为单层的神经网络（无隐藏层），它会先将输入进行加权和，然后通过激活函数最终得到输出。上世纪 60 年代，神经网络作为对人类大脑的模拟算法受到了广泛的关注。 | ================================================== Split Line =============================================== | 然而到了 1969 年， Marvin Minsky 和 Seymour Papert 发现：感知机模型是无法模拟异或运算的！！！ 这里，篇幅原因，我们不对其复杂的数学求证过程做推导。但我们可以通过 TF 游乐场 来模拟一下通过感知机的结构来模拟异或运算问题： 可以看到，感知机模型是无法对异或数据集做出有效区分的，这也就是说感知机模型无法模拟异或运算！！！ 而当加入隐藏层（Hidden Layer）之后，我们发现异或问题可以得到很好的解决。这是由于隐藏层中的神经元节点可以被认为从输入的特征向量中提取出了更高维的数据特征。 深层网络组合特征提取神经网络中的每一层输出都可以看作是对原始输入的一次特征提取（表达），并且随着神经网络层次的 “加深”，逐步提取到由低级到高级的特征（抽象）表示。 类似于人脑视觉系统的信息分级处理机制，【从低级的边缘特征提取（edge basis） &gt;&gt;&gt;&gt; 到形状或目标的部分结构特征（object parts，combination of edge basis） &gt;&gt;&gt;&gt; 再到更高层的整个目标和目标行为特征（object models，combination of object parts）】。 也即是说，高层特征是底层特征的组合，从低层到高层的特征表达越来越抽象，参考信息越多（越来越能表达原始输入）。但深度加深，也意味着会带来计算更加复杂，探索的空间增大，训练数据在每个特征上的稀疏等各种各样的问题！！！ ↓↓↓↓↓↓ 总结 ↓↓↓↓↓↓ 深层神经网络有组合特征提取的功能，对于解决不易提取特征向量的问题（如图像识别、语音识别等）有很大的帮助，这也是深度学习在这些问题上更加容易取得突破性进展的重要原因！ 上面我们针对神经网络结构进一步了解了深度学习的概念。下面我们将介绍如何刻画（评价）不同神经网络模型的效果。 损失函数（Loss Function）我们知道，可以通过损失函数（Loss Function）来定义神经网络模型的优化目标。 除此之外，损失函数还可以用来评价模型的效果，可以通过 “损失函数是否收敛” 来评价一个模型在当前数据集下是否达到最佳？！！ 经典损失函数我们知道，分类和回归问题是监督学习的两大经典类别。 下面，将分别介绍适用于分类/回归问题的经典损失函数，并通过 TF 实现这些损失函数： 分类问题损失分类问题希望解决的是 &gt;&gt;&gt;&gt; 将不同的数据样本划分到事先定义好的类别（Class）中。 比如我们之前章节接触的 FCNN 二分类问题，需要将样本零件划分到合格或不合格两个类别中。后面我们还会介绍到的手写数字识别问题，它可以被归纳为一个十分类问题。 | ================================================== Split Line =============================================== | [1] &gt;&gt;&gt; 类别信息以及表示 在解决判断零件是否合格的二分类问题时，我们认为当最终输出节点值越接近 0，这个样本可能不及格；反之越接近 1 则越有可能合格。为了给出某个零件具体的类别结果，我们可以取 0.5 为阈值。我们认为凡是输出大于 0.5 的样本都认为时合格的，反之不合格。 但是这样的做法时是不容易推广到多分类的。虽然理论上对于多分类设置多个阈值是可能的，但在解决实际问题的过程一般不会这么处理。怎么办？！！ 实际中，通过神经网络解决多分类问题常用的方法是 &gt;&gt;&gt;&gt; one-hot 编码，也就是： 设置 n（n 为类别数目） 个输出节点。对于每一个样例，神经网络都可以得到一个 N 维向量（向量中每一维（或输出层中每一个输出节点）都对应一个类别）作为输出结果。理想情况下，如果一个样本属于类别 k，那么这个类别所对应的输出节点值应该为 1 ，其它的均为 0。 ↓↓↓↓↓↓ 结合一个具体样例进行说明 ↓↓↓↓↓↓ 以手写数字图像识别为例，数字图片需要被分类到 0~9 这 10 个数字类别中。 我们设置 n = 10，对于每一个手写数字图片，通过神经网络模型计算后都可以得到一个 10 维（长度为 10）的向量，每一个维度都对应了 0~9 中数字中的一个。如果某个样本属于数字类别 1，那么输出的数组理想情况（标签）应该是：[0,1,0,0,0,0,0,0,0,0]，神经网络的输出越接近它表示结果越好。 对于这个神经网络模型我们优化的目标是，就是让神经网络的输出向量尽可能的接近真实标注期望的 one-hot 向量。 | ================================================== Split Line =============================================== | 那么，我们如何判断一个输出向量和期望的向量有多接近呢？？？ 交叉熵损失函数是常用的一种评价方法。 交叉熵刻画了两个概率分布之间的距离（差距），它是分类问题最常使用的一种损失函数。 [2] &gt;&gt;&gt; 交叉熵损失函数（Cross Entropy） 交叉熵是信息论中的概念，这里不讨论其原本的意义，这里主要讲解它对于评估分类效果的意义。 假设给定两个概率分布 p 和 q，这里我们通过 q 来表示 p 的交叉熵： $$ H(p,q) = - \\sum_{x}p(x)log(q(x)) $$ 需要注意的是：交叉熵刻画的是两个概率分布之间的距离，然而神经网络的输出却不一定是一个概率分布。（概率分布刻画的是不同事件发生的概率。由概率论知识可知，当事件总数是有限的前提下，概率分布的和是 1） | ================================================== Split Line =============================================== | 那么，如何将神经网络的前向传播结果（输出向量）转换成一个概率分布呢？！！ [3] &gt;&gt;&gt; 引入 Softmax 回归 Softmax 回归是一个非常常用的转化概率分布的方法。事实上，其本身还可以作为一个学习算法来优化分类结果。 但在 TF 中，Softmax 回归的参数被去掉了，它只是一层额外的处理层，作用就是 &gt;&gt;&gt; 将神经网络的输出变成一个概率分布。 添加 softmax 回归的神经网络结构示意图： 如图，假设原始的神经网络的输出为 y_1, y_2, ..., y_n，那么经过 Softmax 回归处理之后的输出为： $$ softmax(y)_i = y_i’ = \\frac{e^{yj}}{\\sum_{j=1}^{n}e^{yj}} $$ 可见，神经网络输出经过一个 Softmax 回归就变换成一个概率分布！！！接下来就可以通过交叉熵来刻画神经网络输出的概率分布向量和 one-hot 标签向量的距离了。 | ================================================== Split Line =============================================== | 返回来继续看交叉熵，从交叉熵公式中可以看出交叉熵函数不是对称的： $$ H(p,q) \\ne H(q,p) $$ 因为正确答案是期望得到的，所有当交叉熵作为损失函数时，p 代表答案标注，q 代表预测值（模型计算结构）。它刻画的是概率分布 q 和 p 的距离，交叉熵越小，概率分布越接近。 以一个三分类样例，来说明通过交叉熵确实可以判断期望值和预测值之间的距离： 假设某个样例的标注（期望）是 (1, 0, 0)，当某网络模型经过 Softmax 回归之后的预测值是 (0.5, 0.4, 0.1)，那么这个预测值和正确答案之间的交叉熵为： $$ H((1,0,0),(0.5,0.4,0.1)) = -(1*log0.5 + 0*log0.4 + 0*log0.1) \\approx 0.3 $$ 另外一个模型经过 Softmax 回归之后的预测值是 (0.8, 0.1, 0.1),那么这个预测值和正确答案之间的交叉熵为： $$ H((1,0,0),(0.8,0.1,0.1)) = -(1*log0.8 + 0*log0.1 + 0*log0.1) \\approx 0.1 $$ 从直观上很容易知道：第二个模型的答案要优于第一个答案！！！ | ================================================== Split Line =============================================== | [4] &gt;&gt;&gt; TF 的交叉熵损失函数实现 在之前的章节中，你已经见过 TensorFlow 中定义的交叉熵损失函数。 这里我们来看其是如何实现的，下面先给出其代码实现： 1cross_entropy = -tf.reduce_mean( input_y * tf.log( tf.clip_by_value(y, 1e-10, 1.0)) ) 其中，input_y 代表输入的正确答案（真实标记/期望），y 代表模型预测结果。 下面分别来看涉及到的几个功能函数： ↓↓↓↓↓↓ tf.clip_by_value(A, min, max) ↓↓↓↓↓↓ 该函数输入一个张量 A，将 A 中的每一个元素值都修剪在（min, max）范围之内，小于/大于 min/max 的等于 min/max。一般用于给出其外部函数（log）的有效域，可以避免一些运算错误（比如：log0 是无效的）。 下面给出一个简单的运算样例： 1234567# Function Test: tf.clip_by_value()import tensorflow as tfv = tf.constant([[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]], dtype=tf.float32)sess = tf.InteractiveSession()print(tf.clip_by_value(v, 2.5, 4.5).eval()) 样例输出结果如下: 12[[2.5 2.5 3. ] [4. 4.5 4.5]] 可见，输入的张量 v 中的每一个元素数值被限制到了 (2.5, 4.5) 中，即： $$ v[i][j]\\in(2.5，4.5) $$ ↓↓↓↓↓↓ tf.tf.log(A) ↓↓↓↓↓↓ 该函数比较简单，用于对张量中的每一个元素计算其对数值。一个简单的运算样例： 12v = tf.constant([1.0, 2.0, 3.0], dtype=tf.float32)print(tf.log(v).eval()) 样例输出结果如下: 1[0. 0.6931472 1.0986123] ↓↓↓↓↓↓ * 运算符 ↓↓↓↓↓↓ 用于将两个矩阵中的元素进行对应相乘，也可以称为数乘（multiply，注意与点乘的区别）。矩阵的乘法通过 tf.matmul() 函数来实现。下面给出一个样例来看一下数乘和点乘的区别： 1234567v1 = tf.constant([[1.0, 2.0], [3.0, 4.0]], dtype=tf.float32)v2 = tf.constant([[5.0, 6.0], [7.0, 8.0]], dtype=tf.float32)# multiplyprint((v1*v2).eval())# matmulprint(tf.matmul(v1, v2).eval()) 样例输出结果如下: 1234[[ 5. 12.] [21. 32.]][[19. 22.] [43. 50.]] | ================================================== Split Line =============================================== | 通过上述三个运算已经可以完成单个样例的的每一个类别的交叉熵 p(x)log(q(x)) 的计算了。这三部的计算的结果是一个 n × m 阶的二维矩阵，其中 n 为一个 batch 中的样本数，m 为分类的类别数。 根据交叉熵公式，应该将每行中的 m 个结果相加得到所有样例的交叉熵 ，然后再对这 n 行取平均值得到一个 batch 的平均交叉熵。但由于分类数是不变的，即每一行都是 n 个分类，所以可以直接对整个矩阵做平均而不改变计算结果的意义，可以使得程序更加简洁。 下面来看 TF 中对矩阵做平均的函数，其语法格式如下： 12345reduce_mean(input_tensor, # 输入的 Tensor axis=None, # 沿指定的轴计算均值；如果不指定，则计算所有元素的均值 keep_dims=False, # 是否保持维度 name=None # 操作节点名称 ) 样例代码： 1234567v1 = tf.constant([[1.0, 2.0], [3.0, 4.0]], dtype=tf.float32)sess = tf.InteractiveSession()print(tf.reduce_mean(v1).eval())# 2.5print(tf.reduce_mean(v1, axis=1).eval())# [1.5 3.5] OK~~~ 前面给出的 TF 交叉熵损失函数定义就解析完毕了！！！ | ================================================== Split Line =============================================== | 什么？！！解析完了也太难记忆？看下面 由于交叉熵一般会与 “Softmax” 回归一起使用，TF 给出了一个统一函数 tf.nn.softmax_cross_entropy_with_logits() 用来封装 Softmax 回归和交叉熵。以下代码给出了使用了 Softmax 回归之后的交叉熵损失函数： 1234# Old usage# cross_entropy = tf.nn.softmax_cross_entropy_with_logits(y, input_y)# New Version（更安全）:cross_entropy = tf.nn.softmax_cross_entropy_with_logits(logits=y, labels=input_y) 注意，在只有一个正确答案的分类问题中（可以表示为：One-Hot），TF 提供了 tf.nn.sparse_softmax_cross_entropy_with_logits() 函数来加速计算过程。 TF 针对分类问题还支持其它的交叉熵函数（类似于 Softmax）： tf.nn.sigmoid_cross_entropy_with_logits：区别于 Softmax（排斥），适用于每个类别相互独立但互不排斥的情况：例如一幅图可以同时包含一条狗和一只大象。 tf.nn.weighted_cross_entropy_with_logits：具有权重的 sigmoid 交叉熵。 回归问题损失我们知道，分类问题希望解决的是：将不同的数据样本划分到事先定义好的类别中。 而，回归问题预测的不是一个事先定义好的类别，而是连续的数，是对具体数值的预测（比如：房价预测、销量预测）。解决回归问题的神经网络，一般只有一个输出节点，这个节点的输出值就是预测值。 对于回归问题，最常用的损失函数是均方误差（MSE：Mean Squared Error）。公式定义如下： $$ MSE(y,y’) = \\cfrac{\\sum_{i=1}^{n}(y_i-y_i’)^2}{n} $$ 其中，y_i 为 batch 中第 i 个数据的正确答案，而 y_i' 是神经网络给出的预测值。 下面给出使用 TF 来实现均方误差损失函数： $$mse = tf.reduce\\_mean(tf.square(y - y’))$$ 注意，这里的 - 运算符是两个数组中对应元素做差值。 自定义损失TensorFlow 中不仅支持经典的损失函数，还可以 优化任意的自定义损失函数。下面将介绍如何 通过自定义损失函数的方法，来使得神经网络优化的结果更加接近实际问题的需求。 这里，我们将以 “预测商品销量” 的问题为样例进行讲解： 在预测商品销量时，如果预测的多了（预测值大于真实销量），商家损失的是生成商品的成本（造成商品积压）；而如果预测少了（预测值小于真实销量），则损失的是商品的利润。那么如何定义网络模型的优化目标（Loss Function）来最大化销售利润？！！ 比如，一件商品的生成成本是 1 元，而利润是 10 元。那么少预测一个就少挣 10 元，而多预测一个才少挣 1 元。如果采用前面的均方误差进行回归预测，那么很有可能此模型无法最大化销售利润（少挣的钱最少）！！！ 为了最大化利润，故定义的损失函数需要刻画商品的成本或者代价（不同的损失权重）。下面公式给出了一个当预测多于或少于真实值时具有不同损失系数的 Loss Funtion： $$ Loss(y,y’) = \\sum_{i=1}^{n}{f(y_i, y_i’)} $$$$ f(x, y) = \\begin{cases} a(x-y), x &gt; y \\\\ b(y-x), x \\leq y \\end{cases} $$ 其中，y_i 为一个 batch 中第 i 个数据的正确答案，y_i' 为神经网络计算得到的预测值。f 函数中，a &amp;&amp; b 是常量。上面的销售问题中，a 为 10（预测少了）；b 为 1（预测多了）。 TF 中实现上述具有不同损失系数的 Loss Function： 1loss = tf.reduce_sum(tf.select( tf.greater(v1,v2), (v1-v2) * a, (v1-v2) * b)) | ================================================== Split Line =============================================== | 下面分别来看涉及到的几个功能函数： ↓↓↓↓↓↓ tf.greater(a, b) ↓↓↓↓↓↓ 比较函数：tf.greater(v1,v2) 的输入是两个张量，函数会比较两个张量中对应位置元素的大小，返回比较的结果。示例代码如下： 123456v1 = tf.constant([[1.0, 2.0], [3.0, 4.0]], dtype=tf.float32)v2 = tf.constant([[3.0, 4.0], [1.0, 2.0]], dtype=tf.float32)print(tf.greater(v1, v2).eval())# [[False False]# [ True True]] ↓↓↓↓↓↓ tf.select(condition, t, e, name=None) ↓↓↓↓↓↓ 选择函数：当条件 condition=True 时，选择参数 t 的值；否则选择参数 e。需要注意的是该函数判断和选择都在元素级别进行。 实例代码如下： 123456789101112131415import tensorflow as tfv1 = tf.constant([1.0,2.0,3.0,4.0])v2 = tf.constant([4.0,3.0,2.0,1.0])sess = tf.InteractiveSession()print (tf.greater(v1,v2).eval())# AttributeError: module 'tensorflow' has no attribute 'select# print (tf.select( tf.greater(v1,v2), v1, v2).eval())# 原因：新版本 TensorFlow API 的名称做了改变，这个选择操作的tf.select()被改为tf.where()。print (tf.where( tf.greater(v1,v2), v1, v2).eval())sess.close() 样例输出结果如下: 12[False False True True][4. 3. 3. 4.] 最后，对上述计算得到的损失值进行平均，计算得到 batch 上的平均利润最少损失即可。 损失函数对模型的影响上面我们了解了 TensorFlow 中经典损失函数以及自定义损失函数的使用，也明白了一个损失函数使用的重要性。 那么对于一个模型来说，损失函数到底会有怎样的影响？！！ 这里，我们将通过一个样例来说明选择一个合适的损失函数对训练结果影响的重要性。实现一个拥有两个输入节点，一个输出节点，没有隐藏层的神经网络结构： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import tensorflow as tffrom numpy.random import RandomStatebatch_size = 8input_x = tf.placeholder(tf.float32, shape=(None,2), name=&quot;input_x&quot;)input_y = tf.placeholder(tf.float32, shape=(None,1), name=&quot;input_y&quot;)w1 = tf.Variable(tf.random_normal([2,1], stddev=1, seed=1))y = tf.matmul(input_x, w1)# 预测少时损失：loss_less = 10# 预测多时损失：loss_more = 1define_loss = tf.reduce_sum(tf.where( tf.greater(y,input_y), (y-input_y) * loss_more, (input_y-y) * loss_less))learning_rate = 0.001train_op = tf.train.AdamOptimizer(learning_rate).minimize(define_loss)# 通过随机数生成一个模拟数据集：rdm = RandomState(1)dataset_size = 128 # 训练数据集样本数目X = rdm.rand(dataset_size, 2)# 定义规则给出样本的标签（x1 + x2 + noise）：# 为了加入不可预测噪音（noise），否则设置不同损失函数意义不大，因为不同损失函数都在完全预测正确时最低# noise 属于 -0.05 ~ 0.05 的值Y = [ [x1 + x2 + rdm.rand()/10.0-0.05] for (x1, x2) in X ]# 下面创建一个会话来运行程序：with tf.Session() as sess: init_op = sess.run(tf.global_variables_initializer()) # 打印训练之前的神经网络参数： print(&quot;| ============= Parameters Before Training ============ |&quot;) print (sess.run(w1)) print(&quot;| ===================================================== |&quot;) # 开始训练： # 定义训练轮数： STEPS = 5000 for i in range(STEPS): # 每次选取一个 batch 的数据进行训练： start = (i * batch_size) % dataset_size end = min(start + batch_size, dataset_size) data_feed = feed_dict={input_x: X[start:end], input_y: Y[start:end]} # 训练神经网络参数 sess.run(train_op, data_feed) # 打印训练之后的神经网络参数： print(&quot;| ============= Parameters Before Training ============ |&quot;) print (sess.run(w1)) print(&quot;| ===================================================== |&quot;) 样例输出结果如下: 12345678| ============= Parameters Before Training ============ |[[-0.8113182] [ 1.4845988]]| ===================================================== || ============= Parameters Before Training ============ |[[1.019347 ] [1.0428089]]| ===================================================== | 标准答案（期望）为：x1 + x2，预测值为 1.02x_1 + 1.04x_2。此时的参数下，模型更加偏向于预测多一点（预测少了的损失更大：loss_less &gt; loss_more）。 如果将 loss_less 和 loss_more 和值互换（此时，预测少时损失小为 1，预测多时损失大为 10），那么最终 w1 = [0.95525807, 0.9813394]，此时模型更加偏向预测少一点。而如果使用均方误差作为损失函数，w1 = [0.97437561, 1.0243336]，会让预测值离标准答案更近。 👇👇👇 结论 👇👇👇 相同的神经网络结构，不同的损失函数的使用会对训练得到的模型（预测方向）产生重要的影响！！！ 神经网络优化器算法（Optimizer）我们知道，反向传播传播算法（BP）是训练（优化）神经网络的核心算法，它可以根据定义好的损失函数优化神经网络中参数的取值，从而使得神经网络模型在训练数据集上的损失函数达到一个较小值，从而提高网络模型的精确度。 其优化（训练）过程可以分为两个阶段： 第一阶段：先通过前向传播算法计算得到预测值，并将预测值和真实值做对比得出两者之间的差距（loss）; 第二阶段：通过反向传播算法计算损失函数对每一个参数的梯度，再根据梯度和学习率使用梯度下降算法更新每一个参数，使得损失函数不断减少。 关于第一阶段的 Loss Function 不再进行赘述，这一小节我们将介绍如何通过反向传播算法（Back Propagation）和梯度下降（Gradient Decent）优化器算法来更新神经网络中的参数（略去算法的数学推导和证明）。 事实上， 梯度下降优化器算法主要用于优化单个参数的取值，而反向传播算法给出了一个高效的方式在所有参数上使用梯度下降算法，最小化损失函数。 梯度下降算法（Gradient Descent）我们知道，神经网络的训练（优化）过程，就是不断降低损失函数值（使其收敛于一个最低值）以及参数更新的过程，从而提高学习模型的精确度。 学习模型中，“损失函数是否收敛于一个较小值” 可以来评价一个模型在当前数据集下是否达到最佳。 事实上，梯度下降算法（Gradient Descent）的目的 &gt;&gt;&gt;&gt; 就是为了最小化损失函数！！！ 梯度下降原理那么，如何寻找损失函数的最低点呢？！！ 显而易见的是，损失函数里一般有两种参数：控制输入信号量的权重参数（Weight，W），以及调整函数与真实值距离的偏置（Bias，b）。梯度下降算法，需要不断地调整权重 W 和偏置 b，使得损失函数的值变得越来越小，以期望达到最低。 目前，没有一个通用的方法对任意的损失函数求解最佳的参数取值。故通常会采用 微积分求导的方式 &gt;&gt;&gt;&gt; 通过求出损失函数的导数值（梯度），找到函数梯度下降的方向，从而找到损失函数的最低点（极值点）。 | ================================================== Split Line =============================================== | 👇👇👇 单个参数的梯度下降过程 👇👇👇 为了方便理解，仅以某一个权重参数 θ 的更新为样例进行说明。 假设模型的损失函数为 J(θ)，满足如下图所示关系。梯度下降算法（GD）会迭代式的更新参数 θ，即不断沿着梯度（∂J/∂θ）下降的方向让参数朝着损失更小的方向进行更新！！！ 如图，通过计算梯度（∂J/∂θ），模型优化器就可以判断权重 θ 的移动方向，会让其向左而不是向右移动，随着不断的迭代训练最终使得损失函数收敛于最低点（梯度为 0 的地方）。 知道了 θ 的移动方向之后，还需要确定每次应该前进多少（即前进的距离或步长），这通过 学习率（Learning Rate）来定义。 ↓↓↓↓↓↓ 详解上述过程 ↓↓↓↓↓↓ 假设要通过梯度下降算法来优化参数 θ，使得损失函数 J(θ)= θ^2 的值尽量小。梯度下降算法的第一步需要随机产生一个参数 θ 的初始值，然后再通过梯度和学习率来更新参数 θ 的取值。 样例中参数 θ 的梯度为： $$\\nabla=\\cfrac{\\partial J(\\theta)}{\\partial θ} = 2\\theta$$ 那么 BP 中每次使用梯度下降算法对参数 θ 的更新公式为： $$ θ_{n+1} = θ_n - \\eta \\nabla $$ 其中，θ_n 表示权重的初始值，θ_(n+1) 表示更新后的权重值，使用 η 来表示学习率。 假设参数 θ 初始值为 5，学习率设置为 0.3，那么优化过程可以总结为下表： epoch 当前轮参数值 梯度×学习率 更新后参数值 1 5 2×5×0.3=3 5-3=2 2 2 2×2×0.3=1.2 2-1.2=0.8 3 0.8 2×0.8×0.3=0.48 0.8-0.48=0.32 4 0.32 2×0.32×0.3=0.192 0.32-0.192=0.128 5 0.128 2×0.128×0.3=0.0768 0.128-0.0768=0.0512 可见，经过 5 轮迭代后，参数 θ 的取值已变为 0.0512，和参数最优值 θ = 0 已经很接近了。 | ================================================== Split Line =============================================== | 上面讲解了对单个权重参数 W 的优化过程，而对于偏置 b 也是同样的处理过程，这里不再进行赘述。 事实上，对神经网络中的所有权重（Weight）和偏置（Bias）参数，均采用上述原理进行优化。 前面提到过：梯度下降优化器算法主要用于优化单个参数的取值，而反向传播算法给出了一个高效的方式在所有参数上使用梯度下降算法，最小化损失函数。 BP 梯度下降过程根据上述说明，给出模型训练时 BP 梯度下降算法的整个过程： 1 &gt;&gt;&gt;&gt; for i = 0 to (训练数据的个数): (1) 计算第 i 个训练数据的权重 W 和偏置 b 相对于损失函数的梯度。最终得到每一个训练数据的权重和偏差的梯度值。 (2) 计算所有训练数据权重 W 的梯度的总和。 (3) 计算所有训练数据偏差 b 的梯度的总和。 2 &gt;&gt;&gt;&gt; 平均梯度计算，更新参数: (1) 根据上面 (2)、(3) 结果，计算所有样本的权重和偏差的梯度平均值。 (2) 使用下面的式子，更新每个样本的权重值和偏差值： $$ W_{i+1} = W_i - \\eta * \\cfrac{\\partial J(\\theta)}{\\partial W_i} $$ $$ b_{i+1} = b_i - \\eta * \\cfrac{\\partial J(\\theta)}{\\partial b_i} $$ 3 &gt;&gt;&gt;&gt; 重复上述过程，直至损失函数收敛不变。 | ================================================== Split Line =============================================== | 伪代码表示： 1234567891011121314151617181920212223242526272829def train(X, y, W, B, alpha, max_iters): ''' 选取所有的数据作为训练样本来执行梯度下降 X : 训练数据集 y : 训练数据集所对应的目标值 W : 权重向量 B ： 偏差变量 alpha ： 学习速率 max_iters : 梯度下降过程最大的迭代次数 ''' dW = 0 # 初始化权重向量的梯度累加器 dB = 0 # 初始化偏差向量的梯度累加器 m = X.shape[0] # 训练数据的数量 # 开始梯度下降的迭代 for i in range(max_iters): dW = 0 # 重新设置权重向量的梯度累加器 dB = 0 # 重新设置偏差向量的梯度累加器 # 对所有的训练数据进行遍历 for j in range(m): # 1. 遍历所有的训练数据 # 2. 计算每个训练数据的权重向量梯度w_grad和偏差向量梯度b_grad # 3. 把w_grad和b_grad的值分别累加到dW和dB两个累加器里 W = W - alpha * (dW / m) # 更新权重的值 B = B - alpha * (dB / m) # 更新偏差的值 return W, B # 返回更新后的权重和偏差。 可见：每一次迭代进行梯度下降的过程中，都需要对所有样本数据的梯度进行计算。 关于反向传播算法（BP）中梯度下降更详细和深入的了解，请参见 &gt;&gt;&gt;&gt; 【BP 算法的深入理解与相关推导】。 存在问题分析事实上，梯度下降算法（Gradient Descent）存在一些问题： [1] &gt;&gt;&gt; 陷入局部最优解 梯度下降算法，并不能保证被优化的损失函数达到全局最优解，可能陷入局部最优！！！什么意思？？？ 如下图所示，图中给出损失函数情况下，就有可能只能得到局部最优解而不是全局最优： 参数梯度落在图中标记点处（小黑点：A），此时损失函数的偏导为 0，于是参数就不会在进一步更新了。 梯度下降是否能够达到全局最优取决于 &gt;&gt;&gt;&gt; 待优化参数初始值落在哪个区域。 参数初始值的选取很大程度影响最后的优化结果。只有当损失函数为凸函数时，梯度下降算法才能保证达到全局最优。 | ================================================== Split Line =============================================== | [2] &gt;&gt;&gt; 耗时 梯度下降算法另一个存在的问题就是计算时间太长。 因为要在全部训练数据上最小化损失，也就是说所有损失函数 J(θ) 是在所有的训练数据上的损失和达到最小。 这样在每一轮的迭代中都需要计算在全部训练数据上的损失。在海量训练训练数据下，要计算所有训练数据的损失函数是极其耗时的。 为了加速训练过程，提出了随机梯度下降算法（Stochastic Gradient Decent：[stə'kæstɪk ˈɡreɪdiənt dɪˈsent]，SGD）: 随机梯度下降算法（SGD）随机梯度下降算法 SGD 优化的不是在全部训练数据上的损失函数，而是在每一轮迭代中随机优化某一条训练数据上的损失函数，这样每一轮参数更新的速度就大大加快了。 但由于 SGD 算法每次优化的只是在某一条数据上的损失函数，所以问题也非常明显：在某一条数据上损失函数更小并不能代表在全部数据上的损失函数更小！！！ 你应该能理解：随机梯度下降 仍然存在陷入局部最优解 的情况（想想上面的局部最优解图示）。 更为严重的是 &gt;&gt;&gt;&gt; 使用随机梯度下降算法优化，得到的神经网络甚至可能无法达到局部最优。为什么？！！ 这是由于每次训练使用的样本数据都是随机的，所以参数可能落在任何使得梯度下降的方向上。 为了综合梯度下降算法（达到某个最优）和随机梯度下降算法（快速）的优缺点，在实际应用中提出了一种折中的办法 &gt;&gt;&gt; Mini Batch SGD: 小批量样本梯度下降（MGD）Mini Batch SGD 算法的优化过程是 &gt;&gt;&gt;&gt; 每次计算一小部分训练数据的损失函数值，也就是我们之前提到的一个 batch 的数据上的损失。 通过矩阵运算，每次在一个 batch 的数据上优化神经网络的参数并不会比单个数据慢太多；另一方面，每次使用一个 batch 的数据可以大大减少损失函数收敛所需要的迭代次数，同时可以使得收敛的结果更加接近梯度下降的效果。 👇👇👇 Batch Size 的设置要合理 👇👇👇 当神经网络模型比较复杂或者数据本身（大尺寸图像）比较大，太大的 batch 会导致计算时间过程过长，甚至发生内存溢出！！！ batch-size 一般选取为：64，128，256，512 等，最好是 2 的次方。 Momentum &amp; RMSprop &amp; Adam &amp; …上面我们介绍的梯度下降算法是最简单、最基础的模型优化方法。 除此之外，还有一些基于梯度下降算法的改进算法，例如：Momentum、Adagrad、RMSProp、Adam 等等。 关于反向传播优化算法更深入的了解，可参考 &gt;&gt;&gt;&gt; 【解析神经网络主流优化器算法】。这里由于篇幅原因，不再进行过多的说明。 BP 和优化器算法说了这么多，你是否能够更好的区分 BP 算法和优化器算法的不同作用，以及在神经网络模型优化中充当的角色？！！ 我们知道，神经网络模型的学习需要有目标函数（损失函数），才能通过求解目标函数的最优解来找到合适的模型（这一过程称为训练或优化）。 而找目标函数最优解的方法，就是 &gt;&gt;&gt;&gt; 优化器算法，如 SGD &amp;&amp; Adam &amp;&amp; RMSprop 等。目前没有一个通用的方法对任意的目标函数求解最优解，优化器算法都是基于目标函数的导数！！！ 而 BP 算法就是一种计算神经网络目标函数的导数的方法。 至此，我们就可以给出 TF 深度神经网络（Deep Neural Network）模型训练（优化）的通用框架： TF-DNN 模型优化通用框架框架代码如下： 12345678910111213141516171819202122232425262728293031323334353637import tensorflow as tffrom numpy.random import RandomState# 定义 batch 大小：batch_size = 8input_x = tf.placeholder(tf.float32, shape=(None,2), name=&quot;input_x&quot;)input_y = tf.placeholder(tf.float32, shape=(None,1), name=&quot;input_y&quot;)w1 = tf.Variable(tf.random_normal([2,1], stddev=1, seed=1))w2.....define_loss = ...learning_rate = 0.001train_op = tf.train.AdamOptimizer(learning_rate).minimize(define_loss)with tf.Session() as sess: init_op = sess.run(tf.global_variables_initializer()) # 打印训练之前的神经网络参数： print (sess.run(w1)) # 开始训练： # 定义训练轮数： STEPS = 5000 for i in range(STEPS): # 每次选取一个 batch 的数据进行训练： start = (i * batch_size) % dataset_size end = min(start + batch_size, dataset_size) data_feed = feed_dict={input_x: X[start:end], input_y: Y[start:end]} # 训练神经网络参数 sess.run(train_op, data_feed) 进一步优化神经网络这一小节，我们将针对神经网络优化过程可能遇到的问题，进一步合理设置神经网络。 例如：如何合理设置梯度下降算法的学习率，让训练模型快速、合理收敛？如何解决过拟合，使得我们训练好的模型更加泛化？以及如何使用滑动平均模型使得学得的模型更加健壮，滑动平均模型可以一定程度上提高模型在最终测试数据集上的表现（增强模型效果）。 学习率设置问题在讲解梯度下降算法（Gradient Descent）时提到，神经网络模型的训练（学习）需要通过学习率来控制参数更新的幅度或步长。 那么考虑一个问题 &gt;&gt;&gt;&gt; 学习率较低时增加了模型收敛所需的迭代次数，那么是否只需要设置一个较大的学习率，就可以让模型在很短时间内达到局部最优？？？ 答案肯定是否定的！！！ | ================================================== Split Line =============================================== | 学习率影响学习率决定了参数每次更新的幅度 &gt;&gt;&gt;&gt; 如果 更新幅度过大，那么可能导致参数在极优值两侧来回移动，无法收敛到一个极小值；相反，如果 更新幅度过小，每次参数更新幅度较小，虽然能够保证收敛性，但这会大大降低参数的优化（训练）速度。模型需要更多轮的迭代才可以达到一个比较理想的结果。 ↓↓↓↓↓↓ 以梯度下降算法中单个参数的梯度下降样例进行讲解 ↓↓↓↓↓↓ 假设：参数 0 初始值为：5 当学习率为：0.001 时，迭代 5 次之后，0 的取值将为 4.95。要将 0 训练到 0.05 需要大约 2300 轮； 当学习率为：0.3 时，只需要迭代 5 轮就可以达到。 👇👇👇 综上所述 👇👇👇 如何更加合理的设置学习率取值为对保证模型优化的高效和精确是必要的！！！ 指数衰减学习率为了解决学习率设定过大过小的问题，TF 中提供了一种更加灵活的学习率设置方法：指数衰减法。 TF 通过 tf.train.exponential_decay() 函数实现了指数衰减学习率。它会 指数级地减少学习率，让模型在训练前期快速接近较优解，又保证在模型训练后期不会波动太大（更加稳定），从而逐渐收敛于最优解。 其语法格式如下： 12345678tf.train.exponential_decay( learning_rate, # 初始学习率 global_step, # 全局迭代次数（总迭代次数） decay_steps, # 衰减速度 decay_rate, # 衰减系数 staircase=False, # 衰减方式（阶梯式衰减 or 连续衰减） name=None # String. Optional name of the operation. Defaults to ‘ExponentialDecay’.) 上述函数实现了以下代码的功能： 1decayed_learning_rate = learning_rate * decay_rate ^ (global_step / decay_steps) | ================================================== staircase =============================================== | 👇👇👇 staircase 参数详解 👇👇👇 指数衰减函数中 staircase 参数用来指定衰减的方式：阶梯式衰减（True）？ or 连续衰减（False）？ 区别在于 &gt;&gt;&gt;&gt; 当参数设置为 True 时，(global_step / decay_steps) 结果会取整，学习率就成为阶梯函数（Staircase Function）了。 不同衰减方式示意图： 阶梯衰减学习率 &gt;&gt;&gt;&gt; decay_steps 通常代表完整的使用一遍训练数据样本所需要的迭代轮数，也就是总训练样本数除以每一个 batch 中的训练样本数（即：batch_size）。这种设置的常用场景是：每完整的过完一遍训练数据，学习率就减少一次。 优点 &gt;&gt;&gt;&gt; 可以使得训练数据集中的所有数据对模型训练有相等的作用。 连续衰减学习率 &gt;&gt;&gt;&gt; 不同的训练数据有不同的学习率，只有当学习率减小时，对应的训练数据对模型的训练结果的影响也就小了。 | ================================================== Split Line =============================================== | 下面将给出一个使用了指数衰减学习率的优化器样例： 123456789101112131415global_step = tf.Variable(0, trainable=False)starter_learning_rate = 0.1learning_rate = tf.train.exponential_decay( starter_learning_rate, global_step, 100000, 0.96, staircase=True)# Passing global_step to minimize() will increment it at each step.train_op = ( tf.train.GradientDescentOptimizer(learning_rate) .minimize(...my loss..., global_step=global_step) 学习率决定了参数更新（损失函数下降）的速度。一般来说，初始学习率、衰减学习率以及衰减速度都是根据经验设置的。 但是损失函数下降的速度和迭代结束之后总损失的大小没有必然的联系。也就是说，并不能通过前几轮损失函数下降的速度来比较不同神经网络模型的效果。 模型拟合问题我们知道，神经网络的训练（优化）的目标，就是在训练的样本数据上优化一个给定的损失函数。 然而在真实的应用中，我们期望的并不是单纯让模型尽量模拟（拟合）训练数据的行为，而是希望通过训练出来的模型对未知数据也能够给出很好的预测。 而在我们机器学习和深度学习的训练过程中，经常会出现 过拟合（Overfitting）和 欠拟合（Underfitting） 的现象。 过拟合/欠拟合 过拟合：是指当一个模型过为复杂之后，它可以很好的记忆每一个训练数据中的随机噪音的部分，而忘记去“学习”训练数据中的通用趋势。 欠拟合：是指模型较为简单，无法很好的学习到数据的内在特征，模型训练时的表现就很差。 欠拟合好理解，下面我们将 ↓↓↓↓↓↓ 通过一个极端的样例进行过拟合的说明 ↓↓↓↓↓↓ 如果一个模型中的参数比训练数据的总数还多（一般样本数维持在参数量的10倍），那么只要训练数据不冲突，这个模型完全可以记住所有训练数据的结果从而使得损失函数为 0。你可以直观的想象一个包含 n 个变量和 n 个等式的方程组：当方程不冲突时，这个方程组是可以通过数学方法求解的。 然而过度拟合训练数据的随机噪音虽然可以得到非常小的损失，但是对于未知数据可能无法做出可靠的判断。 | ================================================== Split Line =============================================== | 下图给出模型训练可能发生的三种不同拟合情况： 第一种情况下，由于模型过于简单，无法很好刻画问题的趋势，属于欠拟合（模型在训练数据集的准确率较低）； 第二张模型是比较合理的，它既不会过于关注训练数据中的噪音，又能很好的刻画问题的整体趋势（理想情况）； 第三种模型就是过拟合了，虽然第三个模型完美地划分了不同形状的点，但这样的划分并不能很好地对未知数据做出判断，因为它过度拟合了训练数据中的噪音数据而忽略了问题的整体规律（测试集准确率远远跟不上训练集测试集）。 我们一直在说一个模型简单/复杂…. 那么如何来衡量一个神经网络的复杂程度？！！ 事实上，神经网络中的参数量可以很大程度上作为衡量模型复杂度的标准！！！其它设置相同的情况下，一个神经网络模型中的参数量数量级越大，意味着模型越复杂。 关于拟合问题更详细深入的了解，你可以参考博文 &gt;&gt;&gt;&gt; 【Deep Learning 之模型评估】。 正则化为了避免过拟合问题，一个非常常用的方法就是 &gt;&gt;&gt;&gt; 正则化（Regularization）。 正则化的核心思想 &gt;&gt;&gt;&gt; 在神经网络模型的优化目标 –&gt; 损失函数中，加入刻画模型复杂程度的指标。 假设用于刻画模型在训练数据上表现的损失函数为 J(θ)，那么在优化时不是直接优化 J(θ)，而是优化 $$ Loss = J(θ) + λR(w) $$ 其中，R(w) 刻画的是模型的复杂程度，而 λ 表示模型的复杂损失在总损失中所占的比例。需要注意的是 &gt;&gt;&gt;&gt; 这里的参数 θ 表示的是一个神经网络中的所有参数，包括权重（weight）和偏置（Bias）；而模型的复杂度只由权重（w）决定。 常用的刻画模型复杂程度的 R(w) 函数有两种，一种是 L1 正则化，其公式为： $$ R(w) = \\mid\\mid w \\mid\\mid_{1} = \\sum_{i}|{w_i}| $$ 另一种是 L2 正则化： $$ R(w) = \\mid\\mid w \\mid\\mid_{2}^{2} = \\sum_{i}{w_i^{2}} $$ 无论哪一种正则化，其思想都是希望通过限制权重的大小，使得模型不能任意拟合训练数据中随机噪音！！！ | ================================================== Split Line =============================================== | 👇👇👇 L1 Vs L2 👇👇👇 L1 正则化会让参数变得更加稀疏（会有更多的参数变为 0），而 L2 则不会，达到类似特征选取的功能。之所以 L2 正则化不会让参数变得稀疏的原因是 &gt;&gt;&gt;&gt; 当参数很小时，例如 0.001，这个参数的平方基本上可以忽略了，于是模型不会进一步计算将这个参数调整为 0。 其次，L1 正则化的计算公式不可导，而 L2 正则化公式可导数。由于在优化时需要计算损失函数的偏导数，故对包含 L2 正则化的损失函数的优化更加方便，优化带 L1 正则化的损失函数要更加复杂（但优化方法也很多）！！！ | ================================================== Split Line =============================================== | 实践中，也可将 L1 正则化和 L2 正则化同时使用： $$ R(w) = \\sum_{i}α|{w_i}| + (1-α){w_i^{2}} $$ TF 正则化防止过拟合我们知道，使用 TensorFlow 可以优化任意形式的损失函数，所以 TF 自然也可以优化任何带正则化的损失函数。 以下代码给出了一个简单的带 L2 正则化的损失函数定义: 123456w = tf.Variable(tf.random_normal([2,1], stddev=1, seed=1))y = tf.matmul(x,w)# loss = 经验风险最小化 + 结构风险最小化loss = tf.reduce_mean(tf.square(y_ - y)) + tf.contrib.layers.l2_regularizer(lambda)(w) #lambda为正则化权重 实际过程中 lambda 为关键字 loss 定义为损失函数，由两个部分组成：第一个部分是均方误差损失函数，刻画模型在训练数据上的表现。第二部分就是正则化，防止模型过度模拟训练数据中的随机噪声。 类似的, tensorflow.contrib.layers.l1_regularizer(lambda)(w) 函数可以计算 L1 正则化的值。以下代码给出了使用这两个函数的样例： 123456789import tensorflow as tfweights = tf.constant([[1.0, -2.0], [-3.0, 4.0]])with tf.Session() as sess: # 输出为：(|1| + |-2| + |-3| + |4|) * 0.5 = 5。其中 0.5 为正则化项的权重。 print (sess.run(tf.contrib.layers.l1_regularizer(.5)(weights))) # 输出为：(1^2 + (-2)^2 + (-3)^2 + 4^2) * 0.5 = 7.5。 print (sess.run(tf.contrib.layers.l2_regularizer(.5)(weights))) 样例输出结果为： 125.07.5 在简单的神经网络中，上述代码可以很好地计算带正则化的损失函数，但当神经网络的参数增多之后，这样的方式可能导致 loss 函数定义可读性变差。更主要的是导致：网络结构复杂之后，定义网络结构的部分和计算损失函数的部分可能不在同一函数中，这样通过变量这样方式计算损失函数就不方便了。 👇👇👇 TF 更加合理的正则化使用方法 👇👇👇 下面我们给出一个使用 TF 中给提供的集合（Collection）解决一个 5 层神经网络带 L2 正则化 的损失函数计算方法（网络结构的部分和计算损失函数的部分不在同一函数）: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556import tensorflow as tf# Part 1：定义神经网络结构以及前向传播算法：# 获取单层神经网络 Edge 上的权重，并且将这个权重的 L2 正则化损失加入到名称为 'losses' 的集合中：def get_weight(shape, lamada): # 创建变量： var = tf.Variable(tf.random_normal(shape), dtype=tf.float32) # 使用 add_to_collection() 函数将这个新创建的变量的 L2 正则化损失加入到集合 # 这个函数的第一个参数 'losses' 是集合的名称；第二个参数是要加入到集合的内容 tf.add_to_collection('losses', tf.contrib.layers.l2_regularizer(lamada)(var)) return var# 带输入特征向量以及标签的占位符input_x = tf.placeholder(tf.float32, shape=(None, 2))input_y = tf.placeholder(tf.float32, shape=(None, 1))# batch size：batch_size = 8# 定义神经网络中每一层网络中的节点个数：layer_dimension = [2, 10, 10, 10, 1]# 获取神经网络的层数n_layers = len(layer_dimension)# 定义一个变量用于维护前向传播时当前层的节点，开始的时候就是输入层：cur_layer = input_x# 获取当前层节点个数：in_dimension = layer_dimension[0]# 通过一个循环生成5层全连接的神经网络结构for i in range(1, n_layers): # 获取下一层节点的个数 out_dimension = layer_dimension[i] # 获取当前计算层的权重并加入了 L2 正则化损失 weight = get_weight([in_dimension, out_dimension], 0.001) # 随机生成偏向 bias = tf.Variable(tf.constant(0.1, shape=[out_dimension])) # 计算前向传播节点，使用RELU激活函数 cur_layer = tf.nn.relu(tf.matmul(cur_layer, weight) + bias) # 进入下一层之前，更新下一层节点的输入节点数 in_dimension = layer_dimension[i] # Part 2：定义损失函数以及反向传播算法：# 计算模型数据的均值化损失加入损失集合mse_loss = tf.reduce_mean(tf.square(input_y - cur_layer))tf.add_to_collection('losses', mse_loss)# get_collection 返回一个列表，列表是所有这个集合的所有元素# 在本例中，元素代表了其他的损失，加起来就得到了所有的损失loss = tf.add_n(tf.get_collection('losses'))global_step = tf.Variable(0)# 学习率的设置：指数衰减法，参数：初始参数，全局步骤，每训练100轮乘以衰减速度0,96(当staircase=True的时候)learning_rate = tf.train.exponential_decay(0.1, global_step, 100, 0.96, staircase=True)train_step = tf.train.GradientDescentOptimizer(learning_rate).minimize(loss, global_step=global_step) 上面给出的代码给出的是一个只有 5 层的全连接神经网络。在更加复杂的网络结构中，使用这样的方式来计算损失函数将大大增强代码的可读性。 上一小节我们通过神经网络训练过程可能产生的过拟合问题，提出了可以通过添加正则化使得模型在测试数据上更健壮（泛化能力更强）。 滑动平均模型这里，我们将要介绍另一种保证模型健壮性的方法 &gt;&gt;&gt;&gt; 滑动平均模型。 在采用 随机梯度下降算法（SGD）训练神经网络时，使用滑动平均模型在很多应用中都可以在一定程度上提高最终模型在预测数据上的表现（学完这一小节思考一下）。 | ================================================== Split Line =============================================== | 滑动平均原理滑动平均是针对神经网络模型中的参数而言的，而 TF 中参数是使用变量来进行管理和组织的，故滑动平均模型又称为：变量的滑动平均模型。 [1] &gt;&gt;&gt; 变量滑动平均 滑动平均 &gt;&gt;&gt;&gt; 使变量的更新与一段时间内（而非某一时刻）的取值有关。 在创建滑动平均模型后，滑动平均模型会为每一个变量维护一个影子变量（shadow_variable，影子变量的初始值为相应变量的初始值），每当变量更新时，影子变量的值会更新为： $$ shadow\\_variable = decay × shadow\\_variable + ( 1 - decay ) × variable $$ 其中，shadow_variable 为影子变量；variable 为待更新变量；decay 为衰减率。注意区分：第一个 shadow_variable​ 是当前时刻影子变量的值，而第二个是上一时刻变量的影子变量。 从公式中可以看出，衰减率 decay 决定了模型更新的速度，decay 越大，影子变量受变量更新的影响越小，模型越趋于稳定。故，在实际的应用中，decay 值一般会设成非常接近 1 的数（如：0.999、0.9999）。 注意，变量的影子变量和变量的滑动平均值是一个意思！！！ | ================================================== Split Line =============================================== | [2] &gt;&gt;&gt; 意义 事实上，滑动平均值可以看作是变量的过去一段时间（过去 1/(1-decay​) 个时刻）取值的均值。相比对变量直接赋值而言，采用滑动平均得到的值在图像上更加平缓光滑，抖动性更小，不会因为某次的异常取值而使得滑动平均值波动很大。 故，使用滑动平均可以防止训练过程遇到异常数据或者随机跳跃（毕竟是随机批量，数据不确定）影响训练效果，使得参数权重和偏置相对稳定。在小数据量、数据不稳定或者小 batch_size 的情况下尤其有用。 | ================================================== Split Line =============================================== | [3] &gt;&gt;&gt; 测试中使用 对神经网络边的权重 weights 使用滑动平均，并且得到其对应的影子变量 shadow_weights。 但注意，在训练过程仍然使用原来不带滑动平均的权重 weights，不然无法得到 weights 下一步更新的值，又怎么求下一步 weights 所对应的影子变量 shadow_weights 呢？！！ 故，之后在测试过程中使用 shadow_weights 来代替 weights 作为神经网络边的权重，这样在测试数据上效果更好。 TF 滑动平均模型实现TF 中通过 tf.train.ExponentialMovingAverage() 函数来实现滑动平均模型。 [1] &gt;&gt;&gt; 滑动平均对象初始化 在初始化滑动平均对象时，需要提供一个衰减率（decay），这个衰减率将用于控制模型更新的速度： 1variable_averages = tf.train.ExponentialMovingAverage(MOVING_AVERAGE_DECAY, num_updates) 为了使模型在训练前期更新得的更快，该函数还提供了 num_updates 参数来动态设置 decay 的大小。如果在函数初始化时提供了 num_updates 参数，那么每次使用的衰减率将是： $$ min \\{ {decay, \\cfrac{1 + num\\_updates}{10 + num\\_updates}} \\} ​$$ 可以看出，num_updates 越大，衰减率就越大。num_updates 一般会设为迭代轮数，所以当迭代轮数越大，模型参数就越稳定。即： 1variable_averages = tf.train.ExponentialMovingAverage(MOVING_AVERAGE_DECAY, global_step) | ================================================== Split Line =============================================== | [2] &gt;&gt;&gt; 添加/更新影子变量 添加目标变量，为之维护影子变量： 1variable_averages_op = variable_averages.apply([var0, var1, ..., var_n]) 需要注意的是 &gt;&gt;&gt;&gt; 维护不是自动的，更新一次影子变量就需要训练中执行一次上述语句。 这里提供了一种方法 &gt;&gt;&gt;&gt; 一般都会使用 tf.control_dependencies 使之和 train_op 绑定，使得每次 train_op 都会更新影子变量。 1234# Tensorflow提供了两种机制：tf.control_dependencie 和 tf.group：# train_op = tf.group(train_step, variables_averages_op) 等价于 ==with tf.control_dependencies([train_step, variables_averages_op]): train_op = tf.no_op(name='train') | ================================================== Split Line =============================================== | [3] &gt;&gt;&gt; 获取影子变量值 从影子变量集合中提取目标变量对应的滑动平均值： 1sess.run(variable_averages.average([var0, var1])) | ============================================== 样例模拟更新过程 =========================================== | 123456789101112131415161718192021222324252627282930313233343536373839404142434445import tensorflow as tf# 定义一个变量用以计算滑动平均 &gt;&gt;&gt;&gt; 变量的初始值为: 0，手动指定类型为: float32v1 = tf.Variable(0, dtype=tf.float32)# 模拟神经网络迭代的轮数，动态控制衰减率step = tf.Variable(0, trainable=False)# 定义一个滑动平均的类，初始化时给定衰减率为 0.99 和控制衰减率大小的变量ema = tf.train.ExponentialMovingAverage(0.99, step)# 定义一个添加/更新影子变量的操作（每次更新都需要调用）# 这里需要给定一个变量列表，每次执行这个操作时，列表里的元素都会被更新maintain_average_op = ema.apply([v1])with tf.Session() as sess: # 初始化所有变量 init_op = tf.global_variables_initializer() sess.run(init_op) # 获取变量，以及其影子变量的初始值： print (sess.run([v1, ema.average(v1)])) # 输出：[0.0, 0.0] # ================ 第一次更新 =============== # # 更新 v1 的值为：5 sess.run(tf.assign(v1, 5)) # 更新 v1 的滑动平均值，衰减率为：min{0.99, (1+step)/(10+step)=0.1}=0.1 # 所以 v1 的滑动平均被更新为：0.1*0 + 0.9*5 = 4.5 sess.run(maintain_average_op) # 更新必执行 print (sess.run([v1, ema.average(v1)])) # 输出：[5.0, 4.5] # ================ 第二次更新 =============== # # 更新迭代的轮数 sess.run(tf.assign(step, 10000)) sess.run(tf.assign(v1, 10)) # 这里的衰减率变成：min{0.99, (1+step)/(10+step)=0.999}=0.99 # v1 = 0.99*4.5 + 0.01*10 = 4.555 sess.run(maintain_average_op) print (sess.run([v1, ema.average(v1)])) # 输出：[10.0, 4.555] # ================ 第三次更新 =============== # # 再次更新滑动平均值 sess.run(maintain_average_op) # v1 = 0.99*4.555 + 0.01*10 = 4.60945 print (sess.run([v1, ema.average(v1)])) # 输出：[10.0, 4.60945] | ================================================== Split Line =============================================== | 关于本篇博文内容，更多是偏向于神经网络中基础概念的原理讲解，没有给出具体的应用示例。为了加强理解和应用，你可以结合博文【TensorFlow 入门之 MNIST 手写体数字识别问题】进行学习，它给出了一个本篇所有内容的综合应用实例。 https://zhuanlan.zhihu.com/p/68468520","link":"/2018/04/04/tensorflow-ru-men-zhi-shen-du-xue-xi-he-shen-ceng-shen-jing-wang-luo/"},{"title":"TensorFlow 入门之 MNIST 手写体数字识别问题","text":"本篇我们将针对实际中的图像识别问题，使用深度学习入门级 MNIST 手写体数字识别数据集，并且结合上一篇博文中给出的更合理的神经网络设计与优化方法，给出一个使用 TF 实现 MNIST 手写体数字识别神经网络模型优化的最佳实践。 配置过程中参考了网络上很多的相关博文，也遇到过很多坑，为了感谢配置过程中各位大佬的帮助以及方便本人下次配置或者升级，整理以作此文。 更多 TensorFlow 框架学习相关内容，请关注博主相关博文系列 ↓↓↓↓↓ 之一 &gt;&gt;&gt;&gt; 一文详解全平台 TensorFlow 深度学习框架在线搭建 (CPU&amp;GPU 支持) 之二 &gt;&gt;&gt;&gt; TensorFlow GPU 支持: Ubuntu16.04 + Nvidia GTX + CUDA + CUDNN 之三 &gt;&gt;&gt;&gt; TensorFlow 入门之 TF 基本工作原理 之四 &gt;&gt;&gt;&gt; TensorFlow 入门之深度学习和深层神经网络 之五 &gt;&gt;&gt;&gt; TensorFlow 入门之 MNIST 手写体数字识别问题 之六 &gt;&gt;&gt;&gt; TensorFlow 入门之图像识别和卷积神经网络（CNN） 提纲本篇，我们总共安排了三个章节来进行学习： [1] &gt;&gt;&gt;&gt; 简单介绍 MNIST 手写体数字图像识别数据集，并给出 TensorFlow 程序如何处理 MNIST 数据集中数据的说明； [2] &gt;&gt;&gt;&gt; 基于 MNIST 手写体数字图像识别问题，TF 实现上一篇博文中给出的更合理的神经网络设计与优化方法，以从实际问题角度展示不同优化方法带来的模型性能提升； [3] &gt;&gt;&gt;&gt; 通过 TF 变量命名空间，来解决 TensorFlow 变量重用的问题，最终给出 MNIST 识别问题的完整样例。 初识 MNIST 数据集MNIST（Mixed National Institute of Standards and Technology Database）是一个非常有名的手写体数字图像识别数据集（NIST 数据集的一个子集），也是一个入门级的计算机视觉数据集（很多资料会将其作为深度学习入门样例）。就好比编程入门有 Hello World，机器学习入门有 MNIST。 MNIST 数据集中包含各种手写的数字图片： MNIST 官方数据集可以分成两部分： 60000 行的训练数据集（mnist.train） 10000 行的测试数据集（mnist.test） 其中，每一行 MNIST 数据单元（数据对象）由两部分组成：一张包含手写数字的图片，和手写数字图片所对应的标签。 MNIST 数据单元手写数字图像 &gt;&gt;&gt;&gt; 每一张图片都代表了一个手写的 0~9 中数字的灰度图（单通道图像），图片大小为 28 px × 28px。 我们可以用一个像素矩阵来表示手写数字 1 的图片： 关于图像的像素矩阵表示方法，可参考文档【 &gt;&gt;&gt;&gt; The Pixel Matrix Representation Of Image &lt;&lt;&lt;&lt;】。 图像标签 &gt;&gt;&gt;&gt; 每一个手写体数字图片，都对应 0~9 中的任意一个数字。 虽然 MNIST 数据集中只提供了训练数据（训练集）和测试数据（测试集），但是为了验证模型训练时的效果，使用时一般会从训练数据集中划分出一部分数据作为验证数据（集验证集）。 TensorFlow Support为了在 TensorFlow 中使用方便，TF 对 MNIST 数据集进行了内部封装，提供了一个示例模块来处理 MNIST 数据集。 12# 这个模块会自动下载并转换 MNIST 数据格式，将其从原始的数据包中解析成训练和测试神经网络时可以使用的数据格式。tensorflow.examples.tutorials.mnist TF MNIST 数据集使用样例： 12345678910111213141516171819# 导入用于下载和读取 MNIST 数据集的模块:from tensorflow.examples.tutorials.mnist import input_data# 指定 MNIST 数据集的下载和读取的路径：MNIST_data_Path = &quot;./MNIST_data/&quot;# 获取 MNIST 数据集对象mnist = input_data.read_data_sets(MNIST_data_Path, one_hot=True)# print mnist.train dataSet size :print(&quot;Training data size : &quot;, mnist.train.num_examples)# print mnist.validation dataSet size :print(&quot;Validating data size : &quot;, mnist.validation.num_examples)# print mnist.test dataSet size :print(&quot;Testing data size : &quot;, mnist.test.num_examples)# print mnist.train.images[0] / mnist.train.labels[0] Formatprint(&quot;Example training data（image）: &quot;, &quot;\\n&quot;, mnist.train.images[0])print(&quot;Example training data lable : &quot;, mnist.train.labels[0]) 可能由于网络原因导致 MNIST 数据集下载失败，你可以参考 【 &gt;&gt;&gt;&gt; MNIST Introduction &lt;&lt;&lt;&lt;】进行手动下载！！！ 下载成功后，样例程序输出结果如下： 1234567891011121314151617181920212223242526272829303132Successfully downloaded train-images-idx3-ubyte.gz 9912422 bytes.Extracting ./MNIST_data/train-images-idx3-ubyte.gzSuccessfully downloaded train-labels-idx1-ubyte.gz 28881 bytes.Extracting ./MNIST_data/train-labels-idx1-ubyte.gzSuccessfully downloaded t10k-images-idx3-ubyte.gz 1648877 bytes.Extracting ./MNIST_data/t10k-images-idx3-ubyte.gzSuccessfully downloaded t10k-labels-idx1-ubyte.gz 4542 bytes.Extracting ./MNIST_data/t10k-labels-idx1-ubyte.gzTraining data size : 55000Validating data size : 5000Testing data size : 10000Example training data : [0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 1. ................. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.34901962 0.9843138 0.9450981 0.3372549 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.01960784 0.8078432 0.96470594 0.6156863 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 1. ...................... 0. 0. 0. 0. 0.01568628 0.45882356 0.27058825 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. ]Example training data lable : [0. 0. 0. 0. 0. 0. 0. 1. 0. 0.] 👇👇👇 MNIST 数据集划分 👇👇👇 可以看出，input_data.read_data_sets 函数生成的数据集对象会自动将 MNIST 数据集划分为 train &amp;&amp; validation &amp;&amp; test 三个数据集。 其中，train 数据集中包含 55000 张训练图片，validation 数据集中包含 5000 张验证图片，它们共同构成了 MNIST 自身提供的训练数据集。test 数据集中包含了 10000 张测试图片，这些图片都来自于 MNIST 提供的测试数据集。 | ================================================== Split Line =============================================== | 👇👇👇 图像输入和标签处理 👇👇👇 FCNN 神经网络结构的输入是一个特征向量，所以这里需要将一张二维图像的像素矩阵扁平化处理为一维数组，方便 TF 将图片的像素矩阵提供给神经网络的输入层。 故，TF 封装模块处理后的每张手写数字图片都是一个长度为 784 的一维数组，这个数组中的元素对应了图片像素矩阵中的任意像素值（28 * 28 = 784）。为了方便计算，像素矩阵中像素的灰度值被归一化到 [0, 1]，它代表了颜色的深浅。其中 0 表示白色背景（background），1 表示黑色前景（foreground）。 并且，对手写数字图片所对应的标签，进行了 one-hot 编码处理，方便神经网络的分类任务。one-hot 标签数组是一个 10 维（长度为 10）的向量，每一个维度都对应了 0~9 中数字中的一个。形如：[0,1,0,0,0,0,0,0,0,0] &lt;&lt;&lt;&lt; 数字 1。 | ================================================== Split Line =============================================== | 👇👇👇 Mini Batch 支持 👇👇👇 为了方便使用小批量样本梯度下降（MGD），input_data.read_data_sets 函数生成的数据集对象还提供了 mnist.train.next_batch 方法，可以快速从所有的训练数据中读取一小部分数据作为一个训练 batch。 以下代码显示如何使用这个功能： 1234567# 取 BATCH SIZE 为 100 大小的训练数据：BATCH_SIZE = 100xs, ys = mnist.train.next_batch(BATCH_SIZE)print ('X Shape: ', xs.shape) # X Shape: (100, 784)print ('Y Shape: ', ys.shape) # Y Shape: (100, 10) 关于 MNIST 数据集更加详细的说明以及使用，请参见文档【 &gt;&gt;&gt;&gt; MNIST Introduction &lt;&lt;&lt;&lt;】。 MNIST FCNN 模型训练以及不同优化效果对比这一章节，首先基于 MNIST 手写体数字图像识别问题给出一个 TF 实现，这个程序整合了上一篇博文中介绍的所有优化方法。 接着，介绍验证/测试数据集在神经网络训练过程中的作用。通过实验数据来证明，神经网络在验证数据集上的表现可以近似地作为评价不同神经网络模型效果的标准或者作为迭代轮数的依据。 最后，通过模型在测试集上的表现对比上一篇博文中提到的神经网络结构设计和参数优化的不同方法，从实际问题中展示不同优化方法所带来的性能提升。 TF 实现 MNIST 图像识别问题这个程序整合了上一篇博文中介绍的所有优化方法： 在神经网络结构设计上采用全连接结构，引入隐藏层、激活函数、偏置项；在训练神经网络上，引入设置指数衰减学习率、正则化以及滑动平均模型。 训练好的神经网络模型在 MNIST 测试数据集上可以达到 98.4% 左右的准确率。 完整的代码如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295''' Hello TensorFlow : MNIST 手写体数字图片识别 Neural Network Structure : Full Connection'''import timefrom datetime import timedeltaimport warningswarnings.filterwarnings('ignore')# import os# os.environ['TF_CPP_MIN_LOG_LEVEL'] = '2'import tensorflow as tftf.compat.v1.logging.set_verbosity(tf.compat.v1.logging.ERROR) # 忽略 TensorFlow 警告信息# 导入用于下载和读取 MNIST 数据集的模块from tensorflow.examples.tutorials.mnist import input_dataimport numpy as npimport matplotlib.pyplot as plt%matplotlib inline###################### Part 1 : Macros Variables Define ######################## 1. MNIST 数据集相关的常数 ### 图像像素（28px * 28px 像素矩阵转化），输入层的节点数；INPUT_NODE = 784# 输出节点数，等于类别数目。分别对应 `0~9` 10 个数字类别；OUTPUT_NODE = 10## 2. 配置神经网络中的参数 ### Layes1: 隐藏层节点数，这里设置只有一层隐藏层（hidden layers）的网络结构LAYER1_NODE = 200# 设置滑动平均衰减率MOVING_AVERAGE_DECAY = 0.99# 设置描述模型复杂度（结构风险）的正则化项在损失函数中的系数(lambda)REGULARIZATION_RATE = 0.0001# 设置初始学习率LEARNING_RATE_BASE = 0.8# 设置学习率的衰减率LEARNING_RATE_DECAY = 0.96# 设置训练轮数TRAINING_STEPS = 30000# 一个训练 batch 块中的训练数据个数。# batch 数值越小，训练过程越接近随机梯度下降；数值越大，训练越接近梯度下降。BATCH_SIZE = 100###################### Part 2 : Referenced Function Define #####################'''### [1] get_time_dif：时间函数 用于获取程序中某些功能模块所使用的时间（Seconds）'''def get_time_dif(start_time): end_time = time.time() time_diff = end_time - start_time return timedelta(seconds=time_diff)''' ### [2] inference : 通过给定的 FCNN 输入和所有参数，计算 FCNN FP 的结果 ## 定义了一个带 ReLU（非线性） 激活函数的三层全连接神经网络，实现了多层网络结构以及去线性化。同时，支持：传入用于计算参数滑动平均值的类，方便在测试时使用滑动平均模型。'''def inference(input_tensor, avg_class, weights1, biases1, weights2, biases2): # 当没有提供滑动平均类时，直接使用参数当前的取值 if avg_class == None: # 计算隐藏层的 FP 结果，激活函数为 ReLU: layer1 = tf.nn.relu(tf.matmul(input_tensor, weights1) + biases1) return tf.matmul(layer1, weights2) + biases2 else: layer1 = tf.nn.relu(tf.matmul(input_tensor, avg_class.average(weights1)) + avg_class.average(biases1)) return tf.matmul(layer1, avg_class.average(weights2)) + avg_class.average(biases2)''' ### [3] train : 模型训练 ## FCNN 模型训练需要的前向传播算法、反向传播算法，以及迭代训练的实现。'''def train(mnist): x = tf.placeholder(dtype=tf.float32, shape=(None, INPUT_NODE), name=&quot;input_x&quot;) y_ = tf.placeholder(dtype=tf.float32, shape=(None, OUTPUT_NODE), name=&quot;input_y&quot;) # 隐藏层参数(Second layer)： weights1 = tf.Variable(tf.random_normal([INPUT_NODE, LAYER1_NODE], stddev=0.1, dtype=tf.float32)) biases1 = tf.Variable(tf.constant(0.1, shape=[LAYER1_NODE])) # 输出层参数(Third layer)： weights2 = tf.Variable(tf.random_normal([LAYER1_NODE, OUTPUT_NODE], stddev=0.1, dtype=tf.float32)) biases2 = tf.Variable(tf.constant(0.1, shape=[OUTPUT_NODE])) #### 1. 前向传播（FP） #### # 计算当前参数下 FCNN FP 的结果，模型训练时前向传播计算的 avg_class = None，所以不会使用参数的滑动平均值进行计算 y = inference(x, None, weights1, biases1, weights2, biases2) # 定义训练时的全局步数，该变量无需计算滑动平均值。所以一般需要指定全局步数变量为不可训练变量(trainable=False) global_step = tf.Variable(0, trainable=False) #### =============== #### #### 2. 滑动平均设置 #### # avg_class = variable_averages variable_averages = tf.train.ExponentialMovingAverage(MOVING_AVERAGE_DECAY, global_step) # 初始化滑动平均对象 # 计算所有可训练神经网络参数变量的滑动平均值（即添加/更新参数变量的影子变量）： variables_averages_op = variable_averages.apply(tf.trainable_variables()) # tf.trainable_variables 可返回 GraphKeys.TRAINABLE_VARIABLES 集合中所有元素（即未指定 trainable=False 的变量） # 计算使用了滑动平均之后的 FP 结果。滑动平均之后不会改变变量本身取值，会维护一个 shadow_variable 来记录其滑动平均值 movingAvg_y = inference(x, variable_averages, weights1, biases1, weights2, biases2) #### =============== #### #### 3. Loss Function #### # 定义交叉熵损失函数（经验风险）:该函数第二个参数需要提供的是正确标签的数字，tf.argmax(y_, 1)可以获取 y_ 对应的类别标签（原型: tf.argmax(array, axis)） # 注意，这里的 logits 参数值只能是不使用滑动平均的变量，不能是影子变量： cross_entropy = tf.nn.sparse_softmax_cross_entropy_with_logits(logits=y, labels=tf.argmax(y_, 1)) # 计算当前 batch 中所有样例的交叉熵平均值 cross_entropy_mean = tf.reduce_mean(cross_entropy) # 定义 L2 正则化损失函数（结构风险）： regularizer = tf.contrib.layers.l2_regularizer(REGULARIZATION_RATE) # 计算模型的 L2 正则化损失（一般只计算权重的正则化损失，而不使用偏置项）: parm_regularization = regularizer(weights1) + regularizer(weights2) # 计算最终 Loss Function：经验风险和结构分析 loss = cross_entropy_mean + parm_regularization #### =============== #### #### 4. 反向传播（BP） #### # 设置指数衰减的学习率:随着迭代进行，更新变量的学习率在这个基础上递减 learning_rate = tf.train.exponential_decay(learning_rate = LEARNING_RATE_BASE, # 初始学习率 global_step = global_step, # 训练时的全局步数 decay_steps = mnist.train.num_examples / BATCH_SIZE, # 遍历一次所有训练数据需要的迭代次数 decay_rate = LEARNING_RATE_DECAY # 衰减系数 ) # 优化器: train_step = tf.train.GradientDescentOptimizer(learning_rate).minimize(loss, global_step=global_step) # 绑定参数滑动平均计算和参数梯度更新计算 # 每迭代一次数据就需要通过 BP 来更新 FCNN 中参数，又要更新每一个参数的滑动平均值（影子变量）。 # TF 中提供了两种机制：tf.control_dependencie 和 tf.group： # # train_op = tf.group(train_step, variables_averages_op) # 等价于 == with tf.control_dependencies([train_step, variables_averages_op]): train_op = tf.no_op(name='train') #### =============== #### ## 5. Model Evaluation ## # 检验使用了滑动平均模型的 FCNN 模型的效果（滑动平均或不使用滑动平均） # correct_prediction = tf.equal(tf.argmax(movingAvg_y, 1), tf.argmax(y_, 1)) correct_prediction = tf.equal(tf.argmax(y, 1), tf.argmax(y_, 1)) # tf.cast(x, dtype) 会将 x 数据格式转化成 dtype 数据格式。这里，将 bool 型数值转为 float 后，x 会变为 0/1 序列。 # 计算模型准确率 accuracy = tf.reduce_mean(tf.cast(correct_prediction, tf.float32)) ############################ Begin To Training ########################### # 定义会话配置: config = tf.ConfigProto(# device_count={&quot;CPU&quot;: 4}, # limit to num_cpu_cor CPU usage # inter_op_parallelism_threads = 1, # config parallelism # intra_op_parallelism_threads = 1, # config parallelism allow_soft_placement=True, log_device_placement=True) with tf.Session(config=config) as sess: start_time = time.time() # 初始化所有变量 init_op = tf.global_variables_initializer().run() print('Training and evaluating...') # 准备验证数据集，一般用于在训练过程中大致判断停止以及模型训练效果: validation_feed = {x: mnist.validation.images, y_: mnist.validation.labels} # 准备测试数据集，用于评价模型优劣的标准 test_feed = {x: mnist.test.images, y_: mnist.test.labels} # 可视化准备 epoch = 0 NUM_EPOCH = int(TRAINING_STEPS / 1000) fig_loss = np.zeros([NUM_EPOCH]) fig_acc_val = np.zeros([NUM_EPOCH]) fig_acc_test = np.zeros([NUM_EPOCH]) # 迭代训练神经网络 for step in range(TRAINING_STEPS): # 产生这一轮使用的一个 batch 的训练数据，并进行训练 xs, ys = mnist.train.next_batch(BATCH_SIZE) sess.run(train_op, feed_dict={x: xs, y_: ys}) # 每 1000 次输出一次在验证数据上的测试结果 if step % 1000 == 0: # print('Epoch:', epoch + 1) loss_train, acc_train = sess.run([loss, accuracy], feed_dict={x: xs, y_: ys}) loss_val, acc_val = sess.run([loss, accuracy], feed_dict=validation_feed) # todo time_dif = get_time_dif(start_time) msg = 'Iter: {0:&gt;6}, Train Loss: {1:&gt;6.2}, Train Acc: {2:&gt;7.2%},' \\ + ' Val Loss: {3:&gt;6.2}, Val Acc: {4:&gt;7.2%}, Time: {5}' print(msg.format(step, loss_train, acc_train, loss_val, acc_val, time_dif)) # 可视化准备 acc_test = sess.run(accuracy, feed_dict=test_feed) fig_loss[epoch] = loss_train fig_acc_val[epoch] = acc_val + 0.05 # 为了区分验证准确率和测试准确率差别, 让验证集准确率上移 0.05 单位 fig_acc_test[epoch] = acc_test epoch += 1 # 训练结束后，在测试数据集上计算 FCNN 模型的最终准确率，以评估模型效果 test_acc = sess.run(accuracy, feed_dict=test_feed) print (&quot;After %d training step(s), test accuracy &quot; &quot;using average Model is %g &quot; % (TRAINING_STEPS, test_acc)) ### -------- 可视化 -------- ### # 训练过程中损失 (Loss) 曲线: fig1 = plt.figure() plt.plot(np.arange(NUM_EPOCH), fig_loss, label=&quot;Loss&quot;) plt.xlabel(&quot;Iteration&quot;) plt.ylabel(&quot;Training Loss&quot;) # plt.show() # 验证集和测试集上的准确率 (Accuracy) 曲线: # fig2 = plt.figure(figsize=(30, 1), dpi=50) # 设置图片大小和像素(dpi=50) fig2 = plt.figure() plt.plot(np.arange(NUM_EPOCH), fig_acc_val, label=&quot;Validation Accuracy&quot;, color=&quot;blue&quot;) # 绘制折线图 plt.plot(np.arange(NUM_EPOCH), fig_acc_test, label=&quot;Test Accuracy&quot;, color=&quot;green&quot;) # 绘制折线图 plt.xlabel(&quot;Iteration&quot;) # 设置 x 轴标签 plt.ylabel(&quot;Modul Accuracy&quot;) # 设置 y 轴标签 y_ticks = np.arange(0, 1, 0.15) # 设置 y 轴刻度 plt.yticks(y_ticks) plt.grid(alpha=0.4, linestyle='-.') # 绘制网格 &gt;&gt;&gt;&gt; alpha 设置网格透明度; linestyle 设置网格样式 # plt.legend(prop=my_font, loc='upper left') # 设置图例字体及其位置 (默认右上) plt.show() ### ======================= ############################### Main Function as the begin of program ###########################def main(arg=None): ###################### Functions for downloading and reading MNIST data. ###################### ''' ## 初始化：下载或读取用于训练、测试以及验证的 MNIST 手写数字图片（28px * 28px）数据集 ## MNIST 数据集分成两部分：60000行的训练数据集（mnist.train）和10000行的测试数据集（mnist.test）。每一个 MNIST 数据单 元（数据对象）有两部分组成：一张包含手写数字的图片和一个对应的标签。比如训练数据集的图片是 mnist.train.images ，训练数据集的标签是 mnist.train.labels。 mnist.train.images 是一个形状为 [60000, 784] 的张量，第一个维度数字用来索引图片，第二个维度数字用来索引每张图片中的像素点。 mnist.train.labels 是一个形状为 [60000, 10] 的张量，第一个维度数字用来索引图片，第二个维度数字用来索引每张图片中的分类标签（one-hot vectors）。 实际，read_data_sets 类会将数据从原始数据包格式解析成训练和测试神经网络时的数据格式 。read_data_sets 会自动将 MNIST 数据集划分为 train（55000）、test（10000） 以及 validation（5000）三个数据集。 ''' print(&quot;Loading training and validation data...&quot;) start_time = time.time() # 指定 MNIST 数据集的下载和读取的路径： MNIST_DATA_PATH = &quot;./MNIST_data/&quot; mnist = input_data.read_data_sets(MNIST_DATA_PATH, one_hot=True) # print mnist.train dataSet size : print(&quot;Training Data Size : &quot;, mnist.train.num_examples) # print mnist.validation dataSet size : print(&quot;Validation Data Size : &quot;, mnist.validation.num_examples) # print mnist.test dataSet size : print(&quot;Testing Data Size : &quot;, mnist.test.num_examples) # print mnist.train.images[0] / mnist.train.labels[0] Format # print(&quot;Example training data[0] pix-matirx : &quot;, &quot;\\n&quot;, mnist.train.images[0]) # print(&quot;Example training picture shape : &quot; + str(len(mnist.train.images[0]))) # print(&quot;Example training data lable : &quot;, mnist.train.labels[0]) # print(&quot;Example training lable shape : &quot; + str(len(mnist.train.labels[0]))) time_diff = get_time_dif(start_time) print(&quot;Time Usage:&quot;, time_diff) ###################### Functions for Training FCNN Model By Using MNIST data. ###################### # begin to train model: train(mnist)if __name__ == &quot;__main__&quot;: # TF 提供的一个主程序入口，tf.app.run 会调用上面定义的 main 函数： # tf.app.run() main() 样例程序输出信息如下： 1234567891011121314151617181920212223242526272829303132333435363738394041Loading training and validation data...Extracting ./MNIST_data/train-images-idx3-ubyte.gzExtracting ./MNIST_data/train-labels-idx1-ubyte.gzExtracting ./MNIST_data/t10k-images-idx3-ubyte.gzExtracting ./MNIST_data/t10k-labels-idx1-ubyte.gzTraining Data Size : 55000Validation Data Size : 5000Testing Data Size : 10000Time Usage: 0:00:00.347534Training and evaluating...Iter: 0, Train Loss: 3.7, Train Acc: 57.00%, Val Loss: 4.5, Val Acc: 38.60%, Time: 0:00:00.421596Iter: 1000, Train Loss: 0.094, Train Acc: 100.00%, Val Loss: 0.17, Val Acc: 97.18%, Time: 0:00:01.537846Iter: 2000, Train Loss: 0.089, Train Acc: 100.00%, Val Loss: 0.15, Val Acc: 97.72%, Time: 0:00:02.682101Iter: 3000, Train Loss: 0.083, Train Acc: 100.00%, Val Loss: 0.14, Val Acc: 97.96%, Time: 0:00:03.847363Iter: 4000, Train Loss: 0.077, Train Acc: 100.00%, Val Loss: 0.14, Val Acc: 97.90%, Time: 0:00:05.014624Iter: 5000, Train Loss: 0.068, Train Acc: 100.00%, Val Loss: 0.13, Val Acc: 98.08%, Time: 0:00:06.187306Iter: 6000, Train Loss: 0.066, Train Acc: 100.00%, Val Loss: 0.12, Val Acc: 98.24%, Time: 0:00:07.310558Iter: 7000, Train Loss: 0.065, Train Acc: 100.00%, Val Loss: 0.12, Val Acc: 98.20%, Time: 0:00:08.489824Iter: 8000, Train Loss: 0.058, Train Acc: 100.00%, Val Loss: 0.11, Val Acc: 98.40%, Time: 0:00:09.660084Iter: 9000, Train Loss: 0.059, Train Acc: 100.00%, Val Loss: 0.11, Val Acc: 98.42%, Time: 0:00:10.893361Iter: 10000, Train Loss: 0.056, Train Acc: 100.00%, Val Loss: 0.11, Val Acc: 98.40%, Time: 0:00:12.093628Iter: 11000, Train Loss: 0.053, Train Acc: 100.00%, Val Loss: 0.11, Val Acc: 98.42%, Time: 0:00:13.272892Iter: 12000, Train Loss: 0.051, Train Acc: 100.00%, Val Loss: 0.1, Val Acc: 98.38%, Time: 0:00:14.393144Iter: 13000, Train Loss: 0.051, Train Acc: 100.00%, Val Loss: 0.1, Val Acc: 98.40%, Time: 0:00:15.549404Iter: 14000, Train Loss: 0.051, Train Acc: 100.00%, Val Loss: 0.1, Val Acc: 98.54%, Time: 0:00:16.730667Iter: 15000, Train Loss: 0.045, Train Acc: 100.00%, Val Loss: 0.099, Val Acc: 98.48%, Time: 0:00:17.896928Iter: 16000, Train Loss: 0.047, Train Acc: 100.00%, Val Loss: 0.099, Val Acc: 98.48%, Time: 0:00:19.068191Iter: 17000, Train Loss: 0.044, Train Acc: 100.00%, Val Loss: 0.096, Val Acc: 98.50%, Time: 0:00:20.166436Iter: 18000, Train Loss: 0.046, Train Acc: 100.00%, Val Loss: 0.096, Val Acc: 98.60%, Time: 0:00:21.333697Iter: 19000, Train Loss: 0.044, Train Acc: 100.00%, Val Loss: 0.094, Val Acc: 98.56%, Time: 0:00:22.496959Iter: 20000, Train Loss: 0.049, Train Acc: 100.00%, Val Loss: 0.094, Val Acc: 98.54%, Time: 0:00:23.666221Iter: 21000, Train Loss: 0.044, Train Acc: 100.00%, Val Loss: 0.093, Val Acc: 98.52%, Time: 0:00:24.835482Iter: 22000, Train Loss: 0.048, Train Acc: 100.00%, Val Loss: 0.093, Val Acc: 98.52%, Time: 0:00:26.002744Iter: 23000, Train Loss: 0.041, Train Acc: 100.00%, Val Loss: 0.093, Val Acc: 98.46%, Time: 0:00:27.125994Iter: 24000, Train Loss: 0.042, Train Acc: 100.00%, Val Loss: 0.092, Val Acc: 98.52%, Time: 0:00:28.296257Iter: 25000, Train Loss: 0.047, Train Acc: 100.00%, Val Loss: 0.092, Val Acc: 98.54%, Time: 0:00:29.459517Iter: 26000, Train Loss: 0.04, Train Acc: 100.00%, Val Loss: 0.091, Val Acc: 98.54%, Time: 0:00:30.612776Iter: 27000, Train Loss: 0.043, Train Acc: 100.00%, Val Loss: 0.091, Val Acc: 98.58%, Time: 0:00:31.786038Iter: 28000, Train Loss: 0.041, Train Acc: 100.00%, Val Loss: 0.091, Val Acc: 98.54%, Time: 0:00:32.886282Iter: 29000, Train Loss: 0.041, Train Acc: 100.00%, Val Loss: 0.09, Val Acc: 98.54%, Time: 0:00:34.055544After 30000 training step(s), test accuracy using average Model is 0.9828 训练过程中损失 (Loss) 曲线如下： 可见，随着训练迭代过程的增加，模型的损失函数逐渐收敛于一个较小值（接近 0）。 训练过程中，验证集和测试集上的准确率 (Accuracy) 变化曲线: 可见，对于分布均匀的数据集，训练过程中模型在验证集上表现可以完全表征其在测试集上的效果！！！ 模型效果评估上述 TF 实现 MNIST 图像识别问题样例中，我们设置了一系列的参数：初始学习率、学习率衰减率、隐藏层节点数、迭代轮数等，并且我们知道神经网络模型的最终表达效果是受上述参数影响的。 那么如何设置这些参数的取值？！！大部分情况下，配置神经网络的参数是需要通过不断对比实验来进行调整，以实现最佳的神经网络模型效果（关于更多神经网络调参内容可参考【&gt;&gt;&gt;&gt; 一文详解深度神经网络调参技巧 &lt;&lt;&lt;&lt;】）。 那么，如何评估不同参数设置下的模型效果优劣？！！ 测试集评估神经网络模型效果的好坏可以通过 &gt;&gt;&gt;&gt; 模型对未知数据（测试集数据）的预测情况来评判的。 但我们不能直接通过模型在测试数据上的效果来选择参数（测试数据集变成了训练数据集的一部分参与训练，这时设置测试集是没有意义的；或者测试集较好表现成为模型优化的目标），这可能导致神经网络过度拟合测试数据，从而失去了对未知数据的预判能力。 也就是说，测试数据不应该对我们最终学得（/训练得到）的神经网络模型提供任何支持，这样才能 保证通过测试数据评估出来的模型效果和在真实场景下模型对未知数据的预测效果是最接近的！！！ &lt;&lt;&lt;&lt; 测试数据集对应的是部分未知数据，所以需要保证训练过程中测试数据不可见。 | ================================================== Split Line =============================================== | 由于测试数据在训练过程的不可见，那么如何评判在 优化/训练过程中 神经网络模型不同参数设置下的效果？！！ 👇👇👇 引入验证集（Validation Set） 👇👇👇 一般会从训练集抽取一部分数据作为验证数据集，通过训练模型在验证数据集上的表现，来（代替测试集）评价优化过程中不同参数选取下模型的好坏。 👇👇👇 K 折（K Fold Cross Validation） 👇👇👇 一般是将整个数据集分成 k 个子集，每个子集均做一次测试集，其余的作为训练集进行训练。交叉验证需要重复 k 次，每次选择一个子集作为测试集，并将 k 次的平均交叉验证识别正确率作为结果。 由于神经网络本身训练时间就比较长，采用交叉验证会花费大量的时间（适合小数据集）。所以在海量数据下，一般会更多的采用验证数据集的形式来评测模型的效果。 验证集近似评估为了说明 &gt;&gt;&gt;&gt; 验证数据可以代替测试集（默认数据分布均匀），近似作为模型效果的评价标准，我们将对比不同迭代轮数情况下，模型在验证数据和测试数据上的准确率： 上图给出了每 1000 轮 FCNN 模型在验证、测试数据集上的准确率变换曲线。可以看出，虽然两条曲线不完全重合，但这两条曲线的趋势基本一致，而且他们的相关系数（correlation coefficient）大于 0.9999。 实验说明 &gt;&gt;&gt;&gt; 模型在验证数据集上的表现，完全可以近似作为评价不同神经网络模型的标准，或者作为训练迭代轮数的依据！！！ | ================================================== Split Line =============================================== | 👇👇👇 需要注意的是 👇👇👇 上面我们所说的测试数据集训练过程不可见，并不是严格不可见。你会看到很多资料不会划分验证数据集，直接使用测试数据集作为模型训练过程中是否近优的评价标准。 个人理解 &gt;&gt;&gt;&gt; 理想情况下，我们希望选取的未划分的样本数据集样本对于问题的数据分布是均匀的。但如果验证数据分布不能很好地代表测试数据分布，那么模型在这两个数据集上的表现就可能不一样。 一般来说，选取的验证数据分布越接近测试数据分布，模型在验证数据上的表现就越可以体现神经网络模型在测试数据（未知数据）下的效果！！！ 不同优化方法模型效果对比了解了神经网络模型效果评估标准后，这一小节将通过模型在 MNIST 测试集上的预测准确率表现对比上一篇博文中提到的神经网络结构设计和参数优化的不同方法，从实际问题中展示不同优化方法所带来的性能提升。 下图，给出了在相同神经网络参数下，设置不同优化方法的对比实验，经过 30000 轮训练迭代后，得到的各个模型最终的正确率（10 次运行结果的平均值）： 👇👇👇 神经网路模型结构影响 👇👇👇 可以看出 &gt;&gt;&gt;&gt; 调整神经网络模型的结构（不使用隐藏层或没有激活函数）对最终的准确率有非常大的影响。这说明神经网络的结构设计对最终模型的效果有本质的影响。 后面会介绍一种更加特殊的神经网络结构 CNN（卷积神经网络），它可以更加有效的处理图像信息。通过 CNN 可以进一步将 MNIST 识别模型准确率提高到 99.5%。 👇👇👇 滑动平均模型/指数衰减学习率/正则化影响 👇👇👇 从上图数字中发现 &gt;&gt;&gt;&gt; 使用滑动平均模型、指数衰减学习率和使用正则化带来的正确率提升并不是特别明显。其中，使用了所有优化方法的模型、和不使用滑动平均模型，以及不使用指数衰减学习率的模型正确率都可以达到约 98.4% 。 那么是不是意味着这些优化方法对模型准确率提升不大？！！ 答案肯定是否定的！！！这里准确率提升不是特别明显，是由于 MNIST 数据集简单，模型收敛速度很快（梯度较小），而滑动平均模型以及指数衰减学习率在一定程度上都是限制神经网络中参数的更新速度，所以这两种优化对最终模型影响不大。 从上面模型在验证数据和测试数据上的准确率曲线可以看出，在迭代 4000 次以后就已经接近最终的准确率了（收敛太快）。 | ================================================== Split Line =============================================== | 下面我们将进一步分析滑动平均模型、指数衰减学习率和使用正则化对训练模型的影响： [1] &gt;&gt;&gt;&gt; 滑动平均模型和指数衰减学习率 先给出不同迭代轮数时，使用了所有优化方法的模型的正确率与平均绝对梯度的变化趋势图： 可以看出，前 4000 轮迭代对模型的改变是最大的。在 4000 轮迭代之后，由于梯度比较小，所以参数的改变也就比较缓慢了。于是滑动平均模型或者指数衰减学习率的作用也就没那么显著了。 不同迭代轮数时，模型正确率和衰减之后学习率的变化趋势图如下： 可以看出，学习率曲线呈现阶梯状衰减方式。在前 4000 轮时，衰减之后的学习率和初始学习率的差距并不大。那么，能否说明这些限制网络参数的更新速度的优化方法作用不大？！！ 实际上，当问题更加复杂时，模型迭代不会这么快收敛，这时滑动平均模型和指数衰减学习率会发挥更大的作用！！！例如 Cifar-10 图像分类数据集上，使用滑动平均模型可以将模型识别的错误率降低 11%，使用指数衰减学习率可以将识别错误率降低 7%。 | ================================================== Split Line =============================================== | [2] &gt;&gt;&gt;&gt; 正则化 相较于滑动平均模型和指数衰减学习率，使用加入了正则化损失函数（结构风险）给模型效果带来的提升要相对显著。 下图对比了两个使用了不同损失函数的神经网络模型，其中一个模型只最小化交叉熵损失，另一个模型优化的是交叉熵损失和 L2 正则化损失的和： 显而易见，只优化交叉熵的模型在训练数据上的交叉熵损失（灰色虚线）要比优化总损失的模型更小（黑色虚线）。然而在测试数据上，优化总损失的模型（黑色实线）却要好于只优化交叉熵的模型（灰色实线）。这就是前面我们提到过的过拟合问题。 这是由于只优化交叉熵的模型可能更好的拟合训练数据（损失更小），却不能很好的挖掘数据中的潜在规律来判断未知的测试数据，故在测试数据上的准确率低。 我们再给出不同模型的损失函数变化规律： 从左侧只优化交叉熵模型子图可以看出，随着迭代的进行，正则化损失是在不断增大的。 而由于 MNIST 问题相对比较简单，迭代后期的梯度很小，所以正则化损失的增长也很慢。对于更加复杂的问题，迭代后期的梯度更大，就会发现总损失（交叉熵损失加上正则化损失）会呈现一个 U 型！！！ | ================================================== Split Line =============================================== | ↓↓↓↓↓↓ 结论 ↓↓↓↓↓↓ 可以发现，上述的这些优化方法确实可以解决前面博文中提到的神经网络优化过程中的问题。当需要解决的问题和使用到的神经网络模型更加复杂时，上面的这些优化方法将更有可能对训练效果产生更大的影响。 TF 变量命名空间管理由于编程习惯，我们通常喜欢采用模块化编程风格，提高代码可读性。 上面给出的 TF 实现 MNIST 手写体数字图像识别示例中，将计算神经网络前向传播结果的过程抽象成了一个函数（模块）: 1def inference(input_tensor, avg_class, weights1, biases1, weights2, biases2) 这样带来的一个好处：在训练、测试以及预测的过程中可以统一调用同一个函数来得到模型的前向传播结果。 变量的重用以及命名空间从上述 FP 过程定义中可以看到，这个函数的形参中需要包括神经网络中的所有参数。 你想过没有：当神经网络的结构更加复杂，引入的参数更多时，就需要一个更好的方式来传递和管理神经网络中的参数了 &gt;&gt;&gt;&gt; TensorFlow 支持通过变量名称来创建或者获取一个变量的机制。 通过这种机制，我们可以在不同函数中可以直接通过变量的名称来使用变量（变量重用），而不要将变量通过参数的形式到处传递。 TF 中通过 tf.get_variable 函数和 tf.variable_scope 函数来分别实现 TF 变量的重用和命名空间管理。 TF 变量重用除了之前提到过的 tf.Variable() 变量创建函数，TensorFlow 中还支持通过 tf.get_variable 函数来获取已存在变量（不存在则创建）。 [1] &gt;&gt;&gt;&gt; tf.Variable 重新认识一下 tf.Variable() 函数： tf.Variable 函数用于生成一个初始值为 initial-value 的变量（必须指定初始化值）： 123456789101112tf.Variable( initial_value=None, trainable=True, collections=None, validate_shape=True, caching_device=None, name=None, variable_def=None, dtype=None, expected_shape=None, import_scope=None) 经常使用的是：initial_value（初始化）、name（命名）、dtype（变量类型）、trainable（是否可训练/优化）。 ↓↓↓↓↓↓ 参数解释 ↓↓↓↓↓↓ initial_value：Variable 初始值，为 Tensor 或可转换为 Tensor 的 Python 对象。如果 validate_shape = True（默认），则初始值必须具有指定的形状； validate_shape：默认为 True，initial_value 必须具有指定的形状。如果为 False，则允许使用未知形状的值初始化变量； name：变量的可选名称，默认为 “Variable” 并自动获取； dtype：如果设置，则 initial_value 将转换为给定类型；如果为 None，则保留数据类型； trainable：用于标识模型训练时是否更新当前参数；如果为 True，当前变量会被添加到图形集合 GraphKeys.TRAINABLE_VARIABLES中； collections：","link":"/2018/04/05/tensorflow-ru-men-zhi-mnist-shou-xie-ti-shu-zi-shi-bie-wen-ti/"},{"title":"The Pixel Matrix Representation Of Image","text":"在计算机视觉中，图像是以像素矩阵（Image Pixel Matrix）的形式进行表示和处理的。 计算机视觉我们知道，图像（图片）是 三维现实场景的二维表示。 一切看似复杂的计算机视觉项目，其基础都会回归到单张（灰度/彩色/黑白）图像上。 那么，计算机是如何认识以及处理图像数据的？！！ 像素网格如果你在某个观景处拍张照片，就可以得到它的二维图像，这是计算机 “看” 图的第一步。 这张图像包含的信息有：景物的颜色、形状、表观大小（随摄影距离的远近，物体表现得更大还是更小），以及随照明条件的不同而产生的不同阴影等。（为了避免彩色带来的复杂性，这里将通过其灰度图像进行说明） 此时，如果你一直放大图片中的某一小部分，最终会发现 &gt;&gt;&gt;&gt; 原来，计算机中图像是由一个个小块（这就是像素）组成的二维网格（像素网格）： 事实上，像素网格中的每个像素都有一个对应的数值（像素值），取值范围是 0~255（其中，0 表示最暗黑色；255 表示最亮白色）。 这样，就可以通过定位像素网格的横纵坐标来获取某一特定位置的像素值： 哎~~~~ 像素网格这不就和矩阵（Matrix）高度吻合了么？，像素网格中的每一个像素对应矩阵的元素！！！ 从像素网格到像素矩阵（Pixel Matrix）： 像素矩阵可以很容易想到 &gt;&gt;&gt;&gt; 图像中的尺寸，有着宽度（width）和高度（height），而矩阵有着对应的行（row）和列（column）定义。矩阵中的每一个元素对应图像中的像素。 这样，我们就完成了：图像 &gt;&gt;&gt;&gt; 像素网格 &gt;&gt;&gt;&gt; 像素矩阵 的 “映射” 分析。 实际上，图像在计算机中的处理，就是 将对图像的操作转换成对图像像素矩阵的操作（计算机中矩阵的操作是非常常见且成熟的）。事实上所有的图像处理工具都是这么做的。 这里，将使用 Python 图像处理库 OpenCV 提供的方法来进行简单的图像读取和处理演示。 [1] &gt;&gt;&gt; 图像读取和查看 123456789101112import cv2# 读取图像，并设置为灰度图（0）mountain = cv2.imread('mountain.png', 0)# 查看图像读取后像素矩阵的数据类型：print (&quot;type:&quot;, type(mountain))# type: &lt;class 'numpy.ndarray'&gt;# 查看图像的尺寸（像素矩阵的形状）：print (&quot;shape:&quot;, mountain.shape)# shape: (480, 640) 可以看到，图像读取后，被存储到 NumPy 中的 ndarray 数组中。其中，图像的像素矩阵行（row）为 480 px，列（column）为 640 px；分别对应原始图像中的高度（width）和宽度（height）。 [2] &gt;&gt;&gt; 获取特定位置的像素值 12print(mountain[100, 100])# 236 可在，在像素矩阵中（100, 100）位置处的像素值为：236。 [3] &gt;&gt;&gt; 图像裁剪操作 对图像像素矩阵的操作就是对原始图像的操作。例如选取像素矩阵中某个区域的值，也就是所谓的 Crop（图像裁剪）操作： 1print (mountain[9:12, 9:12]) 输出以下子矩阵： 123[[244 244 244] [244 236 244] [244 244 236]] 我们来重新截取，并且显示一下截取到的图像： 123456789# 取大一些的区域，并显示出来。crop_image = mountain[200:400, 200:600]cv2.imshow(&quot;crop&quot;, crop_image)# 存储裁剪后的图像，并查看其像素矩阵：cv2.imwrite(&quot;crop_image.png&quot;, crop_image)print(crop_image.shape)print(crop_image)cv2.waitKey() 裁剪区域的像素矩阵如下： 1234567[[132 236 228 ... 116 84 28] [228 204 220 ... 116 92 76] [172 132 116 ... 92 116 76] ... [172 140 92 ... 4 28 28] [180 228 180 ... 4 4 4] [132 148 84 ... 28 4 28]] 裁剪到的子图像如下： 最后再重新读取进来查看一下裁剪到的子图像所对应的矩阵： 123mountain_crop = cv2.imread('crop_image.png', 0)print ('Shape:', mountain_crop.shape)print ('Image Pix Matrix:','\\n', mountain_crop) 输出如下（结果和上述操作完全一致）： 123456789Shape: (200, 400)Pix Matrix: [[132 236 228 ... 116 84 28] [228 204 220 ... 116 92 76] [172 132 116 ... 92 116 76] ... [172 140 92 ... 4 28 28] [180 228 180 ... 4 4 4] [132 148 84 ... 28 4 28]] RGB 色彩通道上面为了避免图像彩色带来的复杂性，仅通过灰度图像引出像素矩阵（Pixel Matrix）的概念，这里我们重新来看彩色图像的像素矩阵。 毋庸置疑，彩色图像比灰度图像拥有更多的信息，如图： 通过 Python 图像处理库 OpenCV 查看其像素矩阵信息： 12345678910import cv2drawing = cv2.imread('color_image.png')print (&quot;type:&quot;, type(drawing))# type: &lt;class 'numpy.ndarray'&gt;print (&quot;shape:&quot;, drawing.shape)# shape: (309, 600, 3)print (&quot;Pixel Value: &quot;, drawing[100, 100])# Pixel Value: [58 19 55] 可以看出，彩色图像读取后仍然是 Ndarray 数组（但变为了 3 维）。不同的是，彩色图像像素矩阵中某个像素点的值成为一个包含 3 个数值的数组，如何理解？！！ 三维堆叠像素矩阵从上可以看出，计算机中，灰度图像是只有长和宽的二维像素矩阵，而彩色图像是三维堆叠像素矩阵。 事实上，彩色图像会被解析为具有宽（width）、高（height）和色彩通道（channel）的三维堆叠像素矩阵。从数组角度理解，axis=0 轴对应图像的色彩通道，axis=1 轴对应图像的高，axis=2 轴对应图像的宽。0 轴上的每一个元素都表征一个特定色彩通道（R/G/B）的像素矩阵。 引入色彩通道，是由于大多数彩色图像可以仅通过三种颜色（三原色 &gt;&gt;&gt;&gt; 红：Red，绿：Green，蓝：Blue）组合来表示，就是我们常说的 RGB。 故，彩色图像的像素矩阵，可以看作 &gt;&gt;&gt;&gt; 三个表征不同色彩（R/G/B）的二维色彩图层堆叠而成！！！因此，获取图像中某像素位置处的像素值取到是包含 3 个值的数组，分别代表该像素点处的 R、G、B 值。 或者，你可以还可以理解为 &gt;&gt;&gt;&gt; 彩色图像的像素矩阵中的，任一像素点都可以分解为 R、G、B 三个基色分量！！！ 二维 RGB 色彩图层深入来看一下 RGB 各个色彩图层究竟是什么样子的？！！ 需要注意的是，Python OpenCV 读取彩色图像对应的像素矩阵中顺序是 BGR。下面我们抽离出各通道矩阵来查看其图像： 12345678910111213141516171819import matplotlib.pyplot as plt%matplotlib inlineimport cv2original = cv2.imread('color_image.png') # BGRoriginal = cv2.cvtColor(original, cv2.COLOR_BGR2RGB) # BGR To RGB# 抽离各色彩通道（R/G/B）的像素矩阵：pixMatrix_all = [original, original[:, :, 0], original[:, :, 1], original[:, :, 2]]channels = [&quot;RGB&quot;, &quot;red&quot;, &quot;green&quot;, &quot;blue&quot;]for i in range(4): plt.subplot(2, 2, i + 1) plt.imshow(pixMatrix_all[i], cmap=plt.cm.gray) plt.title(channels[i])plt.show()# for item in pixMatrix_all:# print(item.shape) 可视化输出如下： 可以看出，抽离出的各色彩通道像素矩阵的灰度图，均为原始图像的完整图像，但细节处存在一定的差异。 为了更贴近彩色图像的像素矩阵表示，你可以将抽离出的各色彩通道像素矩阵转化为三通道彩色图： 1234567891011121314151617181920212223242526import matplotlib.pyplot as plt%matplotlib inlineimport numpy as npimport cv2original = cv2.imread('color_image.png') # BGRoriginal = cv2.cvtColor(original, cv2.COLOR_BGR2RGB) # BGR To RGB# 各通道的图像是一张灰度图，这里我们将其转化为三通道彩色图:red = np.zeros_like(original)red[..., 0] = original[..., 0]green = np.zeros_like(original)green[..., 1] = original[..., 1]blue = np.zeros_like(original)blue[..., 2] = original[..., 2]pixMatrix_all = [original, red, green, blue]channels = [&quot;RGB&quot;, &quot;red&quot;, &quot;green&quot;, &quot;blue&quot;]for i in range(4): plt.subplot(2, 2, i + 1) plt.imshow(pixMatrix_all[i]) plt.title(channels[i])plt.show()#for index in pixMatrix_all:# print(index.shape) 可视化输出如下： 可以看出，每一个 RGB 通道都是一个像素矩阵。这 3 个 RGB 通道堆叠在一起形成了彩色图像~~~ 灰度、灰度级与位深度最近刚开始学数字图像处理，以为灰度只是表示黑白/深浅色图像。事实上，灰度（灰度值）只是表征单色的亮暗程度！！！灰度（灰度值）越大表示当前单色越亮。 例如，在黑白显示器中单指像素点显示的亮暗差别；而在彩色显示器中也表征像素点在不同色彩通道的亮暗程度，但不同亮暗程度 R/G/B 色彩分量的组合又表现为颜色的不同。灰度值越多，表现颜色越多，图像层次越清楚逼真。 而，灰度级 &gt;&gt;&gt;&gt; 取决于图像中每个像素点对应的存储单元位数（bit），限制了灰度（灰度值）的取值范围。 例如，某灰度图像中每个像素使用 8 位二进制存储（8 bit），其灰度级为 2^8 = 256，灰度值范围（亮暗范围）为 (0~255)，也对应当前单色的 256 种亮暗变化色。 位深度 &gt;&gt;&gt;&gt; 即像素点存储单元位数（bit）。这就是我们常说的 8 位图、16 位图以及 32 位图等。 位深度和灰度级满足如下关系（其中，K 为位深度，L 为灰度级）： $$ L = 2^{k} $$ 通常，图像像素矩阵中的灰度值位于图像可正常显示的整数范围 [0, L-1]。有时，出于算法开发以及计算的目的，你还会遇到对图像进行归一化的操作，它是将图像像素矩阵中的灰度值压缩到 [0, 1]。 | ================================================== Split Line =============================================== | 👇👇👇 常见位深度彩色图像 👇👇👇 各个色彩通道（R/G/B）上的灰度值范围由其所占用位数决定，对应各单色的亮暗变化色数量： [1] &gt;&gt;&gt; 8 位图像 存储一个像素需要内存：1 Byte R:G:B = 2:3:3 可显示颜色：$$ 2^{8} = 2^{2}(B) * 2^{3}(G) * 2^{3}(R) $$ 灰度级：255(2^8) [2] &gt;&gt;&gt; 16 位图像 存储一个像素需要内存：2 Byte R:G:B = 5:6:5 可显示颜色：$$ 2^{16} = 2^{5}(B) * 2^{6}(G) * 2^{5}(R) $$ 灰度级：65533(2^16) [3] &gt;&gt;&gt; 24 位图像 存储一个像素需要内存：3 Byte R:G:B = 8:8:8 可显示颜色：$$ 2^{24} = 2^{8}(B) * 2^{8}(G) * 2^{8}(R) $$ 灰度级：2^24 [4] &gt;&gt;&gt; 32 位图像 存储一个像素需要内存：4 Byte 32 位图像：Alpha 透明度通道 + 24 位 | ================================================== Split Line =============================================== | 由上就可以计算，图像文件未经压缩的字节数 = 图像分辨率 * (位深度/8)。 例如，一幅分辨率为（640*480），位深度为 24 bit 的图像，其图像未经压缩的数据容量为：640 * 480 * (24 /8) = 900KB。 为什么要强调图像未经压缩？！！ 这是由于，一张图片可以被保存为很多种不同的格式，例如：bmp/png/jpeg/gif，不同格式文件的压缩品质不同，还有的文件要记录操作信息（图层、通道等），所以上述只是基本的原理算法。 灰度/彩色/黑白图像通过上面的说明，相信你对灰度图像、彩色图像的差异有了一定的认知。这里重新阐述一下： 彩色图像彩色图像不同多说，其像素矩阵是由三个表征不同色彩（R/G/B）的二维色彩图层堆叠而成（三通道），也就说任一像素点都可以分解为 R、G、B 三个基色分量。 每个基色分量上的灰度值，直接决定了其基色的明暗强度！！！ | ================================================== Split Line =============================================== | 灰度图像灰度图像，通常显示为从最暗黑色（0）到最亮的白色（255）的灰度（如下图）。 其像素矩阵就是一个单色的灰度值矩阵（单通道），灰度值表征单个像素点的亮度。 | ================================================== Split Line =============================================== | 黑白图像黑白图像，也叫二值图像，是一种特殊的灰度图像。 与灰度图像不同的是，黑白图像中每个像素的灰度值仅能取 0 或者 255，分别代表纯黑和纯白。 需要注意的是，单通道图像一定没有彩色；没有彩色的图像不一定是单通道的灰度/黑白图像，比如所有像素分量均为 0 的纯黑彩色图像。 图像灰度化/二值化处理大多数的计算机视觉场景下，灰度/黑白图像已经够用了。 故，一般会对原始图像进行灰度化/二值化处理，生成其灰度/黑白图片，减小了参与运算的图像像素矩阵的规模，可以提高算法的计算性能。 [1] &gt;&gt;&gt; 灰度化处理 常用灰度化处理的方法： 浮点算法：Gray = R*0.3 + G*0.59 + B*0.11； 整数方法：Gray = (R*30 + G*59 + B*11) / 100； 移位方法：Gray = (R*28 + G*151 + B*77) &gt;&gt; 8； 平均值法：Gray =（R + G + B）/ 3； 仅取绿色：Gray = G，图像中绿色通道的信息最全面。 | ================================================== Split Line =============================================== | [2] &gt;&gt;&gt; 二值化处理 二值化就是让图像的像素点矩阵中的每个像素点的灰度值为 0（黑色）或者 255（白色），也就是让整个图像呈现只有黑和白的效果。 那么一个像素点在灰度化之后的灰度值怎么转化为 0 或者 255 呢？？？比如灰度值为 100，那么在二值化后到底是 0 还是 255 ？！！ ↓↓↓↓↓↓ 需要借助阀值来实现 ↓↓↓↓↓↓ 1、取阀值为 127（相当于 0~255 的中数，（0+255）/2=127），让灰度值小于等于 127 的变为 0，灰度值大于 127 的变为 255。好处 &gt;&gt;&gt;&gt; 计算量小速度快；缺点 &gt;&gt;&gt;&gt; 因为这个阀值在不同的图片中均为 127，但不同图片的颜色分布差别很大，白菜萝卜一刀切的效果肯定是不好的。 2、像素矩阵中像素点的灰度值的平均值 avg 作为阈值，让灰度值小于等于 avg 的像素点就为 0，灰度值大于 avg 的变为 255。效果要由于方法一。 3、直方图方法（双峰法）来寻找二值化阀值。直方图方法认为图像由前景和背景组成，在灰度直方图上，前景和背景都形成高峰，在双峰之间的最低谷处就是阀值所在。取到阀值之后再一一比较就可以了。 彩色 Or 灰度/黑白？？？上一小节说到，大多数的计算机视觉场景下，灰度/黑白图像已经够用了。为什么还需要彩色图像？！！ 尽管彩色图像带来了不必要的复杂性且占用了更多的内存空间，但在某些任务中，图像色彩信息会非常有用！！！例如，识别交通道路线中的黄白线时，色彩就显得尤为重要了。 那么，到底什么时候需要保留色彩信息呢？？？ 原则 &gt;&gt;&gt;&gt; 在计算机视觉应用中，如果对人眼来说，彩色图像识别起来更轻松，那么彩色图像对算法来说也更轻松些。 一言以蔽之，如果色彩的存在对最终的结果非常有帮助，那就用吧！！！ 深入解析 RGB 图像灰度与通道彩色图像/RGB 图像中，图像是一个三维矩阵，如：(244, 780, 3)，其中 244 表示行数（高），780 表示列数（宽），3 代表三个基色分量（R/G/B）。如下： 每一层矩阵（244, 780, 0/1/2），分别对应 R/G/B 的灰度值像素矩阵。仅仅表示对应单色光灰度值，不是彩色的图像。如下： 1234567891011121314151617181920import matplotlib.pyplot as plt%matplotlib inlineimport numpy as npimport cv2original = cv2.imread('red_vs_white.jpg') # BGRoriginal = cv2.cvtColor(original, cv2.COLOR_BGR2RGB) # BGR To RGB# 抽离各色彩通道（R/G/B）的像素矩阵：original_all = [original, original[:, :, 0], original[:, :, 1], original[:, :, 2]]channels = [&quot;RGB&quot;, &quot;red&quot;, &quot;green&quot;, &quot;blue&quot;]for i in range(4): plt.subplot(2, 2, i + 1) plt.imshow(original_all[i], cmap=plt.cm.gray) plt.title(channels[i])plt.show()# for item in original_all: # print(item.shape) 可视化结果如下： 色彩通道类似颜料（基色），想要什么颜色，对应的通道里的灰度值就大一点就行了。如上图，随便在红色区域上取一个样点 (200, 400)，其灰度值分别是（R:94, G:18,B:18）。 12print(original[200, 400])# [94 18 18] 所以在显示的时候，红色通道里灰度值大，绿色通道和蓝色通道里的灰度值小，显示出来的就是红色。 如果我们交换一下分量放置的顺序，把 G 分量放进红色通道里，把 R 分量放进绿色通道里，B 分量放进蓝色通道里，会怎么样呢？？？ 123456new_img = np.zeros_like(original)new_img[..., 0] = original[..., 1]new_img[..., 1] = original[..., 0]new_img[..., 2] = original[..., 2]plt.imshow(new_img)plt.show() 此时绿通道中的灰度值最大，红色通道和蓝色通道中的灰度值都较低，显示为绿色。 同理，如果把 B 分量放进红色通道里，把 R 分量放进蓝色通道里，G 分量放进绿色通道里，会怎么样呢？？？ 123456new_img = np.zeros_like(original)new_img[..., 0] = original[..., 2]new_img[..., 1] = original[..., 1]new_img[..., 2] = original[..., 0]plt.imshow(new_img)plt.show() 事实上，我们熟知的 RGB 色彩空间，就是把一种颜色，用 RGB 三个分量表达出来。此外还有 CMYK（四个分量）、Lab（三个）、HSV（三个）等等。不同色彩空间之间的关系，类似于空间直角坐标系（x, y, z），球坐标系（r, φ, θ）或柱坐标（r, φ, z）之间的关系。 https://blog.csdn.net/Dontla/article/details/106897794https://blog.csdn.net/qq_41498261/article/details/104898045https://blog.csdn.net/gaoxueyi551/article/details/112684581https://blog.csdn.net/Strive_0902/article/details/78023080https://zhuanlan.zhihu.com/p/427723550https://blog.csdn.net/weixin_44489823/article/details/105996194","link":"/2018/02/01/the-pixel-matrix-representation-of-image/"},{"title":"MNIST Introduction","text":"编程入门有 Hello World，机器学习入门有 MNIST。本篇我们来看手写体数字图像数据集 MNIST 的获取和使用。 MNIST 是一个入门级的计算机视觉数据集，它包含各种手写体数字图片： 也包含每一张图片对应的标签信息，告诉我们这个是数字几。比如，上面这四张图片的标签分别是 5，0，4，1。 MNIST 下载使用说明首先，来看如何下载 MNIST 数据集到本地？？？这里，我们提供两种下载方法： 手动下载 脚本自动化安装 手动下载MNIST 数据集的官网：【 &gt;&gt;&gt;&gt; http://yann.lecun.com/exdb/mnist/ &lt;&lt;&lt;&lt; 】。 找到相应的下载链接即可下载，数据集如下： 数据包下载链接 说明 train-images-idx3-ubyte.gz 训练集图片 ：55000 张 训练图片, 5000 张 验证图片 train-labels-idx1-ubyte.gz 训练集图片对应的数字标签 t10k-images-idx3-ubyte.gz 测试集图片 ：10000 张 图片 t10k-labels-idx1-ubyte.gz 测试集图片对应的数字标签 脚本自动化安装Tensorflow 团队对 MNIST 数据集进行了封装，为我们提供了一份用于 MNIST 数据集自动下载、安装，以及使用接口的 Python 源代码。 源代码参见：【 &gt;&gt;&gt;&gt; input_data.py &lt;&lt;&lt;&lt;】，脚本内容如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187# Copyright 2015 Google Inc. All Rights Reserved.## Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);# you may not use this file except in compliance with the License.# You may obtain a copy of the License at## http://www.apache.org/licenses/LICENSE-2.0## Unless required by applicable law or agreed to in writing, software# distributed under the License is distributed on an &quot;AS IS&quot; BASIS,# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.# See the License for the specific language governing permissions and# limitations under the License.# ==============================================================================&quot;&quot;&quot;Functions for downloading and reading MNIST data.&quot;&quot;&quot;from __future__ import absolute_importfrom __future__ import divisionfrom __future__ import print_functionimport gzipimport osimport numpyfrom six.moves import urllibfrom six.moves import xrange # pylint: disable=redefined-builtinSOURCE_URL = 'http://yann.lecun.com/exdb/mnist/'def maybe_download(filename, work_directory): &quot;&quot;&quot;Download the data from Yann's website, unless it's already here.&quot;&quot;&quot; if not os.path.exists(work_directory): os.mkdir(work_directory) filepath = os.path.join(work_directory, filename) if not os.path.exists(filepath): filepath, _ = urllib.request.urlretrieve(SOURCE_URL + filename, filepath) statinfo = os.stat(filepath) print('Successfully downloaded', filename, statinfo.st_size, 'bytes.') return filepathdef _read32(bytestream): dt = numpy.dtype(numpy.uint32).newbyteorder('&gt;') return numpy.frombuffer(bytestream.read(4), dtype=dt)[0] # 增加 [0]def extract_images(filename): &quot;&quot;&quot;Extract the images into a 4D uint8 numpy array [index, y, x, depth].&quot;&quot;&quot; print('Extracting', filename) with gzip.open(filename) as bytestream: magic = _read32(bytestream) if magic != 2051: raise ValueError( 'Invalid magic number %d in MNIST image file: %s' % (magic, filename)) num_images = _read32(bytestream) rows = _read32(bytestream) cols = _read32(bytestream) buf = bytestream.read(rows * cols * num_images) data = numpy.frombuffer(buf, dtype=numpy.uint8) data = data.reshape(num_images, rows, cols, 1) return datadef dense_to_one_hot(labels_dense, num_classes=10): &quot;&quot;&quot;Convert class labels from scalars to one-hot vectors.&quot;&quot;&quot; num_labels = labels_dense.shape[0] index_offset = numpy.arange(num_labels) * num_classes labels_one_hot = numpy.zeros((num_labels, num_classes)) labels_one_hot.flat[index_offset + labels_dense.ravel()] = 1 return labels_one_hotdef extract_labels(filename, one_hot=False): &quot;&quot;&quot;Extract the labels into a 1D uint8 numpy array [index].&quot;&quot;&quot; print('Extracting', filename) with gzip.open(filename) as bytestream: magic = _read32(bytestream) if magic != 2049: raise ValueError( 'Invalid magic number %d in MNIST label file: %s' % (magic, filename)) num_items = _read32(bytestream) buf = bytestream.read(num_items) labels = numpy.frombuffer(buf, dtype=numpy.uint8) if one_hot: return dense_to_one_hot(labels) return labelsclass DataSet(object): def __init__(self, images, labels, fake_data=False): if fake_data: self._num_examples = 10000 else: assert images.shape[0] == labels.shape[0], ( &quot;images.shape: %s labels.shape: %s&quot; % (images.shape, labels.shape)) self._num_examples = images.shape[0] # Convert shape from [num examples, rows, columns, depth] # to [num examples, rows*columns] (assuming depth == 1) assert images.shape[3] == 1 images = images.reshape(images.shape[0], images.shape[1] * images.shape[2]) # Convert from [0, 255] -&gt; [0.0, 1.0]. images = images.astype(numpy.float32) images = numpy.multiply(images, 1.0 / 255.0) self._images = images self._labels = labels self._epochs_completed = 0 self._index_in_epoch = 0 @property def images(self): return self._images @property def labels(self): return self._labels @property def num_examples(self): return self._num_examples @property def epochs_completed(self): return self._epochs_completed def next_batch(self, batch_size, fake_data=False): &quot;&quot;&quot;Return the next `batch_size` examples from this data set.&quot;&quot;&quot; if fake_data: fake_image = [1.0 for _ in xrange(784)] fake_label = 0 return [fake_image for _ in xrange(batch_size)], [ fake_label for _ in xrange(batch_size)] start = self._index_in_epoch self._index_in_epoch += batch_size if self._index_in_epoch &gt; self._num_examples: # Finished epoch self._epochs_completed += 1 # Shuffle the data perm = numpy.arange(self._num_examples) numpy.random.shuffle(perm) self._images = self._images[perm] self._labels = self._labels[perm] # Start next epoch start = 0 self._index_in_epoch = batch_size assert batch_size &lt;= self._num_examples end = self._index_in_epoch return self._images[start:end], self._labels[start:end]def read_data_sets(train_dir, fake_data=False, one_hot=False): class DataSets(object): pass data_sets = DataSets() if fake_data: data_sets.train = DataSet([], [], fake_data=True) data_sets.validation = DataSet([], [], fake_data=True) data_sets.test = DataSet([], [], fake_data=True) return data_sets TRAIN_IMAGES = 'train-images-idx3-ubyte.gz' TRAIN_LABELS = 'train-labels-idx1-ubyte.gz' TEST_IMAGES = 't10k-images-idx3-ubyte.gz' TEST_LABELS = 't10k-labels-idx1-ubyte.gz' VALIDATION_SIZE = 5000 local_file = maybe_download(TRAIN_IMAGES, train_dir) train_images = extract_images(local_file) local_file = maybe_download(TRAIN_LABELS, train_dir) train_labels = extract_labels(local_file, one_hot=one_hot) local_file = maybe_download(TEST_IMAGES, train_dir) test_images = extract_images(local_file) local_file = maybe_download(TEST_LABELS, train_dir) test_labels = extract_labels(local_file, one_hot=one_hot) validation_images = train_images[:VALIDATION_SIZE] validation_labels = train_labels[:VALIDATION_SIZE] train_images = train_images[VALIDATION_SIZE:] train_labels = train_labels[VALIDATION_SIZE:] data_sets.train = DataSet(train_images, train_labels) data_sets.validation = DataSet(validation_images, validation_labels) data_sets.test = DataSet(test_images, test_labels) return data_sets 使用时，直接通过下面的代码即可引入 TF 封装好的 MNIST 数据集： 12345678910111213141516171819# 导入用于下载和读取 MNIST 数据集的模块:from tensorflow.examples.tutorials.mnist import input_data# 指定 MNIST 数据集的下载和读取的路径：MNIST_data_Path = &quot;./MNIST_data/&quot;# 获取 MNIST 数据集对象mnist = input_data.read_data_sets(MNIST_data_Path, one_hot=True)# print mnist.train dataSet size :print(&quot;Training data size : &quot;, mnist.train.num_examples)# print mnist.validation dataSet size :print(&quot;Validating data size : &quot;, mnist.validation.num_examples)# print mnist.test dataSet size :print(&quot;Testing data size : &quot;, mnist.test.num_examples)# print mnist.train.images[0] / mnist.train.labels[0] Formatprint(&quot;Example training data（image）: &quot;, &quot;\\n&quot;, mnist.train.images[0])print(&quot;Example training data lable : &quot;, mnist.train.labels[0]) 可能由于网络原因导致 MNIST 数据集下载失败 &lt;&lt;&lt;&lt;【Network is unreachable】，你可以参考上一小节的手动下载，然后将下载好的数据集放置于相应路径中即可。 下载成功后，样例程序输出结果如下： 1234567891011121314151617181920212223242526272829303132Successfully downloaded train-images-idx3-ubyte.gz 9912422 bytes.Extracting ./MNIST_data/train-images-idx3-ubyte.gzSuccessfully downloaded train-labels-idx1-ubyte.gz 28881 bytes.Extracting ./MNIST_data/train-labels-idx1-ubyte.gzSuccessfully downloaded t10k-images-idx3-ubyte.gz 1648877 bytes.Extracting ./MNIST_data/t10k-images-idx3-ubyte.gzSuccessfully downloaded t10k-labels-idx1-ubyte.gz 4542 bytes.Extracting ./MNIST_data/t10k-labels-idx1-ubyte.gzTraining data size : 55000Validating data size : 5000Testing data size : 10000Example training data : [0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 1. ................. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.34901962 0.9843138 0.9450981 0.3372549 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0.01960784 0.8078432 0.96470594 0.6156863 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 1. ...................... 0. 0. 0. 0. 0.01568628 0.45882356 0.27058825 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. 0. ]Example training data lable : [0. 0. 0. 0. 0. 0. 0. 1. 0. 0.] 👇👇👇 MNIST 数据集划分 👇👇👇 可以看出，input_data.read_data_sets 函数生成的数据集对象会自动将 MNIST 数据集划分为 train &amp;&amp; validation &amp;&amp; test 三个数据集。 其中，train 数据集中包含 55000 张训练图片，validation 数据集中包含 5000 张验证图片，它们共同构成了 MNIST 自身提供的训练数据集。test 数据集中包含了 10000 张测试图片，这些图片都来自于 MNIST 提供的测试数据集。 | ================================================== Split Line =============================================== | 👇👇👇 图像输入和标签处理 👇👇👇 FCNN 神经网络结构的输入是一个特征向量，所以这里需要将一张二维图像的像素矩阵扁平化处理为一维数组，方便 TF 将图片的像素矩阵提供给神经网络的输入层。 故，TF 封装模块处理后的每张手写数字图片都是一个长度为 784 的一维数组，这个数组中的元素对应了图片像素矩阵中的任意像素值（28 * 28 = 784）。为了方便计算，像素矩阵中像素的灰度值被归一化到 [0, 1]，它代表了颜色的深浅。其中 0 表示白色背景（background），1 表示黑色前景（foreground）。 并且，对手写数字图片所对应的标签，进行了 one-hot 编码处理，方便神经网络的分类任务。one-hot 标签数组是一个 10 维（长度为 10）的向量，每一个维度都对应了 0~9 中数字中的一个。形如：[0,1,0,0,0,0,0,0,0,0] &lt;&lt;&lt;&lt; 数字 1。 | ================================================== Split Line =============================================== | 👇👇👇 Mini Batch 支持 👇👇👇 为了方便使用小批量样本梯度下降（MGD），input_data.read_data_sets 函数生成的数据集对象还提供了 mnist.train.next_batch 方法，可以快速从所有的训练数据中读取一小部分数据作为一个训练 batch。 以下代码显示如何使用这个功能： 1234567# 取 BATCH SIZE 为 100 大小的训练数据：BATCH_SIZE = 100xs, ys = mnist.train.next_batch(BATCH_SIZE)print ('X Shape: ', xs.shape) # X Shape: (100, 784)print ('Y Shape: ', ys.shape) # Y Shape: (100, 10) 该方法返回一个元组，其中包含了两个数组元素 &lt;&lt;&lt;&lt; 图片像素数组和标签数组，该元组可被用于当前的 TensorFlow 运算会话中。 你还可以直接将 input_data.py 脚本文件添加到你的项目中，解析或封装已经下载好的 MNIST 数据集： 12import input_data mnist = input_data.read_data_sets(&quot;MNIST_data/&quot;, one_hot=True) 需要注意脚本文件添加的目录，让其可以正常被 import 到。 你还可以基于上面的脚本文件进行修改，实现定制化的封装需要。 数据集可视化说明MNIST（Mixed National Institute of Standards and Technology Database）是一个非常有名的手写体数字图像识别数据集（NIST 数据集的一个子集），也是一个入门级的计算机视觉数据集（很多资料会将其作为深度学习入门样例）。就好比编程入门有 Hello World，机器学习入门有 MNIST。 MNIST 数据集中包含各种手写的数字图片： MNIST 官方数据集可以分成两部分： 60000 行的训练数据集（mnist.train） 10000 行的测试数据集（mnist.test） 其中，每一行 MNIST 数据单元（数据对象）由两部分组成：一张包含手写数字的图片，和手写数字图片所对应的标签。 MNIST 数据单元手写数字图像 &gt;&gt;&gt;&gt; 每一张图片都代表了一个手写的 0~9 中数字的灰度图（单通道图像），图片大小为 28 px × 28px。 我们可以用一个像素矩阵来表示手写数字 1 的图片： 关于图像的像素矩阵表示方法，可参考文档【 &gt;&gt;&gt;&gt; The Pixel Matrix Representation Of Image &lt;&lt;&lt;&lt;】。 图像标签 &gt;&gt;&gt;&gt; 每一个手写体数字图片，都对应 0~9 中的任意一个数字。 虽然 MNIST 数据集中只提供了训练数据（训练集）和测试数据（测试集），但是为了验证模型训练时的效果，使用时一般会从训练数据集中划分出一部分数据作为验证数据（集验证集）。 训练集可视化这里，将通过可视化训练集来看看 TF 封装之后 MNIST 数据集究竟是什么样子的？！！验证集和测试集同训练集。 mnist.train.images 是一个形状为 [60000, 784] 的数组 &gt;&gt;&gt;&gt; 第一个维度数字用来索引图片，第二个维度数字用来索引每张图片中的像素点数组。像素点的灰度值（强度值）被归一化到 0 和 1 之间。 mnist.train.labels 是一个形状为 [60000, 10] 的数组，第一个维度数字用来索引图片，第二个维度数字用来索引每张图片中的分类标签（one-hot vectors）。 在此张量里的每一个元素，都表示某张图片对应分类的 one-hot vectors 标签向量。比如，标签 0 将表示成([1,0,0,0,0,0,0,0,0,0,0])。 TF 引用样例样例代码如下： 12345678910111213141516171819202122232425262728293031323334353637''' Code For ：MNIST 手写数字图像数据集使用'''import tensorflow as tf# 从模块 tensorflow.examples.tutorials.mnist 中导入用于下载和解析 MNIST 数据集的 python 源文件：见 input_data.pyfrom tensorflow.examples.tutorials.mnist import input_datadef main(arg=None): ###################### Functions for downloading and reading MNIST data. ###################### ''' ## 初始化：下载或读取用于训练、测试以及验证的 MNIST 手写数字图片（28px * 28px）数据集 ## ''' # 指定 MNIST 数据集的下载和读取的路径： MNIST_data_Path = &quot;./MNIST_data/&quot; mnist = input_data.read_data_sets(MNIST_data_Path, one_hot=True) # print mnist.train dataSet size : print(&quot;Training data size : &quot;, mnist.train.num_examples) # print mnist.validation dataSet size : print(&quot;Validating data size : &quot;, mnist.validation.num_examples) # print mnist.test dataSet size : print(&quot;Testing data size : &quot;, mnist.test.num_examples) # print mnist.train.images[0] / mnist.train.labels[0] Format # print(&quot;Example training data : &quot;, &quot;\\n&quot;, mnist.train.images[0]) # print(&quot;Example training data lable : &quot;, mnist.train.labels[0]) ### Next：可以使用了 ###if __name__ == '__main__': # TensorFlow 提供的一个主程序入口，tf.app.run 会调用上面定义的 main 函数： tf.app.run()","link":"/2018/03/01/mnist-introduction/"}],"tags":[{"name":"Eclipse","slug":"Eclipse","link":"/tags/Eclipse/"},{"name":"IDE","slug":"IDE","link":"/tags/IDE/"},{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"Github","slug":"Github","link":"/tags/Github/"},{"name":"Front-End Devp","slug":"Front-End-Devp","link":"/tags/Front-End-Devp/"},{"name":"Blog","slug":"Blog","link":"/tags/Blog/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"Node.js","slug":"Node-js","link":"/tags/Node-js/"},{"name":"Java Modifier","slug":"Java-Modifier","link":"/tags/Java-Modifier/"},{"name":"DataType","slug":"DataType","link":"/tags/DataType/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"Pycharm","slug":"Pycharm","link":"/tags/Pycharm/"},{"name":"HelloWorld","slug":"HelloWorld","link":"/tags/HelloWorld/"},{"name":"PyVers-Management","slug":"PyVers-Management","link":"/tags/PyVers-Management/"},{"name":"virtualenv","slug":"virtualenv","link":"/tags/virtualenv/"},{"name":"conda","slug":"conda","link":"/tags/conda/"},{"name":"Iterable","slug":"Iterable","link":"/tags/Iterable/"},{"name":"Sequence","slug":"Sequence","link":"/tags/Sequence/"},{"name":"Character Encoding","slug":"Character-Encoding","link":"/tags/Character-Encoding/"},{"name":"Variables","slug":"Variables","link":"/tags/Variables/"},{"name":"Programming","slug":"Programming","link":"/tags/Programming/"},{"name":"System Binary","slug":"System-Binary","link":"/tags/System-Binary/"},{"name":"Picture bed","slug":"Picture-bed","link":"/tags/Picture-bed/"},{"name":"Code Annotation","slug":"Code-Annotation","link":"/tags/Code-Annotation/"},{"name":"OOP","slug":"OOP","link":"/tags/OOP/"},{"name":"C++","slug":"C","link":"/tags/C/"},{"name":"Back-End Devp","slug":"Back-End-Devp","link":"/tags/Back-End-Devp/"},{"name":"Operator","slug":"Operator","link":"/tags/Operator/"},{"name":"Anaconda","slug":"Anaconda","link":"/tags/Anaconda/"},{"name":"Jupyter Lab","slug":"Jupyter-Lab","link":"/tags/Jupyter-Lab/"},{"name":"Jupyter Notebook","slug":"Jupyter-Notebook","link":"/tags/Jupyter-Notebook/"},{"name":"Constants Pool","slug":"Constants-Pool","link":"/tags/Constants-Pool/"},{"name":"Flow Control","slug":"Flow-Control","link":"/tags/Flow-Control/"},{"name":"Spider","slug":"Spider","link":"/tags/Spider/"},{"name":"Web Crawler","slug":"Web-Crawler","link":"/tags/Web-Crawler/"},{"name":"Regular Expression","slug":"Regular-Expression","link":"/tags/Regular-Expression/"},{"name":"TensorFlow","slug":"TensorFlow","link":"/tags/TensorFlow/"},{"name":"Linux","slug":"Linux","link":"/tags/Linux/"},{"name":"Operate System","slug":"Operate-System","link":"/tags/Operate-System/"},{"name":"Format Output","slug":"Format-Output","link":"/tags/Format-Output/"},{"name":"Data Analysis","slug":"Data-Analysis","link":"/tags/Data-Analysis/"},{"name":"DataSet","slug":"DataSet","link":"/tags/DataSet/"},{"name":"DeepLearning","slug":"DeepLearning","link":"/tags/DeepLearning/"}],"categories":[{"name":"Java","slug":"Java","link":"/categories/Java/"},{"name":"Git","slug":"Git","link":"/categories/Git/"},{"name":"Web Site","slug":"Web-Site","link":"/categories/Web-Site/"},{"name":"Hexo","slug":"Hexo","link":"/categories/Hexo/"},{"name":"Markdown","slug":"Markdown","link":"/categories/Markdown/"},{"name":"Python","slug":"Python","link":"/categories/Python/"},{"name":"Code Basic","slug":"Code-Basic","link":"/categories/Code-Basic/"},{"name":"VSCode","slug":"VSCode","link":"/categories/VSCode/"},{"name":"Spider","slug":"Spider","link":"/categories/Spider/"},{"name":"DeepLearning","slug":"DeepLearning","link":"/categories/DeepLearning/"},{"name":"OS","slug":"OS","link":"/categories/OS/"},{"name":"Data Analysis","slug":"Data-Analysis","link":"/categories/Data-Analysis/"},{"name":"DataSet","slug":"DataSet","link":"/categories/DataSet/"}]}
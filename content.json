{"pages":[],"posts":[{"title":"Eclipse 2020 Shortcut Key","text":"Eclipse 2020 版本常用快捷键。 注释快捷键1 –&gt; ctrl+shift+/ 使用 /* */（块注释）自动注释掉选择的代码块。 问题：注释后多行语句乱码（合并为一行），取消注释无法恢复。 Solution：Window –&gt; Perference –&gt; Java –&gt; Code Style –&gt; Formatter –&gt; 取名（my_add_annotation）–&gt; Edit –&gt; Comments（左侧）–&gt; 勾掉：Enable block comment formatting –&gt; Apply –&gt; OK –&gt; Apply and Close; 2 –&gt; ctrl+shift+\\ 取消 /* */（块注释）注释。 3 –&gt; ctrl+/ 使用 //（行注释）自动 注释或取消注释 选择的多行代码。 4 –&gt; ctrl+shift+j 快速为文档，类，方法等添加模板注释。 注释模板修改： Window –&gt; Preferences –&gt; Java –&gt; Code Style –&gt; Code Templates –&gt; Comments –&gt; Types –&gt; Edit； ============================================= 文档注释模板格式： 12345678910/** * Project Name: ${project_name} * Class Name: ${type_name} * Created By: ${user} * Created At: ${date} ${time} * E-Mail: ${name:git_config(user.name)} * @Version * * ${tags} */ ============================================= 编辑快捷键1 –&gt; ctrl+d 删除当前光标所在行。 2 –&gt; ctrl+shift+enter 在当前行上插入一行。 3 –&gt; shift+enter 在当前行下插入一行。 4 –&gt; alt+/ 自动补全代码或者提示代码。 问题：Eclipse 编写代码不能自动补全，而需要不停的按 ALT+/ 或者检测到 . 才会进行补全。 Solution：Window –&gt; Perference –&gt; Java –&gt; Editor –&gt; Content Assist –&gt; Auto activation triggers for Java（右侧，只有一个 . 存在） –&gt; 改为：**.abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ** –&gt; Apply –&gt; OK; 这样，就可以通过代码补全，自动生成 main，getter，setter，toString 等方法了。 5 –&gt; ctrl+shift+o 自动引入包和删除无用包。 6 –&gt; ctrl+shift+f 格式化代码。 问题：使用搜狗输入法/微软输入法，会和 “繁/简体切换” 快捷键冲突。 Solution：关闭输入法 “繁/简体切换 ” 快捷键“ 。 7 –&gt; alt+↑/↓ 移动一行或多行。 8 –&gt; ctrl+alt+↑/↓ 复制选择的一行或多行代码块。 9 –&gt; F3 快速查看源码。 窗口快捷键1 –&gt; alt+← 全局 后退历史记录。 2 –&gt; alt+→ 全局 前进历史记录。 3 –&gt; ctrl+o 快速 Outline 视图：查看当前文件中的类、方法名。 4 –&gt; ctrl+PgDn/PgUp 选项卡之间快速切换。 5 –&gt; ctrl+h 全局搜索对话框。 6 –&gt; ctrl+f 当前文件搜索、替换对话框。 Debug 模式快捷键1 –&gt; F11 Debug 模式运行程序。 2 –&gt; F5 单步调试进入函数内部。 3 –&gt; F6 单步调试不进入函数内部。 4 –&gt; F8 一直执行到下一个断点。 5 –&gt; F7 由函数内部返回到调用处。 6 –&gt; alt+shift+x 正常运行应用。","link":"/2017/10/11/eclipse-2020-shortcut-key/"},{"title":"Git 使用指南之 Git 中的黑魔法","text":"git stash，git cherry-pick，git rebase，未完待续 版权说明： 本文思路以及内容主要来自廖雪峰老师的 Git 教程 （强烈推荐膜拜原文），并结合个人使用所作，只作为学习记录使用。如内容有侵权请联系删除，禁止转载！ 更多 Git 相关内容，请关注博主 Git 博文系列： 之一 &gt;&gt;&gt; Git 使用指南之初识 之二 &gt;&gt;&gt; Git 使用指南之时光穿梭机 之三 &gt;&gt;&gt; Git 使用指南之远程仓库 之四 &gt;&gt;&gt; Git 使用指南之分支管理 之五 &gt;&gt;&gt; Git 使用指南之 WorkFlow (工作流) 之六 &gt;&gt;&gt; Git 使用指南之 Git 自定义 之七 &gt;&gt;&gt; Git 使用指南之 HEAD 指针 之八 &gt;&gt;&gt; Git 使用指南之 Git 中的黑魔法","link":"/2017/07/07/git-shi-yong-zhi-nan-zhi-git-zhong-de-hei-mo-fa/"},{"title":"Git 使用指南之 Git 自定义","text":"Git 中支持自定义 忽略文件，使得 Git 自动忽略这些文件，不再被 track。还支持为 Git 中的命令配置简单、易用的 别名，这在频繁使用包含较为复杂参数的命令时极有成效！甚至当你不想使用 Github 或者 Gitee 时，你可以选择自定义 搭建一台 Git 服务器 作为私有仓库使用。 版权说明： 本文思路以及内容主要来自廖雪峰老师的 Git 教程 （强烈推荐膜拜原文），并结合个人使用所作，只作为学习记录使用。如内容有侵权请联系删除，禁止转载！ 更多 Git 相关内容，请关注博主 Git 博文系列： 之一 &gt;&gt;&gt; Git 使用指南之初识 之二 &gt;&gt;&gt; Git 使用指南之时光穿梭机 之三 &gt;&gt;&gt; Git 使用指南之远程仓库 之四 &gt;&gt;&gt; Git 使用指南之分支管理 之五 &gt;&gt;&gt; Git 使用指南之 WorkFlow (工作流) 之六 &gt;&gt;&gt; Git 使用指南之 Git 自定义 之七 &gt;&gt;&gt; Git 使用指南之 HEAD 指针 之八 &gt;&gt;&gt; Git 使用指南之 Git 中的黑魔法 忽略特殊文件场景描述：日常项目中，很多时候你必须把某些文件放到 Git 工作目录中，但又不能提交它们，比如保存了数据库密码的配置文件啦，等等…每次 git status 都会显示 Untracked files ...，有强迫症的看官心里肯定不爽。 解决方法 &gt;&gt;&gt;&gt; Git 考虑到了大家的感受，通过 Git 工作区的根目录下创建一个特殊的 .gitignore 文件，然后把要忽略的文件名填进去，Git 就会自动忽略这些文件。 GitHub Ignore Repo不需要你从头去写 .gitignore 文件，GitHub 已经为我们准备了各种工程项目（Pyhont、Java…）的配置文件，只需要组合一下就可以使用了。所有配置文件可以直接在线浏览： 传送门 —&gt; https://github.com/github/gitignore Ignore Document Policy设置忽略文件，要遵循忽略文件的原则： 忽略操作系统自动生成的文件，比如缩略图等； 忽略编译生成的中间文件、可执行文件等：也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如 Java 编译产生的 .class 文件； 忽略你自己的带有敏感信息的配置文件，比如存放密码、口令的配置文件； 忽略配置文件需要提交。 举个例子 &gt;&gt;&gt;&gt; 假设你在 Windows 下进行 Python 开发，Windows 会自动在有图片的目录下生成隐藏的缩略图文件，如果有自定义目录，目录下就会有 Desktop.ini 文件，因此你需要忽略 Windows 自动生成的垃圾文件： 1234# Windows:Thumbs.dbehthumbs.dbDesktop.ini 然后，继续忽略 Python 编译产生的 .pyc、.pyo、dist 等文件或目录： 1234567# Python:*.py[cod]*.so*.egg*.egg-infodistbuild 加上你自己定义的文件，最终得到一个完整的 .gitignore 文件，内容如下： 12345678910111213141516# Windows:Thumbs.dbehthumbs.dbDesktop.ini# Python:*.py[cod]*.so*.egg*.egg-infodistbuild# My configurations:db.inideploy_key_rsa 最后一步就是把 .gitignore 也提交到 Git，就完成了！！！ 当然，检验 .gitignore 的标准是 git status 命令是不是说 working directory clean。 Git-Ignore More.gitignore 配置文件配置不精确导致某些特殊需要文件被忽略 &gt;&gt;&gt;&gt; 有些时候，你想添加一个文件（App.class）到 Git，但发现添加不了，原因是这个文件被 .gitignore 忽略了： 1234$ git add App.classThe following paths are ignored by one of your .gitignore files:App.classUse -f if you really want to add them. 输出信息提示：如果你确实想添加该文件，可以用 -f 强制添加到 Git： 1$ git add -f App.class 忽略规则配置文件检查（推荐） 如果由于 .gitignore 配置文件配置不精确导致某些特殊需要文件被忽略，你需要找出来到底哪个规则给过滤掉了，这时可以用 git check-ignore 命令检查： 12$ git check-ignore -v App.class.gitignore:3:*.class App.class Git 告诉我们：.gitignore 的第 3 行规则忽略了该文件，于是我们就可以知道应该修订哪个规则。 事实上，很多时候都是由于个人编写的规则排除了部分文件，如下内容： 1234# 排除所有.开头的隐藏文件:.*# 排除所有.class文件:*.class 发现：.* 这个规则把 .gitignore 排除了，并且 App.class 需要被添加到版本库，但也被 *.class 规则排除了。 虽然可以使用 git add -f 强制添加进去，但不要破坏 .gitignore 规则，这个时候可以添加两条 例外规则： 12345678# 排除所有.开头的隐藏文件:.*# 排除所有.class文件:*.class# 不排除 .gitignore 和 App.class:!.gitignore!App.class 例外规则：把指定文件排除在 .gitignore 规则外的写法就是 ! + 文件名，只需把例外文件添加进去即可。 配置别名配置别名是针对 Git 中常用的较长，不容易记忆，或者参数太多太长的命令，为其配置精简别名，以简化使用。 配置配置别名的命令格式如下（注意添加 --global 的影响）： 12345# 为 git status 设置全局命令别名：git st$ git config --global alias.st status# 在当前仓库，为 git status 设置命令别名：git st$ git config alias.st status 大多数开发人员配置的别名（以全局配置为例）： 123$ git config --global alias.co checkout$ git config --global alias.ci commit$ git config --global alias.br branch 一个优秀的 git log 设置方案： 1git config --global alias.lg &quot;log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' --abbrev-commit&quot; 来看看效果： 1234567891011121314151617181920212223242526$ git log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset' --abbrev-commit* 6a9789d - (HEAD -&gt; master, tag: v1.0, origin/master) Tag Test (3 hours ago) &lt;TheNightIsYoung&gt;* fb50835 - Dealing Merge Conflict (5 days ago) &lt;TheNightIsYoung&gt;|\\| * c07648e - (FeatureA) Merge conflic test in FeatureA (5 days ago) &lt;TheNightIsYoung&gt;* | 7d23fef - Merge conflic test in master (5 days ago) &lt;TheNightIsYoung&gt;* | 28157d9 - Merge with no-ff (5 days ago) &lt;TheNightIsYoung&gt;|\\ \\| * | 02636d0 - Func-Add Permission(no-ff) (5 days ago) &lt;TheNightIsYoung&gt;| * | b324182 - Func-Add User(no-ff) (5 days ago) &lt;TheNightIsYoung&gt;|/ /* | 8a39810 - Func-Add Permission (5 days ago) &lt;TheNightIsYoung&gt;* | 3d6d64d - Func-Add User (5 days ago) &lt;TheNightIsYoung&gt;* | 5f264b1 - (tag: v1.2) Merge branch 'featureB' (5 days ago) &lt;TheNightIsYoung&gt;|\\ \\| |/|/|| * 4528426 - (featureB) Add BTest File For featureB (5 days ago) &lt;TheNightIsYoung&gt;* | fc2702b - Add ATest File For (5 days ago) &lt;TheNightIsYoung&gt;|/* 79c3a2c - Add git_rm_test.txt (8 days ago) &lt;TheNightIsYoung&gt;* fe3235b - git tracks changes (8 days ago) &lt;TheNightIsYoung&gt;* d6ddc31 - Git local data management test (8 days ago) &lt;TheNightIsYoung&gt;* 0f5a696 - understand how stage works (8 days ago) &lt;TheNightIsYoung&gt;* ebba382 - Add test code (8 days ago) &lt;TheNightIsYoung&gt;* da1fadc - Add help info (8 days ago) &lt;TheNightIsYoung&gt; 自己动手设置一下，效果显著~~~ 删除有时候，我们想要删除配置好的别名删除怎么办？这时，需要借助配置文件。 我们知道，配置 Git 的时候，加上 --global 是针对当前用户起作用的；如果不加，那只针对当前的仓库起作用。 首先，我们需要知道配置文件放在什么位置？ 1 –&gt; 仓库配置文件 仓库的配置文件都放在 .git/config 文件中： 12345678910111213141516$ cat .git/config [core] repositoryformatversion = 0 filemode = true bare = false logallrefupdates = true ignorecase = true precomposeunicode = true[remote &quot;origin&quot;] url = git@github.com:michaelliao/learngit.git fetch = +refs/heads/*:refs/remotes/origin/*[branch &quot;master&quot;] remote = origin merge = refs/heads/master[alias] last = log -1 别名就在 [alias] 后面，要删除别名，直接把对应的行删掉即可。 2 –&gt; 当前用户的 Git 配置文件 而当前用户的 Git 配置文件放在用户主目录（~）下的一个隐藏文件 .gitconfig 中： 123456789$ cat .gitconfig[alias] co = checkout ci = commit br = branch st = status[user] name = Your Name email = your@email.com 配置别名也可以直接修改这个文件。","link":"/2017/07/05/git-shi-yong-zhi-nan-zhi-git-zi-ding-yi/"},{"title":"Git 使用指南之 HEAD 指针","text":"HEAD 指针说明，未完待续 版权说明： 本文思路以及内容主要来自廖雪峰老师的 Git 教程 （强烈推荐膜拜原文），并结合个人使用所作，只作为学习记录使用。如内容有侵权请联系删除，禁止转载！ 更多 Git 相关内容，请关注博主 Git 博文系列： 之一 &gt;&gt;&gt; Git 使用指南之初识 之二 &gt;&gt;&gt; Git 使用指南之时光穿梭机 之三 &gt;&gt;&gt; Git 使用指南之远程仓库 之四 &gt;&gt;&gt; Git 使用指南之分支管理 之五 &gt;&gt;&gt; Git 使用指南之 WorkFlow (工作流) 之六 &gt;&gt;&gt; Git 使用指南之 Git 自定义 之七 &gt;&gt;&gt; Git 使用指南之 HEAD 指针 之八 &gt;&gt;&gt; Git 使用指南之 Git 中的黑魔法","link":"/2017/07/06/git-shi-yong-zhi-nan-zhi-head-zhi-zhen/"},{"title":"Hello Hexo Matery World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment Begin To Edit ArticleDoc Front-Matter PolicyFront-matter 选项中的所有内容均为 非必填 的。推荐至少填写 title 和 date 的值。 配置选项 默认值 描述 title Markdown 的文件标题 文章标题，强烈建议填写此选项 date 文件创建时的日期时间 发布时间，强烈建议填写此选项，且最好保证全局唯一 author 根 _config.yml 中的 author 文章作者 img featureImages 中的某个值 文章特征图，推荐使用图床(腾讯云、七牛云、又拍云等)来做图片的路径.如: http://xxx.com/xxx.jpg top true 推荐文章（文章是否置顶），如果 top 值为 true，则会作为首页推荐文章 cover false v1.0.2版本新增，表示该文章是否需要加入到首页轮播封面中 coverImg 无 v1.0.2版本新增，表示该文章在首页轮播封面需要显示的图片路径，如果没有，则默认使用文章的特色图片 password 无 文章阅读密码，如果要对文章设置阅读验证密码的话，就可以设置 password 的值，该值必须是用 SHA256 加密后的密码，防止被他人识破。前提是在主题的 config.yml 中激活了 verifyPassword 选项 toc true 是否开启 TOC，可以针对某篇文章单独关闭 TOC 的功能。前提是在主题的 config.yml 中激活了 toc 选项 mathjax false 是否开启数学公式支持 ，本文章是否开启 mathjax，且需要在主题的 _config.yml 文件中也需要开启才行 summary 无 文章摘要，自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要 categories 无 文章分类，本主题的分类表示宏观上大的分类，只建议一篇文章一个分类 tags 无 文章标签，一篇文章可以多个标签 keywords 文章标题 文章关键字，SEO 时需要 reprintPolicy cc_by 文章转载规则， 可以是 cc_by, cc_by_nd, cc_by_sa, cc_by_nc, cc_by_nc_nd, cc_by_nc_sa, cc0, noreprint 或 pay 中的一个 注意: 如果 img 属性不填写的话，文章特色图会根据文章标题的 hashcode 的值取余，然后选取主题中对应的特色图片，从而达到让所有文章都的特色图各有特色。 date 的值尽量保证每篇文章是唯一的，因为本主题中 Gitalk 和 Gitment 识别 id 是通过 date 的值来作为唯一标识的。 如果要对文章设置阅读验证密码的功能，不仅要在 Front-matter 中设置采用了 SHA256 加密的 password 的值，还需要在主题的 _config.yml 中激活了配置。有些在线的 SHA256 加密的地址，可供你使用：开源中国在线工具、chahuo、站长工具。 您可以在文章md文件的 front-matter 中指定 reprintPolicy 来给单个文章配置转载规则 以下为文章的 Front-matter 示例。 The Simple Demo1234---title: typora-vue-theme主题介绍date: 2017-12-18 00:55:00--- The Most Complete Demo1234567891011121314151617---title: Hello, Hexo Worlddate: 2017-12-18 00:55:00author: Waldeinsamkeitimg: /source/images/xxx.jpgtop: truecover: truecoverImg: /images/1.jpgpassword: 8d969eef6ecad3c29a3a629280e686cf0c3f5d5a86aff3ca12020c923adc6c92toc: falsemathjax: falsesummary: 这是你自定义的文章摘要内容，如果这个属性有值，文章卡片摘要就显示这段文字，否则程序会自动截取文章的部分内容作为摘要categories: Markdowntags: - Hexo - Markdown---","link":"/2017/09/23/hello-hexo-matery-world/"},{"title":"Hexo 预安装环境部署之 Node.js","text":"Hexo 是一个快速、简洁且高效的博客框架。Hexo 通过 Node.js 所带来的超快生成速度，可利用靓丽的主题在几秒内瞬间完成静态网页渲染。因此安装 Hexo 前，我们必须完成 Node.js 应用程序的下载和安装。 更多 Hexo 博客框架内容，请关注博主 Hexo 博文系列： 一文学会 Hexo 轻量级框架的博客搭建【持续更新】 Hexo 预安装环境部署之 Node.js Git 使用指南之初识 打造沉浸式写作体验，你需要试试-Markdown-Editor 基于图床的博客图片存储解决方案 稳定快速、高效免费的图床方案-Github-jsDelivr-PicGo Hexo 博客多设备协同管理问题【持续更新】 Node.js了解一定网页基础的同学肯定听说过 JavaScript。Node.js 是一个基于 Chrome JavaScript 运行时建立的一个平台。简单的说， Node.js 就是运行在服务端的 JavaScript。 当然不了解 JavaScript 的同学也不要慌张，我们只需要将 Node.js 理解为：是 Hexo 用来渲染我们博客页面的插件即可。毕竟这里我们更关注的 Node.js 下载和安装，并不关心其原理以及使用。 开始安装之前，这里先给出 Node.js 安装包及源码下载地址。截至目前， Node.js 最新可供下载安装版本为：v10.15.0 (includes npm 6.4.1)。官网下载界面如下，我们可以根据不同平台的下载要求获取相应的安装包： 当然，你也可以从 Node.js 历史版本 获取到较老的历史版本。 下面我们来看不同平台（Windows、Linux 以及 Mac）下 Node.js：v10.15.0 (includes npm 6.4.1) LST（长期支持版本） 的下载以及安装方法： Windows 平台下安装 Node.js这里我们提供了两种 Windows 平台下来安装 Node.js 的方式： 使用 MSI Windows 安装包方式首先打开 Node.js 官网下载地址，下载最新版本 Node.js MSI 安装包：node-v10.15.0-x64.msi 注意：要使用 MSI 安装应用程序 （例如：node-XYZ.msi）, Windows 系统必须支持 Microsoft Installer 2.0。需要看看你的机器是否支持 MSI，Windows XP 和更高版本 已经有 MSI，很多老机器也可以安装 MSI。安装时，只要保存安装文件（**.msi**）到本地计算机，然后运行它即可完成安装（安装时，根据提示 Next 即可）。 下面我们正式开始 node-v10.15.0-x64.msi 的安装过程： 步骤 1 : 双击下载后的安装包 node-v10.15.0-x64.msi 开启安装界面，然后点击 Next 。如下所示： 步骤 2 : 勾选接受协议许可选项，然后点击 Next: 步骤 3 : Node.js 默认安装目录为 C:\\Program Files\\nodejs 。 你可以自定义修改存储目录（这里我存储于：E:\\nodejs），然后点击 Next： 步骤 4 : 点击树形图标来选择你需要的安装模式（默认为：Node.js runtime，这里我们选择：online documentation shortcuts）, 然后点击 Next 进入 Setup 界面。 步骤 5 : 点击 Install（安装） 开始安装 Node.js。 然后点击 Next，等待安装完成点击 Finish 即可： 步骤 6：DOS 安装检测 首先检测系统 PATH 环境变量中是否成功配置了 Node.js（这是关键的），日志信息输出如下： 12345PATH=C:\\WINDOWS\\system32;C:\\WINDOWS;C:\\WINDOWS\\System32\\Wbem;C:\\WINDOWS\\System32\\WindowsPowerShell\\v1.0\\;C:\\WINDOWS\\System32\\OpenSSH\\;E:\\TortoiseSVN\\bin;E:\\Git\\cmd;E:\\nodejs\\;C:\\Users\\xxxxxx\\AppData\\Local\\Microsoft\\WindowsApps;E:\\Anaconda3\\Scripts;E:\\Anaconda3;C:\\Users\\xxxxxx\\AppData\\Roaming\\npm 可以看到 E:\\nodejs\\ 路径已经被成功添加到系统环境变量 Path 中。否则请手动添加系统环境变量。 此时我们来查看安装好的 Node.js 版本号： 12C:\\Users&gt;node -vv10.15.0 至此，使用 “MSI Windows 安装包” 的方式安装 Node.js 的过程已经全部完成。 使用 EXE Windows 二进制文件方式首先打开 Node.js 官网下载地址，下载最新版本 Node.js Binary 安装包：node-v10.15.0-win-x64.zip。 使用 Windows 二进制文件安装 Node.js 比较简单。直接解压安装包，然后双击安装目录下的：node.exe 等待即可…… 注意，node.exe 安装过程中会出现如下安装窗口： 安装版本测试： 查看已安装 Node.js 版本号，信息如下表示安装成功： 12C:\\Users&gt;node -vv10.15.0 如果没显示正确版本号，请手动添加系统环境变量。 Linux 平台下安装 Node.js 注意：Linux 上安装 Node.js 需要安装 Python 2.6 / 2.7 ，不建议安装 Python 3.0 以上版本。 Linux 平台下，我们也提供了两种 Node.js 的 v10.15.0 (includes npm 6.4.1) LST（长期支持版本）的安装方式： 使用已编译好的包Node.js 官网提供了已经编译好的 linux Node.js 安装包，解压即用： 123456789# 下载相应版本安装包（下载目录为：/usr/software）：$ wget -c https://nodejs.org/dist/v10.15.0/node-v10.15.0-linux-x64.tar.xz＃ 解压：$ tar -zxvf node-v10.15.0-linux-x64.tar.xz# Node.js 安装版本测试：＄ cd node-v10.15.0-linux-x64$ ./bin/node -vv10.15.0 注意，你可以在 https://nodejs.org/dist 中查找到其它支持的 node.js 版本进行下载。 注意，解压文件的 bin 目录底下包含了 node、npm 等命令，为了方便系统调用，我们可以使用 ln 设置命令软链接： 12ln -s /usr/software/node-v10.15.0-linux-x64/bin/npm /usr/local/bin/ ln -s /usr/software/node-v10.15.0-linux-x64/bin/node /usr/local/bin/ 使用源码安装1）Ubuntu 这一小节我们来看如何在 Ubuntu OS 环境下使用源码安装 Node.js： 步骤一：前往 Node.js 官网下载地址 获取其源码（source code）下载链接，然后进行下载： 1$ wget -c https://nodejs.org/dist/v10.15.0/node-v10.15.0.tar.gz 步骤二：开放目录权限： 1$ sudo chmod -R 755 node 步骤三：依次执行如下命令编译源码： 1234$ cd node-v10.15.0$ sudo ./configure$ sudo make$ sudo make install 步骤四：设置 Node.js 环境变量，并且完成 source： 123456789# 打开全局配置文件增加如下配置：$ vim /etc/profile# Set for node.jsexport NODE_HOME=/usr/local/node/10.15.0export PATH=$PATH:$NODE_HOME/bin# 使配置文件生效：$ source /etc/profile |——————————————————— 补充：Ubuntu 还可以通过 apt-get 命令 直接安装： 12sudo apt-get install nodejssudo apt-get install npm ———————————————————| 步骤五：检测是否安装成功： 12$ node --versionv10.15.0 2）Centos 这一小节我们来看如何在 Centos OS 环境下使用源码安装 Node.js： 步骤一：前往 Node.js 官网下载地址 获取其源码（source code）下载链接，然后进行下载： 1$ wget -c https://nodejs.org/dist/v10.15.0/node-v10.15.0.tar.gz 步骤二：解压源码文件： 1$ tar -zxvf node-v10.15.0.tar.gz 步骤三：依次执行如下命令编译安装源码： 1234cd node-v10.15.0./configure --prefix=/usr/local/node/10.15.0makemake install 步骤四：设置 Node.js 环境变量，并且完成 source： 123456789# 打开全局配置文件增加如下配置：$ vim /etc/profile# Set for node.jsexport NODE_HOME=/usr/local/node/10.15.0export PATH=$PATH:$NODE_HOME/bin# 使配置文件生效：$ source /etc/profile 步骤五：验证是否安装配置成功： 1$ node -v Mac 平台下安装 Node.js这里我们提供两种方式来在 Mac OS 上安装 Node.js： 1）使用 pkg 安装包 前往 Node.js 官网下载地址 下载最新 Node 版本 .pkg 安装包，进行安装即可。 2）使用包管理器 1$ brew install node","link":"/2017/09/20/hexo-yu-an-zhuang-huan-jing-bu-shu-zhi-node-js/"},{"title":"JAVA 中的 JVM &amp; JRE &amp; JDK ?","text":"我们知道，任何语言或者软件的运行都依赖环境，Java 必然也不例外。Java 语言的开发运行，也离不开 Java 语言的运行环境 JRE。没有 JRE 的支持，Java 语言便无法运行。当然，如果还想编译 Java 程序，搞搞小开发的话，JRE 是明显不够了，这时候就需要 JDK。 那么， JDK，JRE 和 JVM 有什么区别以及联系呢？ JVM &amp; JRE &amp; JDK很多 Java 初学者肯定会或多或少产生过这样的疑问： JDK，JVM 和 JRE ？？？三者有什么区别？又有什么联系呢？ 所以，这里来整理一下三者的关系和区别： JDK（Java Development Kid，Java 开发工具包）：是针对 Java 开发人员的产品，是整个 Java 的核心，包括了 Java 运行环境 JRE、Java 工具和 Java 基础类库。 JRE（Java Runtime Environment，Java 运行环境）是运行 JAVA 程序所必须的环境的集合，包含 JVM 标准实现及 Java 核心类库。 JVM（Java Virtual Machine，Java 虚拟机）是整个 Java 实现跨平台的最核心的部分，能够运行以 Java 语言编写的软件程序。 还不明白？！直接上图： 可以看出： JDK = JRE + 多种 Java 开发工具 JRE = JVM + 各种类库 JDK &gt; JRE &gt; JVM –**&gt; Java IDE ** 那么，加入 Java IDE 的话，IDE 应该处于什么位置呢？？ JAVA IDE &gt; JDK &gt; JRE &gt; JVM","link":"/2017/10/09/java-zhong-de-jvm-jre-jdk/"},{"title":"Java Hello World","text":"相信这里你已经对 Java 有了基本的了解，并且你已经完成了 Java 开发环境的基本搭建。你可能会很疑惑上面我们配置的开发环境是否真的可以运行 Java 应用程序？而不是通过简单的 java –version 来判断。看完本篇博文你会了解一个完整 Java 应用程序的基本开发过程。 Hello Java World在开始后续的学习之前，我们先给出一个经典的 Java 程序 Demo（HelloWorld）： 1234567891011/** * * My First Java Code * */public class HelloJava { public static void main(String[] args) { // TODO Auto-generated method stub System.out.println(&quot;Hello, Java World!&quot;); }} 先来看一下，上诉的 Java 程序有什么样的含义，具体 Java 语句的用法会在后续的学习中深入了解，这里不用深究。 上述代码的含义是，我们运行上述 Java 程序后，会在屏幕打印一行文字：Hello, Java World! 编写 Java 源程序Java 源程序可以使用任何一个文本编辑器（记事本、Sublime、Notepad++…）来编写，这里以 Windows 下的记事本为例： 1）新建一个空白记事本，然后如实地将我们上面给出的 Java 程序内容编写进去。 2）将写完代码后的文件另存为 HelloJava.java，保存类型选择“所有文件”，接着单击“保存”按钮，保存文件到任一文件夹中。 重新打开选用记事本打开编写好的 Java 源程序文件，如下： 提示：保存的 Java 源程序文件名中不能出现空格，类似 “Hello Java.java” 的文件名在编译时会出现找不到文件的错误。 编译源程序将 Java 源程序编写并保存到文件之后，还需要进行编译才能运行。编译 Java 源程序使用的是 JDK 中的 javac 编译器。你需要在 CMD 下执行： 1javac HelloJava.java 此时如果没有任何其他信息，表示该源程序通过了编译；否则会输出错误编译信息，这时说明程序中存在错误，必须根据错误提示，重新在记事本中打开 HelloJava.java 文件修改出错代码，修改完成后保存修改到文件，然后回到命令提示符窗口重新编译（可能要反复几次，修改程序中出现的多个编写错误），直到编译通过为止。 实在通过不了，你可以直接复制我上面给出的代码。 javac HelloJava.java 命令的作用是让 Java 编译器获取 Java 应用程序 HelloJava.java 的源代码，把它编译成符合 Java 虚拟机规范的字节码文件。 这时，你会发现在 HelloJava.java 同目录下生成一个新文件 HelloJava.class，此文件便是我们所说的字节码文件，它也是 JVM 上的可执行文件。 运行字节码文件编译完成后，我们就可以使用 Java 解释器（java）运行 Java 源程序所对应的字节码文件（.class）了，命令如下： 1java HelloJava 你会发现，DOS 下输出如下： Hello, Java World! 到这里，你已经成功运行了你写好的 Java 源程序了！ 注意，运行字节码文件时，无需使用 .class 全名。 Hello World 执行详解从上面的过程中，你肯定不难归纳出 Java 程序的运行必须经过的 3 个步骤： 编写：使用文本编辑器编写，最终形成后缀名为 .java 的 Java 源文件。 编译：是指使用 Java 编译器对源文件进行错误排査的过程，编译后将生成后缀名为 .class 的字节码文件，而不是不像 C 语言那样的可执行文件。 运行：是指使用 Java 解释器将字节码文件翻译成机器代码，执行并显示结果。 Java 程序运行流程示意图如下： 详细说明： 1.字节码文件，是一种二进制文件，是一种和任何具体机器环境及操作系统环境无关的中间代码，这就意味着 任何安装了 JDK 平台编译后生成的字节码文件是相同的。 2.编程人员和计算机都无法直接读懂字节码文件。 3.Java 解释器负责将字节码文件翻译成具体硬件环境和操作系统平台下的机器代码，以便执行。也就是说，Java解释器依托的 JVM 是平台相关的，不同平台下的 JVM 是不同的，相同的字节码文件会被翻译成不同的机器代码。 Java 虚拟机（JVM）是运行 Java 程序的软件环境，Java 解释器是 Java 虚拟机的一部分。 4.JVM 把不同软、硬件平台的具体差别隐藏起来，从而实现了真正的二进制代码级的跨平台移植。 Java 的这种运行机制如下： Java IDE事实上，我们在实际开发 Java 程序时，会使用 Java IDE（Java Integrated Development Environment，Java 集成开发环境）。 即我们会选择一款合适的 IDE 工具来完成 Java 程序的编写 &amp; 编译 &amp; 运行。 Java IDE 可以为我们提供如下功能： 提供代码编辑功能； 快捷方式调用：javac，java….. 可视化界面； 文档自动编写 … IDE 帮助我们把 Java 程序开发过程中的编写、分析、编译、调试、文档生成、字节码混淆、打包压缩、发布部署一系列任务等集成到一个可视化界面，极大的方便了开发人员的工作，提升了编程效率。 Java IDE 推荐：Eclipse / Intellij IDEA 关于反编译在 JDK 安装与配置博文中，JDK 安装目录详解时，我们提到过 javap 反编译器，不知道你是否还记得？？？ Java 程序经过编译后生成的 .class 文件中，包含有大量的源程序信息，很容易被反编译，拿到我们源程序信息。 例如，我们使用 javap 对上面我们的 Hello Java World Demo 进行反编译： 123456$ javap HelloJavaCompiled from &quot;HelloJava.java&quot;public class HelloJava { public HelloJava(); public static void main(java.lang.String[]);} 关于字节码混淆怎么办？事实上，我们可以使用 Java 代码混淆器来进行字节码混淆。 IDE 集成的字节码混淆功能，能够对字节码文件进行代码混淆，防止源程序不被解读。 代码混淆一般原理： 对 .class 文件或 .jar 文件中的字节码进行修改，使其不能被很好的反编译，或者反编译不容易阅读。","link":"/2017/10/10/java-hello-world/"},{"title":"Java, Write Once, And Run Any Where","text":"Java 语言特点中提到过，Java 是平台无关的。Java 的平台无关性具体表现在于 “一次编写，到处运行（Write Once，Run any Where）”，因此采用 Java 语言编写的程序具有很好的可移植性，编译之后可以直接在不同的平台上运行。 Java平台无关性为什么需要平台无关性平台无关（跨平台），用一句话来阐述就是 ”Write once, and run anywhere“，也就是说：语言在计算机上的运行不受不同平台的约束，一次编写，到处运行。 就比如说我们在 Windows 下面写出来的一段 Java 程序，换成 Linux or Mac os 系统里面，一样可以正常运行并且输出相同的结果。 Java 的这种跨平台的特性，很大程度上依赖于 JVM（Java Virtual Machine），但注意不仅限于 JVM。 Java 如何支持平台无关性1 –&gt; Java 平台本身 Java 平台中的 Java API（Application Programming Interface，Java 应用编程接口），提供了一套独立于操作系统的标准接口，作为 Java 程序和所在平台（硬件与操作系统）之间的缓冲角色，这样开发编写 Java 程序只与 Java 平台打交道，而不需要了解平台硬件或操作系统细则。 2 –&gt; Java 字节码 不同平台下，Java 程序经过 Java 编译器会被编译成 同样的 二进制 的 Java 字节码文件（class文件）。class 文件可以在任何平台（Win or Linux or Mac）生成，也可以被任何平台的 JVM 装载运行。 Java 字节码是 Java 平台无关的基石，真正的平台无关。 3 –&gt; JVM 虚拟机机制 Java 的平台无关性很大程度上依赖于 JVM（Java Virtual Machine），JVM 是可以执行 Java 字节码的虚拟进程。JVM 能够将 相同的字节码 编译成与平台相关的 不同的机器码，从而进一步再解释执行。 JVM 机制百度百科上 JVM 的专业解释如下： Java 虚拟机（Java Virtual Machine，简称 JVM）是一种用于计算设备的规范，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。 Java 虚拟机包括一套字节码指令集、一组寄存器、一个栈、一个垃圾回收堆和一个存储方法域。JVM 屏蔽了与具体操作系统平台相关的信息，使 Java 程序只需生成在 Java 虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。JVM 在执行字节码时，实际上最终还是把字节码解释成具体平台上的机器指令执行。 ============================================== 通俗的说： JVM，也就是 Java 虚拟机，就属于 Java 平台的一部分，包含于 JRE 的下面。 解释执行当你需要执行某个 Java 程序时，由 JVM 帮你进行进一步编译（JIT，Just In Time）和解释执行，它负责将编译生成的字节码文件翻译成特定平台下的机器码然后运行。 注意： 1. 编译的结果不是生成机器码，而是生成字节码，字节码不能直接运行。必须通过 JVM 翻译成机器码才能运行。2. 不同平台下编译生成的字节码是一样的，但是由 JVM 翻译成的机器码却不一样。 因此，运行 Java 程序必须有 JVM 的支持，即使你将 Java 程序打包成可执行文件（例如 .exe），仍然需要 JVM 的支持。 平台相关性JVM 屏蔽了与具体操作系统平台相关的信息，可以得知，JVM 是平台相关的。 事实上也正是如此，JVM 分为很多个系统版本的，你编写好的 Java 程序，无论到哪个平台上，Windows 也好，Linux 也好，Mac 也罢，只需要安装对应平台 JVM，便可以成功编译和执行。 这里我们知道： 跨平台的是字节码（Java 程序），不是 JVM。JVM 是平台相关的，不同平台下需要安装不同版本的 JVM。 Java API待续…","link":"/2017/10/09/java-write-once-and-run-any-where/"},{"title":"Java 中的 final 修饰符","text":"Java 中 final 修饰符的使用。 final 修饰变量我们知道，final 修饰符可用来修饰变量。 final 修饰变量（基本数据类型，或引用数据类型）时，三大原则： 当定义的 final 变量为成员变量（类或结构中的属性）时，必须在定义时就明确设定它的初始值，否者直接会报错无法通过编译，并且如果再次对其进行赋值将会提示编译错误。 当定义的 final 变量为 方法中（方法内，或方法块内）的局部变量 时，可以直接定义时赋值，也可以由开发者在声明后，第一次使用该变量之前，显式的赋初始值，实例化该变量； 当定义的 final 变量为 方法上的局部变量（参数） 时，是为了防止数据在方法体中被修改，这时参数的值（或引用）在方法体内是不能不能被重新赋值的。 根据 Java 中数据类型的分类，这里 final 修饰符修饰的变量的使用场景我们需要注意以下两种，使用上是有细微差异的（两个注意）： final 修饰符修饰基本数据类型的变量 final 修饰符修饰引用数据类型的变量 1 –&gt; 修饰基本数据类型的变量时 final 修饰基本数据类型的变量时，基本类型的值是不能够改变的。 2 –&gt; 修饰引用数据类型的变量时 final 修饰引用数据类型的变量时，引用类型变量所指的引用是不能够改变的（地址不变），但是引用类型变量的值是可以改变的（地址所指向存储空间值可变）。 详细使用样例差异，可见下文原则 1~3 中样例。 原则一当定义的 final 变量为成员变量（类或结构中的属性）时，必须在定义时就明确设定它的初始值，否者直接会报错无法通过编译，并且如果再次对其进行赋值将会提示编译错误。 1 –&gt; 基本数据类型 12345678910public class HelloJava { static final int i = 3; // 声明时，显式初始化 public static void main(String[] args) { // TODO Auto-generated method stub System.out.println(i); } } 关于 final 前面的 staitc 修饰符，这里可以不用深究，你就当没看见。 输入： 1203 2 –&gt; 引用数据类型 12345678910public class HelloJava { static final String str1 = &quot;this is a test&quot;; // 声明时，显式初始化 public static void main(String[] args) { // TODO Auto-generated method stub System.out.println(str1); } } 输入： 12nullthis is a test 下面这样的表达可以么？（先忽略之后的注释） 1234567891011121314151617181920public class HelloJava { static final int i; // 编译不通过，声明时，未初始化 static final int j = 3; static final String str1; // 编译不通过，声明时，未初始化 static final String str2 = null; static final int[] a_test = {2,3,4}; public static void main(String[] args) { // TODO Auto-generated method stub j = 1; // 编译错误，再次对 final 修饰成员变量进行赋值操作 System.out.println(j); System.out.println(str2); a_test = {1,2}; // 编译错误，引用类型变量所指的引用是不能够改变的 a_test[0] = 2; // 编译可通过，引用类型变量的值是可以改变的 } } =========================================== final 修饰的成员变量的另一种赋值方法（构造函数）： 1234567public class FinalDemo { final int age; public FinalDemo(int age){ this.age=age; // 编译通过 }} 你可以想想上述赋值方法成立的原因…. 原则二当定义的 final 变量为 方法中（方法内，或方法块内）的局部变量 时，可以直接定义时赋值，也可以由开发者在声明后，第一次使用该变量之前，显式的赋初始值，实例化该变量。 1 –&gt; 基本数据类型 12345678910111213public class HelloJava { public static void main(String[] args) { final int i_test = 3; // 变量声明时，进行初始化 System.out.println(i_test); final int j_test; j_test = 1; // 变量声明后，使用前，进行初始化 System.out.println(j_test); } } 输出： 1231 2 –&gt; 引用数据类型 12345678910111213public class HelloJava { public static void main(String[] args) { // TODO Auto-generated method stub final String i_test = &quot;abc&quot;; System.out.println(i_test); final String j_test; j_test = &quot;def&quot;; System.out.println(j_test); } } 输出： 12abcdef 下面这样的表达可以么？（先忽略之后的注释） 12345678910111213141516public class HelloJava { public static void main(String[] args) { // TODO Auto-generated method stub int i = 1; final String str; if (i &gt; 0) { str = &quot;this is a test&quot;; str = &quot;test&quot;; // 编译错误，块内使用前多次初始化赋值 str.length(); // 编译可通过，块内使用前已初始化赋值 } else { str.length(); // 编译错误，块内使用前未初始化赋值 } } } 原则三当定义的 final 变量为 方法上的局部变量（参数） 时，是为了防止数据在方法体中被修改，这时参数的值（或引用）在方法体内是不能被重新赋值的。 但需要谨记上文的 两个注意。 1 –&gt; 基本数据类型 1234567891011public class HelloJava { public static void main(String[] args) { // TODO Auto-generated method stub } public static void checkValue(final int a) { a = 234; // 编译错误，基本类型的值在方法内部是不能够改变的 } } 2 –&gt; 引用数据类型 123456789101112public class HelloJava { public static void main(String[] args) { // TODO Auto-generated method stub } public static void checkValue(final int[] a) { a = {2,3,4}; // 编译错误，a 变量的引用是不能够改变的 a[0] = 3; // 编译可通过，a 变量所指向的存储中的值是能够修改的 } } final 修饰类final 修饰类时，可以继承其他类，但是不可以被继承的，使用方式跟其它类一样。 123class Parent{}final class Person extends Parent{}class child extends Person{} final 修饰方法final 修饰方法时，不可以被覆盖（不可以重写），但可以继承使用。 123456789class Parent { // final 修饰的方法，不可以被覆盖，但可以继承使用 public final void method1(){} public void method2(){} // 普通方法}class Child extends Parent { // 普通 method2 方法，支持重写 public final void method2(){}}","link":"/2017/10/13/java-zhong-de-final-xiu-shi-fu/"},{"title":"Java 程序设计基础之数据类型","text":"前面我们在介绍 Java 中的字面值以及变量时提到过，Java 中的数据类型分类：基本数据类型（Primitive Type）和引用数据类型（Reference Type），本文我们来详细解读 Java 的数据类型定义以及应用，本文学习之后重新回顾之前的内容，可以帮助你更好的理解前文。 Java 中的数据类型结构如图： 下面我们分别来看两种数据类型的说明： Java 中的基本数据类型Java 中包含八种基本的数据类型，都是 Java 基础语言中预先定义好的。 基本数据类型包括：byte（字节型）、short（短整型）、int（整型）、long（长整型）、boolean（布尔型）、char（字符型）、float（单精度浮点型）、和 double （双精度浮点型）共 8 种。 所有的基本数据类型的大小（所占用的字节数，数据取值范围）都已明确规定，在各种不同的平台上保持不变，这一特性有助于提高 Java 程序的可移植性。 类型名称 关键字 占用内存 取值范围 字节型 byte 1 字节 -128~127 短整型 short 2 字节 -32768~32767 整型 int 4 字节 -2147483648~2147483647 长整型 long 8 字节 -9223372036854775808L~9223372036854775807L 单精度浮点型 float 4 字节 +/-3.4E+38F（6~7 个有效位） 双精度浮点型 double 8 字节 +/-1.8E+308 (15 个有效位） 字符型 char 2 字节 ISO 单一字符集，也可以看作是一种整数类型，相当于无符号整数类型 布尔型 boolean 1 字节 true 或 false 整数类型Java 定义了 4 种整数类型变量用于存放整型字面值： 字节型（byte） 短整型（short） 整型（int） 长整型（long） 使用说明如下： 名称 说明 byte byte 类型是最小的整数类型。当用户从网络或文件中处理数据流时，或者处理可能与 Java 的其他内置类型不直接兼容的未加工的二进制数据时，该类型非常有用。 short short 类型限制数据的存储为先高字节，后低字节，这样在某些机器中会出错，因此该类型很少被使用。 int int 类型是最常使用的一种整数类型。 long 对于大型程序常会遇到很大的整数，当超出 int 类型所表示的范围时就要使用 long 类型。 这些都是有符号的值，具体区别在于不同类型的整型，最大值，最小值不一样，见小节开始。 如果试图给 byte 类型的变量赋予超出其范围的值（300），就会产生编译错误 1234567891011public class HelloWorld{ public static void main(String[] args){ byte b = 1; short s = 200; int i = 300; long l = 400L; byte b2 = 200; // 编译错误 }} 字符型Java 语言中的字符类型（char）使用两个字节的 Unicode 编码表示，它支持世界上所有语言，可以使用单引号字符或者整数（0~65535）对 char 型赋值。 超过一个字符，或整数超过 65535 就会产生编译错误。 123456789public class HelloWorld{ public static void main(String[] args){ char c = '中'; char c2 = '中国'; // char 只能存放一个字符，超过一个字符就会产生编译错误 char c3 = 'ab'; // char 只能存放一个字符，超过一个字符就会产生编译错误 }} 前面我们知道，字符型字面值中的字符可以八进制或者十六进制，八进制使用 ‘反斜杠加3位八进制数字’ 表示，例如 ‘\\141’ 表示字母 a。十六进制使用 ‘\\u加上4为十六进制的数’ 表示，如 ‘\\u0061’ 表示字符 a。 Java 只允许转义不超过 0377 的八进制数来表示字符。0377 是占满 8 位的数，但 Java 中的 char 是 16 位，所以无法表达所有 char 值。 其实 Java 允许转义八进制数表示字符是来源于 C 语言，C 中字符类型只占 8 位，所以才有这个限制。Java 是推荐使用转义十六进制数来表示 char 的。 如果不用转义，换一种方式，你可以用“把八进制数表示为整型，再把整型转为 char 类型”来实现八进制数到 char 的转换。用 ‘卷’ 举例，它的八进制数值为 051567，可以这样：char c = (char)051567; Unicode 字符集（char）通常用十六进制表示，范围从\\uOOOO ~ \\uFFFF，刚好占满（0~65535）。 布尔类型布尔类型（boolean）用于对两个数值或表达式通过逻辑运算，判断结果是“真”还是“假”。 只能是取 true 和 false 这两个值中的一个。 在 Java 语言中，布尔类型的值不能转换成任何数据类型，true 常量不等于 1，而 false 常量也不等于 0。这两个值只能赋给声明为 boolean 类型的变量，或者用于布尔运算表达式中。 浮点类型浮点类型是带有小数部分的数据类型，也叫实型。 浮点型数据包括单精度浮点型（float）和双精度浮点型（double），代表有小数精度要求的数字。 一个值要能被真正看作 float，它必须以 f（或 F）后缓结束；否则，会被当作 double 值。对 double 值来说，d（或 D）后缓是可选的。 123456789public class HelloWorld{ public static void main(String[] args){ double d = 123.45; float f = 54.321; //该行会出现编译错误，因为 54.321 默认是 double 型的 float f2 = 54.321f; }} String说起数据类型，不得不提的就是字符串类型，是使用双引号引起来的单个或多个字符。 事实上，Java 中 String 类型其实 并不是基本类型，是一个类，并且是 Immutable（不可变）类型的，一旦创建就不能够被改变。 引用类型所谓引用数据类型就是对一个对象的引用。 引用数据类型是建立在基本数据类型的基础上，包括数组、类和接口。 Java 语言中不支持 C++ 中的指针类型、结构类型、联合类型和枚举类型。 引用类型还有一种特殊的 null 类型。因为 null 类型没有名称，所以不可能声明一个 null 类型的变量或者转换到 null 类型。 在实际开发中，程序员可以忽略 null 类型，把 null 只当作是引用类型的一个特殊字面值，用于给引用类型赋初始值，并且不要把一个 null 值赋给基本数据类型的变量。。 数据类型转换数据类型的转换是在所赋值的数值类型和被变量接收的数据类型不一致时发生的，它需要从一种数据类型转换成另一种数据类型。也就是说，不同类型之间的数据可以互相转换。 但是要注意，满足一定的规则才可以互相转换： 精度高的数据类型就像容量大的杯子，可以放更大的数据精度低的数据类型就像容量小的杯子，只能放更小的数据小杯子往大杯子里倒东西，大杯子怎么都放得下大杯子往小杯子里倒东西，有的时候放的下，有的时候就会有溢出 所以根据以上两种情况，Java 中的数据类型的转换可以分为 隐式转换（自动类型转换） 显式转换（强制类型转换） 隐式转换自动转换规则：低精度类型向高精度类型进行转换，会进行自动转换。 这里有一个 拓宽转换（widening conversion）原则：在运算过程中，由于不同的数据类型会转换成同一种数据类型，所以整型、浮点型以及字符型都可以参与混合运算。最终结果会自动转发成高精度的字面值。 123456789101112public class HelloJava { public static void main(String[] args) { // TODO Auto-generated method stub float c_test = 10 + 10.0 + 'a'; // 编译错误，将 double 型字面值赋直接给 float short a = 1; short b = 2; short c = a+b; // 编译错误，将 int 型字面值赋直接给 short } } 任何运算单元的长度，超过 int,那么运算结果就按照最长的长度计算。不超过 int,那么运算结果就按照 int 来计算 自动转换规则： 数值型数据的转换：byte→short→int→long→float→double。 字符型转换为整型：char→int→long→float→double。 需要注意的是，虽然 short 和 char 都是16位的，长度是一样的，但是彼此之间，依然需要进行强制转换。byte 也不能自动转换为 char，而且 char 也不能自动转换为 byte。 这里的强制转换，就是我们下面要提到的显示转换。 – &gt; 自动类型提升有好处，但它也会引起令人疑惑的编译错误。引发一个问题： 12byte b = 50;b = b * 2; // Type mismatch: cannot convert from int to byte 第二行会报 “类型不匹配：无法从int转换为byte” 错误。 该程序试图将一个完全合法的 byte 型的值 50*2 再存储给一个 byte 型的变量。但是当表达式求值的时候，操作数被自动的提升为 int 型，计算结果也被提升为 int 型。这样表达式的结果现在是 int 型，不强制转换它就不能被赋为 byte 型。 所以应该使用一个显示的强制类型转换，例如： 12byte b = 50;b = (byte)(b*2); 显示转换当两种数据类型不兼容（byte &lt;–&gt; char），或目标类型的取值范围小于源类型时，自动转换将无法进行，这时就需要进行显示的强制类型转换。其语法格式如下： 1(type)variableName 但是注意，强制转换的意思就是，转是可以转的，但是不对转换之后的值负责。 风险自担，后果自负 就像我们前面说的，大杯子往小杯子里倒东西，有的时候放的下，有的时候就会有溢出。当出现溢出时，不也就意味着数据丢失么？所以使用显示转换时要注意！！！ 显示转化可使用场景如下：","link":"/2017/10/14/java-cheng-xu-she-ji-ji-chu-zhi-shu-ju-lei-xing/"},{"title":"Java 程序设计基础","text":"要想编写规范、可读性高的 Java 程序，就必须熟练掌握 Java 基本语法。基本语法是所有编程语言都必须掌握的基础知识，也是整个程序代码不可缺少的重要部分。随后的章节开始学习 Java 的基础语法部分，主要分为 4 部分内容：数据类型，变(常)量，运算符，以及控制流程语句，这也是构成 Java 程序最基础的 4 个部分，敲黑板！ 其中，数据类型和运算符不仅定义了语言的规范，还决定了可以执行什么样的操作；变量是用来存储指定类型的数据；而控制流程根据用户的输入决定程序要进入什么流程，即要做什么？如何做？ 在开始正式的学习之前，我们需要先了解一些 Java 基本语法最最基本的定义： Java 标识符 &amp; 关键字任何一种计算机语言都离不开标识符和关键字，本小节将详细介绍 Java 的标识符、关键字（保留字）。 标识符所有编程语言中的 标识符，都是为 变量、方法、类、对象以及文件、工程 等进行命名的，可以有一个或多个字符。 标识符构成规则Java 语言规定的，标识符的构成规则如下： 标识符可以由任意多的 字母（AZ 和 az），数字（0~9），下划线（_），dollar 符（$），Unicode 字符集中符号（大于 0xC0 ）的所有符号组合构成。注意不包含空格！！！ 必须以字母，dollar 符以及下划线开头，不可以是数字。 运算符，关键字（保留字）以及标准方法名不可以作为标识符。 注意：标识符中可以包含 关键字 &amp; 标准方法名。 标识符命名规范一个良好的编程习惯要求命名标识符时，应赋予它 ”意义“（非强制）。 见名知义：代码命名神奇 –&gt; CodeIF； 包名全部小写； 类名各单词首字母大写（大驼峰命名法） 变量名，方法，类的实例：第一个单词字母小写，其它单词首字母大写（小驼峰命名法）； 常量名全部大写； 参数的名尽量使用一个单词的情况下，命名明确； 数组命名使用：”类型[] 数组名” 的形式。 驼峰命名法： 小驼峰式（little camel-case）–&gt; 第一个单词首字母小写，后面其他单词首字母大写。 大驼峰式（big camel-case）–&gt; 每个单词的第一个字母都大写; 关键字关键字（或者保留字）是语言中已经被赋予了特殊含义的专有单词，Java 编译器有特殊的意义，不能在程序中做其他目的使用。 保留字是为 Java 预留的关键字，它们虽然现在没有作为关键字，但在以后的升级版本中有可能作为关键字。 Java 语言目前定义了 51 个关键字，这些关键字不能作为标识符使用： 数据类型：boolean、int、long、short、byte、float、double、char、class、interface。 流程控制：if、else、do、while、for、switch、case、default、break、continue、return、try、catch、finally。 修饰符：public、protected、private、final、void、static、strict、abstract、transient、synchronized、volatile、native。 动作：package、import、throw、throws、extends、implements、this、supper、instanceof、new。 保留字：true、false、null、goto、const。 Java 注释注释不是编程语句，编译时会被编译器忽略。 Java 支持以下三种注释方式： 单行注释以双斜杠 “//” 标识，只能注释一行内容： 123456public class HelloJava { public static void main(String[] args) { // 这是一个单行注释 System.out.println(&quot;Hello, Java World!&quot;); }} 多行注释包含在 “/*” 和 “*/” 之间，能注释很多行的内容，也成为 块注释。 为了可读性（美观）比较好，一般首行和尾行不写注释信息: 123456789public class HelloJava { /** * 这是一个多行注释 */ public static void main(String[] args) { // TODO Auto-generated method stub System.out.println(&quot;Hello, Java World!&quot;); }} 注意：多行注释可以嵌套单行注释，但是不能嵌套多行注释和文档注释。 文档注释包含在 “/**” 和 “*/” 之间，也能注释多行内容，只在类、接口、方法、成员变量上面，用来描述其作用。 注释后，鼠标放在类和方法上面会自动显示出我们注释的内容 1234567891011121314151617/** * Project Name: HelloJava * Class Name: HelloJava * Created By: xxxxxx * Created At: xxxx年xx月xx日 上午3:31:44 * E-Mail: * @Version * */public class HelloJava { public static void main(String[] args) { // TODO Auto-generated method stub System.out.println(&quot;Hello, Java World!&quot;); }} 注意：文档注释能嵌套单行注释，但是不能嵌套多行注释和文档注释 Java 平台提供了 javadoc 工具，使用 Java 源代码中的文档注释，来生成 API 说明文档。 语句Java 程序中，语句是最小的组成单位，每个语句必须使用分号作为结束符。 除此之外，Java 对语句无任何其他限制，开发人员可以很随意地用符合自己风格的方式编写语句。 1 –&gt; 一个语句放在多行 123String str = &quot;Apple &quot;+&quot;Banner &quot;+&quot;Pear &quot;+&quot; Orange&quot;; 由于 Java 使用分号作为语句的结束符，所以上面的 3 行代码会被 Java 认为是一条语句，因为这 3 行中只有一个分号。但是，我们不推荐使用这种方式来编写语句（不符合编码规范）。 2 –&gt; 多个语句放在一行 使用分号作为分隔符，将多个语句放在一行来编写也是允许的： 1int a=0,b,c;b=a+10;b++;c=a*b;System.out.println(c); 但也不这样推荐。 3 –&gt; 空语句 所谓空语句（Empty Statement），它在程序中什么都不做，也不包含具有实际性的语句。 空语句的语法格式如下： 1; // 其实就是一个分号 表达式表达式是由变量、操作符以及方法调用所构成的结构。在表达式后面添加分号，就成了独立的表达式语句。 样例： 12int i = 5; System.out.println(5); 注意： ; 也是一个完整的表达式，即使没有任何变量、操作符以及方法调用。 1234567public class HelloWorld { public static void main(String[] args) { //一个空;也是一个表达式 ; ; }} 语句块从 { 开始 到对应的 } 结束，即为一个语句块，也称为：复合语句，是很多个语句的组合。 123456789public class HelloWorld { //类对应的块 public static void main(String[] args) { //主方法对应的块 System.out.println(&quot;abc&quot;); } { // 这是正确的语法 System.out.println(&quot;this is a test&quot;); }} Java 编码规范 程序最开始编写导入包和类语句，即 import 语句，import 语句可以有多行，编写完 import 语句后空一行; 定义 public 类，顶格书写。类的主体左括号 “{” 不换行书写，右括号 “}” 顶格书写； 定义 public 类中的变量，缩进书写； 定义方法用缩进书写，方法的左括号 “{” 不换行书写，右括号 “}” 和方法首行第一个字符对齐；方法体要再次缩进书写，最后一个变量定义和第一个方法定义之间、方法和方法之间最好空一行； 方法名和紧跟在其后的左括号 “(” 无空格，该左括号和其后的标识符之间无空格。多个参数之间的逗号和前一个参数紧靠，与后一个参数空一格。 在一行内只写一个语句，并采用空格、空行来保证语句容易阅读。 关于编码规范，可以以权威公司（Google 等）编码规范为参考。 Java 包名(Package)命名规范每个 Java 开发人员都可以开发自己的 Java 项目，Coder 可以为 Java 项目中的包定义各种各样满足命名规范定义的名字。 但是，我们需要尽可能保障每个 Java Package 命名的唯一性，尤其是在你上传编写好的 Java 库到第三方平台供他人使用时，这尤为重要（第三方平台一般会进行唯一性检验，成功后才允许你上传，否则认为包名冲突了）。 这就要求我们，尽可能的在 Package 命名时： 为自己定义的包名前加上唯一的前缀 1 –&gt; 公司项目命名 一般公司项目中，包名的命名规则可定义为如下： com.公司名.项目名.模块名 2 –&gt; 团队项目 一般公司项目中，包名的命名规则可定义为如下： team.公司名.项目名.模块名 3 –&gt; 个人项目命名 那么，我们的个人项目又怎么命名呢？ indi（individual）–&gt; 个人发起，但非自己独自完成的项目（可公开或私有项目），但 Copyright 主要属于发起者。 命名规则如下: indi.发起者名.项目名.模块名 pers（personal）–&gt; 个人发起，独自完成，可分享的项目，Copyright 属于个人。 命名规则如下: pers.个人名.项目名.模块名 人发起，独自完成，非公开的私人使用的项目，Copyright 属于个人。 命名规则如下: priv.个人名.项目名.模块名","link":"/2017/10/12/java-cheng-xu-she-ji-ji-chu/"},{"title":"Java 程序设计基础之 Java 变量","text":"变(常)量——Java 程序中最基础的元素。我们在前面提到过，Java 字面值是 Java 数据具体、直观的表现，就是一个具体的值。事实上， Java 中字面值的主要功能就是来给变量、常量进行赋值用的。程序设计语言中变量的引入是至关重要的，有了变量后续的一切才是有意义的。 Java 变量什么是变量变量你可以将其看成是一个个带有名字的小盒子，用来存放我们的数据（字面值），方便后续在程序中引用（使用），这是有意义的。 严格来说， 在 Java 中，变量是指向计算机内存中的某一存储区域的引用，该区域有自己的名称（变量名）和数据类型（变量类型）。 事实上，变量的类型是，变量所指向的存储区域中所存储数据的类型。 该区域的数据可以在同一类型范围内不断的变化~ 变量定义Java 语言是强类型（Strongly Typed）语言，强类型包含以下两方面的含义： 所有的变量必须先定义（声明）、后使用 指定数据类型的变量只能接受类型与之匹配的值 定义（声明）变量，就是要告诉编译器这个变量的数据类型，和变量的名称，编译器才知道它能存放什么样的数据，需要分配多少空间给它，以及如何找到它。 1 –&gt; 声明变量 在 java 中用户可以通过指定数据类型和标识符来声明变量，其基本语法如下所示： DataType identifier; 或者： DataType identifier=value; 注意：同一代码块范围内不允许有多个相同命名的变量。 2 –&gt; 初始化变量 初始化变量是指为变量指定一个明确的初始值，变量声明后并不会分配内存空间，只有赋值之后才会分配内存。 初始化变量有两种方式： 声明时直接赋值 先声明、后赋值。 123456// 声明时直接赋值char usersex='female';// 先声明、后赋值String username;username = &quot;Wangyi&quot;; 多个同类型的变量可以同时定义或者初始化，但是多个变量中间要使用逗号分隔，声明结束时用分号分隔。 123# Java 编码规范中不推荐使用String username,address,phone,tel; // 声明多个变量int num1=12,num2=23,result=35; // 声明并初始化多个变量 Java 中初始化变量时需要注意以下事项： 变量是类或者结构中的字段（属性），如果没有显式地初始化，默认状态下会创建变量并初始化为【默认值】，默认值见：【数据类型默认值对照表】。 方法中的变量必须显式地初始化，否则在 使用该变量时 就会出错 常量常量，一种特殊的变量！ 当使用 final 关键字来修饰一个变量时，就成为一个 常量，也称为 final 变量。Java 语言使用 final 关键字来定义一个常量，其语法如下所示： final dataType variableName = value 常量有很多种说法，比如不能改变等等。但更为准确的描述是： 当一个变量被 final 修饰的时候，该变量 只有一次赋值的机会！！！ ========================================== You Need Know More: final 关键字不仅可以用来修饰基本数据类型的常量（或引用类型的变量），还可以用来修饰类、和方法。 当定义的 final 变量为成员变量（类或结构中的属性）时，必须在定义时就设定它的初始值（没有显式初始化，会被隐式初始化为0），如果再次对其进行赋值将会提示编译错误 当定义的 final 变量为方法中的局部变量时，则需要开发者在声明后，第一次使用该变量之前，显式的赋初始值，实例化该变量 Java 中 final 修饰符的用法详细见：Java 中的 final 修饰符，你可以看到 final 修饰类，方法的使用场景。 变量的作用域变量的作用域，也称为：变量的有效范围。 变量的有效范围是指：程序代码中能够访问该变量的区域，若超出该区域进行访问，则在编译时会出现错误。 在程序中，一般会根据变量的有效范围将变量划分为： 成员变量 局部变量 成员变量成员变量是指：定义在类下面，不属于任何一个方法的变量。 别名：字段，属性，Field 作用域是：从变量声明的位置开始，整个类都可以访问得到 类中的成员变量，根据是否有无 static 修饰符修饰，可以分为： 1 –&gt; 实例变量 无 static 修饰符修饰；访问方式：对象名.变量名；生命周期：只要对象被当作引用，实例变量就将存在。 2 –&gt; 类变量（静态变量） 有 static 修饰符修饰；访问方式：类名.变量名（推荐，编码规范），或对象名.变量名；生命周期：其生命周期取决于类的生命周期，类被垃圾回收机制彻底回收时才会被销毁。 注意：Java 中 static 关键字只作用于成员变量，局部变量无法使用 static 修饰。 示例代码如下： 变量声明代码如下所示： 12345678public class DataTest { String name; int age; static final String website = &quot;orangeshare.cn&quot;; static String url = &quot;https://www.orangeshare.cn&quot;;} 测试类代码如下所示： 12345678910111213141516171819public class HelloJava { public static void main(String[] args) { // TODO Auto-generated method stub DataTest dataTest = new DataTest(); // 创建类的对象 // 实例变量调用方法（对象名.变量名）： System.out.println(dataTest.name); System.out.println(dataTest.age); // 类变量调用方法（类.变量名）： System.out.println(DataTest.website); System.out.println(DataTest.url); // 类变量调用方法（对象名.变量名）： System.out.println(dataTest.website); System.out.println(dataTest.url); } } 上面，name 和 age 显示系统默认初始化的值，website 和 URL 显示初始化的值。且用 static final 修饰的变量必须赋予初始值。 关于 static 修饰符的用法详细见：Java 中的 static 修饰符。 局部变量局部变量是指：在方法或者方法代码块中定义的变量。 别名：参数 根据其所处的位置可以分为三种： 1 –&gt; 方法局部变量（方法内定义） 作用域是：从定义这个变量开始到方法结束这一段时间内有效。 2 –&gt; 方法参数变量（形参） 作用域是：整个方法内均有效。局部变量在使用前必须主动初始化值。 3 –&gt; 代码块局部变量（代码块内定义） 作用域是：从定义这个变量开始到代码块结束这一段时间内有效。 观察下面程序是否可正常运行： 123456789101112131415public class HelloJava { public static void main(String[] args) { // TODO Auto-generated method stub System.out.println(&quot;Hello, Java World!&quot;); for (int i = 0; i &lt; 5; i++) { } System.out.println(i); // 无效作用域 } } 重名问题想象一种场景：如果局部变量和成员变量重名，那么在方法中调用打印标识符时，显示的是局部变量的值，还是成员变量的值？ java 采用局部优先的思想。局部变量可以和成员变量相同，使用标识符调用时，优先使用局部变量。想调用成员变量怎么办？如果该变量是实例变量，可使用 this.变量名，否者可使用 类.变量名。 数据类型默认值对照表 数据类型 初始值 boolean false char ‘/uoooo’(null) byte (byte)0 short (short)0 int 0 long 0L float 0.0f double 0.0d 引用型（String等） null 注：引用型数据类型包括：类(class)、接口（interface）、数组（Array）、字符串（String），默认值都为 null。","link":"/2017/10/13/java-cheng-xu-she-ji-ji-chu-zhi-java-bian-liang/"},{"title":"Java 程序设计基础之字面值","text":"所有计算机编程语言的设计初衷，都是为了高效地解决现实世界里的繁琐任务。所谓巧妇难为无米之炊，第一步要做的就是从现实实体中提取出，可用于计算机输入的表达。比如现实世界中最常见的数字、文字、图像、声音等等，在 Java 世界统一被称为：【数据】，有了数据才有后续的一切。 Java 字面值字面值就是数据。 一个具体的数字（3.2，996），或是一个字符串（”I love China“）——文本，都是一个字面值。 字面值，本身就是一个具体（固定的）的值，也只是一个值，是数据最具体，直观的表现。 符合 Java 字面值定义的字面值示例：10，100，3.14，true，false，”I am a Chinese”，’A’，‘b’ 字面值类型我们知道，数据在现实世界中是分门别类的，比如整数、小数、文本等等。将其映射到 Java 中也是一样的。 Java 中对数据的数据类型也是有明确分类定义的，分为：基本数据类型（Primitive Type）和引用数据类型（Reference Type）。 后续章节，我们会更加深入的了解 Java 中定义的数据类型以及其使用。这里如有不理解的地方，不要深究，等待深入学习之后再来进行回顾就一目了然了。 这里，探讨字面值类型的主要目的，是为了明确： Java 中我们可以使用什么数据类型的变量或者常量存储字面值，或是特定数据类型变量或者常量可以使用什么类型的字面值进行赋值，这是关键的！ 根据 Java 的基本数据类型和引用类型，Java 中的字面值类型大致可分为：整型字面值、浮点字面值、布尔型字面值、字符和字符串字面值 以及 特殊字面值 五大类 整型字面值Java 的整型字面值值主要有如下 4 种形式（4 种进制表示）： 十进制数形式（默认）：基 10, 包含从 0-9 的数字。如：54、-67、0。 八进制形式：基 8, 包含从 0-7 的数字，八进制字面值的表示 以 0 开头，如：0125 表示十进制数 85，-013 表示十进制数 -11。 十六进制形式：基 16, 包含从 0-9 的数字，和从 A-F 的字母。十六进制字面值的表示 以 0x 或 0X 开头，如 ：0x100 表示十进制数 256，-0x16 表示十进制数 -22。 二进制形式: 基 2, 包含 0 和 1。二进制字面值的表示 以 0b 或 0B 开头，如：0b11010。 –&gt; 默认情况下，整型字面值对应的是 基本数据类型——整数类型 中的 int 类型（整型），默认在内存中占 32 位。 –&gt; 当整型字面值以 l 或者 L 结尾时（建议使用大写的 L 而非小写的 l，因为容易和 1 混淆），对应的是 基本数据类型——整数类型 中的 long 类型（长整型），表示一个长整型数，它在内存中占 64 位。 –&gt; 如果你可以确定整型字面值（不以 L 结尾）在 基本数据类型——整数类型 中的 byte， short 取值范围之内，你可以把它赋值给 byte(8 bit)， short(16 bit) 类型（字节型，短整型），Java 会自动完成转换，如果试图将超出范围的字面值赋给某一类型（比如把 128 赋给 byte 类型），编译通不过。 浮点型字面值Java 的浮点字面值主要有如下 2 种形式： 小数：如 12.34、-98.0。 科学记数法形式：如 1.75e5 ，2.38E3，其中 e 或 E 之前必须有数字，且 e 或 E 之后的数字必须为整数。 默认情况下（或以 d 或者 D 结尾，写不写都行），浮点字面值是具有双精度型（double）的，对应的是 基本数据类型——浮点类型 中的 double 类型（双精度浮点型），在内存中占 64 位。 当浮点字面值以 f 或者 F 结尾的时，对应的是 基本数据类型——浮点类型 中的 float 类型（单精度浮点型），在内存中占 64 位。 布尔型字面值Java 的布尔型字面值，对应的是 基本数据类型——布尔类型 ，即 boolean 类型。 只有两个值，即 false（假）和 true（真）。 字符型和字符串字面值1 –&gt; 字符型字面值 Java 中的字符型字面值，是用单引号（英文输入）引起来的一个字符，如 ‘e’、E’。 注意，字符型字面值中的字符可以八进制或者十六进制，八进制使用 ‘反斜杠加3位八进制数字’ 表示，例如 ‘\\141’ 表示字母 a。十六进制使用 ‘\\u加上4为十六进制的数’ 表示，如 ‘\\u0061’ 表示字符 a。 不能直接输入的字符，可以使用 转义字符，如 ‘\\n’，‘\\t’，‘\\r’。常见的转义字符序列有： \\ddd(八进制) 、 \\uxxxx(十六进制Unicode字符)、'（单引号）、&quot;（双引号）、\\ （反斜杠）\\r（回车符） \\n（换行符） \\f（换页符） \\t（制表符） \\b（回格符） 2 –&gt; 字符串字面值 字符串字面值则使用双引号引起来的单个或多个字符。如：“I love China” 字符串字面值中同样可以包含字符字面值中的 转义字符序列。字符串必须位于同一行或者使用 + 运算符，因为Java 没有续行转义序列。 Java 字符串字面值中的单引号和双引号不可混用。字符串中包含双引号时，需要对其进行转义处理。 特殊字面值null 是 Java 数据类型中的一种特殊数据类型。 这里将其也看作是一种特殊字面值，它可以赋值给 Java 中的任意 引用类型。 最后，再次重申一遍：字面值就是一个具体的值。 可以看出，Java 字面值和前面我们说过的，Java 标识符和关键字一样，都是 Java 语法中最最基础的定义。","link":"/2017/10/12/java-cheng-xu-she-ji-ji-chu-zhi-zi-mian-zhi/"},{"title":"MarkdownPad2 安装以及常见问题解决教程","text":"Markdown 是一种轻量级的，可以使用 普通文本编辑器编写 的标记语言。它允许所有的写作爱好者（Sharer）可以专注于内容而不是纠结于字体字号行间距等等排版问题（沉浸式写作），使用易读易写的纯文本格式编写文档，然后就可以转化成格式丰富优美的 HTML 页面或 PDF（所思即所得）。 MarkdownPad2 Setup And Crack In WindowsMarkdownPad2 可以在官网得到下载文件，传送门 –&gt; Markdown 官网，点击后自动下载，界面如下： 安装好后直接开始安装，一路 「Next」 即可，安装完成打开后会让升级到豪华版（Pro）。开始破解，点击 「Enter Key」 进入后输入账号密钥。此处提供一个来自网络上的账号（膜拜大佬吧）： Email address : Soar360@live.com License key： 1GBPduHjWfJU1mZqcPM3BikjYKF6xKhlKIys3i1MU2eJHqWGImDHzWdD6xhMNLGVpbP2M5SN6bnxn2kSE8qHqNY5QaaRxmO3YSMHxlv2EYpjdwLcPwfeTG7kUdnhKE0vVy4RidP6Y2wZ0q74f47fzsZo45JE2hfQBFi2O9Jldjp1mW8HUpTtLA2a5/sQytXJUQl/QKO0jUQY4pa5CCx20sV1ClOTZtAGngSOJtIOFXK599sBr5aIEFyH0K7H4BoNMiiDMnxt1rD8Vb/ikJdhGMMQr0R4B+L3nWU97eaVPTRKfWGDE8/eAgKzpGwrQQoDh+nzX1xoVQ8NAuH+s4UcSeQ== 直接粘贴后点击 「OK」 激活成功！至此 MarkdownPad2 安装以及破解已经完成。 Common Problem &amp;&amp; Solution汉化MarkdownPad2 汉化非常简单，已内置汉化包。选择左上角的 「TOOL」 下的 「option」 后在语言栏选择简体中文即可。 右侧无法预览MarkdownPad2 正常安装完成后，即可直接使用标记语言开始写作了，你可以直接在右侧实时预览效果（F5 开启预览功能）。 Win10 安装打开后，你可能会发现右侧预览栏无法显示: 查阅相关资料后需要安装一个插件: To fix this issue, please try installing the Awesomium 1.6.6 SDK. 安装也是全程 「next」 即可，安装过程如下： 安装成功后，关闭软件再次打开即可正常使用 Markdown 了！ 表格以及代码无法显示使用 Markdown 插入表格和代码有时会发现无法正常显示，事实上，你只需要更改一下 Markdown 处理器就可以了： 中文版： 工具 –&gt; 选项 –&gt; Markdown –&gt; Markdown 处理器改为: GitHub Flavored Markdown(Offling) 英文版： Tools –&gt; Options –&gt; MarkDown –&gt; Markdown Processor –&gt; GitHub Flavored Markdown(Offling) 【持续更新…】","link":"/2017/09/20/markdownpad2-an-zhuang-yi-ji-chang-jian-wen-ti-jie-jue-jiao-cheng/"},{"title":"Python-Vers Management","text":"Foreword 设想 –&gt; 场景一：A 项目是一个爬虫项目，需要用到 requests、pyspider、scrapy 等包或框架；B 项目是一个 GUI 界面项目，需要用到 GUI 相关的包或库；这需要把所有用到的包安装到原生 Python 环境中，开发环境越来越臃肿。场景二：C 项目是一个 Python2.x 项目；D 项目是一个 Python3.x；两项目要求的 Python 版本不兼容。怎么办？！！ 前面提到过一个系统中是可以同时存在多个 Python 版本的，它可以完美的解决上述问题，但是你需要注意新添加的 Python 环境对系统既有环境的影响，这就涉及到系统中多个 Python 版本的管理。 Python-Vers Introduction目前，Python 有两个主流的版本： 分别为：2.x 版本 和 3.x 版本。 Python 3.0 是一次重大的升级，为了避免引入历史包袱，Python 3.0 没有考虑与 Python 2.x 的兼容（不完全兼容），这也就导致很长时间以来，将现有应用从 Python 2.x 迁移到 Python 3.x 是一项不小的挑战。 虽说有 2to3 之类的工具可以进行代码的自动转换，但无法保证转换后的代码 100% 正确。而且，如果不做人工修改的话，转换后的代码性能可能还不如转换前。故很多 Python 2.x 的用户不愿意升级到 Python 3.0 2.x &amp; 3.x 版本的不兼容，引发如下问题： 我们给出一种实际情况 –&gt; 原生 Unix &amp; Linux 系统已经自带有一个版本的 Python2，但它不是我们需要的 Python 版本，我们想要编译安装满足我们需要的 Python 版本（Python3）。那么我们面临一种选择：是在原有版本基础上 Update（2.x –&gt; 3.x） 呢？还是去 Setup 一个新版本的 Python（原生版本 Python 也保留）？ Update 存在的问题 –&gt; 事实上，由于 Python 2.x 和 Python 3.x 兼容性问题，将 Python 2.x 直接升级到 Python 3.x 会产生一些问题（Centos 系统下的很多工具（yum、iotop 等）都依赖原生 Python 2.x 版本），直接升级会无法使用。 Solution –&gt; 所以，一般建议添加安装一个新版本的 Python（与系统原生 Python 版本共存），或着使用虚拟隔离环境 Virtual Envs 进行多版本管理（这里不用深究，Virtual Envs 是一种优秀的 Python 多版本共存管理方案）。 多版本共存管理方案正如博文前言场景二中所描述，实际 Python 开发过程中，多 Python 版本开发环境是我们必然要面对的问题。 关键在于：如何保证多个 Python 版本安装、配置以及使用之间互相不产生影响呢？ 这就是当前小节讨论的内容，这里会对网络上主流的几种方案进行试验、分析，你可以根据自身情况选择一个适合开发场景的解决 Python 多版本共存冲突问题的解决方案。 Using Symbolic Link一个简单、快捷的解决多版本冲突问题的方案 –&gt; 使用软链接 核心思想：在系统原生 Python 版本的基础上，再安装（Add）一个目标版本的 Python 环境，且保证新安装 Python 不会影响原生环境，以实现目标版本和原生版本完美共存。 For Unix &amp; Linux Platform在介绍 Unix &amp; Linux 平台下安装 Python 时，已经给出了具体的解决方法: 1 –&gt; 源码编译安装 注意在使用源码安装过程中，不要勾选有关自动添加环境变量的选项（默认不勾选），安装成功后手动设置即可，否则会影响原生环境。 安装步骤见前面系列博文，这里不再赘述。 2 –&gt; 构建软链接 Unix &amp;&amp; Linux 下可以通过构建多个带有不同版本标识的 Python 软链接： 注意，不要去覆盖原生的 /usr/local/bin/python 或 /usr/bin/python 1234# python 3.5 symbolic linkln -s /usr/local/python3.5/bin/python3.5 /usr/local/bin/python3.5# python 2.7 symbolic linkln -s /usr/local/python2.7/bin/python2.7 /usr/local/bin/python2.7 创建软链接后，在使用 Python 时，我们可以启动相应版本的 Python 了： 12345678# 启动系统原生环境：python# 启动 python2.7 环境：python2.7# 启动 python3.5 环境：python3.5 For Windows Platform那么 Windows 下如何实现呢？Windows 下是通过设置环境变量来达成的。 1 –&gt; 二进制包安装 注意在使用二进制包安装过程中，不要勾选有关自动添加环境变量的选项（默认不勾选），安装成功后手动设置即可，否则会影响原生环境。 安装步骤见前面系列博文，这里不再赘述。 2 –&gt; 配置系统环境变量 推荐修改环境变量中设置的 Python 安装目录路径即可，想用那个版本就指向那个版本。 思考：可能有些同学会将多个 Python 安装目录同时添加到系统的环境变量中，以期待可以同时使用多个版本的 Python。这是有问题的，系统搜索程序或可执行文件的路径（$PATH）是具有优先级的！，路径在系统 PATH 变量中设置越靠前，越先被检索到。 ================================================ 至此，我们就可以在当前系统中同时存在多个 Python 版本供我们选择使用！ 使用软链接 实现多版本冲突问题存在一定的缺陷： 不进行特殊安装、配置记录的话，一段时间后，容易引发系统中的 Python 版本管理混乱； Windows 下各版本 Python 环境切换繁琐，并且极易发生库管理混乱问题； 需要开发人员手动进行 Python 版本的管理，很繁琐。 那有没有更好的 Python 多版本共存的解决方案？？？ 答案肯定是有的！！！ Virtual Envs Tools（Recommended）除了上述给出的方法外，虚拟环境管理工具 是一种完美解决 Python 的多版本共存问题的最优解决方案。 什么是虚拟管理工具？Python 的正式学习之后，相信你肯定会对 “Python 实现其强大功能的前提，就是它具有数量庞大且功能相对完善的标准库和第三方库。通过对库的引用，能够快速实现对不同领域业务的开发。” 有比较深入的理解。 1 –&gt; 为什么引入虚拟环境管理工具？ 引入虚拟环境管理工具 –&gt; 可以帮助你完美解决： 不同学习、开发项目对 Python 环境的要求不同（可能使用 Python2.x，可能使用 Python3.x）; 配合包管理工具（Pip），管理以及维护 Python 中数量庞大的标准库和第三方库，这是复杂也是重要的！ 2 –&gt; 虚拟环境管理工具可以做什么? Virtual Envs Toos 可以创建任意多个虚拟环境（可以看作成一个个容器），使用时指定到（切换到）某一虚拟环境之后 Pip 安装的包、库就只会在这个环境（容器）下；并且各虚拟环境（容器）之间，以及虚拟环境和系统原生环境之间是隔离的（一个个相互独立、隔离的容器）。 假设某一个虚拟环境预计不再使用，可以直接删除掉相应虚拟环境，由于虚拟环境的独立、隔离性，不用关注文件残留、关联问题。 通俗来说，Virtual Envs Toos 可以为每个 Python 项目，甚至每个脚本各自建立一套 “独立、隔离” 的 Python 环境（环境中可以自定义特定的 Python 版本以及特定的依赖库）。NB~ virtualenv &amp;&amp; conda这里给出两种用于解决 Python 多版本共存冲突问题的虚拟环境管理工具（神器）： virtualenv conda virtualenv &amp; conda 都可以进行虚拟隔离环境管理，但两者之间也存在一定的 区别： 准确来说，virtualenv 仅仅是虚拟环境管理器，conda 相当于：virtualenv（虚拟隔离环境） + pip（包管理工具），也就是说 conda 同时具有虚拟环境管理和包管理的功能； 作为包管理器，pip 只能安装 python 的包，而 conda 还可以安装一些不是基于 Python 开发的工具软件，但遗憾的是，相较于 pip，conda 作为包管理器一般且会安装过多依赖。故推荐，在无特殊需求安装应用时，可以先选择使用 pip install packagename 进行安装，如果无法安装的话，再尝试使用 conda install packagename 进行安装。 作为虚拟环境，conda 虚拟环境是独立与于系统原生 Python 环境的，即无论系统 Python 解释器什么版本（哪怕 2.7），你也可以指定虚拟环境中 Python 版本为 3.6；而 virtualenv 是依赖系统主环境的，只能虚拟系统中已安装解释器版本的 Python 环境。 事实上，一般不单独使用 virtualenv 和 conda 工具进行 Python 版本管理，而 选用 virtualenv &amp;&amp; conda 的扩展应用 来进行管理 –&gt; virtualenv –&gt; virtualenvwrapper conda –&gt; anaconda(miniconda) 这里是为了以一种更方便、高效、愉悦的方式来使用 virtualenv &amp;&amp; conda。 篇幅原因，关于 virtualenv(virtualenvwrapper) &amp;&amp; conda(anaconda/miniconda) 的使用方法可见相关系列博文： Pythoner 神器之 virtualenv 一文了解数据科学神器 Anaconda","link":"/2018/01/02/python-vers-management/"},{"title":"Hello Hexo World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick Start如果你使用的是 Hexo Matery 主题的话，你可以参考系列博文： Hello, Hexo Matery World Create a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files12$ hexo clean$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment Begin To Edit Article博文编写分为两步： 设置博文的 Front-Matter 创作博文内容 Doc Front-Matter PolicyFront-matter is a block of YAML or JSON at the beginning of the file that is used to configure settings for your writings. Front-matter is terminated by three dashes when written in YAML or three semicolons when written in JSON. YAML 1234---title: Hello Worlddate: 2013/7/13 20:46:25--- JSON 123&quot;title&quot;: &quot;Hello World&quot;,&quot;date&quot;: &quot;2013/7/13 20:46:25&quot;;;; Front-matter 选项中的所有内容均为 非必填 的。推荐至少填写 title 和 date 的值。 Setting Description Default title Title Filename (posts only) date Published date File created date updated Updated date File updated date tags Tags (Not available for pages) categories Categories (Not available for pages) toc Article Contents false 以下为文章的 Front-matter 示例。 The Simple Demo1234---title: Hello Hexodate: 2017-12-18 00:55:00--- The Most Complete Demo1234567---title: Hello, Hexo Worlddate: 2017-12-18 00:55:00categories: [Markdown, Hexo]tags: [Markdown, Hexo]toc: true--- 学会 Front-Matter Policy 之后，你就可以开始正式的创作了~~~","link":"/2017/09/20/hello-world/"},{"title":"一文了解什么是 Java","text":"Java 是一门经典的面向对象编程语言，是基于 C++ 发展起来的，你可以将其看作是 C++ 的 “纯净” 版，它不仅吸收了 C++ 语言的各种优点，还摒弃了 C++ 中难以理解的指针等部分。再加上刚好赶上互联网的“顺风车”，随着 Internet 和 WWW 的迅速发展，Java 成为了越来越受欢迎的语言。尽管经历了近 30 年的技术变革，但 Java 仍然是当前开发基于 Web 的应用程序的最佳选择。 Java 起源及发展–&gt; Java 前身 起初（90 年代初），Sun Microsystems 公司为了开发一种用于编写 “家用电器的小型交互式系统” 的编程语言，如手机、机顶盒、面包机等。由于当时设备平台（硬件和操作系统）多样化，即需要该编程语言具有良好的跨平台能力，而且这些家用设备不足以运行大型程序（小内存），故开发了基于 C++ 的 Oak（橡树）语言。 –&gt; Java 的正式诞生 Oak 语言的诞生，就像 C/C++ 语言的诞生一样，开发者都寄予了很大的期望。但事实上，基于 Oak 语言所开发的智能化家电的市场需求远没有没有预期的那么高，不得以 Sun 公司放弃了该项计划。 绝境中往往孕育着机遇！90 年代随着互联网的迅猛发展，Sun 公司发现 Oak 在互联网上的应用前景，于是再一次做出尝试，改造了 Oak。 1995 年，Sun 公司正式发布了第一个 Java 版本，Java 正式诞生！！！ 2010 年 Oracle（甲骨文）公司收购 Sun Microsystems 公司，之后由 Oracle 公司负责 Java 的维护和版本升级。 随着互联网的迅速发展，定位于网络运算的 Java 语言，特别适合于开发网络应用程序，于是 Java “热” 迅速席卷全球。 Java 开篇Java 不仅仅是一门编程语言，还是一个平台。Java 平台由 Java 虚拟机（Java Virtual Machine，JVM）和 Java 应用编程接口（Application Programming Interface，API）构成。Java 应用编程接口提供了一套独立于操作系统的标准接口，可分为基本部分和扩展部分。 在硬件或操作系统平台上安装一个 Java 平台之后，Java 应用程序就可运行。Java 平台已经嵌入了几乎所有的操作系统，这样 Java 程序只编译一次，就可以在各种系统中运行。 JDK &amp; JRE为了编程人员开发和运行 Java 程序，Sun 公司免费推出了 Java 的开发、运行工具 —— JDK（Java Development Kit，Java 开发工具包）。 有时候，你可能会遇到如下说法： 1 –&gt; Java SDK 我们先来认识一下 SDK： SDK 说法：全称 Software Development Kit，即软件开发工具包，覆盖面很广泛的一个说法。可以这么说：辅助某一类软件开发的相关文档、范例和工具的集合都可以叫做 “SDK”，它为软件的开发提供一个平台。 JDK 是 Java 开发工具包，专为开发、运行 Java 设计而生，是 SDK 的一个子集。 所以，你可以说：JDK 是 Java SDK（Java Software Development Kit），这也没问题。 2 –&gt; Java 2 Java 1.2 版本之后发布的 Java 版本都可以称为：Java 2。 Java 5（Java 7/8/9）：Java 1.5（Java 1.7/1.8/1.9）版本。 所以，现在我们说的 Java，更多的是指 Java 2 平台。 3 –&gt; J2 SDK J2 SDK，全称 Java2 Software Development Kit，包含 JDK、JRE（Java Runtime Environment）等。 JRE：Java Runtime Environment，Java 运行环境，是运行 JAVA 程序所必须的环境的集合。 但要注意的是，JDK 中也包含一套单独的 JRE。 J2 SDK 一般特指 Java 2 平台的 JDK，开发人员必装，可进行 Java 程序的开发、运行。 J2 JRE 就是 Java 2 平台的 JRE，Java 客户端运行必装。如果你只需要运行 Java 程序，只需要安装 JRE 即可。 J2SE &amp; J2EE &amp; J2ME为了推广 Java，根据应用领域的不同，Java 可以分为 3 个体系： 1 –&gt; J2SE J2SE，也称为 Java SE（Java Platform Standard Edition，Java 平台标准版），它允许开发和部署在桌面、服务器、嵌入式环境和实时环境中使用的 Java 应用程序，是 Java 系统的标准与核心平台。 Java SE 包含了 Java 语言基础、JDBC 操作、I/O 操作、JavaSwing 以及多线程等技术，还提供了支持 Java Web 服务开发的类库。 Java SE 平台体系示意图如下： 2 –&gt; J2EE J2EE，也称为 Java EE（Java Platform Enterprise Edition，Java 平台企业版），帮助企业开发和部署可移植、健壮、可伸缩且安全的服务器端 B/S架构的 Java 应用程序。 Java EE 是在 Java SE 基础上构建的，个人理解就是在 J2SE 平台的基础上，添砖加瓦后出现的。它提供 Web 服务、组件模型、管理和通信 API等： servlet jsp spring mybatis … 3 –&gt; J2ME J2ME，也称为 （Java Platform Micro Edition，Java 平台微型版）， Java ME 为在移动设备和嵌入式设备（比如手机、PDA、电视机顶盒和打印机）上运行的应用程序提供一个健壮且灵活的环境。 ============================================== 关系图示： Java 特点Java 语言是一种分布式的面向对象语言，具有面向对象、平台无关性、简单性、解释执行、多线程、安全性等很多特点，下面针对这些特点进行逐一介绍。 面向对象Java 是一种纯面向对象的语言。使用 Java 语言开发程序，需要采用面向对象的思想设计程序和编写代码。 和 C++ 相比，Java 更加纯粹，所有内容都被封装到类中。 1 –&gt; 面向对象的核心： 以更接近人的思维去建立计算机逻辑，利用类和对象对数据和操作的分装到一起，并通过定义统一的接口去和 “外界” 交互，使反映实体的类在程序中能够独立、自治和继承 2 –&gt; 面向对象的程序设计： 从实际问题中抽象出封装了数据和操作的对象，定义其属性和操作，以及接口实现交互，形成一个接近于实际问题的动态对象模式。 简单易学Java 语言是基于 C++ 创建的，所以 Java 语言的风格很像 C/C++ 语言，但要比 C++ 更纯粹。 继承了 C++ 语言面向对象的技术核心，但是拋弃了 C++ 的一些缺点，比如说容易引起错误的指针、操作符重载以及多继承等，同时也增加了垃圾回收机制，释放掉不被使用的内存空间，解决了管理内存空间的烦恼。 基础语法同 C 语言几乎一模一样，便于学习。 平台无关性Java 提出 “Write Once，Run any Where”，即 “一次编写，到处运行”。 Java 编译后产生一种 二进制字节码文件，任何操作系统平台，只要安装有 Java 虚拟机都可以解释执行。并且 Java 中的原始数据存储都是固定的，如任何机器，int 都是 32 位。理所当然，使整数类型平台无关后性能必然下降，但这带来的跨平台特性是值得的。 Java 语言使用 Java 虚拟机机制屏蔽了具体平台的相关信息，使得 Java 语言编译的程序只需生成虚拟机上的目标代码，就可以在多种平台上不加修改地运行。 解释型语言Java 程序在 Java 平台运行时会被编译成字节码文件，在运行文件时，Java 的解释器对这些字节码进行解释执行。 看起来，逐条解释执行，导致单机运行很慢。但事实上，JVM 中采用了即时编译机制（JIT）可以很大程度上的优化，Java 的运行速度也越来越高。 多线程Java 语言是多线程的，但它必须由 Thread 类和它的子类来创建。Java 支持多个线程同时执行，并提供多线程之间的同步机制。 分布式Java 语言支持 Internet 应用的开发，在 Java 的基本应用编程接口中就有一个网络应用编程接口，它提供了网络应用编程的类库，包括 URL、URLConnection、Socket 等。Java 的 RIM 机制也是开发分布式应用的重要手段。 健壮性Java 的强类型机制、异常处理、垃圾回收机制等都是 Java 健壮性的重要保证。对指针的丢弃是 Java 的一大进步。另外，Java 的异常机制也是健壮性的一大体现。 安全性Java 通常被用在网络环境中，为此，Java 提供了一个安全机制以防止恶意代码的攻击。 除了 Java 语言具有许多的安全特性以外，Java 还对通过网络下载的类增加一个安全防范机制，分配不同的名字空间以防替代本地的同名类，并包含安全管理机制。 丰富的类库支持Java 中提供了丰富的类库支持，这些类库存放于 Java 系统的各种包（Package）中，有接口、类、异常处理等等 1 –&gt; java.lang Java 语言包，提供了包括字符串处理，多线程处理，数学函数处理等各种基础类。 2 –&gt; java.io Java 输入输出包，用统一的 “流” 模型来实现所有格式的输入、输出。通过数据流，序列化，文件系统提供系统输入输出。 3 –&gt; java.awt/javax.swing Java 图形用户接口包，提供实现不同平台的计算机图形用户接口部件，包括窗口，菜单，滚动条等等组件。 4 –&gt; java.sql Java 数据库包，提供了用户进行数据库操作的驱动程序和应用程序接口。 5 –&gt; java.util Java 应用程序工具包，支持哈希表，堆栈，可变数组，时间和日期，集合框架，事件模型和各种实用工具类（随机数生成器、位数组等等）。 6 –&gt; java.net Java 网络包，提供了实现网络编程的 URL，Socket 编程，还支持 Internet 的 ICP/IP 协议，提供了与 Internet 的接口。","link":"/2017/10/08/yi-wen-liao-jie-shi-me-shi-java/"},{"title":"一文了解数据科学神器 Anaconda","text":"我们知道：Python 是一种面向对象的解释型计算机程序设计语言，其使用具有跨平台的特点，可以在 Linux、macOS 以及 Windows 系统中安装环境并使用。也就是说，其编写的代码在不同平台上运行时，几乎不需要做较大的改动，使用者无不受益于它的便捷性。 此外，Python的强大之处在于它的应用领域范围之广，遍及人工智能、科学计算、Web开发、系统运维、大数据及云计算、金融、游戏开发等等。而实现其强大功能的前提，就是 Python 具有数量庞大且功能相对完善的标准库和第三方库。通过对库的引用，能够实现对不同领域业务的开发。 然而正是由于库的数量庞大，对于这些库的管理维护成为既重要但复杂度又高的事情，这对于 Python 开发人员来说是极不友好的。同时 Python 多版本控制也是 Python 开发过程中极其常见的并且难以管理的。此时，Anaconda 粉墨登场… Anaconda 提供一种使用虚拟隔离环境来解决库管理以及维护问题的策略，它通过 conda 工具解决了 Python 开发者的两大痛点： 提供包管理：功能类似于 pip，Windows 平台安装第三方包经常失败的场景得以解决； 提供虚拟环境管理：功能类似于 virtualenv，解决了多版本 Python 并存问题。 话不多说了，下面我们正式开始 Anaconda 的学习： What Is Anaconda？Anaconda 官方地址：https://www.anaconda.com/ IntroductionAnaconda 就是可以便捷获取包且对包进行管理，同时对环境进行统一管理的开源的 Python 发行版本。其包含了Conda、Python 等 180 多个科学包及其依赖项。 由于包含了大量的科学计算包，Anaconda 的下载文件比较大（约 500 MB），如果只需要某些包，或者需要节省带宽或存储空间，也可以使用 Miniconda 这个较小的发行版（仅包含 conda 和 Python）。 AdvantagesAnaconda 拥有 Conda 包、环境管理器、Conda 包、1,000+ 开源库 等等，Anaconda 还具有如下特点： 开源 安装、配置过程简单 高性能使用 Python 和 R 语言 免费的社区支持 Conda &amp;&amp; Pip &amp;&amp; Virtualenv进行 Python 学习、开发过程中，你肯定听说或者使用过 Pip 包管理工具、Virtualenv 虚拟环境管理器，再加上这里我们提到的 Anaconda、conda 工具。下面我们来横向比较一下这些工具的区别: 1 –&gt; Anaconda Anaconda 是一个包含 180+ 的科学包及其依赖项的 Python 发行版本。其包含的科学包包括：conda, numpy, scipy, ipython, jupyter notebook 等等，你可以将其理解为一个 Python 的开发生态圈。 2 –&gt; conda conda 是包管理工具，也是虚拟环境管理以及维护工具； conda 为 Python 项目而创造，但同样也适用于：Python, R, Ruby, Lua, Scala, Java, JavaScript, C/C++, FORTRAN 等语言； 适用平台：Windows, macOS, Linux； Conda 主要用途： 通过 conda 快速安装、运行和升级包及其依赖项； 使用 conda 可以在计算机中便捷地创建、保存、加载和切换虚拟环境。 前面我们提到过多版本 Pyhton 环境的问题。如果使用 conda ，仅需要几条命令，你就可以创建一个个完全独立的环境来运行不同的 Python 版本，同时你可以继续在系统原生环境中使用你常用的 Python 版本。 3 –&gt; pip pip 是常用的用于安装和管理软件包的 Python 包管理器； pip 编写语言：Python； Python 中 pip 的默认安装： Python 2.7.9 及后续版本：默认安装，命令为 pipPython 3.4 及后续版本：默认安装，命令为 pip3 名称由来：pip 采用的是递归缩写进行命名的。其名字被普遍认为来源于两处： Pip installs Packages（pip 安装包）Pip installs Python（pip 安装 Python） 4 –&gt; Virtualenv virtualenv：用于创建一个独立的 Python 环境的工具； virtualenv 可解决的问题： 当一个程序需要使用 Python 2.7 版本，而另一个程序需要使用 Python 3.6 版本，如何同时使用这两个程序？ 如果将所有程序都安装在系统下的默认路径（如：/usr/lib/python2.7/site-packages），当不小心升级了本不该升级的程序时，将会对其他的程序造成影响。 如果想要安装程序并在程序运行时对其库或库的版本进行修改，都会导致程序的中断。 在共享主机时，无法在全局 site-packages 目录中安装包。 virtualenv 将会为它自定义的虚拟环境创建一个独立的环境，这并不与其他 virtualenv 环境共享库；同时也可以选择性地连接已安装的全局库。 Compare：Conda &amp;&amp; Pip我们已经知道，pip 和 conda 都可以用于安装和管理 Python 相关软件包以及其依赖项。那么它们有什么区别？（5 tips） 1 –&gt; 依赖项检查 pip： 不一定会展示所需其他依赖包； 安装包时或许会直接忽略依赖项而安装，仅在结果中提示错误。 conda： 罗列出所需其他依赖包； 安装包时自动安装其依赖项； 可以便捷地在包的不同版本中自由切换。 注意：同样可以在 conda 虚拟环境中安装的 pip 进行软件包的安装，所以在 conda 封装的独立环境中我们可以同时使用 conda、pip 进行包管理。 2 –&gt; 环境管理 pip：维护多个环境难度较大； conda： 比较方便地在不同环境之间进行切换，环境管理较为简单。 3 –&gt; 对系统自带 Python 的影响 pip：在系统自带 Python 中包的 更新/回退版本/卸载 将影响其他程序。 conda：多版本环境实现隔离，不会影响系统自带 Python。","link":"/2018/01/05/yi-wen-liao-jie-shu-ju-ke-xue-shen-qi-anaconda/"},{"title":"基于图床的博客图片存储解决方案","text":"一个优秀的博客图片存储解决方案—图床。 更多 Hexo 博客框架内容，请关注博主 Hexo 博文系列： 一文学会 Hexo 轻量级框架的博客搭建【持续更新】 Hexo 预安装环境部署之 Node.js Git 使用指南之初识 打造沉浸式写作体验，你需要试试-Markdown-Editor 基于图床的博客图片存储解决方案 稳定快速、高效免费的图床方案-Github-jsDelivr-PicGo Hexo 博客多设备协同管理问题【持续更新】 Pictures use in hexo当你看到这里的时候，应该已经有一个自己的 Hexo 博客了。如果还没有的话，不妨使用 Hexo 和 Markdown 来写博客和文章。 在 Hexo 使用初期，你可能也遇到过和我相似的问题： 一篇添加了本地图片的博文在你的个人博客站点无法预览显示出来。 考虑一下：为什么博客站点中的本地图片无法正常加载显示？ 事实上，这个很好理解，图片是无法直接作为 MD 文本源码的一部分插入的，只能插入图片的地址，这个地址可以是相对 MD 文件的相对路径，也可以是网络图片地址（网络图片事实上也是不可靠的，毕竟来源是第三方的，当网络图片来源被删除时也会丢失，所以很多使用网络图片的博客一段时间后就会发生图像无法显示、缺失）。 这里我们来考虑插入电脑本地图片的场景，Markdown 文档中指定的图片路径就是自己本地的路径，博客站点当然链接不到自己本地的图片了。 这里，我们先来分享一种基本的解决此问题的方法。使用 hexo-asset-image 插件来为博客插入图片： 插件下载在 Git Bash 中，进入 Hexo 站点目录下执行如下命令： 1$ npm install https://github.com/CodeFalling/hexo-asset-image --save Hexo 配置在 Hexo 站点配置文件中，搜索 post_asset_folder 关键字，并将其值设为：true： 1post_asset_folder: true 下载以及设置完成后，当你通过 hexo new “Blog Name” 新建博客后，会在 &lt;Hexo 站点目录&gt;\\source_posts 文件夹下产生一个和博文同名的文件夹（这个和博文同名文件夹可以作为当前博文的图集，远程推送时会被一起推送到远程库中）。 Demo设置后如何进行图像的插入呢？ 当博文需要添加图片时，将需要添加的图片放入和博文同名的文件夹中，同时通过【相对路径】索引到该图片即可。 例如，你想要在博文 post_name.md 中想要插入了一张图片（test.jpg）。首先你需要将图片资源放在同名文件夹 post_name 中，然后使用相对路径就可以引用到图片资源： 1![](test.jpg) 添加后你可以使用 hexo s 开启本地 Hexo 服务预览一下，发现已经可以正常显示图片了~ ========================================== 事实上，这样的使用是存在问题的： 当添加的图片比较多、比较大时，除了自己本地的博客源文件比较臃肿外，还会占用大量本地空间。再加上 Github 仓库的使用，会使得网站部署时非常的慢（推送图集）； 博客中所有的图片都是要部署到仓库的，而仓库容量是受限的，你懂得； 博文中存在大量图片时，会大大降低网页的加载速度，加载的难受啊； 哪里都有玄学….咳咳，之前的博客采用这种方法，不知道什么时候竟然丢失了一部分图片。 ┓( ´∀` )┏ 怎么办？幸好有度娘啊… 一个广泛使用的，优秀的博客图片存储解决方案 —— 图床。 Image HostImage Host（Picture Host），也称为图床。图床？！！ 何为图床？图床是指 用于储存图片，并且可以对外提供图片访问链接 的服务器。 服务器？！！难道博主又要骗我花钱买服务器拉？┓( ´∀` )┏ 事实上，有很多免费的图床可供你选择。国内和国外都有，国外的图床可能由于有空间距离等因素决定访问速度很慢影响图片显示速度（但可以通过 CDN 技术实现加速）。国内很多大中小型公司都提供免费的图床服务，注册后就可以使用（真香）。 事实上，图床的本质就是： 将图片保存在网络上，并且可以获得图片的直链地址。 爱思考的看客老爷可能已经反应过来了： 这不就是博主前面说的网络图片链接么？你不是说不可靠么？！不要担心，前面我们使用的网络图片其实是其他人提供的图床。这当然是不可靠的，毕竟你不知道什么时候这些图床就不再提供了！之后我们使用的都是自己的图床，这是可控的。 了解了图床的基本概念之后，我们再来看一下图床都有哪些优点： 图床的优点1 –&gt; 图床访问速度快 图床，一般会把图片存储到第三方的 CDN，除了加快图片访问速速，还可以降低你服务器的存储压力，后续网站迁移扩容就不受影响了。 2 –&gt; 博客前瞻性 目前，你可能只是在部署一个个人博客小网站，但是以后无论是自己的博客还是实际的项目，都可以用图片来提供外链，方便管理。 并且如果你的网站访问量很高啊，一天几十万几百万啊，这时候你考虑的就不是服务器空间够不够大，而是惊人的并发数啊，光是请求 HTML 文件（或其他）的链接就处理不过来了，哪还有多余的资源去读取图片啊，索性就把图片存另一个服务器，为主服务器缓解压力。 大致了解了图床的基本概念以及其优点，这里我们来看当前个人博客有哪些具体的图床实施方案？ 图床实施方案说到这里，图床原来就是图片网络链接啊。可能一些爱动手的看客老爷可能已经开始思绪乱飞~ 下面我们来看如何将图片保存在网络上且获得图片的链接地址方案，看客老爷可以根据个人实际情况进行选择： 网盘很多看客老爷可能想到，如果直接把图片放到各类网盘（百度、腾讯、坚果、OneDrive…）是否可行？ 事实上，虽然网盘上传图片方便快捷，免费存储空间又足够，但是网盘中的图片无法获取到链接，或者获取到链接后很快就无法使用了。 直接 Pass…. 自建图床服务器关于自建图床服务器，如果你有一台可供使用的个人服务器，可以尝试使用FTP、Nginx、PHP、MySQL、Chevereto等工具搭建个人图床服务器。 缺点就是，你需要支出必要的服务器等费用，还需要去进行相对繁琐的安装过程才可以使用。 关于自建图床服务器方法，网络上的教程很多。当然你也可关注博主相关系列博客 –&gt; 传送门（未完成，待续…）。 云存储对象腾讯云、阿里云、等云平台都提供有云储存对象支持，可以用作图床使用，配置过程也非常简单快捷。 但是缺点是，虽有免费额度，但使用量较大时，可能产生相关存储流量费用。但贵在对于访问量较少的个人博客使用很便宜甚至免费，具体收费情况可见各云平台。 特别说明，云存储对象的使用可能涉及到实名认证，域名备案等过程。 关于使用云存储对象配置图床，请参见博主相关系列博客 –&gt; 传送门（未完成，待续…）。 第三方免费图床(推荐)上面我们说过，国内外有很多免费的图床可供使用。 在选择一款免费图床平台时，你需要关注的是，图床平台服务商是否可靠，图床的流量限制、储存限制以及访问速度等。 例如：免费存储容量为10G，每月访问流量10G，每小时限制上传 20 张，每张大小小于 10M 之类的，但这对于写MD 远远够了。当然这些第三方服务商也是提供相关的收费服务的，你可以消费提升使用权限。 特别说明，一定要选择相对大平台的服务商，主要是怕图床服务商经营惨淡，挂掉以后图片就丢失了。并且有些第三方免费图床会要求进行实名认证，域名备案等。 网络上各路 主流图床推荐： 1 –&gt; 微博图床 你在查找时，很有可能查到使用微博做为博客图床的教程。 这里特别说明一下，微博图床之前使用人较多，但从2019年开始开启了防盗链，直接凉凉了…. 2 –&gt;七牛云 官网地址：https://portal.qiniu.com 简介：注册认证后有 10G 永久免费空间，每月 10G 国内和 10G 国外流量，速度相当快，七牛云是国内专业 CDN 服务商，插件支持比较多，有免费 SSL 证书，但 HTTPS 流量收费。 图片上传限制：暂无 七牛云 30 天后会回收测试域名，因此你必须要实名认证以及绑定自己的已经备案的域名。 3 –&gt;又拍云 官网地址：https://www.upyun.com 简介：注册认证后有10G永久免费空间，每月 15G 的 HTTP 和 HTTPS 流量，提供两款可以免费续期的 SSL 证书，不过用户需要加入又拍云联盟（即在网站底部添加又拍云 LOGO 及官网链接）。 图片上传限制：暂无 需要实名认证以及绑定自己的已备案域名，又拍云认证比较麻烦，建议使用七牛云。 4 –&gt;路过图床 官网地址：https://imgchr.com 简介：支持免注册上传图片，永久存储，支持 HTTPS 加密访问和调用图片，提供多种图片链接格式。 图片上传限制：最大10M 5 –&gt;SM.MS 官网地址：https://sm.ms 简介：永久存储免注册，图片链接支持 HTTPS，可以删除上传的图片，提供多种图片链接格式，有时速度可能较慢。 图片上传限制：每个图片最大 5M，每次最多上传 10 张 ================================================== 墙裂推荐： 如果想要长期稳定使用，请优先选择七牛云或者又拍云（需要实名认证以及已备案域名），再下来就是路过图床和 SM.MS 图床。 图床配套工具选择好图床之后，你可以选择搭配以下图床工具一起使用以便更高效地使用图床： 图片压缩工具上传图片之前建议压缩一下，一方面可以降低存储，又可以有效加快图片载入速度： TinyPNG –&gt; 传送门 Tiomg –&gt; 传送门 图床工具使用图床工具可以方便我们快速将本地图片转换成图床链接，以方便各位博主使用： PicGo（Molunerfinn/PicGo），是一款比较优秀的图床工具，可以支持微博，七牛云，腾讯云 COS，又拍云，GitHub，阿里云 OSS，SM.MS，imgur 等八种常用图床。且功能强大，简单易用。 关于 PicGo 的安装以及配置方法，请参见博主相关系列博客 –&gt; 传送门。 这里，由于篇幅原因，不做赘述。关于博客中图床方案的具体应用参加博文系列：稳定快速、高效免费的图床解决方案-Github-jsDelivr-PicGo","link":"/2017/09/21/ji-yu-tu-chuang-de-bo-ke-tu-pian-cun-chu-jie-jue-fang-an/"},{"title":"打造沉浸式写作体验，你需要试试 Markdown + Editor","text":"Markdown，一款轻量级的，可以使用普通文本编辑器编写的标记语言，打造沉浸式写作新体验。 Markdown + Editor「Action &gt;&gt;&gt; 夜深人静，房间的门紧闭着，灯也关着。 屏幕发出的亮光隐约勾勒出坐在电脑前码字的你的轮廓。 你脑海中的思绪畅游，无数想法在飞舞，但输出过程却不像脑中的思考那么流畅。 为了打磨用词和造句，你的手不断的从键盘移到鼠标上，只为把光标移到合适的位置。为了快速的调整样式，你虽然记住一些快捷键，但发现依然要先用鼠标选中。 不要小瞧了这看似短暂频繁的切换，稍纵即逝的想法可不会因为你的输出的节奏的中断而停留。 沉浸式写作 的前提，可 不是只要有个安静不受打扰的环境就够了，你还需要让输出的速度跟上你思考的速度。 如果你刻意练习过盲打，那么你会知道提高打字速度的首要条件就是保证打字姿势的稳定，手要保持在键盘上，尽量减少手的移动范围。 可问题是，在写作过程中，如何才能在保持手在键盘上，却依旧能准确的移动光标、调整样式呢？ 答：忘记鼠标，只用键盘就好。 …… 哎哎哎，千万别走，不是在逗你。 相信我，你只需要一个简单的文本编辑器（YOU WANT），再熟练掌握一把“利刃”——Markdown Syntax，就可以开启新世界的大门。 Markdown 初识Markdown 是一种轻量级的，可以使用 普通文本编辑器编写 的标记语言。它允许所有的写作爱好者（Sharer）可以专注于内容而不是纠结于字体字号行间距等等排版问题（沉浸式写作），使用易读易写的纯文本格式编写文档，然后就可以转化成格式丰富优美的 HTML 页面或 PDF（所思即所得）。你唯一要付出的代价就是掌握极其 简单的标记语法。 眼尖尖的同学已经发现：普通文本编辑器编写！？对，你看的没错，只要你手头有 任意一款文本编辑器，参照后文中 「Markdown Function Demo」标记语法，就可以开始使用 Markdown “随心所欲”了。 敲黑板！！！是不有“急躁”的看官已经默默打开 Windows 自带的记事本准备开始尝试了…？ 初学者警告！！！ 初学 MarkDown 的人，最开始可能会用 Windows 自带的记事本进行编辑，然后baidu，balabala….在线转成 HTML 或 PDF，用自带的浏览器打开查看效果。这种方式是最绿色的不依靠任何其他软件，就可以完成一份高质量的排版，但…实在是太累了。 Windows 自带的记事本没有 MD 语法提醒功能，也没有语法高亮功能，还无法 实时预览 效果，对初学者很不友好。往往边写作的同时还要百度语法，这就失去了用 MarkDown 快速办公的意义了（相信看客老爷们愤怒了，你不是说任何普通编辑器就可以编写了！！！前提是你得使用灰常熟练啊~人艰不拆…）。 事实上，更多使用的文本编辑器是： –&gt; 1 Markdown 在线编辑器，推荐一种：MdEditor； –&gt; 2 专门支持用来写 Markdown 的编辑器：MarkdownPad、Typora 等等。 对于新手，选择一款顺手的 Markdown 编辑器是刚需啊… MarkDown 编辑器推荐MarkdownPad2很多初学者的第一选择，支持多操作系统平台，UI 简洁，使用流畅，功能全面，但需要升级到 Pro 版本后（付费升级，可破解）才可解锁所有功能。主要特点：左右分屏实时预览（F5），可自定义添加各种 CSS 样式渲染。 关于 MarkdownPad2 安装以及常见问题解决见: 传送门 –&gt; MarkdownPad2 安装以及常见问题解决教程 。 缺点也很明显，软件 UI 一般般，更重要的是，安装后可能存在一些 Bug，如公式不能正常显示…，需要自行 baidu 解决。 Typora推荐，同样支持多平台（OS X， Windows 和 Linux），UI 界面美观，官网的首页如下： Typora 抛弃了传统的交互模式，它只使用一个窗口，却能优雅地实现同时将代码编辑与预览结合起来！从而为用户带来更加流畅直观的，所见即所得的 Markdown 写作体验。毕竟，对于刚接触 MarkDown 的新手来说，实时预览的功能真的太重要了。 Typora 安装过程很简单，一路 「Next」 即可。 Atom开源世界的巨人，全世界最大的，开源平台，GitHub 出品的编辑器 Atom，也是很多人选择使用的。 和 Typora 不同的是，Atom 并不只是用来写 MarkDown，通过丰富的插件机制支持 CSS，HTML，JavaScript 等各种网页编程语言，常用于 WEB 开发, 也可用于 PHP 等后端开发。 个人建议，可以和 Typora 二选其一（博主没有使用过 Atom，捂脸~）。 事实上，光日常学习和使用有上面几款编辑器已经可以满足你的需要了。 VS Code真正的编辑器神器，强烈安利！ 本人最常用的一款开源的文本编辑器编辑器（Atom 表示很悲伤），不仅用它写 MarkDown 文档，还可以通过丰富的插件机制用它写 Python、C/C++、Java 等等，几乎支持所有的语言。 你只需要下载它，安上 Markdown Preview Enhanced 插件就可以薅微软爸爸的羊毛了。界面效果图如下： 对于使用，篇幅原因，这里不进行详细的赘述。如果你想要详细了解 VS Code 的更多使用方法，可以关注我的相关系列博文。 Markdown 编辑器选择好之后，你就可以开始学习 Markdown 标记语法了： Markdown Function Demo标题演示一级标题：H1 语法规则： # 标题H1 MarkdownPad 中快捷键：Ctrl + 1 二级标题：H2 语法规则： ## 标题H2 MarkdownPad 中快捷键：Ctrl + 2 三级标题：H3 语法规则： ### 标题H3 MarkdownPad 中快捷键：Ctrl + 3 四级标题：H4 语法规则： #### 标题H4 MarkdownPad 中快捷键：Ctrl + 4 五级标题：H5 语法规则： ##### 标题H5 六级标题：H6 语法规则： ##### 标题H6 字符效果和横线演示删除线语法规则： &lt;s&gt;删除内容&lt;/s&gt; 显示效果： 删除内容 斜体字语法规则：*斜体字* &amp;&amp; _斜体字_ 显示效果： 斜体字 &amp;&amp; 斜体字 粗体法规则： **粗体** &amp;&amp; __粗体__ 显示效果： 粗体 &amp;&amp; 粗体 斜粗体语法规则： ***粗斜体*** &amp;&amp; ___粗斜体___ 显示效果： 粗斜体 &amp;&amp; 粗斜体 上下标语法规则：X&lt;sub&gt;2&lt;/sub&gt;, O&lt;sup&gt;2&lt;/sup&gt; 下标：X2，上标：O2 缩写缩写功能，同 HTML 的 &lt;abbr&gt; 标签 即更长的单词或短语的缩写形式，前提是开启识别 HTML 标签，默认已开启。 语法规则： The &lt;abbr title=&quot;Hyper Text Markup Language&quot;&gt;HTML&lt;/abbr&gt; specification is maintained by the &lt;abbr title=&quot;World Wide Web Consortium&quot;&gt;W3C&lt;/abbr&gt;. 显示效果如下： The HTML specification is maintained by the W3C. 分割线 语法规则： --- 字体颜色 语法规则: &lt;font color=blue/red/yellow...&gt; Text &lt;/font&gt; 显示效果： 此处文本为蓝色 此处文本为红色 引用 Blockquotes 文本引用 Blockquotes 引用的行内混合 Blockquotes 规则: &gt; 引用内换行使用&lt;br /&gt;标签，此处换行–&gt;这里为下一行引用文本。 锚点与链接 Links这是一个普通链接 语法规则： [这是一个普通链接](https://www.baidu.com/) 语法规则： [这是一个带标题的普通链接（光标移到此处显示标题）](https://www.baidu.com/ &quot;百度一下&quot;) 这是一个直接链接：https://www.baidu.com 语法规则： 这是一个直接链接：&lt;https://www.baidu.com&gt; 多语言代码高亮 Codes行内代码1Ctrl + k 或者 Tab 或者 ``` ``` 预格式化文本缩进后可用于格式化文本，正常以下内容会显示一个表格（可见下文绘制表格部分：3.8）： 1234| First Header | Second Header || ------------- | ------------- || Content Cell | Content Cell || Content Cell | Content Cell | JS 代码12345​```javascriptfunction test() { console.log(&quot;Hello world!&quot;);}​``` 显示效果如下： 123function test() { console.log(&quot;Hello world!&quot;);} HTML 代码12345678910111213141516171819​```html&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;mate charest=&quot;utf-8&quot; /&gt; &lt;meta name=&quot;keywords&quot; content=&quot;Editor.md, Markdown, Editor&quot; /&gt; &lt;title&gt;Hello world!&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; body{font-size:14px;color:#444;font-family: &quot;Microsoft Yahei&quot;, Tahoma, &quot;Hiragino Sans GB&quot;, Arial;background:#fff;} ul{list-style: none;} img{border:none;vertical-align: middle;} &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1 class=&quot;text-xxl&quot;&gt;Hello world!&lt;/h1&gt; &lt;p class=&quot;text-green&quot;&gt;Plain text&lt;/p&gt; &lt;/body&gt;&lt;/html&gt;​``` 显示效果如下： 1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html&gt; &lt;head&gt; &lt;mate charest=&quot;utf-8&quot; /&gt; &lt;meta name=&quot;keywords&quot; content=&quot;Editor.md, Markdown, Editor&quot; /&gt; &lt;title&gt;Hello world!&lt;/title&gt; &lt;style type=&quot;text/css&quot;&gt; body{font-size:14px;color:#444;font-family: &quot;Microsoft Yahei&quot;, Tahoma, &quot;Hiragino Sans GB&quot;, Arial;background:#fff;} ul{list-style: none;} img{border:none;vertical-align: middle;} &lt;/style&gt; &lt;/head&gt; &lt;body&gt; &lt;h1 class=&quot;text-xxl&quot;&gt;Hello world!&lt;/h1&gt; &lt;p class=&quot;text-green&quot;&gt;Plain text&lt;/p&gt; &lt;/body&gt;&lt;/html&gt; 图片链接 语法规则： ![](https://www.mdeditor.com/images/logos/markdown.png)](https://markdownpad.com &quot;markdown&quot;) 可以发现，我们只是把链接中的文本替换为图片，就创建了一个图片链接。 如何 插入图片： 语法规则： ![](https://www.mdeditor.com/images/logos/markdown.png) 插入图片效果如下： Follow your heart. 如何实现 图像居中 呢？！！ 语法规则： &lt;div align=center&gt; &lt;img src='url'&gt; &lt;/div&gt; 图片居中效果如下： 列表 Lists无序列表（减号）Unordered Lists (-)- 列表一 - 列表二 - 列表三 显示效果如下： 列表一 列表二 列表三 无序列表（星号）Unordered Lists (*)* 列表一 * 列表二 * 列表三 显示效果如下： 列表一 列表二 列表三 无序列表（加号和嵌套）Unordered Lists (+)多级列表注意缩进（2 空格），显示效果如下： 列表一 列表二 列表二-1 列表二-2 列表三 列表三-1 列表三-2 有序列表 Ordered Lists 第一行 第二行 第三行 绘制表格 Tables语法规则： 默认标题栏居中对齐，内容居左对齐。 -: 表示内容和标题栏居右对齐，:- 表示内容和标题栏居左对齐，:-: 表示内容和标题栏居中对齐。 内容和 | 之间的多余空格会被忽略，每行第一个 | 和最后一个 | 可以省略，- 的数量至少有一个。 | First Header | Second Header | | ------------ | ------------- | | Content Cell | Content Cell | | Content Cell | Content Cell | 显示效果如下： First Header Second Header Content Cell Content Cell Content Cell Content Cell 去练习如下样式： 表一 –&gt; Function name Description help() Display the help window. destroy() Destroy your computer! 表二 –&gt; Left-Aligned Center Aligned Right Aligned col 3 is some wordy text $1600 col 2 is centered $12 zebra stripes are neat $1 表三 –&gt; Item Value Computer $1600 Phone $12 Pipe $1 特殊符号 HTML Entities Codes &amp;copy; &amp; &amp;trade; &amp;iexcl; &amp;pound; &amp; &trade; &iexcl; &pound; &amp;amp; &amp;lt; &amp;gt; &amp;yen; &amp;euro; &amp;reg; &amp;plusmn; &amp;para; &amp;sect; &amp;brvbar; &amp;macr; &amp;laquo; &amp;middot; &amp; &lt; &gt; &yen; &euro; &reg; &plusmn; &para; &sect; &brvbar; &macr; &laquo; &middot; X&amp;sup2; Y&amp;sup3; &amp;frac34; &amp;frac14; &amp;times; &amp;divide; &amp;raquo; X&sup2; Y&sup3; &frac34; &frac14; &times; &divide; &raquo; 18&amp;ordm;C &amp;quot; &amp;apos; 18&ordm;C &quot; &apos; 科学公式 MathJaxMarkdown 文档中引入 MathJax 标签就可以正常显示了，标签内容如下： &lt;script type=&quot;text/javascript&quot; src=&quot;http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML&quot;&gt;&lt;/script&gt; 然后你会发现，博文中插入的公式已可以正常显示了： $$ x = {-b \\pm \\sqrt{b^2-4ac} \\over 2a} $$","link":"/2017/09/20/da-zao-chen-jin-shi-xie-zuo-ti-yan-ni-xu-yao-shi-shi-markdown-editor/"},{"title":"稳定快速、高效免费的图床解决方案-Github-jsDelivr-PicGo","text":"一种稳定快速、高效免费的图床解决方案 —— Github + jsDelivr + PicGo。 更多 Hexo 博客框架内容，请关注博主 Hexo 博文系列： 一文学会 Hexo 轻量级框架的博客搭建【持续更新】 Hexo 预安装环境部署之 Node.js Git 使用指南之初识 打造沉浸式写作体验，你需要试试-Markdown-Editor 基于图床的博客图片存储解决方案 稳定快速、高效免费的图床方案-Github-jsDelivr-PicGo Hexo 博客多设备协同管理问题【持续更新】 Introduction先来对比一下之前博文我们给出的图床解决方案: 自建图床服务器：需要支出必要的服务器等费用，还需要去进行相对繁琐的安装过程才可以使用； 云存储对象：有免费额度，但使用量较大时，可能产生相关存储流量费用，并且需要进行实名认证，域名备案等； 第三方免费图床：流量、储存、图片上传受限，国内大平台图床服务商需要进行实名认证，域名备案等； 其它小众图床：不可靠，随时有挂掉的风险。 使用过 Github 的看官肯定知道，Github 的 Repo 也可以储存东西，最直接的就是程序的版本控制，当然也可以用来当作备份储存。关于存储，Github 官方回复是：该行为不构成 Abuse（滥用）。 因此，GitHub 作为图床是个不错的选择，利用 jsDelivr CDN 加速访问（jsDelivr 是一个免费开源的 CDN 解决方案），PicGo 工具一键上传，操作简单高效。 并且 GitHub 和 jsDelivr 都是大厂，不用担心跑路问题，速度和容量问题都得以解决，而且完全免费，可以说是目前免费图床的较佳的一种解决方案！ 下面我们来看解决方案的具体实施： New Github Repo登录/注册 GitHub，新建一个仓库。填写好仓库名（HexoImageBed0），仓库描述(Hexo Image Host Repo)，仓库必须设为：public 的，根据需求选择是否为仓库初始化一个 README.md 描述文件: 填好仓库信息后，点击【Create Repository】即可完成 Repo 的创建。 生成一个 Token在主页选择【Settings】： Next –&gt; 点击【Developer settings】: Next –&gt; 依此点击【Personal access tokens】–&gt;【Generate new token】: 进入如下界面： 填写好描述，勾选【repo】，然后点击【Generate token】生成一个如图所示的 Token： 注意：请勿关闭当前页面，这个 Token 只会显示一次，自己先截图保存下来。或者等后面配置好 PicGo 后再关闭此网页。 PicGoPicGo，一款比较优秀的图床工具。 所谓图床工具，就是自动把本地图片转换成链接，以精简用户繁杂的图床上传、下载过程的一款工具，网络上有很多免费图床工具可供使用。 PicGo 可以支持微博，七牛云，腾讯云 COS，又拍云，GitHub，阿里云 OSS，SM.MS，Imgur 等八种常用图床，功能强大，简单易用。 PicGo Setup首先，你可以从这里提供的 PicGo 下载链接地址 下载 PicGo下载到最新的 PicGo。下载好后界面如下所示： PicGo 配置安装好后就可以开始配置 Github 图床了: 具体步骤为：【图床设置】–&gt; 【GitHub图床】，配置界面如下： ============================================== 配置内容详解： 设定仓库名：按照【用户名 / 图床仓库名】的格式填写； 设定分支名：【master】； 设定 Token：粘贴之前生成的【Token】； 指定存储路径：填写想要储存的路径，如【Img/】，这样就会在仓库下创建一个名为 Img 的文件夹，图片将会储存在此文件夹中； 设定自定义域名：在图片上传后，PicGo会按照【自定义域名+储存路径+上传的图片名】的方式生成访问链接。这里由于我们要使用 jsDelivr 加速访问，所以可以设置为【https://cdn.jsdelivr.net/gh/用户名/图床仓库名 】。使用时，我们就可以通过【https://cdn.jsdelivr.net/gh/用户名/图床仓库名/图片路径】加速访问我们的图片了。 About CDN百度百科：CDN 的全称是 Content Delivery Network，即内容分发网络。 CDN 是构建在网络之上的内容分发网络，依靠部署在各地的边缘服务器，通过中心平台的负载均衡、内容分发、调度等功能模块，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。CDN 的关键技术主要有内容存储和分发技术。 我们知道，放在 Github 的资源在国内加载速度比较慢，因此需要使用 CDN 加速来优化网站打开以及资源访问速度，“jsDelivr + Github” 是免费，好用的 CDN 加速方案，非常适合博客网站使用。 jsDelivr 引用资源方法： https://cdn.jsdelivr.net/gh/ {your usrname name}/{your repositry name}@{release version}/{resource file path} 例如： 12# https://cdn.jsdelivr.net/gh/TheNightIsYoung/HexoImageBed0@1.0/images/test.png# https://cdn.jsdelivr.net/gh/TheNightIsYoung/HexoImageBed0@2.0/css/style.css 注意：版本号不是必需的，是为了区分新旧资源，如果不使用版本号，将会直接引用最新资源，除此之外还可以使用某个范围内的版本，查看所有资源等，具体使用方法如下： 123456789101112131415161718# 加载任何Github发布、提交或分支https://cdn.jsdelivr.net/gh/user/repo@version/file# 加载 jQuery v3.2.1https://cdn.jsdelivr.net/gh/jquery/jquery@3.2.1/dist/jquery.min.js# 使用版本范围而不是特定版本https://cdn.jsdelivr.net/gh/jquery/jquery@3.2/dist/jquery.min.jshttps://cdn.jsdelivr.net/gh/jquery/jquery@3/dist/jquery.min.js# 完全省略该版本以获取最新版本https://cdn.jsdelivr.net/gh/jquery/jquery/dist/jquery.min.js# 将“.min”添加到任何JS/CSS文件中以获取缩小版本，如果不存在，将为会自动生成https://cdn.jsdelivr.net/gh/jquery/jquery@3.2.1/src/core.min.js# 在末尾添加 / 以获取资源目录列表https://cdn.jsdelivr.net/gh/jquery/jquery/ Quick Start安装配置好 Github + jsDelivr+PicGo 之后，我们就可以进行高效创作了 点击 PicGo【上传区】，将图片拖拽到上传区域，即可自动上传到 Github 仓库（支持多图片上传），注意上传区域下方可设置图床链接格式，默认为 Markdown 格式（可以直接复制到 MD 文档中使用）。 PicGo 还有相册功能，可以快速查看以及复制上传的图片链接。并且可以对已上传的图片进行删除，修改链接等快捷操作。 例如，我们选择默认的链接格式（Markdown），上传完毕后，点击相册，然后复制相应图片链接，示例： 1![](https://cdn.jsdelivr.net/gh/TheNightIsYoung/HexoImageBed0/Img/hexo-picgo-setting.png) 这样的 Markdown 链接格式，可以直接插入到 MD 中使用了。 ======================== PicGo Use Error ======================== PicGo 用了一段时间，可能突然发现偶尔上传图片时报如下错误： 12# 上传失败：服务端出错，请重试# 上传失败：请检查配置和上传文件是否符合要求 解决方法（迷之方法~）： 更改文件名（任何形式的改动）即可成功上传。向服务器上传已存在图片也会上报上诉错误。 ================================================================ 自此，我们就成功搭建起了基于 “Hexo + Github·Pages + Gitee·Pages + Domain + VSCode + TinyPNG + PicGo + Image Host ” 的个人博客。 You need to know more当然了，人无完人。Gihub+jsDelivr+PicGo 图床解决方案也是有缺陷的，你应该了解当前方案的局限： Github Page 容量受限正如 Github 官方给出的说明： Github 没有设置磁盘配额。我们试图为所有 Git 仓库提供充足的存储空间。保持存储库的大小可以确保我们的服务器快速且下载速度快。 如果您经常向 GitHub 推送大型文件，可以考虑将 Git 大型文件存储（Git LFS）作为你的工作流的一部分。Git LFS 可以很好地使用 GitHub 流，并且可以与任何大文件一起使用，不管它的类型是什么。 如果您的存储库超过 1 GB，则可能会收到来自 GitHub 支持的礼貌电子邮件，要求您减少存储库的大小以使其恢复。 也就是说，对于 Github Repo 是没有磁盘配额限制的，但单个仓库存储要低于 1G。 这也就意味着，一旦仓库满额，就得需要重新配置一个新的图床仓库了… Public RepoGithub 中创建的图床仓库必须是 Public，如果是 Pravite，那么图片地址会带有一个随时刷新 Token，这样虽然 Repo 他人不可见，但是也没法作为图床用。 Github Contribution Activity图床每添加一张，就会进行一次 commit，这样会导致你的 Github 动向表部分一片绿……虽然这样显得你很活跃，但是真正点进去会发现你的代码更新并没有你真正提交 commit 的频率高。 小结: Gihub 是一个稳定快速，高效免费的图床解决方案，但绝对不适用于大流量场景，只限于个人小流量博客站点适用。 并且，我们要注意：禁止滥用！！！把 Github 当图床算滥用，那么和把微博当图床使用最终导致被锁理所应当。","link":"/2017/09/21/wen-ding-kuai-su-gao-xiao-mian-fei-de-tu-chuang-jie-jue-fang-an-github-jsdelivr-picgo/"},{"title":"Git 使用指南之 WorkFlow (工作流)","text":"Git 多人协作必须有一个规范的工作流程，让大家有效地合作，使得项目井井有条地发展下去，这个流程叫做 WorkFlow（工作流），也称为 Git 分支管理策略。工作流不涉及任何命令，因为它就是一个规则，完全由开发者自定义，并且自我遵守。 版权说明： 本文思路以及内容主要来自廖雪峰老师的 Git 教程 （强烈推荐膜拜原文），并结合个人使用所作，只作为学习记录使用。如内容有侵权请联系删除，禁止转载！ 更多 Git 相关内容，请关注博主 Git 博文系列： 之一 &gt;&gt;&gt; Git 使用指南之初识 之二 &gt;&gt;&gt; Git 使用指南之时光穿梭机 之三 &gt;&gt;&gt; Git 使用指南之远程仓库 之四 &gt;&gt;&gt; Git 使用指南之分支管理 之五 &gt;&gt;&gt; Git 使用指南之 WorkFlow (工作流) 之六 &gt;&gt;&gt; Git 使用指南之 Git 自定义 之七 &gt;&gt;&gt; Git 使用指南之 HEAD 指针 之八 &gt;&gt;&gt; Git 使用指南之 Git 中的黑魔法 何为 Git 工作流？WorkFlow 的字面意思，工作流，即工作流程。Git 中因为有分支的存在，才构成了多工作流的特色。 事实的确如此，因为项目开发中，多人协作，分支很多，虽然各自在分支上互不干扰，但是我们总归需要把分支合并到一起，而且真实项目中涉及到很多问题，例如版本迭代，版本发布，bug 修复等，为了更好的管理代码，需要制定一个约束的工作流程。 简言之，Git 工作流指的是多人协作过程中的 git 的使用流程，不涉及技术细节，是一种项目管理、开发约定的方式。 工作流最受欢迎榜 目前使用度最高的工作流前三名（排名不分先后）分别是以下三种： Git Flow GitHub Flow GitLab Flow 其中 Git Flow 出现的最早；GitHub Flow 是在 Git Flow 的基础上，做了一些优化，适用于持续版本的发布；而 GitLab Flow 是综合前面两种工作流的优点，制定而成的一个工作流。 PopCharts Introduction你可以根据这里关于上述三种工作流的特性描述，为自己的项目构筑适配的工作流，毕竟适合自己的才是最好的~~~ Git FlowGit Flow 工作流，是 Vincent Driessen 2010 年发布出来的他自己的分支管理策略，一经发布就广为留下，目前位置使用度非常高，也是我们日常项目的常用工作流。 Git Flow 的分支结构很特别，按功能来说，可以分支为 5 种分支。从分支生命周期来看，可以分别归类为:长期分支 &amp;&amp; 短期分支，或者更贴切描述为，主要分支 &amp;&amp; 协助分支。 主要分支Git Flow 分支管理策略项目中，代码的中央仓库会一直存在以下两个 长期分支： master develop 其中，origin/master 分支上的最新提交永远是提供给用户使用的正式发布版本（任何时候 master 分支上拿到的，都是稳定的分布版）。origin/develop 分支用于日常开发，存放最新的开发进度。 当 develop 上的代码达到一个稳定的状态，可以发布版本的时候，develop 上的修改可以以某种特别方式（–no-ff，有时也需要借助后面将要提到的协助分支 {非必须} 等）被合并到 master 分支上，然后标记上对应的版本标签（tag），为以后项目排查定位提供便利。 事实上，常设分支只需要这两条主要分支就够了，不需要其他了~~~ 协助分支然而，除了常设分支以外，Git Flow 的开发模式还需要一系列的协助分支，来帮助更好的功能的并行开发，简化功能开发和问题修复。 协助分支是暂时分支，它们非常无私奉献，在需要它们的时候，迫切地创建，用完它们的时候，又挥挥衣袖地彻底消失。 协助分支分为以下三类： Feature Branch（功能分支） Release Branch（预发布分支） Hotfix Branch（热修复分支） 1 –&gt; Feature Branch Feature 功能分支，是为了开发某种特定功能，从 develop 分支上面分出来的。Feature Branch 命名可以采用：feature-xxx 的方式。 待功能模块开发完成之后，会将其重新合并到 develop 分支上，然后删除 Feature Branch。 如图，有两个功能模块在开发，其中一个已经完成，重新合并到 develop 分支；另一个仍处于开发状态。 2 –&gt; Hotfix Branch Hotfix 热修复分支，是用来做线上的紧急 Bug 修复的，建议命名为 hotfix-xxx。 当线上（master）某个版本出现了问题，将检出对应版本的代码，创建 Hotfix 分支，问题修复后，合并回 master 和 develop ，然后删除 Hotfix Branch。 这里注意，合并到 master 的时候，也要打上修复后的版本标签。 3 –&gt; Release Branch Release 预发布分支，是指发布正式版本之前（即 develop 分支合并到 Master 分支之前），我们可能需要从 develop 分支上分出来一个预发布的版本分支进行测试，预发布（测试）结束以后，必须将其合并进 develop 和 master 分支，然后删除 Release Branch。Release Branch 命名可以采用：reature-xxx 的方式。 例如，在软件 1.0.0 版本的功能全部开发完成提交后，从 develop 检出 release-1.0.0 进行测试，测试中出现的小问题，在 release 分支进行修改提交，测试完毕准备发布的时候，代码会合并到 master 和 develop，master 分支合并后会打上对应版本标签 v1.0.0, 合并完成后删除 release-1.0.0。 这样做的好处是：在 测试的时候，不影响下一个版本功能并行开发。 最后我们来看发布之后的目前的日志记录情况，这里将没有用的分支 hotfix、release、feature 均删除了，可以看出常驻分支只有 master/dev，最下面的 feature 表示仍在开发中。 No Fast Forward需要说明的是，Git Flow 的作者 Vincent Driessen 非常建议，合并分支的时候，加上 no-ff 参数，采取禁用快速合并模式，使用递归策略合并模式。 好处：保证一个非常清晰的提交历史，防止丢失分支信息。 Git Flow Diagram这里给出 Git Flow 整体工作流程的图解，可以看出，Git Flow 的五种分支，master，develop，feature branchs ,release branchs , hoxfixes。 其中，master 和 develop 字体被加粗代表主要分支。master 分支每合并一个分支，无论是 hotfix 还是 release ,都会打一个版本标签。通过箭头可以清楚的看到分支的开始和结束走向，例如 feature 分支从 develop 开始，最终合并回 develop ，hoxfixes 从 master 检出创建，最后合并回 develop 和 master，master 也打上了标签。 Git Flow EvaluationGit Flow 综合考虑了开发、测试、新功能开发、临时需求、热修复，理想很丰满，现实很骨干，这一套运行起来实在是太复杂了/(ㄒoㄒ)/~~ Git Flow 的优点是清晰可控，缺点除了：1.频繁在两个长期分支（master &amp;&amp; develop）之间切换；2.没有 GUI 图形页面，只能命令行操作； 更大的问题在于 &gt;&gt;&gt;&gt;&gt; Git Flow 是基于 “版本发布” 的，目标是一段时间以后产出一个新版本。但很多网站项目是”持续发布”（快速迭代），代码一有变动，就部署一次。这时，master 分支和 develop 分支的差别不大，没必要维护两个长期分支。 GitHub FlowGithub flow 是 Git flow 的简化版，专门配合 ”持续发布”，它是 Github.com 使用的工作流程。 Github flow 只有一个长期分支，就是 master，因此用起来非常简单。 Introduction官方推荐的流程如下： GitHub Flow 模型简单说明: 第一步：根据需求，只有一个长期分支 master ,而且 master 分支上的代码，永远是可发布状态。并且 master 分支会设置 protected 分支保护，只有有权限的人才能推送代码到 master 分支。 第二步：根据需求，从 master 拉出新分支，不区分功能分支或热修复分支等。 第三步：新分支开发完成后，或者需要讨论的时候，就向 master 发起一个 pull request（简称 PR）。 第四步：Pull Request 既是一个通知，让别人注意到你的请求;又是一种对话机制，大家一起评审和讨论你的代码。对话过程中，你还可以不断提交代码。 第四步：你的 Pull Request 被接受，合并进 master，重新部署后，原来你拉出来的那个分支就被删除。 特色之 Pull RequestGitHub Flow 最大的特色就是 Pull Request 的提出，这是一个伟大的发明，它的用处并不仅仅是合并分支，还有以下功能： 可以很好控制分支合并权限：分支不是你想合并就合并，需要对方同意 问题讨论 或者 寻求其他小伙伴们的帮助:和拉个讨论组差不多，可以选择相关的人参与，而且参与的人还可以向你的分支提交代码，非常适合代码交流 代码 Review：如果代码写的很烂，有了 pull request 提供的评论功能支持，准备好接受来自 review 的实时吐槽吧。 Github Flow 这种方式，要保证高质量，对于贡献者的素质要求很高，换句话说，如果代码贡献者素质不那么高，安安心心小板凳做好膜拜大佬就好了~~~ 特色之 issue tracking日常开发中，会用到很多第三方库，然后使用过程中，出现了问题，是不是第一个反应是去这个第三方库的 GitHub 仓库去搜索一下 issue ，看没有人遇到过，项目维护者修复了没有？？？一般未解决的 issue 是 open 状态，已解决的会被标记为 closed，这就是 issue tracking（问题追踪）。 如果你是一个项目维护者，除了标记 issue 的开启和关闭，还可以给它标记上不同的标签，来优化项目。当提交的时候，如果提交信息中有 fix #1 等字段，可以自动关闭对应编号的 issue。 issue tracking 非常适合开源项目。 GitLab FlowGitlab Flow 集百家之长，补百家之短。 Gitlab Flow 是 Git Flow 与 Github Flow 的综合。它吸取了两者的优点，既有适应不同开发环境的弹性，又有单一主分支的简单和便利。它是 Gitlab.com 推荐的做法。 GitLab 既支持 Git Flow 的分支策略，也有 GitHub Flow 的 Pull Request（ Merge Request ） 和 issue tracking。 Git &amp; GitHub Flow 的瑕疵当 Git Flow 出现后，它解决了之前项目管理的很让人头疼的分支管理，但是实际使用过程中，也暴露了很多问题： 默认工作分支是 develop，但是大部分版本管理工具默认分支都是 master，开始的时候总是需要切换很麻烦。 Hotfix 和 Release 分支在需要版本快速迭代的项目中，几乎用不到，因为刚开发完就直接合并到 master 发版，出现问题 develop 就直接修复发布下个版本了。 Hotfix 和 Release 分支，一个从 master 创建，一个从 develop 创建，使用完毕，需要合并回 develop 和 master。而且在实际项目管理中，很多开发者会忘记合并回 develop 或者 master。 随着，GitHub Flow 的出现，极大程度上简化了 Git Flow ，因为只有一个长期分支 master，并且提供 GUI 操作工具，一定程度上避免了上述的几个问题，然而在一些实际问题面前，仅仅使用 master 分支显然有点力不从心，例如： 版本的延迟发布（例如开发 iOS 应用审核过程中（等待审核上架），可能也要在 master 上推送代码，导致线上版本落后 master 分支） 不同环境的部署 （例如：测试环境，预发环境，正式环境） 不同版本发布与修复 （只有一个 master 分支真心不够用） GitLab Flow 解决方案在给出解决方案之前，需要明确 GitLab Flow 中的一个最大原则：”上游优先”（upsteam first）。 ”上游优先”原则：即只存在一个主分支master，它是所有其他分支的”上游”。只有上游分支采纳的代码变化，才能应用到其他分支。只有紧急情况，才允许跳过上游，直接合并到下游分支。 关于”上游优先”原则的具体应用，请参看下文 &gt;&gt;&gt;&gt; 为了解决 Git Flow &amp; GitHub Flow 中那些毛茸茸的小问题，GitLab Flow 给出了以下的解决方案： 1 –&gt; 版本的延迟发布 解决思路：Prodution Branch &amp; Upsteam First master 分支不够，于是添加了一个 prodution 分支，专门用来发布版本。 但要注意需要遵循 ”上游优先”（upsteam first），代码的变化，必须由”上游”向”下游”发展。比如，生产环境出现了 bug，这时就要新建一个功能分支，先把它合并到 master，确认没有问题，再 cherry-pick 到 production。 2 –&gt; 不同环境的部署 应对”持续发布”的项目，解决思路：Environment Branches &amp; Upstream First 每个环境，都对应一个分支，例如下图中的 pre-production 和 prodution 分支都对应不同的环境，GitLab Flow 模型比较适用服务端，测试环境、预发环境、正式环境，一个环境建一个分支。 比如，”开发环境”的分支是 master，”预发环境”的分支是 pre-production，”生产环境”的分支是 production。 开发分支是预发分支的”上游”，预发分支又是生产分支的”上游”。代码的变化，必须由”上游”向”下游”发展。比如，生产环境出现了 bug，这时就要新建一个功能分支，先把它合并到master，确认没有问题，再 cherry-pick 到 pre-production，这一步也没有问题，才进入 production。 只有紧急情况，才允许跳过上游，直接合并到下游分支。 3 –&gt; 版本发布分支 应对”版本发布”的项目，解决思路：Release Branches &amp; Upstream First 只有当对外发布软件的时候，才需要创建 release 分支。作为一个移动端开发来说，对外发布版本的记录是非常重要的，如果线上出现了一个问题，需要拿到问题出现对应版本的代码，才能准确定位问题。 GitLab Flow 中建议的做法是：每一个稳定版本，都要从 master 分支拉出一个分支，比如 2-3-stable、 2-4-stable 等等。发现问题，就从对应版本分支创建修复分支，完成之后，先合并到 master，才能再合并到 release 分支，遵循 “上游优先” 原则，并且记得要更新小版本号。 Useful TipsPull RequestGitHub Flow 中的 Pull Request 见上文相关部分，GitLab Flow 中也支持 Pull Request，只是叫法改为 Merge Request！！！ Protected branchmaster 分支应该受到保护，不是每个人都可以修改这个分支，以及拥有审批 Pull Request 的权限。 Github 和 Gitlab 都提供”保护分支”（Protected branch）这个功能。 Issue trackingIssue 用于 Bug追踪和需求管理。建议先新建 Issue，再新建对应的功能分支。功能分支总是为了解决一个或多个 Issue。 功能分支的名称，可以与issue的名字保持一致，并且以 issue 的编号起首，比如：”15-require-a-password-to-change-it”。 开发完成后，在提交说明里面，可以写上 “fixes #14” 或者 “closes #67”。Github 规定，只要 commit message 里面有下面这些 “动词 + 编号”，就会关闭对应的 issue。 123456789closeclosesclosedfixfixesfixedresolveresolvesresolved Merge With NO-FF需要说明的是，合并分支的时候，加上 no-ff 参数，采取禁用快速合并模式，使用递归策略合并模式。 这样可以保证一个非常清晰的提交历史，防止丢失分支信息。 Squash commits为了便于他人阅读你的提交，也便于 cherry-pick 或撤销代码变化，在发起 Pull Request 之前，应该把多个 commit 合并成一个（前提是，该分支只有你一个人开发，且没有跟 master 合并过）。 这可以采用 rebase 命令附带的 squash 操作 ===================================================== 至此，Git 中的分支管理策略就也就介绍完了。事实上，Git 的使用真的很灵活自由，你完全可以采取搭配式的工作流模式，比如：GitLab + Git Flow，一定要把思路打开。 这里再扩展一种工作流：Forking Flow Forking Flow开源项目常用的工作流 ——Forking 工作流，介绍之前首先需要了解什么是 fork 操作，见下图： fork 操作是在个人远程仓库新建一份目标远程仓库的拷贝，操作很简单，比如 github 上在项目的主页点击 fork 按钮即可。 明白了 fork 操作之后，我们来看下 forking 工作流的流程，如下： 首先开发者 A 拥有一个远端仓库 &gt;&gt;&gt; 这时候有一个开发者 C 也想参与 A 的这个项目的开发工作，那他就可以 fork 一份 A 的这个仓库，之后在 C 的个人仓库里就有了这份代码库，后续开发者 C 就可以在自己的这个项目里进行开发工作，C 在完成了某个功能的实现之后，可以给 A 的仓库发一个 PR 请求，这时候会通知到开发者 A 有新的 PR，A 如果有问题可以直接在这个 PR 里提，开发者 C 可以进行进一步的修改，最后 A 通过了 C 的这份 PR 请求，就会将 C 的代码合并进 A 的仓库，这样就完成了 A / 代码库新特性的开发。同时如果有其他开发者对 A 的项目有兴趣也会进行相同的操作。 这里注意到 开发者 B/C 并不是 A 代码库的开发人员，而是第三方开发者，所以这种工作流主要用于开源项目！ Tag Management在开发过程中, Git 支持使用 标签（Tag） 给仓库历史中的某一个提交打上标签，以示重要。 例如版本发布, 有重大修改, 升级的时候，开发人员会使用标签来标记发布（修改、升级）结点：v1.0 、 v2.0 等等，这可以为以后项目排查、定位提供极大便利。 将来无论什么时候，可以通过之前打好的标签（v1.0 、 v2.0），拿到那个时刻的历史快照，相当于版本库某个特殊时刻的快照。Git 标签虽然是 版本库的快照，但本质上它是 指向某个 commit 的指针（是不是跟分支很像？？？），所以创建和删除标签也都是瞬间完成的。 注意和分支指针不同的是：标签是指向 commit 的死指针，分支是指向 commit 的活指针！！！事实上，你可以将标签简单理解为 某个 Commit 的别名。 为何引入 Git Tag思考一下：为什么 Git 有 commit，为什么还要引入 tag ？？？ 你：“请把上周一的那个版本打包发布，commit 号是 6a5819e..” 同事：“一串乱七八糟的数字不好找！” 如果换一个办法： 你：“请把上周一的那个版本打包发布，版本号是v1.2” 同事：“好的，按照 tag v1.2 查找 commit id 就行！” 所以，tag 就是一个让人 容易记住的有意义的名字，它跟某个 commit 绑在一起（别名）。 查看标签在开始标签操作说明之前，需要先介绍一下 Git 中的标签查看命令，后续标签操作需要查看命令的配合。 1 –-&gt; git tag：列出标签 在 Git 中列出已有的标签非常简单，只需要输入 git tag: 1234# 如果仓库中已创建了标签：v1.0，v2.0，可以使用命令进行查看$ git tagv1.0v2.0 git tag 列出的标签，会以字母顺序列出，但是它们显示的顺序并不重要。 这时会有一个问题：当项目经过长时间维护，仓库中包含的标签数量较多时，以上命令会全部进行显示，不方便精确查找到目标。 这时，你可以通过通配符的方式，使用 git tag -l &quot;tag version*&quot;进行精确查找，例如只对 1.8.5 系列感兴趣，可以运行： 1234567891011$ git tag -l &quot;v1.8.5*&quot;v1.8.5v1.8.5-rc0v1.8.5-rc1v1.8.5-rc2v1.8.5-rc3v1.8.5.1v1.8.5.2v1.8.5.3v1.8.5.4v1.8.5.5 2 –&gt; git show：查看标签信息 git show 命令可以用来查看某个标签对应的提交的信息： 1234567 $ git show v0.8commit fb508357fe0e488ac6720874941ecd6bbd3aacf2 (HEAD -&gt; master, tag: v0.8, origin/master)Merge: 7d23fef c07648eAuthor: TheNightIsYoung &lt;guojie0213_iit@163.com&gt;Date: Mon Feb 28 19:52:38 2022 +0800 Dealing Merge Conflict Git WorkFlow 学习之后，你应该知道标签（Tag）正式情况下更多运用在 master 分支上（生产线上）。 创建标签Git 中支持两种类型的标签： 轻量标签（Lightweight） 附注标签（Annotated） 轻量标签，轻量级的标签，它只是某个特定提交的引用。 而附注标签见名知义，除了引用作用之外，还包含了丰富的信息：打标签者的名字、电子邮件地址、日期时间等。 通常，推荐创建附注标签，这样你可以拥有以上所有信息。但是如果你只是想用一个临时的标签， 或者因为某些原因不想要保存这些信息，那么也可以用轻量标签。 轻量标签创建轻量标签非常简单，没有保存任何其他信息，故创建时只需要提供标签名字即可： 命令格式 –&gt;&gt;&gt; git tag &lt;name&gt; 1234567891011121314# 1.首先，切换到需要打标签的分支上(master)：$ git branch* dev master$ git checkout masterSwitched to branch 'master'# 2.创建 v0.8 版本标签：$ git tag v0.8# 3. 查看当前版本库已有标签$ git tagv0.8# 可以看到，已经成功创建标签 附注标签在 Git 中创建附注标签也十分简单，可以配合 -a &amp;&amp; -m 参数一起使用，例如创建名为 v1.0 的附注标签： 1234$ git tag -a v1.0 -m &quot;Version 1.4: User Authorization&quot;(master) GitTestProject $ git tagv0.8v1.0 参数 -m，你可以理解为提交时的提交信息。如果没有为附注标签指定一条信息，Git 会启动编辑器要求你输入信息。 通过使用 git show 命令查看标签信息和与之对应的提交信息： 123456789101112$ git show v1.0tag v1.0Tagger: TheNightIsYoung &lt;guojie0213_iit@163.com&gt;Date: Sat Mar 5 11:19:29 2022 +0800Version 1.4: User Authorizationcommit 6a9789d4f788a797aa75283c15b521dd6b028be4 (HEAD -&gt; master, tag: v1.0)Author: TheNightIsYoung &lt;guojie0213_iit@163.com&gt;Date: Sat Mar 5 11:18:58 2022 +0800 Tag Test 可以看到，输出显示了打标签者的信息、打标签的日期时间、附注信息，然后显示具体的提交信息。 后期打标签默认标签是打在最新提交的 commit 上的。有时候，如果忘了打标签，比如，现在已经是周五了，但应该在周一打的标签没有打，怎么办？ 方法是你可以对历史提交的 commit id 打标签。 语法规则：git tag -a &lt;tag name&gt; &lt;commit id&gt; 假设当前提交历史是这样的： 12345678910111213141516171819 $ git log --pretty=oneline --abbrev-commit 6a9789d (HEAD -&gt; master, tag: v1.0) Tag Testfb50835 (tag: v0.8, origin/master) Dealing Merge Conflictc07648e (FeatureA) Merge conflic test in FeatureA7d23fef Merge conflic test in master28157d9 Merge with no-ff02636d0 Func-Add Permission(no-ff)b324182 Func-Add User(no-ff)8a39810 Func-Add Permission3d6d64d Func-Add User5f264b1 Merge branch 'featureB'4528426 (featureB) Add BTest File For featureBfc2702b Add ATest File For79c3a2c Add git_rm_test.txtfe3235b git tracks changesd6ddc31 Git local data management test0f5a696 understand how stage worksebba382 Add test codeda1fadc Add help info65586b3 ADD Project Base 现在，假设在 v1.2 时你忘记给项目打标签，也就是在 “Merge branch ‘featureB’” 提交。你可以在之后补上标签: 1$ git tag -a v1.2 5f264b1 这时，Git 会启动编辑器要求你输入标签信息（类似于 git commit）。 可以看到你已经在那次提交上打上标签了： 123456789101112131415161718$ git tagv0.8v1.0v1.2(master) GitTestProject $ git show v1.2tag v1.2Tagger: TheNightIsYoung &lt;guojie0213_iit@163.com&gt;Date: Sat Mar 5 11:41:30 2022 +0800Version 1.2: Add Function-Bcommit 5f264b1aecadb5082627d33d431ee52ce37dcd23 (tag: v1.2)Merge: fc2702b 4528426Author: TheNightIsYoung &lt;guojie0213_iit@163.com&gt;Date: Mon Feb 28 13:17:29 2022 +0800 Merge branch 'featureB' 注意：标签总是和某个 commit 挂钩。如果这个 commit 既出现在 master 分支，又出现在 dev 分支，那么在这两个分支上都可以看到这个标签。 共享标签默认情况下，创建的标签都只存储在本地，git push 命令并不会自动推送标签到远程仓库服务器上。 想要将本地创建的标签同步到远程仓库中，在创建完标签后你必须显式地推送标签到远程仓库上。这个过程就像共享远程分支一样——你可以通过 git push origin &lt;tagname&gt; 实现： 1234567$ git push origin v1.2Enumerating objects: 1, done.Counting objects: 100% (1/1), done.Writing objects: 100% (1/1), 186 bytes | 186.00 KiB/s, done.Total 1 (delta 0), reused 0 (delta 0), pack-reused 0To github.com:TheNightIsYoung/GitTestProject.git* [new tag] v1.2 -&gt; v1.2 如果想要一次性推送很多标签，也可以使用带有 --tags 选项的 git push 命令。 这将会把所有不在远程仓库上的标签全部传送到那里: 12345678$ git push origin --tagsEnumerating objects: 1, done.Counting objects: 100% (1/1), done.Writing objects: 100% (1/1), 187 bytes | 187.00 KiB/s, done.Total 1 (delta 0), reused 0 (delta 0), pack-reused 0To github.com:TheNightIsYoung/GitTestProject.git* [new tag] v0.8 -&gt; v0.8* [new tag] v1.0 -&gt; v1.0 从远程仓库已经可以看到推送上来的所有标签了： 删除标签1 –&gt; 本地标签删除 要删除掉你本地仓库上的标签，可以使用命令: git tag -d &lt;tagname&gt;。 例如，可以使用以下命令删除一个标签： 12345678910$ git tagv0.8v1.0v1.2(master) GitTestProject $ git tag -d v0.8Deleted tag 'v0.8' (was fb50835)$ git tagv1.0v1.2 注意上述命令并不会从任何远程仓库中移除这个标签，你必须用下面命令更新你的远程仓库： 1$ git push &lt;remote&gt; :refs/tags/&lt;tagname&gt; 实测如下： 123$ git push origin :refs/tags/v0.8To github.com:TheNightIsYoung/GitTestProject.git- [deleted] v0.8 登陆 GitHub 查看，发现远程仓库标签已经被删除： 检出标签如果你想查看某个标签所指向的文件版本，可以使用分支介绍中我们提到过的 git checkout 命令，但这会使我们仓库处于 “头指针游离（detached HEAD）” 的状态： 12345678910111213141516171819202122$ git checkout v1.2Note: switching to 'v1.2'.You are in 'detached HEAD' state. You can look around, make experimentalchanges and commit them, and you can discard any commits you make in thisstate without impacting any branches by switching back to a branch.If you want to create a new branch to retain commits you create, you maydo so (now or later) by using -c with the switch command. Example:git switch -c &lt;new-branch-name&gt;Or undo this operation with:git switch -Turn off this advice by setting config variable advice.detachedHead to falseHEAD is now at 5f264b1 Merge branch 'featureB'# 可以看到，HEAD 指针已经切换到 v1.2 了：((v1.2)) GitTestProject $ 为什么会进入游离态？前面介绍 HEAD 指针时说过：HEAD 不指向 branch，而是指向分支上的某一个 commit 时就会进入游离态，再结合命令 git checkout 移动 HEAD 指针来实现切换分支，这里移动 HEAD 指针指向被打了标签的某一个特定提交，所以游离是显而易见的。 HEAD 处于 “游离态” 会产生不好的副作用，如果你做了某些更改然后提交它们，标签不会发生变化， 但你的新提交将不属于任何分支，并且将无法访问。如果你需要进行更改，比如你要修复旧版本中的错误（修复 Bug），那么通常需要创建一个新分支，然后在新分支上进行提交，这时新分支上的内容和 v1.2 就不一样了。 更多关于 HEAD 游离态的说明可以参看博文：Git 使用指南之 HEAD 指针。","link":"/2017/07/05/git-shi-yong-zhi-nan-zhi-workflow-gong-zuo-liu/"},{"title":"Git 使用指南之远程仓库","text":"上一篇博文我们已经掌握了 Git 版本库管理日常操作指令，已经初步达成了简单管理日常项目的目标，再也不用担心文件备份或者丢失的问题了。有用过集中式版本控制系统 SVN 的童鞋会说，这些功能在 SVN 里早就有了，没看出 Git 有什么特别的地方。 确实没错，如果只是作为仓库管理文件历史，Git 和 SVN 还真没啥区别，但项目开发不仅仅是管理文件历史。为了体现 Git 作为分布式版本控制系统较于 SVN 的优势（不做“杠精”哈~），本篇我们将介绍 Git 的杀手锏功能之一：Git 远程仓库，这也是 Git 迅速流行的主要原因。 版权说明： 本文思路以及内容主要来自廖雪峰老师的 Git 教程 （强烈推荐膜拜原文），并结合个人使用所作，只作为学习记录使用。如内容有侵权请联系删除，禁止转载！ 更多 Git 相关内容，请关注博主 Git 博文系列： 之一 &gt;&gt;&gt; Git 使用指南之初识 之二 &gt;&gt;&gt; Git 使用指南之时光穿梭机 之三 &gt;&gt;&gt; Git 使用指南之远程仓库 之四 &gt;&gt;&gt; Git 使用指南之分支管理 之五 &gt;&gt;&gt; Git 使用指南之 WorkFlow (工作流) 之六 &gt;&gt;&gt; Git 使用指南之 Git 自定义 之七 &gt;&gt;&gt; Git 使用指南之 HEAD 指针 之八 &gt;&gt;&gt; Git 使用指南之 Git 中的黑魔法 Git 分布式版本控制策略Git 是分布式版本控制系统，意味着同一个 Git 仓库，可以分布到不同的机器上。 怎么分布呢？ 起初肯定只有一台机器有一个原始版本库，此后别的机器可以 克隆 这个原始版本库，而且每台机器的版本库其实都是一样的，并且没有主次之分。 那么 如何保证所有分布式节点版本库数据同步呢？ 考虑以下场景： 某个项目由多人负责开发，想要实现所有人项目版本库数据同步 多地点不同机器进行项目开发（公司，家等），难道每天需要将项目拷贝过来拷贝过去？ 我们在介绍版本控制系统的集中式和分布式区别时，我们提到过：分布式不像集中式一样有中央服务器，但它会选用一台服务器充当“中央服务器”的角色。 实际使用情况确实如此，找一台电脑充当服务器的角色，每天24小时开机，分布式系统中其它每个用户都从这个 “中央服务器” 仓库克隆一份到自己的电脑上，并且各自把各自的最新提交推送到服务器仓库里，也从服务器仓库中拉取别人的提交。 在公司局域网内进行项目开发时，完全可以搭建一台运行 Git 的 “中央服务器” 进行项目开发。不过为了学习 Git，先搭个服务器绝对是小题大作（看官老爷也要骂街了~）。不知道你还记不记得之前我们提过的 GitHub —&gt; 提供了远程 Git 仓库托管服务的，只要注册一个 GitHub 账号，就可以免费获得 Git 远程仓库，然后就可以将其作为 “中央服务器” 使用了。 P.S. 如果你想要尝试一下个人搭建 Git 服务器，可以了解一下 GitLab。 后续我们将以 GitHub 作为远程仓库（中央仓库）进行继续学习，阅读后续内容前，请自行注册 GitHub 账号。 Github首先我们给出 GitHub 登陆界面： SSH Reff我们需要知道：本地 Git 仓库和远程 GitHub 仓库之间的传输是通过 SSH 加密的，所以首先我们需要设置 Git 和 GitHub 之间的 SSH，只有配置了 SSH，Git 才可以和 GitHub 远程仓库进行同步通信（SSH 保证了 Git 与 Github 之间的通信安全，防止其它人恶意操作你的 Github 仓库）。 SSH 是一种通讯协议，是用于实现 远程安全登录 的。有使用过在 Windows 下远程登录 Linux 服务器进行文件互传的看官，相信会对 SSH 有初步的了解，你可以直接跳过下面关于 SSH 安全机制的说明。 |—————————— SSH 安全机制 ——————————| SSH 之所以能够保证安全，原因在于它采用了非对称加密技术(RSA)的安全机制，提供两种级别的验证方法： 第一种级别（基于口令的安全验证）：只要你知道自己帐号和口令，就可以登录到远程主机。所有传输的数据都会被加密，但是不能保证你正在连接的服务器就是你想连接的服务器。可能会有别的服务器在冒充真正的服务器，这是危险的。 第二种级别（基于密钥的安全验证）：必须为自己创建一对密钥，并把公钥放在需要访问的服务器上。如果你要连接到 SSH 服务器上，客户端软件就会向服务器发出请求，请求用你的密钥进行安全验证。服务器收到请求之后，先在该服务器上你的主目录下寻找你的公钥，然后把它和你发送过来的公钥进行比较。如果两个密钥一致，服务器就用公钥加密 “质询”（challenge）并把它发送给客户端软件。客户端软件收到 “质询” 之后就可以用你的私钥在本地解密再把它发送给服务器完成登录。 Config SSH Key For Git下面来看如如何为 GiHub 配置本地 Git 仓库机器的 SSH： 1 –&gt; 本地 Git 创建 SSH Key 检查用户主目录（~）下是否有 .ssh 目录，以及 .ssh 目录下是否有 id_rsa 和 id_rsa.pub 这两个文件。如果都存在，可以跳过当前步骤，否则通过 Shell（ Windows 下打开 Git Bash），使用邮箱创建 SSH Key： 1$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot; 将 youremail@example.com 换成可用的邮件地址，然后一路回车，使用默认值即可。 如果创建成功的话，可以在用户目录下找到 .ssh 目录，并且 .ssh 目录中还有 id_rsa 和 id_rsa.pub 两个文件（SSH Key 的秘钥对）。其中 id_rsa 是私钥，id_rsa.pub 是公钥。 2 –&gt; GitHub Settings 登陆 GitHub，打开 “Settings” –&gt; “SSH and GPG keys” 页面： 然后点击 “Add SSH Key”，填任意 Title，在 Key 文本框里粘贴本地 Git 节点中 id_rsa.pub 文件的内容，点击下方 “Add SSH Key” 即可查看到添加好的 SSH Key 了： |—————————————————————– 内容补充： 为什么 GitHub 需要 SSH Key 呢？因为 GitHub 需要识别出推送的提交确实是你推送的，而不是别人冒充的，而 Git 支持 SSH 协议，所以 GitHub 只要知道了你的公钥，就可以确认只有你自己才能推送。 当然，GitHub 允许用户添加多个 SSH Key。假定你有若干台设备时，只要把每台设备的 Key 都添加到 GitHub，就可以在每台设备上往 GitHub 进行推送了（是不实现了版本库的数据同步了）。 注意：GitHub 上免费托管的 Git 仓库，任何人都可以看到（但只有你自己才能改）。所以，不要把敏感信息放进去。当然你可以使用 GitHub 创建私有仓库。 —————————————————————–| SSH Key 添加成功之后，我们可以在 Git bash 中进行测试： 123$ ssh -T git@github.comWarning: Permanently added the RSA host key for IP address 'X.X.X.X' to the list of known hosts.Hi TheNightIsYoung! You've successfully authenticated, but GitHub does not provide shell access. 返回 “Hi username ！You’ve successfully ……” 说明你已经成功啦！ Add Repo For Local Git当前的场景是：我们的本地机器已经拥有了一个本地 Git 仓库，想将 GitHub 作为本地 Git 某个仓库（GitTestProject）的远程仓库（“中央仓库”）。这样 GitHub 上的仓库既可以作为备份，又可以让其他人通过该仓库来协作，真是一举多得。 1 –&gt; GitHub 上创建一个新仓库，作为中央仓库（备份、同步仓库） 这里我们还是以 GitTestProject 作为项目名称。创建好后，GitHub 上的这个 GitTestProject 仓库还是空的。 可以看到，GitHub 告诉我们：可以从这个仓库克隆出新的仓库；也可以把一个已有的本地仓库与之关联，然后把本地仓库的内容推送到 GitHub 仓库；还可以从其它仓库导入代码。 这里我们只关注本地 Git 仓库与其进行关联。 2 –&gt; 本地 Git 仓库关联 GitHub 远程仓库 根据你自己的 …or push an existing repository from the command line 中关联命令在 GitTestProject 目录下进行关联操作： CMD 9 –&gt;&gt;&gt; git remote add &lt;repo name&gt; &lt;repo addr&gt; 12# 将地址为：git@github.com:TheNightIsYoung/GitTestProject.git 的远程仓库 origin（别名）链接到当前本地 Git 仓库$ git remote add origin git@github.com:TheNightIsYoung/GitTestProject.git 注意：TheNightIsYoung 应该是你 GitHub 的用户名。如果使用成我的，关联没问题，但你无法推送（未添加你设备的 SSH Key）。 添加后，远程库的名字就是 origin，这是 Git 默认的叫法（比较形象），当然也可以改成别的。 修改本地映射的远程库的名字：git remote rename 3 –&gt; 推送本地 Git 所有内容到 GitHub 把本地库的内容推送到远程，用 git push 命令，实际上是把当前分支 master 推送到远程。 CMD 10 –&gt;&gt;&gt; git push &amp;&amp; git pull 123456789101112131415$ git push -u origin masterThe authenticity of host 'github.com (127.8.0.1)' can't be established.RSA key fingerprint is SHA256:nThbg6kXUpJWGl7E1IGOCspRomTxdCARLviKw6E5SY8.Are you sure you want to continue connecting (yes/no)? yesWarning: Permanently added 'github.com' (RSA) to the list of known hosts.Enumerating objects: 29, done.Counting objects: 100% (29/29), done.Delta compression using up to 8 threadsCompressing objects: 100% (19/19), done.Writing objects: 100% (29/29), 2.32 KiB | 395.00 KiB/s, done.Total 29 (delta 5), reused 0 (delta 0)remote: Resolving deltas: 100% (5/5), done.To github.com:TheNightIsYoung/GitTestProject.git * [new branch] master -&gt; masterBranch 'master' set up to track remote branch 'master' from 'origin'. |—————————————————————– SSH 连接警告 当你第一次使用 Git 的 clone 或者 push 命令连接 GitHub 时，会得到一个警告： 123The authenticity of host 'github.com (xx.xx.xx.xx)' can't be established.RSA key fingerprint is xx.xx.xx.xx.xx.Are you sure you want to continue connecting (yes/no)? 这是因为 Git 首次使用 SSH 连接，而 SSH 连接在第一次验证 GitHub 服务器的 Key 时，需要你确认 GitHub 的 Key 的指纹信息是否真的来自 GitHub 的服务器，输入 yes 回车即可。 后续，Git 会输出一个警告，告诉你已经把 GitHub 的 Key 添加到本机的一个信任列表里了： 1Warning: Permanently added 'github.com' (RSA) to the list of known hosts. 这个警告只会出现一次，后面的操作就不会有任何警告了。 如果你实在担心有人冒充 GitHub 服务器，输入 yes 前可以对照 GitHub 的 RSA Key 的指纹信息 是否与 SSH 连接给出的一致。 参数说明 由于远程库是空的，我们第一次推送 master 分支时，加上了 -u 参数，Git 不但会把本地的 master 分支内容推送的远程新的 master 分支，还会把本地的 master 分支和远程的 master 分支关联起来，在以后的推送或者拉取时就可以简化命令（直接使用 git pull or git push）。 —————————————————————–| 4 –&gt; 查看 GitHub GitTestProject 仓库 推送成功后，可以立刻在 GitHub 页面中看到远程库的内容已经和本地一模一样： 从现在起，只要本地作了提交，就可以通过命令： 1$ git push origin master 把本地 master 分支的最新修改推送至 GitHub（origin）。到这里你就拥有了真正的分布式版本库！ Remove Repo For Local Git如果添加的时候地址写错了，或者就是想删除远程库，可以用如下命令删除远程仓库的关联： CMD 11 –&gt;&gt;&gt; git remote rm &lt;repo name&gt; 建议先用 git remote -v 查看远程库信息： 123$ git remote -vorigin git@github.com:TheNightIsYoung/GitTestProject.git (fetch)origin git@github.com:TheNightIsYoung/GitTestProject.git (push) 然后，根据名字删除，比如删除 origin： 1$ git remote rm origin 注意：此处的 “删除” 其实是 解除了本地和远程的绑定关系，并不是物理上删除了远程库。远程库本身并没有任何改动。要真正删除远程库，需要登录到 GitHub，在后台页面找到删除按钮再删除。 Clone Repo From Github之前我已经创建好了一个 GitTestProject 远程库，并且关联到了我自己的本地测试项目仓库。 多个人协作开发时，其他人要想获取我的版本库的话，可以直接使用 git clone 从我的 GitHub 克隆一个 GitTestProject 本地库： CMD 12 –&gt;&gt;&gt; git clone &lt;repo addr&gt; 12345$ git clone git@github.com:TheNightIsYoung/GitTestProject.gitCloning into 'gitskills'...remote: Counting objects: 3, done.remote: Total 3 (delta 0), reused 0 (delta 0), pack-reused 3Receiving objects: 100% (3/3), done. GitHub 给出的地址不止一个，还可以用 https://github.com/TheNightIsYoung/GitTestProject.git 这样的地址。实际上 Git 支持多种协议，默认使用 SSH 协议，即 git://xxxxx ，但也可以使用 https 等其他协议。 使用 https 除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令，但是在某些只开放 http 端口的公司内部就无法使用 ssh 协议而只能用 https。 Git Clone 仓库中的单个目录 很多时候，由于项目较大，我们只想 git clone 仓库的某单个或多个文件夹，而不是全部的仓库内容。 Git1.7.0 以前，这无法实现。但是幸运的是，在 Git1.7.0 以后加入了 Sparse Checkout 模式，这使得 CheckOut 指定文件或者文件夹成为可能。 假设我们有一个 Github 仓库：https://github.com/yourgithub/Demo，我们想要 git clone Demo 里面的 childDir 子目录： 1234567891011121314151617181920212223###注意： 'childDir' 需要替换为自己想要下载的目录名称：# 初始化本地仓库：$ git init Demo &amp;&amp; cd Demo# 设置允许进行子目录克隆：$ git config core.sparsecheckout true$ 设置目标子目录名称（假设我的 childDir 位于 https://github.com/yourgithub/Demo/code 下）：echo 'code/childDir*' &gt;&gt; .git/info/sparse-checkout$ 映射：git remote add origin https://github.com/yourgithub/Demo.git# 拉取：$ git pull origin masterremote: Enumerating objects: 2750, done.remote: Total 2750 (delta 0), reused 0 (delta 0)Receiving objects: 100% (2750/2750), 36.41 MiB | 10.38 MiB/s, done.Resolving deltas: 100% (542/542), done.From e.coding.net:xdzsoft/mashangwuyou * branch master -&gt; FETCH_HEAD * [new branch] master -&gt; origin/master OK!!! 配置多个 SSH Key事实上，除了 Github 提供远程 Git 仓库托管服务，国内也有一些优秀的远程 Git 仓库托管服务平台（Gitee、Coding …），只要注册相关平台账号，就可以免费使用 Git 远程仓库，而且由于这些平台在国内，所以可以为我们提供更快的访问速度。 随着工作与学习的不断深入，你会拥有多个 Git 账户。比如公司 Gitlab 一个工作账号，Github 和 Gitee 一个个人学习账号，Coding 一个个人项目账号。而平时我们又会通过配置 SSH 公私钥认证的方式省去繁琐的登录远程仓库的操作，不同的 Git 账户一般都是不同的邮箱，而 SSH Key 又通过邮箱生成，那么就会涉及到为不同 Git Host 配置多对 ssh key 的问题。 详细步骤如下（以 Gitlab &amp;&amp; Gitee 为例）： 1 –&gt; 为公司账号生成一对密钥（Gitlab） 通过 -f 参数指定生成的密钥文件的名称 1$ ssh-keygen -t rsa -C &quot;yourEmail1@xx.com&quot; -f ~/.ssh/gitlab_id_rsa 执行后，生成公私钥文件如下： 12your identification has been saved in /home/xx_usr/.ssh/gitlab_id_rsa. ==&gt; 私钥your public key has been saved in /home/xx_usr/.ssh/gitlab_id_rsa_pub. ==&gt; 公钥 2 –&gt; 为个人账号生成一对密钥（Gitee） 通过 -f 参数指定生成的密钥文件的名称 1$ ssh-keygen -t rsa -C &quot;yourEmail2@xx.com&quot; -f ~/.ssh/gitee_id_rsa 执行后，生成公私钥文件如下： 12your identification has been saved in /home/xx_usr/.ssh/gitee_id_rsa. ==&gt; 私钥your public key has been saved in /home/xx_usr/.ssh/gitee_id_rsa_pub. ==&gt; 公钥 3 –&gt; 配置不同 SSH Key 使用规则 在 ~/.ssh 目录下新建名为 config 的文件（无后缀），config 文件用于配置多个不同的 Git Host 使用不同的 ssh key ： 1234567891011# giteeHost gitee.com HostName gitee.com PreferredAuthentications publickey IdentityFile ~/.ssh/gitee_id_rsa# gitlabHost gitlab.com HostName gitlab.com PreferredAuthentications publickey IdentityFile ~/.ssh/gitlab_id_rsa 配置文件参数说明： Host：用于区别不同平台的识别模式，名字随意； HostName：登录服务器的域名地址或者 ip 地址； PreferredAuthentications：配置登录时用什么权限认证 –&gt; 可设置 publickey，password publickey； IdentityFile：私钥路径。 4 –&gt; 配置平台的 SSH 将上面生成的公钥文件 gitlab_id_rsa_pub &amp;&amp; gitee_id_rsa_pub 中的内容，分别添加到 Gitlab 和 Gitee 平台的 SSH 中，添加过程类似于 Github。 至此，你可以像使用 Github 平台一样使用其它平台提供的 Git 仓库托管服务了~~~","link":"/2017/07/03/git-shi-yong-zhi-nan-zhi-yuan-cheng-cang-ku/"},{"title":"Hexo 博客多设备协同管理问题【持续更新】","text":"优秀的 Hexo 博客多环境、多设备协同管理方案。 前面我们已经成功搭建了基于 Hexo + Github·Page + Coding·Page + Domain + VSCode + TinyPNG + PicGo + Image Host 的个人博客环境。系列博文中给出了 Hexo 新手小白如何快速搭建基于 Hexo 的个人博客进行产出。 更多 Hexo 博客框架内容，请关注博主 Hexo 博文系列： 一文学会 Hexo 轻量级框架的博客搭建【持续更新】 Hexo 预安装环境部署之 Node.js Git 使用指南之初识 打造沉浸式写作体验，你需要试试-Markdown-Editor 基于图床的博客图片存储解决方案 稳定快速、高效免费的图床方案-Github-jsDelivr-PicGo Hexo 博客多设备协同管理问题【持续更新】 前面我们提到过，hexo d 仅仅是将 Hexo 博文静态页面（public）推送到了远程仓库（Github·Page 或 Coding·Page）上以实现公共访问，而 Hexo 个人博客框架相关配置信息都存放在本地终端。如果未进行其它备份或同步处理，一旦存放 Hexo 配置信息的本地终端出现问题（如系统崩溃），那么我们便无法再维护我们的的博客了，Game Over… 所有当我们更换工作环境（公司、个人）或者原来用于搭建 Hexo 博客环境的设备需要重新更换系统，出于安全性以及灵活性考虑，我们不得不面对的一个问题就是： 如何将本地终端中的 Hexo 博客相关配置信息完美移植到新环境或保持不同创作环境同步是至关重要的。 使用 Git 解决 Hexo 个人博客多平台同步管理关于 Hexo 博客多平台（多设备）协同管理以及更新教程网络上有很多，但对于刚刚接触 Hexo 、Git 的小白们不太友好，配置过程中容易出现各种问题，本文提到的所有配置方案均通过实际测试给出。 本文所作的主要目的：一方面作为学习记录回顾使用；另一方面适用于类似我这样的 Hexo 新手以供参考分享，可以快速对应以及解决问题。所以文中有些地方可能表达有误，欢迎各位大佬指正。 模拟场景公司和家里两台 PC： 公司 PC_A：最初用于搭建 Hexo 个人博客的终端； 个人 PC_B：移植 Hexo 个人博客项目的终端。 为了可以随时随地创作更新个人 Blog，两台 PC 中都必须搭建有相同的 Hexo 博客环境，并这必然要求我们的 Hexo 博客本地配置项目要保持同步（即实现版本控制）。 对于 同步 问题： 由于除了静态页面 以外，其它全部文件都在本地生成，所以如果在公司终端上推送了 articleA 文章后回家又写了篇 articleB 文章，在家里推送后我们会发现只有 articleB 文章而 articleA 文章没了（因为家里的 PC 上没有 articleA 文章的 md 文件），故及时同步两台 PC 终端中的 Hexo 博客项目相当重要。 也就是说，对我们的 Hexo 个人博客本地项目实现版本控制是必要的。 — important split line — 这里，我们首先给出新设备环境，解决 Hexo 个人博客多平台同步管理的通用步骤： 搭建 Hexo 个人博客环境，包括： Node.js、Git 以及 hexo 的安装，具体安装方式可见前面提到的搭建教程。 对 Hexo 个人博客本地配置信息项目实现同步，也就是版本控制。 实施方案分析介于模拟场景提到的解决方法，搭建 Hexo 个人博客环境本文不在做细致说明，参考前面教程即可。针对同步（备份），这里我们给出三种具体的版本控制（同步、备份）的实施方案分析： 存储设备备份使用存储设备备份，是指我们使用存储设备对 Hexo 个人博客项目本地文档进行备份。例如，我们可以直接对 PC_A 中最新的本地 Hexo 博客站点目录进行打包存储到硬盘、U盘或者云盘（大多数使用）中，然后将其移植 PC_B 中进行直接使用。 下面我们来分析其优略： 1）优点： 免费且操作简单快捷。 在某些场景下可以很快完成移植，而不需要进行额外的同步设置。例如，当我们的电脑需要重装系统时，我们可以直接将最新的 Hexo 博客项目进行打包，新系统中搭建好 Hexo 个人博客环境后，直接解压几乎就可以使用了。 2）缺点： 对于硬盘、U盘等设备，备份后的同步十分麻烦，每次其它终端都需要手动下载备份最新的 Hexo 博客文件夹，进行手动覆盖。 目前大多数云盘，可以开启云端自动备份功能，写完 Blog 后可以自动备份（同步）到云端。但是很容易产生一些云盘内部文件，影响 Hexo 解析产生一些不可预期的错误。 因此，使用存储设备备份使用的很少。 第三方代码仓库备份鉴于之前我们将 Hexo 个人博客产生的静态页面托管到了一些第三方 Git 服务平台，以实现远程访问。同样，类似于代码托管，我们可以将我们的 Hexo 个人博客项目本地配置信息文档托管到远程仓库进行版本控制，以实现多设备的同步管理。这是 目前最合理，并且使用最多 的解决方案。 使用第三方代码仓库进行备份是目前普遍使用的对 Hexo 个人博客进行备份同步的方法。 国内外现在知名的 Git 服务提供商主要有： Github、Coding 以及 Gitee（码云）等等，使用上没有比较大的差异，但国内站点访问较快。 下面我们来分析其优略： 1）优点： 部署完成后同步非常方便，Hexo 更新完后只需要再更新（push）全站到 Git 远程仓库即可。 2）缺点： 部署过程相对比较麻烦，对 Git 新手不友好，但这仅仅是 Git 使用上的问题，不是难点。 对于使用第三方代码仓库（以 Github 为例）进行备份的方法，目前主流的有两种方法： 分支备份法：我们知道，Hexo生成的静态博客文件都是上传到 GitHub 上的, 且默认放在 master 分支上。分支备份法是将本地的 Hexo 相关环境配置文件都推送到对应仓库新创建的分支上（如 hexo 分支），以实现备份。 将本地整个 Hexo Blog 项目进行备份：创建一个新的仓库用来对本地环境配置文件进行版本管理以及备份。 实施方案细则下面我们将以前面提到的实施方案给出其具体的操作指南，你可以根据需要选择不同的实施方案： 方案一：Hexo Envs + Cloud Service–&gt; 步骤一：Hexo envsPC_A 中我们已经成功搭建和使用 Hexo 博客了，所以不需要重复安装。而关于 PC_B 中 Hexo 个人博客环境的搭建，参考：一文学会 Hexo 轻量级框架的博客搭建【持续更新】 。步骤如下： 安装 Node.js 安装 Git 安装 Hexo –&gt; 步骤二：yunpan1）将 PC_A 终端中 Hexo 个人博客项目目录进行打包（打包格式任选，在 PC_B 中可以实现快速解压即可），备份到云盘。 2）然后在 PC_B 中从云盘下载已经上传好的 Hexo 个人博客项目压缩文件，然后进行解压。 3）PC_B 中开启 Hexo 服务，然后打开浏览器，通过访问 localhost:4000 进行 Hexo 博客本地测试，发现已经可以成功访问到我们的 Hexo 本地博客页面。 4）Hexo 个人博客本地测试通过后，由于更换设备，我们需要为Hexo Github·Page（Coding·Page）仓库配置新设备的 SSH Key。此时只需要将新设备（PC_B ）的 SSH Key 添加到 Github（Coding）中即可。如果不进行设置，当使用 hexo d 进行推送时无法成功，原因在于 Hexo 无法连接到 Github·Page（Coding·Page）。 关于新设备创建 SSH Key 方法以及为 Github 配置 SSH Key 可参加：Git 使用指南之远程仓库。 除了上述添加方式外，还有一种更简单的方式，我们可以将 PC_A 生成的 .ssh 文件直接放到 PC_B 设备当前用户目录下即可。 自此，设置完成。这种方法缺点很明显，操作太繁琐，对于同步很不友好！！！ 方案二：Hexo envs + hexo 备份（Recommended）这一小节，我们来看如何将本地整个 Hexo Blog 项目进行备份。即创建一个新的仓库用来对本地环境配置文件进行版本管理以及备份。 关于 Git 远程仓库的选择，Github or Coding or Gitee 三选其一即可，这里以 Github 为例，推荐使用 Coding or Gitee。这也就意味着： Hexo 博客静态页面托管到一个仓库，Hexo 博客配置托管到另一个远程仓库。 –&gt; 步骤一：Hexo envsPC_A 中我们已经成功搭建和使用 Hexo 博客了，所以不需要重复安装。而关于 PC_B 中 Hexo 个人博客环境的搭建，参考：一文学会 Hexo 轻量级框架的博客搭建【持续更新】 。步骤如下： 安装 Node.js 安装 Git 安装 Hexo 步骤一和方案一种中完全一样，实现 PC_B 上 Hexo 环境的部署。 –&gt; 步骤二：hexo 项目备份注意，这一部分操作全部在 PC_A（保存了 Hexo Blog 最新进度）上进行，用于将本地整个 Hexo Blog 项目托管到 Github 上的一个全新仓库（以创建 HexoBackups 为例）。 首先，添加设备 SSH Key 到 Github 以提供访问权限（在搭建 Hexo 环境时已经添加过），并且在 Github 中创建 HexoBackups 仓库（操作方法可见：Git 使用指南之远程仓库）。 1）删除 Hexo 站点目录主题路径（Hexo站点目录\\themes）下原有的 .git* 缓存文件夹，并编辑站点目录中的 .gitignore 文件。 有些插件或者主题是从 Github 上 clone 过来安装的，每个文件夹下都会有对应的 .git 文件夹，记得先删掉，否则会和 Blog 仓库冲突。（.git 默认是隐藏文件夹，需要先开启显示隐藏文件夹。.git 文件夹被删除后整个文件对应的 Git 仓库状态也会被清空，避免冲突） 编辑 .gitignore 文件的作用是声明不被 Git 记录的非必要文件（我们希望将必要的 Hexo 配置文件进行版本控制，而不是所有文件）。Blog 站点目录下的 .gitignore 是 Hexo 初始化时生成的，可以先删除或者直接编辑，对 Hexo 不会有影响。我的 Hexo 默认 .gitignore 文件内容如下： 1234567.DS_StoreThumbs.dbdb.json*.lognode_modules/public/.deploy*/ .deploy_git 是 Hexo 默认的 .git 配置文件夹，不需要同步； public 内文件是根据 source 文件夹内容自动生成，不需要备份，不然版本仓库每次修改内容太多； node_modules 目录中存放了 Hexo 个人博客所需的所有插件，太大，使用时通过 npm install 安装即可。 .DS_Store、Thumbs.db、*.log 、db.json 等均属于非必要文件。 2）初始化本地仓库 Hexo Blog 站点目录下执行以下代码： 123# &lt;server&gt; 是指远程备份仓库的地址（HexoBackups）；origin 是本地分支；remote add 操作会将本地仓库映射到云端 git initgit remote add origin &quot;Repository Addr&quot; “Repository Addr” 即上面创建的用于备份的仓库：HexoBackups 的仓库地址。 3）添加本地文件到本地仓库并同步到远程 Github 上 123456# 添加 Hexo Blog 站点目录下所有文件（.gitignore 声明过的文件不包含在内)git add .# 添加更新操作说明git commit -m &quot;Hexo Blog Backups&quot;# 推送更新到云端服务器git push -u origin master 在执行这步之前一定要注意检查下 .gitignore 文件的内容，看看是否正确的把一些文件夹忽略掉了。如果加错了的话可以用： 1git rm -r --cached . 自此，我们已经成功将本地 Hexo 博客配置文件推送到了 Github 远程仓库 HexoBackups 中实现版本控制。 –&gt; 步骤三：其它设备终端克隆测试1）添加 SSH Key 到 GitHub 首先，我们需要将设备 PC_B 的 SSH Key 添加到 GitHub 以提供访问权限。 2）将 Hexo Github 仓库内容同步到本地 之前我们已经成功将 PC_A 电脑里的 Hexo 配置信息备份到 Github HexoBackups 仓库了。 现在在 PC_B 电脑准备通过为本地仓库配远程 Hexo Github 版本仓库以实现 Hexo 配置信息同步。 123456789# 创建本地博客目录mkdir HexoBlogProjectcd HexoBlogProjectgit init# 将本地文件和云端仓库映射起来。这步不可以跳过git remote add origin &quot;Repository Addr&quot;git fetch --allgit reset --hard origin/master 当然我们还可以直接 git clone 将 HexoBackups 仓库中的 Hexo 博客配置文件拉取下来： 1git clone &quot;Repository Addr&quot; 3）安装依赖插件 同步后需要安装相应的 Hexo 插件（这是由于我们之前备份时未备份 node_modules 插件目录），否则无法正常使用 Hexo： 1npm install 4）localhost 测试 PC_B 中打开浏览器，通过访问 localhost:4000 进行 Hexo 博客本地测试，发现已经可以成功访问到我们的 Hexo 本地博客页面。 方案三：Hexo envs + hexo 分支备份和方案二中备份整个 Hexo 本地配置信息文件到一个新仓库不同的是，分支备份是在原 Hexo 静态页面托管仓库（username.github.io）重新创建一个分支（以 hexo 分支为例）来备份 Hexo 本地配置信息文件。 最终，username.github.io 仓库的 master 分支和 hexo 分支各自保存着一个版本： master 分支用于保存 Hexo 博客静态资源，提供博客页面以供人访问；hexo 分支用于备份博客部署文件，供自己维护更新，两者在一个 username.github.io 仓库内也不会有任何冲突。 -&gt; 步骤一：Hexo envsPC_A 中我们已经成功搭建和使用 Hexo 博客了，所以不需要重复安装。而关于 PC_B 中 Hexo 个人博客环境的搭建，参考：基于 Hexo 轻量级框架的博客搭建 。步骤如下： 安装 Node.js 安装 Git 安装 Hexo 步骤一和方案一种中完全一样，实现 PC_B 上 Hexo 环境的部署。 –&gt; 步骤二：hexo 分支备份注意，这一部分操作全部在 PC_A（保存了 Hexo Blog 最新进度）上进行。 和 方案二 中备份过程类似，这一部分给出 Hexo 分支备份通用流程，关于操作解读可对应 方案二 中的步骤二。 12345678910111213141516171819# 消除 Git 仓库冲突rm -rf Hexo站点目录\\themes\\主题目录、.git*# 即 Hexo 博客根目录cd Hexo站点目录# 初始化本地仓库git init# 将本地与 Github 远程仓库进行对接git remote add origin git@github.com:user/user.github.io.git# 添加 Hexo Blog 站点目录下所有文件（.gitignore 声明过的文件不包含在内)git add .# 添加更新操作说明git commit -m &quot;Hexo Blog Backups&quot;# 创建名为 hexo 的分支git checkout -b hexo# 推送分支到 GitHubgit push origin hexo –&gt; 步骤三：其它终端克隆测试1）添加 SSH Key 到 GitHub 首先，我们需要将设备 PC_B 的 SSH Key 添加到 GitHub 以提供访问权限。 2）克隆 Hexo 博客环境 123# 将 Github 中 hexo 分支 clone 到本地git clone -b hexo git@github.com:username/username.github.io.gitcd user.github.io 3）安装依赖插件 12# 安装 Hexo 博客中使用到的插件npm install 4）localhost 测试 PC_B 中打开浏览器，通过访问 localhost:4000 进行 Hexo 博客本地测试，发现已经可以成功访问到我们的 Hexo 本地博客页面。 Git + Hexo 管理博文这一部分我们来看加入版本控制后，如何进行 Hexo Blog 的多平台协同创作 （Git + Hexo）？ –&gt; 步骤一：发布静态页面 假设在 PC_B 电脑上写完了文章，然后进行发布： 1$ hexo d -g –&gt; 步骤一：同步 Hexo 最新配置 接下来，我们还需要将新文章的 .md 文件推送到备份仓库。（其实就是提交更新给 Hexo Github 备份仓库）： 1$ git add . 这时候可以用 git status 查看状态，一般会显示刚刚更改过的文件状态。如： 123456On branch masterChanges to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) modified: db.json new file: source/_posts/test.md 上面的输出状态即说明 db.json 文件做了更改，source/_posts 目录下新增了 test.md 文件。 然后对更改添加说明并推送到远程仓库： 123456git commit -m '更新信息'# 推送git push# 或者（取决于整体备份还是分支备份）git push origin hexo 当显示类似如下提示的时候，即表示备份成功： 12To git@git.oschina.net:xxxx/HexoBackups.git + 2c77e1e...5616bc6 master -&gt; master (forced update) 再回到到 PC_A 电脑上的时候，我们需要拉取最新的 Hexo 配置信息到本地以实现本地仓库和远程仓库一致： 1234# 拉取最新版本git pull# 或者（取决于整体备份还是分支备份）git pull origin hexo 即可实现 Hexo 博客同步更新以及协同管理。 自此，基于 Hexo + Github·Page + Coding·Page + Domain + VSCode + MarkDown + TinyPNG + PicGo + Image Host + Git 框架的 Hexo 个人博客创作生态已经建立。 常见问题Hexo 博客使用过程中的 真·疑难杂症： hexo init 卡死Hexo 搭建个人博客时，调用 hexo init 命令一直卡住不动： 12$ hexo initINFO Cloning hexo-starter https://github.com/hexojs/hexo-starter.git 这就很困惑了，npm 已经使用了淘宝源，node.js &amp;&amp; npm 版本也比较新，就是 hexo init 不成功…. 此时查看 Hexo 站点路径，发现目录中已经出现 clone 的文件目录结构： 12345678.gitscaffoldssourcethemes.gitignore_config.ymldb.jsonpackage.json 网上查找原因，应该是 Hexo 主题未能成功下载（子模块未能成功下载），可以在 .gitmodules 查看相关信息： 123submodule &quot;themes/landscape&quot; path = themes/landscape url = https://github.com/hexojs/hexo-starter.git 通过查看站点目录下的 themes 目录，发现确实没有相应主题。 –&gt; 解决方法： 为 Git 配置代理： git config –global http.proxy http://proxyuser:proxypwd@proxy.server.com:port 当然，你也可以等待网络流畅时重新进行 hexo init，说不定下一次执行就成功了。 npm install 很慢很慢安装 Hexo 博客相关依赖插件时，我们需要使用 npm install 下载进行安装。但是执行指令后一直没反应，这是由于 npm 官方资源被墙，我们可以为其更换一个国内源： 1npm config set registry https://registry.npm.taobao.org 当然，当我们的 Hexo 个人博客使用较多的插件时，npm install 可能看起来很慢（好像卡在某一个安装语句不再执行），此时我们可以通过 Hexo 站点目录下的 node_modules 目录更新时间来判断。 如果 node_modules 目录下各种插件文件更新时间长时间不发生变化，就意外着安装已停止，Ctrl + c 即可。 Git 监测不到空文件夹Git 无法监测到空文件夹，也就意外着无法将空文件夹 git add、git commit -m &quot;&quot;、git push 推送到远程仓库，这会导致 Hexo 博客项目中丢失一些空的功能文件夹。这应该算是 Git 的设计失误。 解决方法： 需要在空文件夹中添加一个占位文件。主流做法是在空文件夹里放置一个 .gitkeep 文件。或者加个 .gitconfig 文件在里面比较实用，也不会觉得突兀，虽然绝大多数时候这个文件不起作用。 Hexo 推送错误距离上次写博文已经有一段时间了，今天想将最近写好的博文推送到远程仓库，却发现推送不上去了，WTF？？！ 错误信息提示如下： ssh: connect to host github.com port 22: Connection timed outfatal: Could not read from remote repository.Please make sure you have the correct access rights and the repository exists. 然后进行了连接测试，果然发现连接有问题： 123$ ssh -T git@github.com# 和$ ssh -T git@gitee.com 从报错信息可以看出 GitHub 连接超时，去 ping github.com 也是正常的，浏览器也可以正常访问 Github，于是认为应该不是网络的问题。 第一反应是 SSH 配置出问题了，于是删除掉 .ssh 文件，重新生成并配置 Github SSH 公钥。配置完成之后再次推送，还是上述问题！！！ 于是开始 Google 解决问题了。网络上主流思路是“上述问题是由于 22 端口被占用了，修改一下访问端口就好使了！”，这种方法想要同时解决 Github &amp; Gitee 推送是有问题的，不要尝试了！！！ 当时采用切换端口的思路，使用 ssh -T -p 443 git@ssh.github.com 进行网络测试，确实是可以连接到的。于是从端口占用角度还去查了环境中 22 端口占用情况，发现也没问题，人方了 走投无路的时候，宿舍同学电脑这时候联不上校园网了，抱怨说学校的网络太辣鸡了~，这时候才想到可能真的是网络问题（有些网络环境下被 q 了），于是尝试使用手机热点进行推送，成功了！！！自此问题解决。","link":"/2017/09/22/hexo-bo-ke-duo-she-bei-xie-tong-guan-li-wen-ti-chi-xu-geng-xin/"},{"title":"Java JDK 下载与安装教程","text":"开始正式的 JAVA 语言学习之前，首要的就是完成 Java 程序所需的开发、运行环境搭建——JDK（Java Development Kit：Java 开发工具包）的安装，以及配置。 本篇博文所作目的主要是记录一下 Java 开发环境的搭建过程，即 JDK 的安装以及配置过程 安装以及配置 JDK这里，首先给出 JDK 各版本下载地址供安装选择： Download –&gt; JDK 官方最新版 Download –&gt; JDK 1.8 官方最新版 [Download –&gt; JDK 官方各历史版本 本文将以 JDK1.8 的安装配置为 Demo，其它 JDK 版本安装过程一样。 JDK Package Download根据个人的使用需要，从上面选择要访问的 JDK 下载页，选择就可以下载相应的安装包了： 注意：目前从官网下载相应版本 JDK 之前，你需要注册一个 Oracle 账号，并完成登录，才会被授权下载使用。 可以发现，JDK 官网提供了不同平台下（Linux、Mac 以及 Windows）JDK 的安装包。后文我们会给出 Linux &amp; Windows 平台下 JDK 的安装配置方法： 根据需要下载相应平台安装包 1.1 –&gt; For Windows: 对于 Windows 下的安装包，提供了 i586（32 bit） 和 x64（64 bit） 供我们下载使用。 这里我们选择安装包：jdk-8u261-windows-x64.exe 用于后续的安装。 1.2 –&gt; For Linux: 对于 Linux下的安装包，提供了 i586（32 bit） 和 x64（64 bit） 的 RPM 包以及 .tar.gz 包供下载使用。 这里我们选择安装包：jdk-8u261-linux-x64.tar.gz 用于后续的安装。 JDK Setup上面我们已经下载好了 JDK 的安装包，接下来我们来看如何在不同的平台下安装下载好的 JDK 安装包： For Windows1）检查当前系统中是否安装有 JDK Windows 命令行（Terminal ）下执行如下指令： 1$ java -version 如果原始系统中已安装有 JDK ，则会输出如下 JDK 版本等信息： 123java version &quot;1.8.0_131&quot;Java(TM) SE Runtime Environment (build 1.8.0_131-b11)Java HotSpot(TM) 64-Bit Server VM (build 25.131-b11, mixed mode) 否则的话，开始安装 JDK（当然，如果系统中已存在某个版本的 JDK 了，我们还可以再同时安装一个其它目标版本的 JDK），接下文。 2）安装 JDK 双击 jdk-8u261-windows-x64.exe 安装包开始进行安装…… 安装过程中没有什么难的，Next 即可。需要注意的是，我们可以自定义 JDK 安装路径，不要什么东西都往系统盘安装，这里假设我们安装在：E:\\JAVA 目录下。 等待安装完成关闭安装界面即可。 可以发现，JDK 以及被安装到了 E:\\JAVA 目录下，包含两个文件： 12jdk1.8.0_261jre1.8.0_261 自此 Windows 下 JDK 的安装就完成了，但此时仍不能使用，我们还需要为 JDK 配置环境变量，接 【1.3.1 Windows 下 JDK 环境变量配置】。 For Linux1）检查当前系统中是否安装有 JDK 1[root@localhost test]# java -version 有些 Linux 系统默认会安装有 openjdk（一种 Linux 开源 JDK），例如会输出如下信息： 123openjdk version &quot;1.8.0_102&quot;OpenJDK Runtime Environment (build 1.8.0_102-b14)OpenJDK 64-Bit Server VM (build 25.102-b14, mixed mode) 我们可以选择先将其卸载掉（当然，不用管也可以）： 1234# Centos 下可以使用 yum 进行卸载：[root@localhost test]# yum remove *openjdk*# Ubuntu 下[root@localhost test]# apt-get remove openjdk* 当然系统中还有可能装有其它版本（区别于 openjdk，例如：oracle）的 JDK，例如： 123java version &quot;1.8.0_131&quot;Java(TM) SE Runtime Environment (build 1.8.0_131-b11)Java HotSpot(TM) 64-Bit Server VM (build 25.131-b11, mixed mode) 否则的话，开始安装 JDK（当然，如果系统中已存在某个版本的 JDK 了，我们还可以再安装一个其它目标版本的 JDK），接下文。 2）安装 JDK 进入到 jdk-8u261-linux-x64.tar.gz` 安装包存放目录（例如：~/Downloads），并且对安装包进行解压： 12345678910# 查找安装包：[root@localhost test]$ cd Downloads[root@localhost Downloads]$ ls |grep jdk*jdk-8u131-linux-x64.tar.gz# 解压至 /usr/java 目录下：[root@localhost Downloads]$ tar -zxvf jdk-8u131-linux-x64.tar.gz -C /usr/java# 等待解压完成即可。# 解压后，我们可以在 /usr/java 目录下可以查看到解压好的 JDK 目录：jdk1.8.0_131 自此 Linux下 JDK 的安装就完成了，但此时仍不能使用，我们还需要为 JDK 配置环境变量，接 【3. 环境变量配置】。 Config EvnsFor WindowsWindows 下为 JDK 配置环境变量: 首先打开环境变量配置界面：右键我的电脑 ---&gt; 属性 ---&gt; 高级系统设置 ---&gt; 环境变量。界面如下： –&gt; 开始设置环境变量: 这里注意，我们既可以设置普通用户变量，也可以设置系统变量。区别在于设置普通用户变量的话，只有该用户下可用，其他用户想要使用的话需要重新配置环境变量。而设置系统变量后，我们可以在所有用户下都可以使用。 –&gt; 故，这里我们选择设置系统变量： 1）点击系统变量下面的新建按钮，变量名设置为：JAVA_HOME（代表 JDK 安装路径），变量值：E:\\JAVA\\jdk1.8.0_261（具体的 JDK 的安装路径）。如下： 2）继续在系统变量里面新建一个 CLASSPATH 变量， 其变量值为：.;%JAVA_HOME%\\lib\\tools.jar;%JAVA_HOME%\\lib\\dt.jar;。如下： 这里注意变量前面还有一个 .;，表示当前路径，不要漏加！！！ 3）在系统变量里面找一个变量名是 Path 的变量，找到后进行编辑，在它的变量值最后面追加一段如下的代码： 1%JAVA_HOME%\\bin; 最后点击确定，此时 Windows 下 JDK 的环境变量配置就完成了，还不圆满，需要测试一下。 4）测试 WIndows Terminal 下分别执行如下指令： –&gt; java -version 1234$ C:\\Users\\guoji&gt;java -versionjava version &quot;1.8.0_211&quot;Java(TM) SE Runtime Environment (build 1.8.0_211-b12)Java HotSpot(TM) 64-Bit Server VM (build 25.211-b12, mixed mode) –&gt; java 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051C:\\Users\\guoji&gt;java用法: java [-options] class [args...] (执行类) 或 java [-options] -jar jarfile [args...] (执行 jar 文件)其中选项包括: -d32 使用 32 位数据模型 (如果可用) -d64 使用 64 位数据模型 (如果可用) -server 选择 &quot;server&quot; VM 默认 VM 是 server. -cp &lt;目录和 zip/jar 文件的类搜索路径&gt; -classpath &lt;目录和 zip/jar 文件的类搜索路径&gt; 用 ; 分隔的目录, JAR 档案 和 ZIP 档案列表, 用于搜索类文件。 -D&lt;名称&gt;=&lt;值&gt; 设置系统属性 -verbose:[class|gc|jni] 启用详细输出 -version 输出产品版本并退出 -version:&lt;值&gt; 警告: 此功能已过时, 将在 未来发行版中删除。 需要指定的版本才能运行 -showversion 输出产品版本并继续 -jre-restrict-search | -no-jre-restrict-search 警告: 此功能已过时, 将在 未来发行版中删除。 在版本搜索中包括/排除用户专用 JRE -? -help 输出此帮助消息 -X 输出非标准选项的帮助 -ea[:&lt;packagename&gt;...|:&lt;classname&gt;] -enableassertions[:&lt;packagename&gt;...|:&lt;classname&gt;] 按指定的粒度启用断言 -da[:&lt;packagename&gt;...|:&lt;classname&gt;] -disableassertions[:&lt;packagename&gt;...|:&lt;classname&gt;] 禁用具有指定粒度的断言 -esa | -enablesystemassertions 启用系统断言 -dsa | -disablesystemassertions 禁用系统断言 -agentlib:&lt;libname&gt;[=&lt;选项&gt;] 加载本机代理库 &lt;libname&gt;, 例如 -agentlib:hprof 另请参阅 -agentlib:jdwp=help 和 -agentlib:hprof=help -agentpath:&lt;pathname&gt;[=&lt;选项&gt;] 按完整路径名加载本机代理库 -javaagent:&lt;jarpath&gt;[=&lt;选项&gt;] 加载 Java 编程语言代理, 请参阅 java.lang.instrument -splash:&lt;imagepath&gt; 使用指定的图像显示启动屏幕有关详细信息, 请参阅 http://www.oracle.com/technetwork/java/javase/documentation/index.html。 —&gt; javac 12345678910111213141516171819202122232425262728293031323334C:\\Users\\guoji&gt;javac用法: javac &lt;options&gt; &lt;source files&gt;其中, 可能的选项包括: -g 生成所有调试信息 -g:none 不生成任何调试信息 -g:{lines,vars,source} 只生成某些调试信息 -nowarn 不生成任何警告 -verbose 输出有关编译器正在执行的操作的消息 -deprecation 输出使用已过时的 API 的源位置 -classpath &lt;路径&gt; 指定查找用户类文件和注释处理程序的位置 -cp &lt;路径&gt; 指定查找用户类文件和注释处理程序的位置 -sourcepath &lt;路径&gt; 指定查找输入源文件的位置 -bootclasspath &lt;路径&gt; 覆盖引导类文件的位置 -extdirs &lt;目录&gt; 覆盖所安装扩展的位置 -endorseddirs &lt;目录&gt; 覆盖签名的标准路径的位置 -proc:{none,only} 控制是否执行注释处理和/或编译。 -processor &lt;class1&gt;[,&lt;class2&gt;,&lt;class3&gt;...] 要运行的注释处理程序的名称; 绕过默认的搜索进程 -processorpath &lt;路径&gt; 指定查找注释处理程序的位置 -parameters 生成元数据以用于方法参数的反射 -d &lt;目录&gt; 指定放置生成的类文件的位置 -s &lt;目录&gt; 指定放置生成的源文件的位置 -h &lt;目录&gt; 指定放置生成的本机标头文件的位置 -implicit:{none,class} 指定是否为隐式引用文件生成类文件 -encoding &lt;编码&gt; 指定源文件使用的字符编码 -source &lt;发行版&gt; 提供与指定发行版的源兼容性 -target &lt;发行版&gt; 生成特定 VM 版本的类文件 -profile &lt;配置文件&gt; 请确保使用的 API 在指定的配置文件中可用 -version 版本信息 -help 输出标准选项的提要 -A关键字[=值] 传递给注释处理程序的选项 -X 输出非标准选项的提要 -J&lt;标记&gt; 直接将 &lt;标记&gt; 传递给运行时系统 -Werror 出现警告时终止编译 @&lt;文件名&gt; 从文件读取选项和文件名 For Linux开始设置环境变量: 这里注意，我们既可以设置普通用户变量（局部变量），也可以设置系统变量（全局变量）。区别在于设置普通用户变量的话，只有该用户下可用，其他用户想要使用的话需要重新配置环境变量。而设置系统变量后，我们可以在所有用户下都可以使用。 –&gt; 故，这里我们选择设置系统变量： 1234567# 打开系统变量配置文件：[root@localhost test]# vim /etc/profile# 追加如下内容：export JAVA_HOME=/usr/java/jdk1.8.0_131export CLASSPATH=.;%JAVA_HOME%/lib/tools.jar:%JAVA_HOME%/lib/dt.jarexport PATH=$PATH:${JAVA_HOME}/bin –&gt; 生效 /etc/profile 配置文件： 1[root@localhost test]# source /etc/profile ============================================= 再来看一下普通用户变量如何设置： 12345# 在 ~/.bashrc 用户配置文件中添加上述内容即可。[root@localhost test]$ vim ~/.bashrc# 追加完配置内容后，需要使配置生效：[root@localhost test]$ source ~/.bashrc 此时 Linux下 JDK 的环境变量配置就完成了，还不圆满，需要测试一下。 –&gt; 测试 12345$ java -version$ java$ javac 篇幅原因，输出信息释义见 Windows 中测试部分。 You Need Know MorePath 和 CLASSPATH 详解1 –&gt; Path Path，是系统用来搜索可执行文件路径的环境变量。如果所执行的文件不在当前目录下，就会依次搜索 Path 中设置的路径。 而 Java 中的可执行文件路径是存放于 bin 目录下的，所以在 Path 中设置了 JDK 的 bin 路径后，DOS/Shell 中即使不把 jdk 可执行文件的完整路径给出，系统会自动去 Path 中设置的路径查找，然后执行。 这也是很多应用配置系统环境变量（Path）后，就可以直接在 DOS/Shell 中快速调用或启动的原因！ 2 –&gt; CLASSPATH CLASSPATH，是 Java 专用的查找类的路径，用来指定 Java 程序中所用类文件所在的位置。 如 Java 程序中，“import javax.swing.JTable” 就是告诉编译器引入 “javax.swing” 这个包下面的 “JTable”，而 CLASSPATH 就是告诉编译器要去哪里找到这个包。 两套 JRE？？？Windows 下 Java 安装完成之后，你会发现有两套 JRE：一套位于 &lt;JDK安装目录&gt;\\jre 下，一套位于 C:\\Program Files\\Java\\jre1.8.0_xxx 或和 &lt;JDK安装目录&gt; 同目录下。 并且安装 JDK 可以选择是否只安装 JRE，而不是 JDK，那么只会在安装目录下安装唯一的一套 JRE。 1 –&gt; 两套 JRE 的作用？ 两套 JRE 主要体现在工作的职责上，也就是不同的JRE负责不同的工作范围： JDK 里的工具有些是用 Java 所编写，因此要使用 JDK 所附的工具来开发 Java 程序，也必须要附一套 JRE 才行（如javac.exe、jar.exe…） 例如： javac.exe 与输入 java -cp c:/jdk/lib/tools.jar com.sun.tools.javac.Main 是一样的，可以认为 javac.exe 只是一个包装器（Wrapper），目的是简写指令。 而，另外一套 JRE 就是专门用来运行开发好的 Java 程序用的。 2 –&gt; 执行谁？ 例如 Java.exe 依照顺序来查找 JRE： 自己的目录下有没有 JRE ? 父目录有没有 JRE ? 查询注册表（环境变量）：[HKEY_LOCAL_MACHINE/SOFTWARE/JavaSoft/Java Runtime Environment] ? JDK 安装目录详解JDK安装目录如下（JDK 8）： 下面来详细介绍： 1 –&gt; bin bin(binary) 目录下存放了 JDK 的各种工具的可执行文件： 12345678# 主要工具可执行文件：Javac：Java编译器，将 Java 源代码编译为字节码文件；Java：Java解释器，解释执行 Java 字节码文件；appletviewer：Java Applet小程序查看器，可以执行 HTML 文件上 Java Applet 程序；Javadoc：java文档生成器，提取 Java 源码中的注释生成 HTML 说明文档；Jdb：Java调试器，可以逐行执行程序，设置断点和检查变量；Javap：Java反编译器，显示编译成的类文件中的可访问功能和数据，同时显示字节代码含义。jar：java打包器，可将 Java 包结构压缩成以 .jar 为后缀的 JAR 文件 2 –&gt; db db 目录是从 Java 6 开始新增的一个目录，这是一个纯 Java 实现、开源的数据库管理系统（DBMS），源于 Apache 软件基金会（ASF）名下的项目 Derby。 3 –&gt; include 由于 JDK 是通过 C 和 C++ 实现的，因此在启动时需要引入一些 C 语言的头文件，所以 include目录里面是一些供 C语言使用的标题文件。 支持 Java 本地接口和 Java 虚拟机调试程序接口的本地编程技术。 4 –&gt; jre jre 目录路径下安装的就是 Java 运行时环境。 5 –&gt; lib lib(libarary)，见名知义，存放类库，存放的是开发工具使用的归档包文件。 6 –&gt; src.zip 该压缩文件里面存放的就是 Java 所有核心类库的源代码。通过该文件可以查看 Java 基础类的源代码。 7 –&gt; javafx-src.zip 存放 JavaFX 脚本，JavaFX 它是一种声明式、静态类型编程语言。(是 JDK 1.8 以上新加的)。","link":"/2017/10/09/java-jdk-xia-zai-yu-an-zhuang-jiao-cheng/"},{"title":"Java 程序设计基础之操作符","text":"关于 Java 程序设计语言的 基础语法 部分，前面我们已经详细了解过了 Java 中的字面值，变(常)量，数据类型，本文我们来看 Java 基础语法的另一个重要组成部分——操作符，Java 中提供了丰富的操作符支持。 Java 中的操作符1 –&gt; 特殊概念 –&gt; 优先级 &amp; 结合性 Java 中的操作符，等价于数学中的运算符，也是有优先级，和结合性的概念的。 这也就是说，当一个表达式中出现多种操作符时，执行的先后顺序不仅要遵守操作符优先级规定，还要受操作符结合性的约束，以便确定是自左向右进行运算？还是自右向左进行运算？ –&gt; 操作数 操作符进行运算时，所操作（依赖）的数据 –&gt; 操作符按照【操作数的数量】可以分为：单目运算符、双目运算符和三目运算符。 2 –&gt; 操作符类别 Java 中最基本的操作符可归纳为以下 6 大类： 算术操作符 赋值操作符 关系操作符 逻辑操作符 条件操作符 位操作符 详细解读上面提到的 6 种 Java 基本操作符用法： 算术操作符Java 语言中，算术操作符的功能是对数据进行算术运算。这里为了方便记忆，特将算术运算分为两类： 基本算术操作符：+（加） -（减） *（乘） /（除）％（取模/余） 基本算术赋值操作符：+=（加赋值）-=（减赋值）*=（乘赋值）/=（除赋值）%=（取模赋值） 算术单目运算符：-（负） ++（自增） –（自减） 基本算术操作符Java 算术操作符种，最基本的算术运算就是： 1+（加） -（减） *（乘） /（除）％（取模/余） 上述运算符，和我们平常接触的数学运算具有相同的含义。 隐藏运算规则： 如果表达式中有任何运算单元的长度超过 int，那么运算结果就按照最长的长度计算 如果表达式中有任何运算单元的长度都不超过 int，那么运算结果就按照 int 来计算 123456789101112public class HelloWorld { public static void main(String[] args) { int a = 5; long b = 6; int c = (int) (a+b); // a+b 的运算结果是 long 型，所以要进行强制转换 byte d = 1; byte e= 2; byte f = (byte) (d+e); //虽然 a b 都是 byte 类型，但是运算结果是 int 类型，需要进行强制转换 }} 基本算术赋值操作符算术赋值运算符只是一种简写（算术操作符 &amp;&amp; 赋值运算符的一种应用），一般用于变量自身的变化： 运 算 符 名 称 例 子 等价于 += 加赋值 a += b + 3 a = a + b + 3 -= 减赋值 a -= b a = a - b *= 乘赋值 a *= b a = a*b /= 除赋值 a /= b a = a/b %= 取余赋值 a %= b a = a%b 算术单目操作符算术操作符中的，单目运算符有 3 个，分别表示：-（负） ++（自增） –（自减）。 其中，-（负）最为简单，就是数学上的含义，不做过多说明，下面重点来看自增、自减的使用。 使用原则： 自增/自减只能作用于变量，不允许对常量、表达式等进行操作； 自增/自减运算可以用于整数类型 byte、short、int、long；浮点类型 float、double；字符串类型 char 自增/自减运算（Java V1.5 以上）可以用于基本类型对应的包装器类 Byte、Short、Integer、Long、Float、Double 和 Character 自增/自减运算作用于变量自身加/减 1，放在操作数的前面或后面都是允许的。 1 –&gt; 自增 &amp; 自减 i++（自增）i –（自减）：在变量 i 原来的基础上，增加 1 或者减少 1。 123456789public class HelloWorld { public static void main(String[] args) { int i = 4; i++; System.out.println(5); // 输出为6 }} 2 –&gt; 前后置区别 以 ++ 为例，– 同理。 123int i = 4;i++; // 先取值，再运算++i; // 先运算，再取值 具体测试例： 1234567891011public class HelloWorld { public static void main(String[] args) { int i = 5; System.out.println(i++); // 输出5 System.out.println(i); // 输出6 int j = 5; System.out.println(++j); // 输出6 System.out.println(j); // 输出6 }} 思考：下面的 j 是 多少？ 12int i = 1;int j = ++i + i++ + ++i + ++i + i++; // 2 + 2(3) + 4 + 5 + 5 = 18 赋值操作符赋值运算符是指为 变量或常量 指定数值的符号。使用很简单，其语法格式如下所示： 1变量名称 = 表达式内容 它是双目运算符，左边的操作数必须是变量，不能是常量或表达式；右侧可以为字面值，表达式。 注意：不要将赋值运算符与相等运算符 “==” 混淆。 示例： 123456public class HelloWorld { public static void main(String[] args) { /* 首先进行 5+5 的运算，得到结果 10，然后把 10 这个值，赋给变量 i */ int i = 5+5; }} 关系操作符关系操作符（relational operators）也可以称为：“比较操作符”，用来比较判断两个变量或常量的大小。 运算结果是 boolean 型。当操作符对应的逻辑关系成立时，运算结果是 true，否则是 false。 比较操作符的含义及其实例应用： 1 –&gt; 大于操作符（&gt;） 只支持左右两边操作数是数值类型。如果前面变量的值大于后面变量的值， 则返回 true。 12# false2 &gt; 3 2 –&gt; 大于等于操作符（&gt;=） 只支持左右两边操作数是数值类型。如果前面变量的值大于等于后面变量的值， 则返回 true。 12# true4 &gt;= 2 3 –&gt; 小于操作符（&lt;） 只支持左右两边操作数是数值类型。如果前面变量的值小于后面变量的值，则返回 true。 12# true2 &lt; 3 4 –&gt; 小于等于操作符（&lt;=） 只支持左右两边操作数是数值类型。如果前面变量的值小于等于后面变量的值， 则返回 true。 12# false4 &lt;= 2 5 –&gt; 相等运算符（==） 5.1 数值类型比较： 无论它们的数据类型是否相同，只要它们的值相等，也都将返回 true。 12345678# true4 == 4# true97 == 'a'# true5.0 == 5# falsetrue == false 等于操作符支持，两个 boolean 类型的值进行比较。但注意：boolean 类型的变量、值不能与其他任意类型的变量、值使用 == 进行比较。 5.2 引用类型比较： 只有当两个引用变量的类型具有父子关系时才可以比较，只要两个引用指向的不是同一个对象就会返回 true。 6 –&gt; 不相等运算符（!=） 6.1 数值类型比较： 如果进行比较的两个操作数都是数值类型，无论它们的数据类型是否相同，只要它们的值不相等，也都将返回 true。 12# true4 != 2 6.2 引用类型比较： 如果两个操作数都是引用类型，只有当两个引用变量的类型具有父子关系时才可以比较，只要两个引用指向的不是同一个对象就会返回 true。 ============================================= You Know More： == 和 != 可以应用于基本数据类型和引用类型。当用于引用类型比较时，比较的是两个引用是否指向同一个对象，但实际开发过程多数情况下，只是比较对象的内容是否相当，不需要比较是否为同一个对象。 基本类型的变量、值不能和引用类型的变量、值使用 == 进行比较；boolean 类型的变量、值不能与其他任意类型的变量、值使用 == 进行比较；如果两个引用类型之间没有父子继承关系，那么它们的变量也不能使用 == 进行比较。 逻辑操作符逻辑运算符把各个关系表达式连接起来组成一个复杂的逻辑表达式，以判断程序中的表达式是否成立，判断的结果是 true 或 false。 逻辑运算符的用法、含义及实例： 1 –&gt; 逻辑与（&amp;） 和 短路与（&amp;&amp;） 两边的运算单元都是布尔值，运算规则： 都为真时，才为真 有假即假 区别： 逻辑与 两侧，都会被运算 短路与 只要第一个是false，第二个就不进行运算了 1234567891011121314public class HelloWorld { public static void main(String[] args) { //长路与 无论第一个表达式的值是true或者false,第二个的值，都会被运算 int i = 2; System.out.println( i== 1 &amp; i++ ==2 ); //无论如何i++都会被执行，所以i的值变成了3 System.out.println(i); //短路与 只要第一个表达式的值是false的，第二个表达式的值，就不需要进行运算了 int j = 2; System.out.println( j== 1 &amp;&amp; j++ ==2 ); //因为j==1返回false,所以右边的j++就没有执行了，所以j的值，还是2 System.out.println(j); }} 2 –&gt; 逻辑或（|） 和 短路或（||） 两边的运算单元都是布尔值，运算规则： 有真即真 都为假时，才为假 区别： 逻辑或（|）两侧都会被运算 短路或（||） 只要第一个是 true 的，第二个就不进行运算了 1234567891011121314public class HelloWorld { public static void main(String[] args) { //长路或 无论第一个表达式的值是true或者false,第二个的值，都会被运算 int i = 2; System.out.println( i== 1 | i++ ==2 ); //无论如何i++都会被执行，所以i的值变成了3 System.out.println(i); //短路或 只要第一个表达式的值是true的，第二个表达式的值，就不需要进行运算了 int j = 2; System.out.println( j== 2 || j++ ==2 ); //因为j==2返回true,所以右边的j++就没有执行了，所以j的值，还是2 System.out.println(j); }} 3 –&gt; 取反（!） 真变为假，假变为真。 123456789public class HelloWorld { public static void main(String[] args) { boolean b = true; System.out.println(b); //输出true System.out.println(!b);//输出false }} 4 –&gt; 异或（^） 不同，返回真；相同，返回假。 12345678910public class HelloWorld { public static void main(String[] args) { boolean a = true; boolean b = false; System.out.println(a^b); //不同返回真 System.out.println(a^!b); //相同返回假 }} 注意：短路与（&amp;&amp;）和短路或（||）能够采用最优化的计算方式，从而提高效率。在实际编程时，应该优先 考虑使用短路与和短路或。 条件操作符Java 中提供了一个特别的三目运算符，经常用于取代某个类型的 if-then-else 语句。 使用条件操作符的一般语法结构为： result = &lt;expression&gt; ? &lt;statement_1&gt; : &lt;statement_3&gt;; 其中，expression 是一个布尔表达式。当 expression 为真时，执行 statement_1， 否则就执行 statement_3。 12345678910111213141516171819public class HelloWorld { public static void main(String[] args) { int i = 5; int j = 6; int k = i &lt; j ? 99 : 88; // 相当于 if (i &lt; j) { k = 99; } else { k = 88; } System.out.println(k); }} 位操作符Java 中定义的位运算（bitwise operators），按位运算表示按每个二进制位（bit）进行计算。 可以直接对 整数类型 的二进制位进行操作，这些整数类型包括 long，int，short，char 和 byte。其操作数和运算结果都是整型值。 Java 语言中的位运算符分为 位逻辑操作符 、 位移操作符 以及位操作符： 位逻辑操作符：&amp;（与）、|（或）、~（非）和 ^（异或） 位移操作符：将操作数向左（&lt;&lt;）或者右（&gt;&gt;），移动指定的二进制位数 这里注意，位逻辑操作符和逻辑操作符的区别。 1 –&gt; 整数的二进制 位操作，都是对整型操作数二进制而言的。 Java 中可以通过 Integer.toBinaryString() 方法，将一个十进制整数转换为一个二进制字符串 12345678910public class HelloJava { public static void main(String[] args) { // TODO Auto-generated method stub int i = 5; String string = Integer.toBinaryString(i); System.out.println(string); } } 2 –&gt; 位逻辑操作符 2.1 –&gt; 位与（&amp;） 运算规则： 参与运算的操作数，低位对齐，高位不足的补零；如果对应的二进制位同时为 1，那么计算结果才为 1，否则为 0。 例如：100&amp;0 2.2 –&gt; 位或（|） 运算规则： 参与运算的操作数，低位对齐，高位不足的补零；如果对应的二进制位只要有一个为 1，那么结果就为 1；如果对应的二进制位都为 0，结果才为 0。 例如：11|7 2.3 –&gt; 位异或（^） 运算规则： 其运算规则是：参与运算的数字，低位对齐，高位不足的补零，如果对应的二进制位相同（同时为 0 或同时为 1）时，结果为 0；如果对应的二进制位不相同，结果则为 1。 例如：11^7 2.4 –&gt; 位取反（~） 运算规则： 只对一个操作数进行运算，将操作数二进制中的 1 改为 0，0 改为 1。 例如：~10 注意：位操作符的操作数只能是整型或者字符型数据以及它们的变体，不用于 float、double 或者 long 等复杂的数据类型。 3 –&gt; 位移操作符 位移运算符用来将操作数向某个方向（向左或者右）移动指定的二进制位数。 位移操作符说明： 运算符 含义 实例 结果 » 右移位运算符 8»1 4 « 左移位运算符 9«2 36 3.1 –&gt; 左位移（&lt;&lt;） 运算规则： 按二进制形式把所有的数字向左移动对应的位数，高位移出（舍弃），低位的空位补零。 例如：11 –&gt; 22 3.2 –&gt; 右位移（&gt;&gt;） 运算规则： 按二进制形式把所有的数字向右移动对应的位数，低位移出（舍弃），高位的空位补零。 例如：11 –&gt; 5 ======================================================= 带符号右移与无符号右移： 1 –&gt; 带符号右移：&gt;&gt; 对于正数， 带符号右移 &gt;&gt; 会把所有的位右移，并在最前面补0对于负数， 带符号右移 &gt;&gt; 会把所有的位右移，并在最前面补1 2 –&gt; 无符号右移：&gt;&gt;&gt; 如果是一个负数，那么对应的二进制的第一位是1。无符号右移&gt;&gt;&gt;会把第一位的1也向右移动，导致移动后，第一位变成0，这样就会使得负数在无符号右移后，得到一个正数。 4 –&gt; 位赋值操作符 所有的二进制位运算符都有一种将赋值与位运算组合在一起的简写形式： 运算符 含义 实例 结果 &amp;= 按位与赋值 num1 &amp;= num2 等价于 num 1=num 1 &amp; num2 |= 按位或赋值 num1 |= num2 等价于 num 1=num 1 ^= 按位异或赋值 num1 ^= num2 等价于 num 1=num 1 ^ num2 «= 按位左移赋值 num1 «= num2 等价于 num 1=num 1 « num2 »= 按位右移赋值 num1 »= num2 等价于 num 1=num 1 » num2 ============================================ 位赋值实例： 1234567891011121314151617181920212223public class HelloJava { public static void main(String[] args) { // TODO Auto-generated method stub int a = 1; int b = 2; int c = 3; a &amp;= 4; System.out.println(a); a |= 4; System.out.println(a); a ^= c; System.out.println(a); a -= 6; System.out.println(a); b &gt;&gt;= 1; System.out.println(b); c &lt;&lt;= 1; System.out.println(c); } } 输出： 123456047116 操作符优先级Java 中操作符优先级助记口诀： 单目乘除为关系，逻辑三目后赋值 口诀解释： 单目：单目操作符 –&gt; !（取反）+（正） –（负数） ++/ –（自增自减） ~ 乘除：算数操作符中的 *（乘） /（除） %（取模）–&gt; 后 +（加）-（减） 为：位移操作符 &lt;&lt; （左移）&gt;&gt;（右移） 关系：关系运算符&gt; （大于）&lt;（小于） &gt;=（大于等于） &lt;=（小于等于）==（等于） !=（不等于） 逻辑：逻辑操作符 &amp;&amp;（短路与） ||（短路或） &amp;（逻辑与） |（逻辑或） ^ （异或） 三目：三目操作符 A &gt; B ? X : Y 后：无意义，仅仅为了凑字数 赋值：=（赋值）+=/-+/*=//=/%=（算术赋值）&amp;=/|=/^=/~=（位逻辑赋值）&lt;&lt;=/&gt;&gt;=（位移赋值） 操作符优先级： 优先级 运算符 结合性 1 ()、[]、{} 从左向右 2 !、+、-、~、++、– 从右向左 3 *、/、% 从左向右 4 +、- 从左向右 5 «、»、&gt;&gt;&gt; 从左向右 6 &lt;、&lt;=、&gt;、&gt;=、instanceof 从左向右 7 ==、!= 从左向右 8 &amp; 从左向右 9 ^ 从左向右 10 | 从左向右 11 &amp;&amp; 从左向右 12 || 从左向右 13 ?: 从右向左 14 =、+=、-=、*=、/=、&amp;=、|=、^=、~=、«=、»=、&gt;&gt;&gt;= 从右向左 实际的开发中，需要去记忆运算符的优先级别，也不要刻意的使用运算符的优先级别，对于不清楚优先级的地方使用小括号去进行替代。 Scanner截至目前为止，学习了使用 System.out.println(“”) 向控制台输出数据。 那么，如何从控制台输入数据？ 使用Scanner类，需要在最前面加上 import java.util.Scanner; 表示导入这个类，才能够正常使用。 Scanner 读取整数1234567891011import java.util.Scanner; public class HelloWorld { public static void main(String[] args) { Scanner s = new Scanner(System.in); int a = s.nextInt(); System.out.println(&quot;第一个整数：&quot;+a); int b = s.nextInt(); System.out.println(&quot;第二个整数：&quot;+b); }} Scanner 读取浮点数12345678910import java.util.Scanner; public class HelloWorld { public static void main(String[] args) { Scanner s = new Scanner(System.in); float a = s.nextFloat(); System.out.println(&quot;读取的浮点数的值是：&quot;+a); }} Scanner 读取字符串123456789import java.util.Scanner; public class HelloWorld { public static void main(String[] args) { Scanner s = new Scanner(System.in); String a = s.nextLine(); System.out.println(&quot;读取的字符串是：&quot;+a); }} 读取了整数后，接着读取字符串: 如果在通过nextInt()读取了整数后，再接着读取字符串，读出来的是回车换行:”\\r\\n”,因为nextInt仅仅读取数字信息，而不会读取回车换行”\\r\\n”。 所以，如果在业务上需要读取了整数后，接着读取字符串，那么就应该连续执行两次nextLine()，第一次是取走回车换行，第二次才是读取真正的字符串。 123456789101112import java.util.Scanner; public class HelloWorld { public static void main(String[] args) { Scanner s = new Scanner(System.in); int i = s.nextInt(); System.out.println(&quot;读取的整数是&quot;+ i); String rn = s.nextLine(); String a = s.nextLine(); System.out.println(&quot;读取的字符串是：&quot;+a); }} Scanner Close使用之后记得关闭 Scanner，防止消耗资源 scan.close();","link":"/2017/10/14/java-cheng-xu-she-ji-ji-chu-zhi-cao-zuo-fu/"},{"title":"Java 程序设计基础之流程控制","text":"关于 Java 程序设计语言的 基础语法 部分，前面我们已经详细了解过了 Java 中的字面值，变(常)量，数据类型以及操作符，这里我们来看 Java 基础语法的另一个重要组成部分——Java 中的流程控制语句，它决定程序要进入什么流程，即“做什么”以及“怎么做等。 流程控制结构从结构化程序设计角度出发，编程语言一般会有 3 种结构： 顺序结构 分支结构 循环结构 若是在程序中没有给出特别的执行流程控制，系统则默认自上而下一行一行地执行该程序，这类程序的结构就称为顺序结构。 但事实上，现实事物的发展往往不会遵循早就设想好的轨迹进行，此时需要引入：分支结构，循环结构。 分支结构Java 支持两种选择语句： if 语句：使用 布尔表达式或布尔值 作为分支条件，来进行程序执行分支控制 switch 语句：用于对多个 整型值、字符串值 进行匹配，从而实现程序执行分支控制。 下面会分别对上述的两种选择（分支）语句进行解读： if 语句1 –&gt; if 结构 if 语句的最简语法格式如下，表示：“如果条件表达式为 true，就执行语句块”。 123if (条件表达式) { 语句块;} if 条件语句的运行流程如下： 实例： 12345678910public class HelloWorld { public static void main(String[] args) { boolean b = true; if(b){ // 如果成立就打印：yes System.out.println(&quot;yes&quot;); } }} –&gt; 多表达式与一个表达式 123456789101112131415161718192021222324252627public class HelloWorld { public static void main(String[] args) { boolean b = false; // 如果有多个表达式，必须用大括弧包括起来 if(b){ System.out.println(&quot;yes1&quot;); System.out.println(&quot;yes2&quot;); System.out.println(&quot;yes3&quot;); } // 否则表达式2 3, 无论 b 是否为 true 都会执行 if(b) System.out.println(&quot;yes1&quot;); System.out.println(&quot;yes2&quot;); System.out.println(&quot;yes3&quot;); // 如果只有一个表达式可以不用写括弧，看上去会简约一些（但语法规范不推荐） if(b){ System.out.println(&quot;yes1&quot;); } if(b) System.out.println(&quot;yes1&quot;); }} 2 –&gt; if-else 结构 if-else 结构语法格式如下，表示：“如果条件（表达式）正确则执行 –&gt; 语句块1，否则执行 –&gt; 语句块2”。 12345if (表达式) { 语句块1;} else { 语句块2;} if-else 结构的运行流程如下： 实例： 12345678910111213public class HelloWorld { public static void main(String[] args) { boolean b = false; if (b){ System.out.println(&quot;yes&quot;); } else{ System.out.println(&quot;no&quot;); } }} 3 –&gt; 多条件 if-else-if 结构 if-else-if 结构是多条件判断，语法格式如下： 12345678910if(表达式1) { 语句块1;} else if(表达式2) { 语句块2;...} else if(表达式n) { 语句块n;} else { 语句块n+1;} 表现为：依次判断表达式的值，当某个分支的条件表达式的值为 true 时，则执行该分支对应的语句块，然后跳到整个 if 语句之外继续执行程序。如果所有的表达式均为 false，则执行语句块 n+1，然后继续执行后续程序。 if-else-if 结构的运行流程如下： 实例： 1234567891011121314151617181920212223242526public class HelloWorld { public static void main(String[] args) { // 如果只使用 if,会执行 4 次判断 int i = 2; if (i==1) System.out.println(1); if (i==2) System.out.println(2); if (i==3) System.out.println(3); if (i==4) System.out.println(4); // 如果 i == 2 时成立，则后续判断均不再执行 if (i==1) System.out.println(1); else if (i==2) System.out.println(2); else if (i==3) System.out.println(3); else if (i==4) System.out.println(4); }} 4 –&gt; if 嵌套结构 if 条件结构里嵌套另一个 if 结构。同样，if…else 结构语句和 if…else if 结构语句中也可以嵌套另一个 if 结构的语句，以完成更深层次的判断（一般不要超过 3 层）。 嵌套 if 的语法格式如下： 12345678910111213141516171819if(表达式1) { if(表达式2) { 语句块1; } else { 语句块2; }} else { if(表达式3) { 语句块3; } else if(表达式4) { 语句块4; } else { if(表达式n) { 语句块n; } else { 语句块n+1; } }} switch 语句switch 语句是 Java 中的多路分支语句，提供了一种基于一个表达式的值来使程序执行不同部分的简单方法。 switch 提供了一个比一系列 if-else-if 语句更好的选择。 switch 语句的基本语法形式如下所示： 123456789101112131415switch(表达式) { case 值1: 语句块1; break; case 值2: 语句块2; break; … case 值n: 语句块n; break; default: 语句块n+1; break;} switch 语句的执行过程如下：表达式的值与每个 case 语句中的常量作比较。如果发现了一个与之相匹配的，则执行该 case 语句后的代码。如果没有一个 case 常量与表达式的值相匹配，则执行 default 语句。 default 语句是可选的。 如果没有相匹配的 case 语句，也没有 default 语句，则什么也不执行。 注意：重复的 case 值是不允许的。 ================================================= 使用注意： switch 关键字后面小括号里的值：要放一个整型变量或字符型变量；表达式必须为 byte，short，int，char类型； case 关键字后的值，可以是：类型为 char、byte、 short 或 int 的常量表达式；enum 常量；或字符串字面量； break：一般语句块后均需要加 break；如果在 case 分支语句的末尾没有 break 语句，那么就会接着执行下一个 case 分支语句。这种情况相当危险，常常会引发错误。 default：表示“默认”，即其他情况都不满足；default 块和 case 块的先后顺序可以变动，不会影响程序执行结果。通常，default 块放在末尾，也可以省略不写。 switch 语句中也支持嵌套，但一般不这么用 if 语句可计算任何类型的布尔表达式。也就是 switch 语句只能寻找 case 常量间某个值与表达式的值相匹配。 循环结构所有流行的编程语言中都有循环语句。Java 中采用的循环语句与C语言中的循环语句相似，主要有： while do-while for Java 5 之后，还推出了 for-each 循环语句。它是专门为数组、集合遍历而设计的。但 for-each 并不是一个关键字。 while 语句while 语句是 Java 最基本的循环语句，是一种先判断的循环结构。while 循环语句的语法结构如下： 123while(条件表达式) { 语句块;} 其中语句块中的代码可以是一条或者多条语句，而条件表达式是一个有效的 boolean 表达式，它决定了是否执行循环体。当条件表达式的值为 true 时，就执行大括号中的语句块。 循环语句的执行流程如下: 实例： 1234567891011public class HelloWorld { public static void main(String[] args) { // 打印 0~4 int i = 0; while(i&lt;5){ System.out.println(i); i++; // 控制循环结束 } }} do…while语句如果 while 循环一开始条件表达式就是假的，那么循环体就根本不被执行。然而，有时需要在开始时条件表达式即使是假的情况下，while 循环至少也要执行一次。 do-while 循环语句的特点是先执行循环体（循环至少也要执行一次），然后判断循环条件是否成立，成立后继续执行。 do-while 语句的语法格式如下： 123do { 语句块;}while(条件表达式); do-while 循环语句执行流程如下： 实例（图书列表中保存了 50 条信息，现在需要让它每行显示 10 条，分 5 行进行显示）： 12345678910public static void main(String[] args) { int bookIndex = 1; do { System.out.print(bookIndex+&quot;\\t&quot;); if(bookIndex%10 == 0) { System.out.println(); } bookIndex++; }while(bookIndex&lt;51);} for 语句for 循环，和 while 循环一样，只是表达方式不一样。 for 语句语法格式如下所示： 123for(条件表达式1;条件表达式2;条件表达式3) { 语句块;} for 关键字后面括号中的 3 个条件表达式必须用 “;” 隔开。 for 循环中 3 个表达式的含义: 表达式 形式 功能 举例 条件表达式 1 赋值语句 循环结构的初始部分，为循环变量赋初值 int i=1 条件表达式 2 条件语句 循环结构的循环条件 i&gt;40 条件表达式 3 迭代语句，通常使用 ++ 或 – 运算符 循环结构的迭代部分，通常用来修改循环 变量的值 i++ 123456789public static void main(String[] args) { for (int bookIndex = 1;bookIndex&lt;51;bookIndex++){ System.out.print(bookIndex+&quot;\\t&quot;); if(bookIndex%10 == 0) { System.out.println(); } }} ================================================== 特别： for 语句中初始化、循环条件以及迭代部分都可以为空语句（但分号不能省略），三者均为空的时候，相当于一个无限循环。但无论缺少哪部分条件表达式，都可以在程序的其他位置补充，从而保持 for 循环语句的完整性，使循环正常进行。 1 –&gt; 条件表达式 1 为空 例如，使用 for 语句的这种形式计算 1~100 所有奇数的和。 123456789public static void main(String[] args) { int result = 0; int number = 1; // 相当于for语句的第1个表达式 for (; number &lt; 101; number++) { if (number % 2 != 0) // 如果不能整除2，说明是奇数，则进行累加 result += number; } System.out.print(&quot;100 以内所有奇数和为：&quot; + result);} 2 –&gt; 条件表达式 2 为空 当 for 语句中条件表达式 2 为空时，将没有循环的终止条件。为了使循环达到某种条件时退出，需要在语句块中进行逻辑判断，并使用 break 语句来跳出循环，否则将产生死循环。 同样是计算 1~100 所有奇数的和，使用这种方式的代码如下。 12345678910public static void main(String[] args) { int result = 0; for (int number = 1;; number++) { if (number &gt; 100) break; // 相当于for语句的表达式2，满足时就退出for循环 if (number % 2 != 0) // 如果不能整除2，说明是奇数，则进行累加 result += number; } System.out.print(&quot;100 以内所有奇数和为：&quot; + result);} 3 –&gt; 条件表达式 3 为空 当 for 语言中条件表达式 3 为空时，也就没有设置控制变量的表达式，即每次循环之后无法改变变量的值，此时也无法保证循环正常结束。 同样是计算1~100 所有奇数的和，使用这种方式的代码如下： 123456789public static void main(String[] args) { int result = 0; for (int number = 1; number &lt; 101;) { if (number % 2 != 0) // 如果不能整除2，说明是奇数，则进行累加 result += number; number++; // 相当于for语句的条件表达式3，每次递增1 } System.out.print(&quot;100 以内所有奇数和为：&quot; + result);} 4 –&gt; 3 个条件表达式都为空 事实上，在 for 循环语句中，无论缺少哪部分条件表达式，都可以在程序的其他位置补充，从而保持 for 循环语句的完整性，使循环正常进行。 但是，对于这种情况，读者在使用时应该尽量避免。 例如，计算 1~100 所有奇数的和，使用这种方式的代码如下： 123456789101112public static void main(String[] args) { int result = 0; int number = 1; // 相当于for语句的条件表达式1 for (;;) { if (number &gt; 100) break; // 相当于for语句的条件表达式2 if (number % 2 != 0) // 如果不能整除2，说明是奇数，则进行累加 result += number; number++; // 相当于for语句的条件表达式3 } System.out.print(&quot;100 以内所有奇数和为： &quot; + result);} 循环嵌套和其他编程语言一样，Java 允许循环嵌套。如果把一个循环放在另一个循环体内，那么就可以形成嵌套循环。 嵌套循环既可以是 for循环嵌套 while 循环，也可以是 while 循环嵌套 do-while 循环 …… 即各种类型的循环都可以作为外层循环，也可以作为内层循环。 假设外层循环的循环次数为 n 次，内层循环的循环次数为 m 次，那么内层循环的循环体实际上需要执行 n×m 次。 for、do-while 和 while 的区别： 名称 概念 适用场景 for 根据循环次数限制做多少次重复操作 适合循环次数是已知的操作 while 当满足什么条件的时候，才做某种操作 适合循环次数是未知的操作 do-while 先执行一次，在判断是否满足条件 适合至少执行一次的循环操作 foreach 语句foreach 循环语句是 Java 1.5 的新特征之一，在 遍历数组、集合 方面，foreach 为开发者提供了极大的方便。 foreach 循环语句的语法格式如下： 123for(类型 变量名:集合) { 语句块;} 其中，“类型”为集合或数组中 元素的类型，“变量名”表示集合或数组中的每一个元素，“集合”是被遍历的集合对象或数组。 样例，假设有一个数组，采用 for 语句遍历数组的方式如下： 1234567// 声明并初始化数组int[] numbers = { 43, 32, 53, 54, 75, 7, 10 };System.out.println(&quot;----for----&quot;);// for语句for (int i = 0; i &lt; numbers.length; i++) { System.out.println(&quot;Count is:&quot; + numbers[i]);} 关于数组集合会在教程后面详细介绍，这里我们只需要大概了解就可以。numbers.length 是获得数组的长度，length 是数组的属性，numbers[i] 是通过数组下标访问数组元素。 那么采用 for-each 循环语句遍历数组的方式如下： 1234567// 声明并初始化int数组int[] numbers = { 43, 32, 53, 54, 75, 7, 10 };System.out.println(&quot;----for each----&quot;);// for-each语句for (int item : numbers) { System.out.println(&quot;Count is:&quot; + item);} 从示例中可以发现，item 不是循环变量，它保存了集合中的元素，for-each 语句将集合中的元素一一取出来，并保存到 item 中，这个过程中不需要使用循环变量，通过数组下标访问数组中的元素。可见 for-each 语句在遍历集合的时候要简单方便得多。 –&gt; 注意：foreach 循环迭代数组（集合）元素时，并不能改变数组（集合）元素的值 当使用 foreach 循环来迭代输出数组元素或集合元素时，通常不要对循环变量进行赋值，虽然这种赋值在语法上是允许的，但没有太大的实际意义，而且极容易引起错误。例如下面程序。 1234567891011public static void main(String[] args) { String[] languages={&quot;Java&quot;,&quot;ASP.NET&quot;,&quot;Python&quot;,&quot;C#&quot;,&quot;PHP&quot;}; System.out.println(&quot;时下流行的编程语言：&quot;); // 使用 foreach 循环语句遍历数组 for(String lang:languages) { lang = &quot;Google&quot;; System.out.println(lang); } System.out.println(languages[0]);} 运行上边程序，将看到如下结果： 1234567时下流行的编程语言：GoogleGoogleGoogleGoogleGoogleJava 可以发现，由于在 foreach 循环中对数组元素进行赋值，结果导致不能正确遍历数组元素，不能正确地取出每个数组元素的值。而且当再次访问第一个数组元素时，发现数组元素的值依然没有改变。 =================================================== 原理解析： 当使用 foreach 来迭代访问数组元素时，foreach 中的循环变量相当于一个临时变量，系统会把数组元素依次赋给这个临时变量，而这个临时变量并不是数组元素，它只是保存了数组元素的值。因此，如果希望改变数组元素的值，则不能使用这种 foreach 循环。 break 语句某些时候需要在某种条件出现时强行终止循环，而不是等到循环条件为 false 时才退出循环。此时，可以使用 break 来完成这个功能。 Java 中，break 语句有 3 种作用： break，可用于直接结束当前循环 在 switch 语句中终止一个语句序列 实现 goto 的功能 直接结束当前循环使用 break 语句直接强行退出循环的示例如下： 123456789101112public class HelloWorld { public static void main(String[] args) { // 打印单数 for (int j = 1; j &lt; 10; j++) { if(0==j%2) break; // 如果是双数，直接结束循环 System.out.println(j); } }} 输出如下： 11 break 语句能用于任何 Java 循环中，包括人们有意设置的无限循环。 在一系列嵌套循环中使用 break 语句时，它将仅仅终止最里面的循环 123456789101112131415public static void main(String[] args) { // 外循环，循环5次 for (int i = 0; i &lt; 5; i++) { System.out.print(&quot;第&quot; + (i + 1) + &quot;次循环：&quot;); // 内循环，设计为循环10次 for (int j = 0; j &lt; 10; j++) { // 判断j是否等于3，如果是，则终止循环 if (j == 3) { break; } System.out.print(&quot;内循环的第&quot; + (j + 1) + &quot;次循环\\t&quot;); } System.out.println(); }} break 带标签实现 goto 功能Java 提供了一种带标签的 break 语句，用于跳出多重嵌套的循环语句，可以实现 goto 的功能。 通过使用扩展的 break 语句，可以终止执行一个或者几个任意代码块，这些代码块不必是一个循环或一个 switch 语句的一部分。同时这种扩展的 break 语句带有标签，可以明确指定从何处重新开始执行。 标签 break 语句的通用格式如下： break label; label 是标识代码块的标签。被加标签的代码块必须包围 break 语句，但是它不需要直接包围 break 的块。也就是说，可以使用一个加标签的 break 语句来退出一系列的嵌套块，但是不能使用 break 语句将控制权传递到不包含 break 语句的代码块。 用标签（label）可以指定一个代码块，标签可以是任何合法有效的 Java 标识符，后跟一个冒号。 下面是使用带标签的break 语句的示例。 123456789101112public class GotoDemo { public static void main(String[] args) { label: for (int i = 0; i &lt; 10; i++) { for (int j = 0; j &lt; 8; j++) { System.out.println(j); if (j % 2 != 0) { break label; } } } }} 程序执行结果： 1201 可以发现，加上标签的代码块可以作为 break 语句的对象，使程序在加标签的块的结尾继续执行。 标签语句必须和循环匹配使用，使用时书写在对应的循环语句的上面，标签语句以冒号结束。如果需要中断标签语句对应的循环，可以采用 break 后面跟标签名的方式。 但注意，标签语句可以独立使用， Java 不会报错 switch 语句中终止一个语句序列break 在 switch 语句中可终止一个语句序列，就是在每个 case 子句块的最后添加语句 “break;”，具体使用可见分支结构中的 switch 语句。 continue 语句与 break 语句一样， 它将中断正常的控制流程。与 break 语句的区别在于：continue 并不是中断循环语句，而是中止当前迭代的循环，进入下一次的迭代。 简单来讲，continue 是忽略循环语句的当次迭代。 123456789101112public class HelloWorld { public static void main(String[] args) { //打印单数 for (int j = 0; j &lt; 10; j++) { if(0==j%2) continue; //如果是双数，后面的代码不执行，直接进行下一次循环 System.out.println(j); } }} 程序输出： 1234513579 –&gt; continue label 同 break 语句一样，continue 语句同样可以配合 label 使用。 带标签的 continue 语句示例代码如下： 123456789101112public class GotoDemo { public static void main(String[] args) { label: for (int i = 0; i &lt; 10; i++) { for (int j = 0; j &lt; 8; j++) { System.out.println(j); if (j % 2 != 0) { continue label; } } } }} 注意，与 break label 使用时的区别。 输出如下: 12345678910110101010101...","link":"/2017/10/16/java-cheng-xu-she-ji-ji-chu-zhi-liu-cheng-kong-zhi/"},{"title":"Python 简介与开发环境搭建","text":"Foreword 不管是由于工作需要必须掌握 Python，或是抱着极其浓厚的兴趣想要学习 Python 程序设计语言，亦或是不甘落于人后（身边越来越多的人开始使用 Python）…… 不要困惑，我们已经站在 Python 花园秘境的入口，即将一睹大门背后绮丽的风景。 那句话怎么说来着？人生苦短，快来使用 Python 吧 …… 这一章节我们通过对以下两部分内容的解读，正式开启 Python 的学习之旅的第一站（叩门）： Python Introduction Python Development Envs Setup Python Introduction这一小节我们来简要介绍 Python 的背景知识，你可以将其作为 Python 学习入门需知。 注意，相关介绍没必要深究，在后续正式进入 Python 学习生态环境之后，你会越来越深入理解相关的内容。 Python 发展历史Python 的创始人为荷兰人 Guido van Rossum（吉多·范罗苏姆）。1989年圣诞节期间，吉多·范罗苏姆为了在阿姆斯特丹打发时间， 决心开发一个新的脚本解释程序。之所以选中 Python（蟒蛇）作为程序的名字，是因为他是一个叫 Monty Python 戏剧团的忠实粉丝。 大佬不愧为大佬啊….. 1991年，第一个 Python 解释器诞生，它是用 C 语言实现的，并能够调用 C 语言的库文件。 Python 2.0 于 2000 年 10 月发布，增加了完整的垃圾回收，并且支持 Unicode。 Python 3.0 于 2008 年 12 月发布，此版不完全兼容之前的 Python 源代码。不过，很多新特性也被移植到旧版本。 2019 年 12 月份世界编程语言排行榜中，Python 排名第三，成为了仅次于 Java 和 C 语言的黑马。 Python 能干什么？ 基础编程开发 Web 开发 网络爬虫 自动化运维 / 运维开发 自动化测试 / 测试开发 游戏开发 科学计算 大数据 / 数据分析 / 数据挖掘 机器学习 / 人工智能 &amp; 深度学习 …… 看到这里是不是了解了为什么 Python 经常被和 大数据、人工智能 捆绑到一起作为 AI 关键词的原因了。 事实上，像 Google，Facebook，Yahoo，YouTube 以及著名的开源云计算平台 openstack，还有国内的豆瓣都是用 Python 写的 !!! Python 究竟是什么？相较于其它高级编程语言，Python 是一个高层次的 解释型的面向对象的交互式脚本语言。 Python 是一种解释型语言： 这意味着开发过程中没有了编译这个环节，类似于 PHP 和 Perl 语言。 Python 是一种交互式语言：这意味着，你可以在一个 Python 提示符（Shell），直接互动执行你编写的程序。 Python 是一种面向对象语言：这意味着 Python 支持面向对象的风格或代码封装于对象的编程技术。 Python 是一种初学者的语言：Python 对初级程序员而言，作为学习编程的入门语言再合适不过。它支持广泛的应用程序开发，从简单的文字处理到 WWW 浏览器再到游戏。 Python 特点相较于其它高级程序设计语言，Python 有如下特点： 易于阅读、学习：Python有相对较少的关键字，和明确定义的语法，代码结构清晰易读，学习起来更加简单。 互动模式：互动模式的支持，你可以从终端输入执行代码并获得结果的语言，互动的测试和调试代码片断。 跨平台：作为开源、免费的解释型语言，Python 已经被移植（跨平台）到许多平台。 广泛的类库支持：Python 的最大的优势之一是丰富的类库支持，在 UNIX，Windows 和Macintosh 兼容很好。 可扩展：如果你需要一段运行很快的关键代码，或者是想要编写一些不愿开放的算法，你可以使用 C 或 C++ 完成那部分程序，然后从你的 Python 程序中调用。 可嵌入: 你可以将 Python 嵌入到C/C++程序，让你的程序的用户获得”脚本化”的能力。 数据库：Python 提供所有主要的商业数据库的接口。 GUI 编程：Python 支持 GUI 可以创建和移植到许多系统调用。 Python 有缺点么 ？？？一味鼓吹 Python 没有缺陷是伪命题，任何编程语言都有缺点，Python 也不例外。 第一个缺点：运行速度慢 和 C 程序相比非常慢，因为 Python 是解释型语言，代码在被执行时会一行一行地翻译成 CPU 能理解的机器码，这个翻译过程非常耗时，所以很慢。而 C 程序是运行前直接被编译成 CPU 能执行的机器码，所以非常快。 但是大量的应用程序不需要这么快的运行速度，因为用户根本感觉不出来。例如开发一个网络应用程序，C 程序的运行时间需要 0.001 秒，而 Python 程序的运行时间需要 0.1 秒，慢了 100 倍，但由于网络更慢，需要等待 1 秒，你想，用户能感觉到 1.001 秒和 1.1 秒的区别吗？这就好比 F1 赛车和普通的出租车在北京三环路上行驶的道理一样，虽然 F1 赛车理论时速高达 400 公里，但由于三环路堵车的时速只有 20 公里，因此，作为乘客，你感觉的时速永远是 20 公里。 甚至我们可以将需要快速执行的 Python 代码段转成 C 内置于 Python 中以提升性能。 第二个缺点：代码不能加密 由于 Python 的开源、免费特性，如果要发布你的 Python 程序，实际上就是发布源代码，这一点跟 C 语言不同，C语言不用发布源代码，只需要把编译后的机器码（也就是你在 Windows 上常见的 xxx.exe 文件）发布出去。要从机器码反推出 C 代码是不可能的，所以，凡是编译型的语言，都没有这个问题，而解释型的语言，则必须把源码发布出去。 当然，想要加密 Python 代码，也并非无解，网络上也给出了一些 Python 加密方法用以提高其源码保密性。 然而，开源是软件产业的大趋势，传统程序员需要转变观念。 Python 彩蛋最后一部分，我们给出一个 Python 彩蛋：“Python 之歌”，它概要地解读了 Python 语言设计的特点。在后续我们介绍完 Python 开发环境搭建，你可以执行 Python 指令之后，重新返回到这一部分“敲开”彩蛋： 1234567891011121314151617181920212223242526# Python 解释器执行如下命令：import this# 获取到如下信息：The Zen of Python, by Tim PetersBeautiful is better than ugly.Explicit is better than implicit.Simple is better than complex.Complex is better than complicated.Flat is better than nested.Sparse is better than dense.Readability counts.Special cases aren't special enough to break the rules.Although practicality beats purity.Errors should never pass silently.Unless explicitly silenced.In the face of ambiguity, refuse the temptation to guess.There should be one-- and preferably only one --obvious way to do it.Although that way may not be obvious at first unless you're Dutch.Now is better than never.Although never is often better than *right* now.If the implementation is hard to explain, it's a bad idea.If the implementation is easy to explain, it may be a good idea.Namespaces are one honking great idea -- let's do more of those! Python Development Envs Setup工欲善其事，必先利其器。这一小节将向大家介绍如何搭建本地 Python 语言学习、开发环境。 前面我已经提到过 Python 具有良好的移植性，可应用于多平台包括：Windows、Linux 和 Mac OS X 等等，Python 官网 确实也提供了不同平台的 Python 安装包以提供下载安装。 关于 Python 安装版本选择，个人建议选择 Python3.x（越来越多的开发者转战到 Python3，已成为主流使用版本）。 安装后，你会得到 Python 解释器（负责解释运行 Python 程序），一个 命令行交互环境，还有一个简单的 集成开发环境（IDLE）。 下面我们来开始本地 Python 语言开发环境的搭建 –&gt; 环境检查在开始正式安装之前，你可以通过在 终端窗口（Terminal）输入 “python -V” 命令来查看本地是否已经安装 Python 以及 Python 的安装版本。 如果输出如下信息表示当前系统中已安装有 Python，你已经可以直接跳过安装环节开始 Python 语言的学习了： 1234Python 3.5.0 (default, Dec 1 2018, 17:15:02) [GCC 4.8.5 20150623 (Red Hat 4.8.5-28)] on linuxType &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.&gt;&gt;&gt; 这里一定要注意 Python 的版本信息，如上，当前系统中已安装 Python 版本为：3.5.0 如果当前系统中的 Python 版本不符合你的期望（不需要卸载），或者系统中没有找到 Python 信息，接下文 –&gt; Python DownloadPython 最新源码，二进制文档，相关新闻资讯等可以在 Python 的官网查看到： Python 官网：https://www.python.org/ ，以下给出各个平台 Python 安装包的下载地址： 并且，你可以在以下链接中下载 Python 的文档，你可以下载 HTML、PDF 和 PostScript 等多种格式的文档。 Python 文档下载地址：https://www.python.org/doc/ Python Setup我们知道 Python 已经被移植在许多平台上（使它能够工作在不同平台上），类似于 Java，“一次编写，多次运行”。而 不同平台的安装步骤视使用的操作系统和安装方式而异。 安装 Python 的 两种主流方式：我们既可以从 源码 安装，同时也可以下载使用已经编译并且打包好的 二进制版本 安装包进行安装。 如果你选择的平台（例如：Unix/Linux）的二进制代码不可用，你可以使用手动编译源代码进行安装。编译的源代码，功能上有更多的选择性， 为 Python 安装提供了更多的灵活性。 以下给出不同平台（Unix/Linux、Windows）上安装 Python 的方法： Source Code For Unix &amp; Linux Platform Binary Package For Windows Platform For Unix &amp; Linux Platform由于 Unix &amp; Linux 平台一般自带相应版本的 Python（Python2/Python3），如果你选择在 Unix &amp; Linux 平台学习 Python，那么你可以直接跳过后续教程（你已经可以开始使用 Python 了！）。 当然，有些同学就是想尝试一下 Python 的编译过程（或者 系统原生 Python 版本不是你学习使用所需要版本），下面给出在 Unix &amp; Linux 平台上安装 Python 的通用步骤: 注意多个 Python 版本是可以共存的！！！前提是你需要注意新安装的 Python 环境对原有环境的影响，严格遵循下文安装过程不会对系统原生环境产生影响，你可以放心安装。这也就意味着：你可以使用下面的方法在系统中安装多个 Python 版本而不影响系统原生环境。 源码编译安装 –&gt; 打开 WEB 浏览器访问：https://www.python.org/downloads/source/ 选择适用于 Unix/Linux 的源码压缩包。 cd 到安装目录：/usr/local，下载及解压压缩包。 如果你需要自定义一些选项，可以修改 Modules/Setup 执行 ./configure （配置） make make install 执行以上操作后，Python 相关的可执行文件默认会被存放到：/usr/local/bin 中，库文件默认会被安装到：/usr/local/lib/pythonXX，XX 为你使用的 Python 的版本号。 这样显得有点杂乱… 来认识一下：“linux, configure –prefix=/”的作用是 –&gt; 编译的时候用来指定程序存放路径。 |&gt;&gt;&gt;=============== prefix 选项用于配置安装的路 ================| 如果不配置该选项，安装后可执行文件默认放在 /usr/local/bin，库文件默认放在 /usr/local/lib，配置文件默认放在 /usr/local/etc，其它的资源文件放在 /usr/local/share 如果配置 prefix，如：”./configure –prefix=/usr/local/test”，可以把所有资源文件放在 /usr/local/test 的路径 |=======================================================&lt;&lt;&lt;| Begin to Setup –&gt; 以 “Python-3.5.0 安装” 为样例演示上述安装过程： 1 –&gt; 准备编译环境（系统环境中可能缺失编译环境，导致遇到各种问题，比如：wget 无法下载 https 链接文件，缺少了zlib的解压缩类库等） 12345# Centos[root@node1 ~]# yum install wget zlib-devel bzip2-devel openssl-devel ncurses-devel# Ubuntu[root@node1 ~]# apt-get install zlib* 2 –&gt; 下载及解压 Python3.5.0 源代码包 1234567891011[root@node1 ~]# cd /usr/local/[root@node1 ~]# wget https://www.python.org/ftp/python/3.5.0/Python-3.5.0.tar.xz# 下载完成后进行减压：[root@node1 ~]# tar Jxvf Python-3.5.0.tar.xz# 减压后进入到相应目录，可以看到一个 README 文档。说明了如何进行安装：[root@node1 ~]# cd Python-3.5.0# 查看安装方法：[root@node1 Python-3.5.0]# cat README 3 –&gt; 编译安装 123456789101112# 编译后你会在目录 [/usr/local] 下发现新产生的：[python3.5] 目录[root@node1 Python-3.5.0]# ./configure --prefix=/usr/local/python3.5[root@node1 Python-3.5.0]# make &amp;&amp; make install### 日志信息如下：Ignoring indexes: https://pypi.python.org/simpleCollecting setuptoolsCollecting pipInstalling collected packages: setuptools, pipSuccessfully installed pip-7.1.2 setuptools-18.2# 同时提示成功安装 pip-7.12 与 setuptools！之后你就可以使用 pip 包管理器进行安装 Python 扩展包。{关于 pip，当前你知道它是用来解决 Python 库包依赖（一个扩展包的安装需要其它扩展包的安装支持）的工具即可。} 至此 Unix &amp; Linux 平台下 Python 的安装已完成！请跳转至【Python 环境变量配置】章节完成最后的配置即可开始 Unix &amp; Linux 平台下 Python 的学习之旅。 For Windows Platform以下为在 Windows 平台上安装 Python 的简单步骤： 二进制包安装 1）Python 2.X 版本安装： 以最新的 “Python 2.7 版本安装” 为样例： 打开 WEB 浏览器访问 https://www.python.org/downloads/windows/ 在下载列表中选择 Windows 平台安装包，包格式为：【python-XYZ.msi】 文件 ， XYZ 为你要安装的版本号。 要使用安装程序 【python-XYZ.msi】, Windows 系统必须支持 Microsoft Installer 2.0 搭配使用。需要看看你的机器是否支持 MSI，Windows XP 和更高版本已经有 MSI，很多老机器也可以安装 MSI。 只要保存安装文件到本地计算机，然后运行它即可（安装时，根据提示 Next 即可）。注意！！！为防止对系统原生环境的影响，不要勾选有关自动添加环境变量的选项（默认不勾选），随后我们会手动设置 Python 环境变量。 2）Python 3.X 版本安装： 以 “Python 3.5.1 版本安装” 为样例： 打开 WEB 浏览器访问 https:////www.python.org/ ，点击 Downloads，进入选择下载界面： 这里我选择的是：python3.5.1，会看到如下界面： 这里，我们需要安装的是 Windows 下的 Python 版本，所以在 Operating System 中可以选择对应的 Windows 版本。另外需要注意的是要根据系统位数选择相应位数（64-bit 或 32-bit） Python 安装二进制版本，现在主流的都是 64-bit的。 其中，executable 表示可执行版，需要安装后使用，embeddable 表示嵌入版，就是解压以后就可以使用的版本（免安装版本）。 Begin to Setup –&gt; 1 –&gt; executable setup 这里，我们选择安装可执行版本（executable），可执行版安装比较简单，step by step，then ok。注意！！！为防止对系统原生环境的影响，不要勾选有关自动添加环境变量的选项（默认不勾选），随后我们会手动设置 Python 环境变量。 2 –&gt; embeddable setup embeddable 版本 Python 安装好后一定需要配置环境变量。 Python 环境变量配置Python 默认安装完成后并不可以直接使用，即通过终端窗口输入 “python” 命令无法查看到 Python 版本信息（系统无法访问到安装好的 Python 可执行程序）如下，说明我们还需要为其配置系统环境变量。 123C:\\Users\\guoxx&gt;python'python' 不是内部或外部命令，也不是可运行的程序或批处理文件。 为什么需要配置环境变量？我们想要运行的程序或可执行文件（python.exe）可能位于系统中的许多目录，而这些路径很可能 不在操作系统提供可执行文件的搜索路径中。故，不可以直接执行这些程序或可执行文件。 而路径（PATH）可以存储到系统环境变量中，这是由操作系统维护的一个命名的字符串。这些变量包含系统中可用的命令行解释器（Python 解释器）和其他程序的位置信息。想要操作系统能够搜索到程序或可执行文件，我们需要将其相应的路径添加到系统环境变量中（注意在添加时，要加上环境变量中原有的路径 :$PATH，否则会覆盖原始路径，导致系统出错）。 因此，我们需要将 Python 相关的可执行文件或程序路径添加到系统环境变量 $PATH 中。 下面我们来看不同平台如何配置其环境变量： For Unix/Linux Platform1）export PATH 方法 在 csh shell: 输入 setenv PATH “$PATH:/usr/local/python” 在 bash shell (Linux): 输入 export PATH=”$PATH:/usr/local/python” 在 sh 或者 ksh shell: 输入 PATH=”$PATH:/usr/local/python” 注意: 【/usr/local/python】 是 Python 的安装目录。 2）构建 Python 使用软链接（推荐） 以上面 “Python-3.5.0 安装 样例为示例： 123# 产生软连接时要注意系统中已存在的 Python 软链接，防止原生 Python 调用被覆盖掉：# 覆盖掉后只能访问最新版本 python。[root@node1 Python-3.5.0]# ln -s /usr/local/python3.5/bin/python3.5 /usr/local/bin/python3.5 这里由于【/usr/local/bin/】 路径已在 PATH 中，故可以将 Python 解释器路径放于 /usr/local/bin 下。 For Windows Platform在环境变量中添加 Python 目录： 1）cmd 方法 在命令提示框中(cmd) : 输入 1path=%path%;C:\\Python;C:\\Python\\Scripts; 注意: C:\\Python 是 Python 的实际安装目录。 GUI 方法 右键点击”计算机”，然后点击”属性” 然后点击”高级系统设置” 选择 “系统变量” 窗口下面的 “Path”,双击即可！ 然后在 “Path” 行，添加 python 安装路径即可(C:\\Python)，所以在后面，添加该路径即可。 ps：记住，路径直接用分号 “；” 隔开！ 检测是否配置成功？在 命令行（终端） 中输入： 1python 或 python -V 如果配置成功的话，会有 Python 版本信息输出，并进入 Python 交互式环境（可执行 Python 语句）。如下： 1234Python 3.5.0 (default, Dec 1 2018, 17:15:02) [GCC 4.8.5 20150623 (Red Hat 4.8.5-28)] on linuxType &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.&gt;&gt;&gt; 至此，我们已经完成了 Python 本地环境的安装以及配置，下面我们给出一个 “Python Hello World” 来验证本地环境已经搭建成功： Python Hello World首先，在 命令行终端 中输入：“python”，会进入 Python 交互式解释器环境： 12345[root@node1 ~]# pythonPython 3.5.0 (default, Dec 1 2018, 17:15:02) [GCC 4.8.5 20150623 (Red Hat 4.8.5-28)] on linuxType &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.&gt;&gt;&gt; 然后在命令提示符 &gt;&gt;&gt; 之后输入命令： 1234# python 3 输入:print (&quot;Welcome to Python World&quot;)# python 2 输入:print &quot;Welcome to Python World&quot; 语句执行成功后会输出以下语句，表示 Python 本地环境搭建成功： 1Welcome to Python World Python 运行方式Python 本地环境搭建成功之后，我们来看如何使用搭建好的 Python 环境编写、运行 Python 程序。通常有三种方式： 交互式解释器你可以通过命令行窗口（Command Terminal）进入 Python 交互式解释器中开始编写 Python 代码。你可以在 Unix，DOS 或任何其他提供了命令行或者 shell 的系统进行 python 编码工作。如下： 12345# Unix/Linux &amp; Windows/DOS：Python 3.5.0 (default, Dec 1 2018, 17:15:02) [GCC 4.8.5 20150623 (Red Hat 4.8.5-28)] on linuxType &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.&gt;&gt;&gt;print (&quot;Hello Python World&quot;) Python 交互模式的代码是输入一行，解释执行一行。 退出交互式环境： 12345# Unix/Linux &amp; Windows/DOS：Python 3.5.0 (default, Dec 1 2018, 17:15:02) [GCC 4.8.5 20150623 (Red Hat 4.8.5-28)] on linuxType &quot;help&quot;, &quot;copyright&quot;, &quot;credits&quot; or &quot;license&quot; for more information.&gt;&gt;&gt;exit() 可见，Python 交互模式主要是为了调试 Python 代码用的，也便于初学者学习，它不是正式运行 Python 代码的环境！ 命令行脚本在你的应用程序中通过 引入解释器 可以在命令行中执行 Python 脚本 【 HelloWorld.py 】，如下所示： 1234567# Unix/Linux：[root@node1 ~]# python HelloWorld.py # 或者# Windows/DOSC:&gt; python HelloWorld.py 注意：在执行脚本时，系统会检查脚本是否有可执行权限。命令行模式下直接运行 .py 文件是一次性执行该文件内的所有代码。 集成开发环境（IDE：Integrated Development Environment）和大多数程序设计语言一样，一个体验良好的集成开发环境对于 Python 程序开发是必不可缺的。这里推荐使用 PyCharm（大多数 Python 开发人员的首选）。 以 “PyCharm IDE” 为例： PyCharm 是由 JetBrains 打造的一款 Python IDE，支持 macOS、 Windows、 Linux 系统。 PyCharm 功能 : 支持调试、语法高亮、Project管理、代码跳转、智能提示、自动完成、单元测试、版本控制…… PyCharm 下载地址 : https://www.jetbrains.com/pycharm/download/ 以下展示的是 PyCharm 工作界面样例图（是不看起来相当美观）： ================================================================= 至此，这一章节的主要内容已经解读完成，基于上述内容的介绍你已经可以对照 Python 参考书开始 Python 语言的学习了。但我强烈建议你阅读下面的内容，它可以帮助你快速在 Python 学习中走的更远…… You Need Know MorePython 解释器详解前面我们一直提到 Python 解释器，当我们编写 Python 代码时，我们得到的是一个包含 Python 代码的以.py为扩展名的文本文件。要运行代码，就需要 Python 解释器去执行.py文件。 由于整个 Python 语言从规范到解释器都是开源的，所以理论上，只要水平够高，任何人都可以编写 Python 解释器来执行 Python 代码（当然难度很大）。事实上，确实存在多种 Python 解释器。 1 –&gt; CPython 当我们从 Python 官方网站下载并安装好 Python 3.x 后，我们就直接获得了一个官方版本的解释器：CPython。这个解释器是用 C 语言开发的，所以叫 CPython。在命令行下运行 python 就是启动 CPython 解释器。所以 CPython 是使用最广的 Python 解释器。 2 –&gt; IPython IPython 是基于 CPython 之上的一个交互式解释器，也就是说，IPython 只是在交互方式上有所增强，但是执行Python 代码的功能和 CPython 是完全一样的。好比很多国产浏览器虽然外观不同，但内核其实都是调用了 IE。 CPython 用 &gt;&gt;&gt; 作为提示符，而 IPython 用 In [序号]: 作为提示符。 3 –&gt; Jython Jython 是运行在 Java 平台上的 Python 解释器，可以直接把 Python 代码编译成 Java 字节码执行。 4 –&gt; PyPy PyPy 是另一个 Python 解释器，它的目标是执行速度。PyPy 采用 JIT 技术，对 Python 代码进行动态编译（注意不是解释），所以可以显著提高 Python 代码的执行速度。 绝大部分 Python 代码都可以在 PyPy 下运行，但是 PyPy 和 CPython 有一些是不同的，这就导致相同的 Python 代码在两种解释器下执行可能会有不同的结果。 5 –&gt; IronPython IronPython 和 Jython 类似，只不过 IronPython 是运行在微软 .Net 平台上的 Python 解释器，可以直接把 Python 代码编译成 .Net 的字节码。 注意：Python 的解释器很多，这里我们简单介绍了常见的几种，但使用最广泛的还是 CPython。如果要和 Java 或 .Net 平台交互，最好的办法不是用 Jython 或 IronPython，而是 通过网络调用来交互，确保各程序之间的独立性。 这一小节内容你可以先跳过，等后续对 Python 多版本使用有了较深的了解之后再来学习当前内容，这可以帮助你更深入、灵活地掌握 Python 环境的使用。 Python Versions Management设想这样的情景 –&gt; 场景一：A 项目是一个爬虫项目，需要用到 requests、pyspider、scrapy 等包或框架；B 项目是一个 GUI 界面项目，需要用到 GUI 相关的包或库；这需要把所有用到的包安装到原生 Python 环境中，开发环境越来越臃肿。 场景二：C 项目是一个 Python2.x 项目；D 项目是一个 Python3.x；两项目要求的 Python 版本不兼容。怎么办？！！ 解决思路 –&gt; 前面提到过一个系统中是可以同时存在多个 Python 版本，但是你需要注意新添加的 Python 环境对系统既有环境的影响，这就涉及到系统中多个 Python 版本的管理 问题。 篇幅原因，方案的详细说明请见同系列博文：Python-Vers Management 。","link":"/2018/01/01/python-jian-jie-yu-kai-fa-huan-jing-da-jian/"},{"title":"Pythoner 神器之 virtualenv","text":"Foreword 实际 Python 学习、开发过程中，往往由于各种原因，多 Python 版本解释器环境 &amp;&amp; 多版本的 Python 库（模块）需求是我们必然要面对的问题，这使得很多人在 Python 的环境管理上产生极大的混乱。甚至，不同的项目，或同一项目的不同阶段需要不同的 Python 解释器和依赖库。 那么，为每个 Python 项目，甚至每个脚本各自建立一套 “独立、隔离” 的 Python 环境（环境中可以自定义特定的 Python 版本以及特定的依赖库） 是必要的。 virtualenvvirtualenv 就是用来给每个 Python 项目，甚至每个脚本各自建立一套 “独立、隔离” 的 Python 运行环境的工具。 用 virtualenv 来保持一个干净、无污染的 Python 运行环境是非常有用的。 和主流的虚拟隔离环境工具类似，virtualenv 可以帮助你： 可以创建任意多个虚拟环境（可以看作成一个个容器），使用时指定到（切换到）某一虚拟环境之后 Pip 安装的包、库就只会在这个环境（容器）下；并且各虚拟环境（容器）之间，以及虚拟环境和系统原生环境之间是隔离的（一个个相互独立、隔离的容器）。 假设某一个虚拟环境预计不再使用，可以直接删除掉相应虚拟环境，由于虚拟环境的独立、隔离性，不用关注文件残留、关联问题。 虚拟机制virtualenv 管理的多版本 Python 运行环境示意图如下： 图解： 每个 Python 解释器都有一个特定的指向自己的 pip 工具，两者一一对应； 一个操作系统中，可以同时安装有多个不同版本的 Python 解释器（注意保证无冲突共存），你可以将其看作是 “操作系统级别” 的 Python 解释器； virtualenv 可以将上述任一 “操作系统级别” 的 Python 解释器，虚拟成为一个 “虚拟级别” 的 Python 解释器，Python 版本取决于虚拟时所使用 “操作系统级别” 的 Python 解释器 版本； 每个 “虚拟级别” 的 Python 解释器都拥有自己独立的 pip 工具和 site-package。 Setup这一小节来看 virtualenv 在 Windows &amp;&amp; Linux 平台下的安装方法。但前提是： 你的操作系统中必须已安装有一个 Python 环境。这是重要的，因为 virtualenv 的安装需要依赖于 Python 的包管理器——pip。 1 –&gt; Begin to setup Python 多版本共存环境下，建议直接使用操作系统下环境变量中指定的 Python 版本所绑定的 pip，安装命令如下： 1pip install virtualenv 当然，你也可以选择操作系统中其它的 Python 版本所指向的 pip 进行安装，上面只是为了方便命令调用和管理。 看到如下安装信息，表示 virtualenv 成功安装： 123...Successfully installed virtualenv-20.4.4 appdirs-1.4.4 distlib-0.3.1 filelock-3.0.12 importlib-resources-3.2.1... 你可以看到，除了安装 virtualenv 外，pip 还为我们安装了一些必须的依赖包。 2 –&gt; Setup Test 安装成功之后，我们还可以进行 virtualenv 版本安装测试。成功安装的话，可以查看到版本信息： 123456789101112131415# Windows InfoXXX Guo@LAPTOP-SNOSCKOB MINGW64 ~/Desktop$ pip -Vpip 9.0.3 from f:\\python\\python36\\lib\\site-packages (python 3.6)XXX Guo@LAPTOP-SNOSCKOB MINGW64 ~/Desktop$ virtualenv --versionvirtualenv 20.4.4 from f:\\python\\python36\\lib\\site-packages\\virtualenv\\__init__.py# Linux Inforoot@iZ2zeazcdax8nlsrpzpd83Z:~# pip -Vpip 20.3.4 from /usr/local/lib/python3.5/dist-packages/pip (python 3.5)root@iZ2zeazcdax8nlsrpzpd83Z:~# virtualenv --versionvirtualenv 20.4.4 from /usr/local/lib/python3.5/dist-packages/virtualenv/__init__.py 可以看到， 不管是 Windows 平台使用的是 python3.6，还是 Linux 平台下使用的 python3.5，virtualenv 均被成功安装到 操作系统下环境变量中指定的有效 Python 版本库（site-package/dist-package）中。 =================================================== 你或许有疑惑？设想若 Windows 下还存在一个 Python2.7，那我要虚拟 Python2.7 的版本怎么办？在 2.7 下也装一个 virtualenv？ 不需要的！virtualenv 可以指定虚拟的 Python 解释器版本，只要你本地操作系统的任一 Python 版本安装了 virtualenv 即可！ 关于 virtualenv 可以指定创建虚拟环境的 Python 解释器版本，可见下文中使用，这里有这个概念即可。 Envs Management这一小节来看，如何使用 virtualenv 进行虚拟隔离环境管理。 如何创建虚拟环境这里将以 Windows 为例来看如何使用 virtualenv 来创建虚拟环境，Linux 平台下与 Windows 操作无异。 使用 virtualenv 来管理所有的虚拟隔离环境，通常会建立一个单独的目录(virtualenvs_py)，用来放置 virtualenv 中管理的所有虚拟环境： 1mkdir E:\\virtualenvs_py 然后，先来为深度学习项目创建一个名为 for_tensorflow 的 Python 运行环境，执行如下命令： 1virtualenv -p F:\\\\Python\\\\Python36\\\\python.exe E:\\\\virtualenvs_py\\\\for_tensorflow 命令参数说明如下： -p：指定你要虚拟的 “操作系统级别” 的 Python 解释器版本，这里选择了系统中的 Python3.6.5； E:\\virtualenvs_py\\for_tensorflow：表示在 virtualenvs_py 目录下，建立一个名为 for_tensorflow 的虚拟环境，专门用于进行深度学习使用。 运行情况如下： 123456$ virtualenv -p F:\\\\Python\\\\Python36\\\\python.exe E:\\\\virtualenvs_py\\\\for_tensorflow created virtual environment CPython3.6.5.final.0-64 in 2759ms creator CPython3Windows(dest=E:\\virtualenvs_py\\for_tensorflow, clear=False, no_vcs_ignore=False, global=False) seeder FromAppData(download=False, pip=bundle, setuptools=bundle, wheel=bundle, via=copy, app_data_dir=C:\\Users\\XXX Guo\\AppData\\Local\\pypa\\virtualenv) added seed packages: pip==21.0.1, setuptools==56.0.0, wheel==0.36.2 activators BashActivator,BatchActivator,FishActivator,PowerShellActivator,PythonActivator,XonshActivator 找到 for_tensorflow 虚拟环境目录，你可以发现 virtualenv 帮助你创建了一个非常 “干净” 的 Python 运行环境！ |&gt;&gt;================== “干净”何解？ ================== virtualenv 的最新版本，以 20.0.0+ 为例，取消了 –-no-site-packages 参数，默认已经使用了 –-no-site-packages 模式，表示 “虚拟级别” 的 Python 运行环境，不可以访问源 “操作系统级别” Python 解释器的第三方库。 与之相对的，还有另外一个参数 –system-site-packages，表示 可以访问源 “操作系统级别” Python 解释器的第三方库。一般推荐直接使用默认模式。 最终命令格式如下： 1virtualenv -p python_xxx envs_destination 表示：使用 “操作系统级别” Python 解释器（python_xxx），来虚拟一个名为 “envs_destination” 的虚拟环境。并且，虚拟环境中不包含任何来源于 “python_xxx” 的第三方库（纯净）。 ==============================================&lt;&lt;| 几种常见的创建虚拟环境的命令格式以及其含义： 123456789# 1. 使用系统默认指定的 Python 解释器来创建 “env_py36”（不使用 &quot;-p&quot; 选项）$ virtualenv env_py36# 2. 多版本 Python 共存环境，创建指定 Python 版本的解释器虚拟环境$ virtualenv -p F:\\\\Python\\\\Python27\\\\python.exe env_py27 # 解释器为 python2.7（Linux）$ virtualenv -p python3.5 env_py35 # 解释器为 python3.5# 3. 创建继承系统第三方库的虚拟环境$ virtualenv --system-site-packages env_py34 如何激活虚拟环境虚拟环境创建成功之后，不能立即使用！使用某一虚拟环境之前，你需要启动（激活）特定的虚拟环境之后，才可以使用。 1 –&gt; For Windows 以 “for_tensorflow” 虚拟环境为例： 命令行下，进入你要使用的虚拟环境的目录下的 Script 文件夹，运行 activate 命令，或者使用绝对路径的方式调用该命令。 123456789101112131415161718192021E:\\virtualenvs_py\\for_tensorflow\\Scripts&gt;dirE:\\virtualenvs_py\\for_tensorflow\\Scripts 的目录2021/04/30 21:16 &lt;DIR&gt; .2021/04/30 21:16 &lt;DIR&gt; ..2021/04/30 21:16 2,152 activate # 环境激活命令2021/04/30 21:16 1,025 activate.bat2021/04/30 21:16 3,075 activate.fish2021/04/30 21:16 1,755 activate.ps12021/04/30 21:16 1,166 activate.xsh2021/04/30 21:16 1,193 activate_this.py2021/04/30 21:16 510 deactivate.bat2021/04/30 21:16 106,362 pip-3.6.exe2021/04/30 21:16 106,362 pip.exe......# 启动（激活）for_tensorflow 环境E:\\virtualenvs_py\\for_tensorflow\\Scripts&gt;activate# 或者使用绝对路径：(for_tensorflow) E:\\virtualenvs_py\\for_tensorflow\\Scripts&gt; 注意命令提示符（for_tensorflow），它表示你当前在 for_tensorflow 这个虚拟环境内，你认为你当前处于一个纯净的、可以正常使用的 Python 环境。 当前环境下，1. 运行 Python 命令；2. 使用 pip 工具安装第三方库。这些操作都会被限制、绑定到 for_tensorflow 这个虚拟环境，不会对操作系统原生的 Python 环境和其它虚拟环境产生任何影响。 2 –&gt; For Linux 对于 Linux 平台下，由于虚拟环境中的文件路径（activate）和脚本调用的方式（source）不同，激活虚拟环境和 Windows 有略微不同。 以 “env27” 虚拟环境为例： Linux 中 activate 脚本位于 &lt;env27\\bin&gt; 目录中，所以启动虚拟环境命令为： 1$ source env27/bin/activate 这个命令会修改系统路径 $PATH，把 env27/bin 的路径至于系统路径之前。 如何退出虚拟环境Windows &amp;&amp; Linux 下，退出当前虚拟环境只需要执行如下命令，即可回退到系统原生的 Python 运行环境： 1$ deactivate 如何删除虚拟环境当某一虚拟环境不再使用时，你可以将其删除释放系统资源。 Windows &amp;&amp; Linux 下，删除虚拟环境（for_test）时，你只需要将 virtualenvs_py 目录下，准备弃用的 for_test 虚拟环境目录删除掉即可！ Application这里给出一个 virtualenvs 虚拟环境管理器配合 pip 包管理工具，确保开发环境一致性的应用实例： 假设：在本地开发环境，已经准备好了 “项目 + 依赖包” 环境；现在需要将项目上传至服务器，上线发布；那么，保证本地和服务器 Python 运行环境的一致性至关重要！ 解决方案 –&gt; 1 –&gt; pip list 首先，我们需要使用 pip list 命令，来查看当前 Python 运行环境中项目依赖包的安装情况： 12345678910111213141516171819202122(for_test1) E:\\virtualenvs_py\\for_test1&gt;pip listPackage Version------------------- ---------appdirs 1.4.4certifi 2020.12.5chardet 4.0.0distlib 0.3.1filelock 3.0.12idna 2.10importlib-metadata 4.0.1importlib-resources 5.1.2numpy 1.19.5pip 21.0.1requests 2.25.1setuptools 56.0.0six 1.15.0typing-extensions 3.7.4.3urllib3 1.26.4virtualenv 20.4.4wheel 0.36.2zipp 3.4.1WARNING: The repository located at mirrors.aliyun.com is not a trusted or secure host and is being ignored. If this repository is available via HTTPS we recommend you use HTTPS instead, otherwise you may silence this warning and allow it anyway with '--trusted-host mirrors.aliyun.com'. 2 –&gt; pip freeze virtualenv 虚拟环境，配合 pip 的 freeze 功能，可以将当前虚拟环境中所有的依赖包以及其版本信息以列表的形式存放到文件中： 1$ pip freeze &gt; requirements.txt 3 –&gt; pip install xxx 对应的，我们可以将上述生成的文件上传至服务器项目发布目录，然后在服务器下创建 virtualenv，即可使用下面的命令在 venv 中重新安装项目所需的模块依赖： 1$ pip install -r requirements.txt virtualenvwrappervirtualenvwrapper 是一个基于 virtualenv 的升级版本，相较于 virtualenv，virtualenvwrapper 更容易对所有的虚拟环境进行统一管理。 Why virtualenvwrapper参考上文，你可以发现 virtualenv 存在的一个最大缺点就是： 使用 virtualenv 创建虚拟环境时，如果你没有特别的，有意识的去统一管理虚拟环境目录，很容易导致虚拟环境放的到处都是。 其次，每次开启虚拟环境之前要去虚拟环境所在目录下的 bin（Scripts） 目录下 activate，这就需要我们记住每个虚拟环境所在的目录。并且还有可能你忘记了虚拟环境放在哪…… 而使用 virtualenvwrapper 默认会将所有的虚拟环境都统一管理在一个目录下，你可以很方便、快捷的找到所有的虚拟环境。 Setup我们同样需要使用 pip 工具来进行 virtualenvwrapper 的安装，并且 Windows &amp;&amp; Liunx 平台下的安装、配置过程稍有不同： For Linux1 –&gt; Setup virtualenvwrapper 命令如下： 1$ pip install virtualenvwrapper Linux 中 virtualenvwrapper 默认将所有的虚拟环境放在 ～/.virtualenvs 目录下管理，另外可以通过修改环境变量 WORKON_HOME 来指定虚拟环境的保存目录。 12# 为了保持和后文 Windows 保持一致，可以设置为统一目录：Envsexport WORKON_HOME=~/Envs 2 –&gt; Config virtualenvwrapper Linxu 中，每次打开一个 Shell 想要使用 virtualenvwrapper 工具之前，都必须先激活 virtualenvwrapper 服务 123root@iZ2zeazcdax8nlsrpzpd83Z:~# find / -name virtualenvwrapper.sh/usr/local/bin/virtualenvwrapper.shroot@iZ2zeazcdax8nlsrpzpd83Z:~# source /usr/local/bin/virtualenvwrapper.sh 这是麻烦的，可以将上述命令添加到：.bashrc || .profie 等 shell 启动文件中。以便 shell 登陆后可直接使用 virtualenvwrapper。 例如，在 .bashrc 中添加如下内容： 12export WORKON_HOME=~/Envs # 设置 virtualenv 的统一管理目录source /usr/local/bin/virtualenvwrapper.sh # 激活 virtualenvwrapper 工具 读取文件，使得配置生效： 1source ~/.bashrc For WindowsWindows 安装命令如下： 1pip install virtualenvwrapper-win 默认创建的虚拟环境管理目录位于 C:\\Users\\username\\Envs，可以通过环境变量 WORKON_HOME 来定制： 通过计算机–&gt;属性–&gt;高级系统设置–&gt;环境变量–&gt;在系统变量中新建“变量名”：WORKON_HOME,变量值：“你自定义的路径”。 Envs Management这一小节，我们来看：相较于 virtualenv 工具virtualenvwrapper 是如何进行虚拟环境的统一管理。 Windows &amp;&amp; Linux 下 virtualenvwrapper 虚拟环境管理命令是一致的！ 如何创建虚拟环境使用下列命令可以在 ~/Envs 目录创建 for_tensorflow 虚拟环境目录： 1$ mkvirtualenv for_tensorflow 创建后，自动进入到相应虚拟环境中。 如何激活&amp;退出虚拟环境使用下列命令可以激活 for_tensorflow 虚拟环境： 1$ workon for_tensorflow workon env_name：可以实现在虚拟环境中来回切换。 使用下列命令可以退出 for_tensorflow 虚拟环境： 1$ deactivate 如何删除虚拟环境使用下列命令可以删除 for_tensorflow 虚拟环境： 1$ rmvirtualenv for_tensorflow 其它常用其他命令 lsvirtualenv列举所有的环境（可以直接使用 workon + Enter 代替）。cdvirtualenv导航到当前激活的虚拟环境的目录中。cdsitepackages导航到当前激活的虚拟环境的目录中的 site-packages 目录中。lssitepackages显示 site-packages 目录中的内容。","link":"/2018/01/02/pythoner-shen-qi-zhi-virtualenv/"},{"title":"玩转 VSCode 之配置远程开发环境","text":"微软在 PyCon 2019 大会上发布了 VS Code Remote，开启了远程开发的新时代！这次发布包含了三款核心的全新插件，它们可以帮助开发者在容器，物理或虚拟机，以及 Windows Subsystem for Linux (WSL) 中实现无缝的远程开发。VSCode Remote 的提出彻底引发了一场 “谁才是新一代最强编辑器？” 的争论。 由于在安装配置使用过程中查阅了网络上很多的相关博文，也遇到过很多问题，为了感谢过程中各位大佬的帮助以及分享给更多的新手使用，以作此文。文中如有表述不正确的地方，望各位大佬指正~~~ 更多 VS Code 相关内容，请关注博主 Visual Studio Code 博文系列： 之一 &gt;&gt;&gt; Visual Studio Code (VS Code) 你们都在用吗 ? 之二 &gt;&gt;&gt; 玩转 VSCode 之配置远程开发环境 Why Configure Remote Development-Envs先来思考一下，为什么需要配置远程开发环境？？？ 日常学习或者工作中，你可能正在面临这样的问题： 每当更换电脑就要轻（ying）轻（zhe）松（tou）松（pi）从新搭建一遍开发环境； 每当拉取完最新代码程序在本地跑不起来的时候，就要重新检查服务器和开发电脑的环境； 每当本地开发完代码需要部署到服务器上测试时发现 Bug 就想如果可以调试服务器代码多好啊。 尤其在项目开发过程中，通常大多数的 编辑和开发环境都是系统隔离的。 编辑IDE和开发环境的系统隔离比如后台服务器开发工作，远端的服务器 Linux 系统一般是没有图像用户界面的，也就没有 IDE 界面，IDE 部署在个人的本地 Windows 电脑。服务端的程序一般都是跑在 Linux 服务器上面，传统的开发流程是在 Window 或 Mac 的 IDE（假设目前在用 VS Code）环境编写代码，然后使用 SSH 客户端软件（XShell、PuTTY…）实现 SSH 远程登录 Linux 服务器上传代码，这时候你的编辑 IDE 和开发环境（代码编译、运行）就是隔离的。 这种隔离性表现在你在代码编辑不会实时刷新到开发环境进行后续的编译 &amp; 测试 &amp; 验证。 如何打通系统隔离事实上，打通系统隔离的方法有挺多的： SSH 远程登录（XShell、XFtp、PuTTY…）； 共享服务器（Samba、Ftp…）； 版本管理工具（Git、SVN），编辑这边提交更改，开发环境那边 pull 下来。 传统的远程开发流程 &gt;&gt;&gt;&gt; 在本地 Windows 和 Linux 开发服务器之间开启一个同步程序（Samba），本地编辑代码，实时后台同步到 Linux 远端服务器，然后用 XShell 登录开发机编译、调试。 现在来看（有了 VS Code Remote），这个过程有点不够优雅：需要了解 【Samba 同步 &amp;&amp; XShell】 的使用，并且还需要熟悉 Linux 命令行操作，这给开发者带来了工作效率的困扰。 除此之外，上述方法是有使用条件的，比如远程开发机在外网 ip，或者企业内部做了机器隔离，或者只开通了 SSH 接口登录，怎么办？？！ 这时需要 –&gt; 配置基于 SSH 通信连接的远程开发环境。 配置之后你可以干啥 &gt;&gt;&gt;&gt; 把开发环境作为沙箱，以避免影响本地计算机配置； 让新手轻松上手，让每个人都保持一致的开发环境； 从多台不同的计算机访问现有的开发环境； …. 并且，配置之后，使用 VS Code 也可以实现 SSH 远程登录，而且使用 VS Code 进行登录后，可以向操作本地文件（夹）一样来操作远程主机上的文件（夹），而且在进行代码编写时，也可以复用 VS Code 支持的代码高亮、提示等功能…. 快来让你的工作效率飞起来吧~~~ 下面我们来看如何进行配置，本人的 Local OS 是 Windows10 , Remote OS 是 Linux 远程服务器。 Pre-Preparation Before Envs-Configuration（SSH）VS Code 的安装比较简单，你可以参看博文系列中 【Visual Studio Code (VS Code) 你们都在用吗 ?】，此处默认本地 Windows 上已经安装好 VS Code。 远程开发插件安装（Remote-SSH）要能连上远程主机，首先我们需要下载 VS Code 远程开发插件 –&gt; Remote Development。 点击 VS Code 插件按钮，或者使用快捷键 Ctrl + Shift + X，直接进入插件应用商店搜索：remote development（先不要安装）： 事实上，Remote Development 插件是个插件包，包括了三个安装套件： Remote - SSH –&gt; 可以通过使用 SSH 链接虚拟或者实体 Linux 主机; Remote - Containers –&gt; 连接 Docker 开发容器; Remote - WSL –&gt; 连接 Windows Subsystem for Linux （Linux子系统）。 打开软件的扩展界面，搜索 Remote 开头的插件，也能看到这三个不同的远程开发插件。这里，我们连接的是远程 Linux 服务器，所以实际只需要安装 Remote - SSH 插件即可（当然你可以选择直接安装 Remote Development 插件包体验其它远程连接功能）。 Remote - SSH这里我只选择安装 Remote - SSH 插件，安装成功后，你会发现同时自动安装了一个名为 Remote - SSH: Editing Configuration Files 的插件，插件官方解释是用来 Edit SSH configuration files，不用深究，后续你会用到。 并且，你可以看到 VS Code UI 左侧多出来一个名为 Remote Explorer 的按钮（远程资源管理器），用于在当前菜单区域组织和管理远程资源： 同时，VS Code UI 最下方状态栏出现了一个通过点击可 唤醒远程命令弹窗 的图标： 远程命令弹窗中，可查看以及运行当前 VS Code 中支持的远程命令，包括连接服务器，查看远程配置文件等等。 Remote-SSH 工作原理下面是官方给出的 Remote-SSH 的工作原理解析图： 简单来说，就是在远程机器上运行 VSCode Server，本机的 VSCode 只负责编辑、展示等，两者通过 SSH-Tunnel 通信。 这种模式的优点是客户端基本没有压力（降低了客户端设备的配置要求），编译、运行、Debug 等处理操作全部在目标机器完成。开启 SSH 模式后插件全是安装在 Remote 端，只有部分 UI 相关的插件会装在 Local 端。 Remote-SSH 最终搭建起了一套 【远程终端 + 定制化插件（如代码高亮等） + 远程调试开发 + 可视化 linux 文件目录…..】 的远程开发环境。 直呼 NB 就完事~~~ SSH Setup &amp; Configuration本地 VS Code 采用 SSH 协议与远程服务端通信，所以要先安装和配置 SSH 环境。 最新版本的 Win10 中已经自带了 openSSL（支持 SSH 通信），但我们推荐使用 Git 中自带的 SSH 客户端程序，如果你还没装 Git 的话，这里要先安装 Git，参见 –&gt; Git 使用指南之初识。并且你需要配置 Git 的 bin 目录到环境变量的 PATH 变量下，这样 VS Code 连接的时候就能找到 SSH 了。 Win10 中由于自带有 openSSL 比较特殊，系统和 VS Code 可能会优先加载到 openSSL 中的 SSH 程序，这会导致后续 VS Code Remote 连接错误。你可以在 DOS 窗口下通过如下命令查看一下当前系统调用的 SSH 程序位置： 123&gt;where sshC:\\Users\\xxx Guo\\sshC:\\Windows\\System32\\OpenSSH\\ssh.exe 可以看到，当前我的系统默认中找到的是系统自带的 OpenSSH 中的 ssh.exe。 因此，此时需要你确保 VS Code 中 remote.SSH.path 设置项使用的是 Git 中的 ssh.exe，如果设置项为空的话，请显式设置 Git/bin 下的 ssh，例如： 1&quot;remote.SSH.path&quot;: &quot;E:\\\\Git\\\\usr\\\\bin\\\\ssh.exe&quot; 安装好 SSH 之后，你就可以正常使用 VS Code 连接远程服务器了~~~ Remote Connection这里来看，如何使用 VS Code 安装好的插件 –&gt; Remote Development，以及 SSH 工具 进行远程服务器的连接： Add Remote Host首先，在 VS Code 远程资源管理器（Remote Explore）中添加远程主机： 1 –&gt; 切换到 Remote Explore。 2 –&gt; 在 SSH TARGETS 处点击 +，而后会弹出如下图界面： 在 ssh hello@microsoft.com -A 处输入你的远程主机信息，其中： hello 位置填写你在远程主机处的用户名（注意字母大小写）； microsoft.com 位置填写远程主机的 IP 地址； -A 位置可不写。 例如：ssh ubuntu@81.xx.xxx.36 。 3 –&gt; 按照上述格式填写信息后，然后 【Enter】，然后会询问你远程服务器连接配置文件存放位置： 选项一（...\\\\.ssh\\config）是保存到当前用户下，选项二（...\\ssh\\ssh_config）是保存到所有用户下；选择默认选项一即可，然后 【Enter】，右下角会出现提示： 1Host added ! 添加成功了，你可以查看一下 SSH TARGETS 区域，已经可以看到成功添加的服务器了~~~ 最后查看一下 ...\\user\\your-user-name\\.ssh\\config（当前用户目录下的 .ssh 目录） 中的服务器配置信息： 1234Host 81.xx.xxx.36 HostName 81.xx.xxx.36 User ubuntu Port 22 除了上述配置项，更完整的格式以及释义： 12345Host &lt;远程主机名称&gt; ==&gt; 远程主机别名，便于记忆 HostName &lt;远程主机IP&gt; ==&gt; 远程主机 IP User &lt;用户名&gt; ==&gt; 用于登录远程主机的用户名 Port &lt;ssh端口，默认22&gt; ==&gt; SSH 通信协议端口 IdentityFile &lt;本机SSH私钥路径&gt; ==&gt; 采用密钥方式登录时，需指定私钥的路径 =============================== 另一种添加 Remote Host 方法 =============================== 通过 「远程资源管理器」 之后的 「设置按钮」，可以直接生成且打开远程服务器连接配置文件，然后你可以按照上面的服务器配置格式以及参数进行配置，配置后自动添加服务器。 如连接多个远程服务器，可参考如上内容，配置多个即可； 12345678910Host &lt;远程主机名称1&gt; HostName &lt;远程主机1 IP&gt; User &lt;用户名1&gt; Port &lt;ssh端口，默认22&gt; IdentityFile &lt;本机SSH私钥路径&gt;Host &lt;远程主机名称2&gt; HostName &lt;远程主机2 IP&gt; User &lt;用户名2&gt; Port &lt;ssh端口，默认22&gt; IdentityFile &lt;本机SSH私钥路径&gt; Login Remote Host这里针对远程服务器的两种登录方式，VS Code Remote 提供两种相应的登录方法： 用户密码登录; 密钥（公私钥）登录。 用户密码登录在 SSH TARGETS 区域选中你要登入的服务器，右键选择新窗口中连接还是在当前窗口连接（服务器后方 ＋ 号表示直接在新窗口连接）。 这里选择 【当前窗口连接】，然后会重新加载弹出 Enter password for ubuntu@81.xx.xxx.36 让你输入 ubuntu 用户的密码，输入后 【Enter】 确认。 等待一会儿即可连接成功，VS Code 状态栏中用于唤醒远程命令弹窗的按钮可以看到已连接到的服务器名称~~~ 遗留问题：每次连接远程服务器都需要输入密码，太麻烦了，随后配置一下免密码登录。参加 【Reffs: Configuration –&gt; 配置免密登录】。 密钥登录密码登录机制是不安全的，很容易被网络上的其它人攻击，植入一些挖矿程序。而密钥登录替代密码的方式的连接特性，可以使得远程登录非常安全。公私钥的登录原理 是利用密钥生成器（ssh-kengen）制作一对密钥 –&gt; 一只公钥 &amp;&amp; 一只私钥。将公钥添加到服务器的某个账户上，然后在客户端持有私钥即可完成认证并登录。 这样一来，没有私钥，任何人都无法通过 SSH 暴力破解你的密码来远程登录到系统。此外，如果将公钥复制到其他账户甚至主机上，任何一个持有私钥的客户端就可以登录（保存好你的私钥！！！）。按照当前实际搭建情况如下图所示： img img img Go Start &gt;&gt;&gt;&gt; 1 –&gt; 密钥生成 密钥对的生成可以是本地的 Win10，也可以通过服务器生成，只要遵循上图中密钥登录架构原理图即可。 这里，尝试选择在 Linux 服务器上生成密钥对： 1）通过 XShell 或者 Putty 工具连接 Linux 服务器。 2）服务器终端中输入如下指令（密钥生成器）建立密钥对（先不要执行，先看注意事项！！！）： 1$ ssh-keygen 注意事项：如果之前你已经生成过密钥（Git），此操作可能会使用新的密钥文件覆盖你之前生成的密钥文件，这说有风险的！但你也可以使用之前已经生成的密钥对（Git）进行配置，这是允许的。如果使用已有密钥对的话，你可以跳至下一小节（这里就不生成了，直接白嫖~）。 如果你第一次使用 SSH 可以放心生成密钥对，执行 ssh-keygen，继续往下看 3）需要你确定密钥文件存储路径（这里你可以自定义安装路径），默认 【Enter】 即可： 1Enter file in which to save the key (/home/xx_usr/.ssh/id_rsa): 一路 【Enter】，即可自动生成公钥和私钥，下面是公私钥默认下存储路径： 12your identification has been saved in /home/xx_usr/.ssh/id_rsa. ==&gt; 私钥your public key has been saved in /home/xx_usr/.ssh/id_rsa_pub. ==&gt; 公钥 生成公私钥之后，就可以开始进行服务器端和客户端设置了： 2 –&gt; 服务器上安装公钥 1）添加公钥到服务器授权名单： 1234$ cat ~/.ssh/id_rsa_pub &gt;&gt; ~/.ssh/authorized_keys# 查看确保成功添加公钥$ cat ~/.ssh/authorized_keys 2）为了确保连接成功，请保证以下文件权限正确： 12$ sudo chmod 600 ~/.ssh/zutorized_keys$ sudo chmod 700 ~/.ssh 3 –&gt; 配置密钥登录 1）打开 SSH 配置文件，查看确认以下两项配置（默认不需要修改）： 12RSAAuthentication yesPublicAuthentication yes 2）禁用密码登录 你可以在 设置密钥登录成功之后 修改以下配置项为 no，来禁止密码登录提示访问安全性： 12# 一定要确保设置密钥登录成功之后再关闭，否则你将无法登录服务器了PasswordAuthentication no 3）配置完成后需要重启服务器 SSH 服务才可生效 1$ sudo service sshd restart 4 –&gt; 服务器私钥复制到客户端 前面生成的密钥是通过服务器生成的，因此需要把生成的私钥复制本地 Win10 上面，简单点你可以直接使用 XShell 文件传输组件（XFTP）直接拷贝到 Win10 下即可（推荐拷贝到：~/.ssh/ 下，重命名为 id_rsa_remote_ssh ，方便日后管理）。 下载私钥到本地 Win10 之后，修改 VS Code 中服务器配置信息： 12345Host 81.xx.xxx.36 HostName 81.xx.xxx.36 User ubuntu Port 22 IdentityFile ~/.ssh/id_rsa_remote_ssh 重新尝试连接，应该就可以成功了~~~~ 关于云服务器（阿里，腾讯…）中的密钥登录问题 &gt;&gt;&gt;&gt; 有些远程服务器设置为只可以使用密钥登录，例如阿里云创建实例后要求只能使用密钥进行登录，这时云平台会给你下发一个私钥文件，你的客户端持有改私钥文件，才可以访问云服务器。怎么配置远程登录？？？ 此时，公钥默认已安装到服务器上，你只需要直接在 VS Code Remote 配置文件中配置私钥路径即可，就可以尝试进行登录了。 关于 Windows 下已存在公私钥的问题 &gt;&gt;&gt;&gt; 前面我们是基于在服务器上创建密钥对，然后进行密钥登录配置的。并且也提到过，只要遵循密钥登录原理，密钥对的生成可以是本地的 Win10，也可以通过服务器生成。 既然，本地 Windows 端已经有了密钥对了（之前配置 Git 远程库时创建的），那自然是可以直接用的，作为远程密钥登录方式的密钥对，这是合理的。 可以成功登录服务器之后，你就可以尝试 VS Code Remote 连接服务器后的操作了： Remote Host Use登录成功，即可像操作本地环境一样，在 VS Code 客户端操作远程服务器了。 可视化 Linux 目录点击 Explorer 或者直接使用快捷键 Ctrl + Shift + E，点击 Open Folder 后可以在下述位置处，选择想要进入（cd）的远程主机位置： 选择好相应文件夹后，即可在 Explorer 资源管理区域看到可视化后的 Linux 目录，操作上面的文件和操作本地环境里的一样。 Remote Host Extensions同时，可以给远程 VS Code 安装需要的插件，安装的插件是在云服务器的 VS Code（VSCode-server）上，对本机的 VS Code 没有影响，插件在远端提供功能，比如代码审查、自动补齐等等，而这所有的一切就像在本地操作一样。 细心的你可以发现，之前我们本地安装的插件大部分都处于 disabled 状态，此时 VS Code 提示： 1This extension is disabled in this workspace because it is defined to run in the Remote Extension Host. Please install the extension in 'SSH: TC-DeepCoding' to enable. 简言之，就是说你当前处于远程服务器状态，本地插件在当前状态下不生效，如果你想使用的话，请将其安装在服务器端。之后，我们的插件资源管理器就变成这样的了： 但请 注意：连接到一个新服务器时，插件是需要重新安装的，这是合理的。并且有些插件是不适合远程开发模式的，插件资源管理器中支持你 install 的才可以安装。 Remote Terminal终端调试时，打开的是远端服务器的终端，直接在终端操作编译或者查看云/服务器信息等，这和在远端服务器上使用是一样的。 Reffs: Configuration配置免密登录前面在使用账号密码进行 VS Code 登录远程主机时，你会发现每次登录都需要输入密码，太麻烦了/(ㄒoㄒ)/~~这时可以设置免密登录远程服务器，什么是免密登录？？！ 将本机添加到远程服务器连接白名单，让服务器知道是已认证的电脑在连接。过程类似于 GitHub 网站添加本地电脑的 SSH 公钥。 那么，如何设置？？！ 生成公私钥12345# 方法一$ ssh-keygen# 方法二，参考使用 Git 生成密钥$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot; 拷贝公钥文件至远程主机拷贝 id_rsa.pub 至远程 Linux 上的 ~/.ssh 下的 authorized_keys 文件中。 也可以使用命令： 12345# Local M:$ scp -P 22 id_rsa.pub user@ip-of-your-remote-host:/home/user/.ssh/id_rsa.pub# Remote Host$ cat ~/.ssh/id_rsa.pub &gt; ~/.ssh/authorized_keys 免密登录已经配置完成了~~~你可以尝试登录时是否需要输入密码了。 免密登录 == 密钥登录方式 应该有眼尖的看官老爷们会发现，这里为账号密码登录配置免密登录的方式，和前面给出的 Windows 下创建密钥对进行密钥登陆的方式很相似啊！ 这里，配置免密登录只是把想要登录远程服务器的客户端公钥放到了服务器的“信任名单（authorized_keys）”，当远程服务器请求登录密码时，发现当前请求的客户端是信任设备，会直接采用上面密钥登录（跳过提供密码的环节）的访问方式，只要客户端中持有相应私钥，就可以直接访问远程服务器。 但要注意的是，这里的私钥一定要和配置免密登录中的公钥是一对。例如 ssh-keygen 默认情况下生成的公私钥：id_rsa --&gt; id_rsa.pub，如果免密登录中你拷贝至远程服务器中的是 vs_remote_id_rsa_pub，那么你必须在 VS Code Remote 配置文件（config）中显式的配置 IdentityFile 选项为 vs_remote_id_rsa。默认情况下，会自动使用私钥 id_rsa。 完结，撒花~~~","link":"/2017/08/02/wan-zhuan-vscode-zhi-pei-zhi-yuan-cheng-kai-fa-huan-jing/"},{"title":"Git 使用指南之分支管理","text":"Git 的分支管理。使用过 SVN 等其它版本控制系统的童鞋可能会说：“SVN 也有分支管理啊”。但由于创建和切换分支慢的一批…那么，Git 分支管理功能有性能提升吗？”。 当然有！Git 的分支是与众不同的。无论创建、切换和删除分支，Git 都能在 1 秒钟 之内就能完成！无论你的版本库是 1 个文件还是 1 万个文件。这种跟版本库大小无关的特性，到底是怎么做到的？？！。 版权说明： 本文思路以及内容主要来自廖雪峰老师的 Git 教程 （强烈推荐膜拜原文），并结合个人使用所作，只作为学习记录使用。如内容有侵权请联系删除，禁止转载！ 更多 Git 相关内容，请关注博主 Git 博文系列： 之一 &gt;&gt;&gt; Git 使用指南之初识 之二 &gt;&gt;&gt; Git 使用指南之时光穿梭机 之三 &gt;&gt;&gt; Git 使用指南之远程仓库 之四 &gt;&gt;&gt; Git 使用指南之分支管理 之五 &gt;&gt;&gt; Git 使用指南之 WorkFlow (工作流) 之六 &gt;&gt;&gt; Git 使用指南之 Git 自定义 之七 &gt;&gt;&gt; Git 使用指南之 HEAD 指针 之八 &gt;&gt;&gt; Git 使用指南之 Git 中的黑魔法 Meet Branchs Management从使用场景上解释，是这么个概念： 【场景模拟】 ↓↓↓↓ 参与一个项目开发任务，需要为在线平台增加一个新功能，半个月过去了，开发任务按照预期完成了 50%，就在此时在线平台突然出现 BUG …… 如果立刻提交，由于代码还未完成，不完整的代码库会影响项目内其他人工作；如果等代码全部写完再一次提交，又存在丢失工作进度的巨大风险。 【解决思路】 &gt;&gt;&gt;&gt; 使用 Git 分支管理 可以帮助你完美解决上述问题~~~ 借用一句话就是：分支就像是科幻电影里面的平行宇宙，当你正在电脑前努力学习 Git 的时候，另一个你正在另一个平行宇宙里努力学习 SVN。如果两个平行宇宙（两条平行的时间线）互不干扰，那对现在的你也没啥影响。并且如果在某个时间点，两个平行宇宙合并了，结果你既学会了 Git 又学会了 SVN！ 有了分支管理，你可以创建一个属于你自己的分支，项目内其他人是无法看到的，还继续在原来的分支（master）上正常工作。而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，既安全，又不影响别人工作。 Branch 指针深入一点理解分支的（本质）话，是这么个概念： Git 中的分支，本质上仅仅是 指向提交对象（Commit objects）的可变指针，指向当前的最新提交（Commit，也称为：快照）。 在介绍版本回滚时，我们曾提到过：每次提交，Git 都把它们串成一条时间线，这条时间线就是一个分支，指针指向时间线上的最新时间点（commit）。 实际上，当我们起初使用 Git 的时候，就已经使用到分支了，因为 Git 的默认分支名字是 master，如果你有心的话，会发现执行 git init 后，命令行的输出头部已经默认在 master 分支了。 但是这个时候，还并未创建 master 分支，只有当有一个提交的时候，才会创建 master 分支。原因在于，分支的指针要指向提交的呀。 这里需要重新认识一下 HEAD 指针，你才能更深入的了解 Branch 的使用： HEAD 指针前面，我们介绍过 HEAD 指针是一个特别的指针，用于记录当前工作的位置（当前版本库所处的分支，以及当前分支的提交点）。 严格来说，一般情况（默认）下 HEAD 指针不是直接指向 commit 的，而是指向 branch 的，branch 才是指向提交的！！！ 事实上，HEAD 指针除了可以指向 branch 也可以移动 HEAD 指针指向快照（commit），但当 HEAD 指向 branch 时且执行提交操作（git add）后会和 branch 指针一起向后移动；当 HEAD 不指向 branch（指向分支上的某一个 commit）时且执行提交（git add）后会使得 HEAD 指针处于特殊的 detached（[dɪˈtætʃt]，游离）状态，关于 HEAD 指针在 detached 状态的说明可参加系列博文。 通俗来讲，分支（Branch）代表着不同的基于主时空（master branch）的平行时空，无干预时互不影响。HEAD 指针等同于处于不同平行宇宙时间线下的 你自己：你在哪儿（时间点），指针就在哪；你在哪个分支（时间线），HEAD 指针就指向哪个分支的指针。 Branch Working Principle Diagram这一小节，我们通过图解的方式来简单分析一下： Git 分支管理的工作机制，来增强对 Git 分支的认识。 我们知道，一开始的时候，Git 默认创建的 master 分支是一条线，Git 用 master 指向最新的提交，再用 HEAD 指向 master，就能确定当前分支，以及当前分支的提交点。 master 分支上，每一次提交，master 分支都会向前移动一步，随着你不断提交，master 分支的线也就越来越长： 创建并切换分支时（以 develop 分支为例），Git 将新建一个指针 develop，并将 develop 指针指向 master 相同的提交，然后再将 HEAD 指向 develop。表示当前分支在 develop 上： 这也可以看出，为什么 Git 创建分支会如此之快，工作区的文件都没有任何变化，并且只是增加了一个 develop 指针以及改变了 HEAD 的指向，此后对工作区的修改和提交就是针对 develop 分支了。 比如新提交一次后，develop 指针往前移动一步，而 master 指针不变： 一段时间后，我们成功在 develop 分支上完成新功能的开发，此时我们想把新功能整合到在线平台，也就是想把 develop 合并到 master 上，Git 如何实现呢？最简单的方法，就是直接把 master 指向 develop 的当前提交，就完成了合并： 可以看出，Git 合并分支也很快！就改改指针，工作区内容也不变！合并完分支后，甚至可以删除 develop 分支。删除 develop 分支就是把 develop 指针给删掉，删掉后，我们就剩下了一条 master 分支： 通过上面的学习，相信你已经对 Git 的分支管理有了相对深入的认识，下面正式开始 Git 分支管理的学习： 玩转 Branch 必备技能有关分支的命令不多，无非是换着花样的增删改查，掌握好以下基本的命令，以后就可以在 Branch 的草原上策马奔腾潇潇洒洒啦~~~ 重要的分支操作命令格式：CMD 13 –&gt;&gt;&gt; git branch &lt;options&gt; 创建分支创建分支的命令非常简单，命令格式如下： 1$ git branch &lt;branch name&gt; 使用起来非常简单，似乎简单到你只需要想个分支的名字就好了。但是在创建分支的时候，要想下：是否要从当前分支的内容基础上去开辟一条新分支？？？ 查看分支如何查看本地仓库以及远程库中的分支情况呢？三个命令，让你想看什么分支就看什么分支： 1 –&gt; 如何查看本地分支： 1$ git branch 2 –&gt; 如何查看远程分支： 1$ git branch -r 3 –&gt; 如何查看本地和远程的所有分支： 1$ git branch -a 重命名分支实际项目开发过程中，有时会涉及到 分支的重命名： 【场景一】：重命名本地分支 当本地的开发分支还没有推送到远程分支的时候，会在本地进行分支的重命名。 在当前分支时: 1$ git branch -m &lt;new branch name&gt; 不在当前分支时: 1$ git branch -m &lt;old branch name&gt; &lt;new branch name&gt; ====================================================================== 如果是已经推送到远端，应该怎么做呢？ 【场景二】：重命名远程库分支 假设是在当前分支，并且远端分支与本地分支名是一致的。 重命名本地分支 1$ git branch -m &lt;new branch name&gt; 删除远程分支 1$ git push origin --delete &lt;old branch name&gt; 上传新命名的本地分支 1$ git push origin &lt;new branch name&gt; 关联修改后的本地分支与远程分支 1$ git branch --set-upstream-to origin/&lt;new branch name&gt; 检出/切换分支检出分支的 “检出” 二字，算是个关于 Git 分支的专业术语了,可以理解为切换当前分支。 CMD 14 –&gt;&gt;&gt; git checkout &lt;-b&gt; &lt;branch name&gt; 当 checkout 表征 “检出” 含义时，checkout 操作是移动 HEAD 指针，将 HEAD 指针指向要切换的分支的指针处。 使用场景有两个： 已经存在的分支，现在要切换过去。 1$ git checkout &lt;branch name&gt; 创建一个新分支，且切换到新分支，这个一步到位的话需要 -b 参数 以当前分支为基础，创建一个新分支： 1$ git checkout -b &lt;branch name&gt; 以指定的某一个提交，创建一个新分支： 1$ git checkout -b &lt;branch name&gt; &lt;Commit-ID(SHA1)&gt; CMD 15 –&gt;&gt;&gt; git switch &lt;-c&gt; &lt;branch name&gt; 记忆力好的看官可能想到，前面撤销修改操作使用过 git checkout -- &lt;file&gt;，太迷惑了……事实上，Git提供了新的 git switch 命令来专门处理分支切换。 对应 checkout 的两种使用场景： 已经存在的分支，现在要切换过去。 1$ git switch &lt;branch name&gt; 创建一个新分支，且切换到新分支，这个一步到位的话需要 -b 参数 以当前分支为基础，创建一个新分支： 1$ git switch -c &lt;branch name&gt; 删除分支分支生命周期完成后，我们就可以放心删除了： 当本地分支删除后，推动到远程仓库后，远程仓库并不能自动删除对应的远程分支。意味着，分支的完全删除是分两个部分的： 本地分支的删除 远程分支的删除。 1 –&gt; 删除本地分支： 123456## 1. 一般删除：删除前会检查 merge 状态，只有满足删除条件才会执行删除操作$ git branch -d &lt;lacal branch name&gt;## 2. 强制删除：会直接执行删除操作# 如果要丢弃一个没有被合并过的分支，可以通过-D 强行删除$ git branch -D &lt;local branch name&gt; 参数 -D 比 -d 要粗暴一点。当被删除分支有新内容没有被合并的时候，使用 -D，会直接删除；使用 -d，会提示该分支有新内容没有被合并，不执行删除。删除需谨慎，建议非特殊情况下，使用温柔的 -d 要好一点，以免小手一抖，/(ㄒoㄒ)/~~ 2 –&gt; 删除远程分支： 1$ git push origin --delete &lt;remote branch name&gt; 以上，是分支的增删改查独立操作，但是 Git 创造这个分支，并不只是为了让它们自个儿和自个儿玩的，还需要它们之间的相互协作和配合。 就像日常项目开发过程中，分好开发任务，你和你的小伙伴新建了两个分支，你写你的 Butter，他写他的 Fly,到开发完成之后，肯定要合在一起，才能成就 Butterfly。合的这个动作，就涉及到了分支合并的概念。 Branch 合并大事记合并指定分支到当前分支的命令格式为：CMD 16 –&gt;&gt;&gt; git merge &lt;branch name&gt; git merge 命令可以加 -m &quot;message&quot; 参数添加合并提交日志。 Git 中分支的合并是非常智能的，目前有两种模式。两种模式的选择，不需要我们参与，而是 Git 根据分支情况不同，自行判断选择最适合的 Merge 模式。 个人在使用 Git 的过程中，执行分支合并时：有时需要输入提交信息，有时不需要，起初作为小白的我懵的不知所以然，后来才知道，原来是合并模式的问题啊！！！ 两种合并模式是： Fast-Forward（快进式） Recursive Strategy Merge（递归策略合并式，也称为三方合并式） Fast-Forward 如图，有两个分支，master 分支和 feature 分支。当这两个分支处于上面的关系时，当进行合并操作时，就会出现 fast-forward。 【说明】：由于当前 master 分支所指向的提交是 feature 分支的直接上游，所以 Git 只是简单的将指针向前移动。换句话说，当你试图合并两个分支时，如果顺着一个分支走下去能够到达另一个分支，那么 Git 在合并两者的时候，只会简单的将指针向前推进（指针右移）—-&gt;这就叫做 “快进（fast-forward）”。 合并后的分支指针位置如下： Recursive Strategy Merge这个合并方式，是为补充 fast-forward 而出现的。 因为你知道，在项目开发过程中，很多人开发的情况下，出现 fast-forward 的情况并不是很多，很多是类似下面这种。提交历史是分叉的，无法满足执行 fast-forward 的条件： 【说明】：，master 分支所在提交并不是 feature 分支所在提交的直接上游（祖先），Git 不得不做一些额外的工作。 出现这种情况的时候，Git 会使用两个分支的末端所指的快照（C4 和 C5）以及这两个分支的工作祖先（C3），做一个简单的三方合并,生成一个新的提交（C6）。 Branch Demo【2.玩转 Branch 必备技能】 &amp;&amp; 【3.Branch 合并大事记】，说起来就是一堆理论，这一小节我们基于 GitTestProject 来实操一下： 1）从 master 分支末尾，创建并切换 featureA 分支，并创建一个提交： 1234$ git checkout -b featureA$ touch ATest.txt$ git add .$ git commit -m &quot;Add ATest File For featureA&quot; 2）从 master 分支末尾，创建并切换 featureB 分支，并创建一个提交： 12345$ git checkout master$ git checkout -b featureB$ touch BTest.txt$ git add .$ git commit -m &quot;Add BTest File For featureB&quot; 3) 切换回 master 分支 1$ git switch master 测试分支 featureA &amp;&amp; featureB 完成后，就可以开始尝试分支的合并功能了： 4) Fast-Forward 合并 master 分支合并 featureA 时，是快进式合并： 123456$ git merge featureAUpdating 79c3a2c..fc2702bFast-forward ATest.txt | 0 1 file changed, 0 insertions(+), 0 deletions(-) create mode 100644 ATest.txt 图例如下： 5) Recursive Strategy Merge 合并 master 分支合并 featureA 后， 再合并 featureB 时，已经不满足快进式条件了，此时合并会触发一个三方合并，产生一个新的提交。 执行合并 featureB 命令，会跳到一个 VIM 页面，让我们编辑这个新提交的提交信息，你可以看到默认的提交信息是 “Merge branch ‘branch name’”。此时，按 i 进入编辑模式可编写提交信息, 编写好后，通过 ： + wq 保存并退出 VIM 页面即可完成合并。 12345$ git merge featureBMerge made by the 'recursive' strategy. BTest.txt | 0 1 file changed, 0 insertions(+), 0 deletions(-) create mode 100644 BTest.txt 图例如下： 最后再提供一下用来查看分支合并图的命令： CMD 16 –&gt;&gt;&gt; git log –graph –pretty=oneline –abbrev-commit 12345678910111213 $ git log --graph --pretty=oneline --abbrev-commit* 5f264b1 (HEAD -&gt; master) Merge branch 'featureB'|\\| * 4528426 (featureB) Add BTest File For featureB* | fc2702b (featureA) Add ATest File For|/* 79c3a2c (origin/master) Add git_rm_test.txt* fe3235b git tracks changes* d6ddc31 Git local data management test* 0f5a696 understand how stage works* ebba382 Add test code* da1fadc Add help info* 65586b3 ADD Project Base 其中，--pretty=oneline 参数表示提交以单行显示，--abbrev-commit 参数表示减少头部数据（缩短 SHA1 数值）。 No Fast ForwardFast Forward 意为 “快进模式”。主要使用在多分支合并的情况下。即：当前分支合并另一个分支的时候（如果合并的过程中没有 Conflict 冲突的时候，关于 Conflict 的说明见下一小节，这里不用深究），则会通过直接移动两个分支的指针，来达到合并的过程，这个过程就叫做 Fast Forward。 那么，何为 No Fast Forward？？？No Fast Forward 指的是，合并时禁用 fast forward 模式，采用 Recursive Strategy Merge 模式进行合并。 为什么要禁用 Fast Forward 模式，这就不得不提到 Fast Forward 的弊端了： 1 –&gt; Fast Forward 弊端 在 Fast Forward 模式下，当我们 merge 合并后，将会删除无用的分支。即：删除分支后，会丢掉分支的所有信息。 什么是丢掉分支信息呢？看下面的例子 &gt;&gt;&gt; 假设，新建一个名为 dev 的分支，在分支上进行了两次操作：1.Func-Add User；2.Func-Add Permission，然后切换至 master 主分支，使用 Fast Forward 模式进行合并分支，查看日志信息如下： 12345678910111213$ git merge devUpdating 5f264b1..8a39810Fast-forward dev_function.txt | 2 ++ 1 file changed, 2 insertions(+) create mode 100644 dev_function.txt$ git log --graph --pretty=oneline --abbrev-commit* 8a39810 (HEAD -&gt; master, dev) Func-Add Permission* 3d6d64d Func-Add User* ebba382 Add test code* da1fadc Add help info* 65586b3 ADD Project Base 可以看到，对于功能 Func-Add User &amp;&amp; Func-Add Permission，无法判断是 master 分支还是 dev 分支提交的。 怎么办？？？ 2 –&gt; No Fast Forward(–no-ff) 如果要强制禁用 Fast Forward 模式，Git 就会在 merge 时生成一个新的 commit，这样，从分支历史上就可以看出分支信息。命令格式如下： 1$ git merge --no-ff -m &quot;message&quot; &lt;branch name&gt; 对比一下： 1234567891011121314151617181920212223$ git switch masterSwitched to branch 'master'Your branch is ahead of 'origin/master' by 5 commits. (use &quot;git push&quot; to publish your local commits)$ git merge --no-ff -m &quot;Merge with no-ff&quot; devMerge made by the 'recursive' strategy. dev_function.txt | 3 +++ 1 file changed, 3 insertions(+)$ git log --graph --pretty=oneline --abbrev-commit* 28157d9 (HEAD -&gt; master) Merge with no-ff|\\| * 02636d0 (dev) Func-Add Permission(no-ff)| * b324182 Func-Add User(no-ff)|/* ================= Shortcut Line ================* 8a39810 Func-Add Permission* 3d6d64d Func-Add User......* ebba382 Add test code* da1fadc Add help info* 65586b3 ADD Project Base 可以看到，使用 no-ff 合并的方式可以保留分支信息。 如果合并分支之后，将 dev 分支删除了，你就找不到 dev 分支了，但在分支示意图上仍然可以看到分支结构： 1234567891011121314151617$ git branch -d devDeleted branch dev (was 02636d0).$ git log --graph --pretty=oneline --abbrev-commit* 28157d9 (HEAD -&gt; master) Merge with no-ff|\\| * 02636d0 Func-Add Permission(no-ff)| * b324182 Func-Add User(no-ff)|/* ================= Shortcut Line ================* 8a39810 Func-Add Permission* 3d6d64d Func-Add User*......* ebba382 Add test code* da1fadc Add help info* 65586b3 ADD Project Base |———————————————————— 友情提示： 我们知道 Git 创建、合并和删除分支都非常快（操作指针）。所以，Git 鼓励用户使用分支完成某个任务，合并后再删掉分支，这和直接在 master 分支上工作效果是一样的，但过程更安全。 ————————————————————| 和平解决 Branch 合并冲突有人在的地方就有江湖，有分支在的地方，就有冲突~~~ 很多时候，合并操作不会如此顺利。 如果你在两个不同的分支中，对同一个文件的同一个部分进行了不同的修改，Git 就没法干净的合并它们，于是就会发生冲突。 例如，分别在 master 和 featureA 下，在 ATest.txt 文件添加一行任意内容，然后两个分支合并，就会发生冲突。 1234$ git merge featureAAuto-merging ATest.txtCONFLICT (content): Merge conflict in ATest.txtAutomatic merge failed; fix conflicts and then commit the result. 这是，可以通过 git status，查看冲突的详细信息。冲突提示信息中，指明冲突文件为： ATest.txt。 1234567891011121314(master *+|MERGING) GitTestProject $ git statusOn branch masterYour branch is ahead of 'origin/master' by 9 commits. (use &quot;git push&quot; to publish your local commits)You have unmerged paths. (fix conflicts and run &quot;git commit&quot;) (use &quot;git merge --abort&quot; to abort the merge)Unmerged paths: (use &quot;git add &lt;file&gt;...&quot; to mark resolution) both modified: ATest.txtno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 需要说明的是：如果遇到冲突的话，git 就无法自动合并了，接下来要靠我们自己手动解决冲突，方法是： 查看造成冲突的文件，修改冲突部分; 对修改后冲突文件，执行 git add 操作; 创建一个修改冲突的提交。 先了解一下发现冲突的解决思路，接下来，一步一步仔细看～ 1 –&gt; 查看造成冲突的文件，修改冲突部分 冲突文件 ATest.txt 内容如下（Git 虽然无法解决冲突， 但是使用简单的三个符号，标明了冲突的地方，以及冲突的两个分支在该地方发生冲突时的内容）： 1234567&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD# This is a test about merge conflict.=======# This ia a test about merge conflict.&gt;&gt;&gt;&gt;&gt;&gt;&gt; featureA~~ 符号说明如下： 符号 分隔符 ======= 分隔符 &lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD 至 ======= master 分支中该地方的内容 ======= 至 &gt;&gt;&gt;&gt;&gt;&gt;&gt; featureA featureA 分支中该地方为内容 接下来编辑 ATest.txt 文件，根据功能需要完成合并，确认之后，把 Git 冲突标识符号给删除掉即可。 2 &amp; 3 –&gt; 修改后冲突文件，add &amp;&amp; commit 12345678910111213141516171819202122$ git add ATest.txt(master +|MERGING) GitTestProject $ git statusOn branch masterYour branch is ahead of 'origin/master' by 9 commits. (use &quot;git push&quot; to publish your local commits)All conflicts fixed but you are still merging. (use &quot;git commit&quot; to conclude merge)Changes to be committed: modified: ATest.txt(master +|MERGING) GitTestProject $ git commit -m &quot;Dealing Merge Conflict&quot;[master fb50835] Dealing Merge Conflict(master) GitTestProject $ git statusOn branch masterYour branch is ahead of 'origin/master' by 11 commits. (use &quot;git push&quot; to publish your local commits)nothing to commit, working tree clean 关联本地分支&amp;&amp;远程分支学习了分支的概念后，你应该意识到：多人协作项目中，为了保证本地分支和远程库中分支保持数据同步，团队中的每一个 Partner 使用 git pull 或者 git push 拉取（或推送）最新分支内容时，需要明确指定从本地的哪个分支 拉取/推送 到远程的哪个分支，这是重要的！！！ Git Pull &amp;&amp; Git Push 参数详解补充说明在远程仓库中提到的：CMD 10 –&gt;&gt;&gt; git push &amp;&amp; git pull 1 –&gt; git push 123456789101.将本地当前分支 推送到 与本地当前分支同名的远程分支上（使用前提：本地分支&amp;&amp;远程分支实现关联）$ git push2.将本地当前分支 推送到 与本地当前分支同名的远程分支上$ git push origin &lt;local current branch name&gt;3.将本地当前分支 推送到 远程指定分支上$ git push origin &lt;local current branch name&gt;:&lt;remote brance name&gt;推荐使用第二种！！！ 2 –&gt; git pull 123456789101.将与本地当前分支同名的远程分支 拉取到 本地当前分支上（使用前提：本地分支&amp;&amp;远程分支实现关联）$ git pull2.将远程指定分支 拉取到 本地当前分支上$ git pull origin &lt;remote branch name&gt;3.将远程指定分支 拉取到 本地指定分支上$ git pull origin &lt;remote brance name&gt;:&lt;local current branch name&gt;推荐使用第二种！！！ 注意：pull or push 自身的动作，决定了后面跟随最近的仓库是远程的还是本地的。pull From –&gt; remote brance name；push To –&gt; local branch name。 实际中，上面推荐使用的第二种（可以直接使用）和第一种语法都常使用，然而第一种的使用前提是：需要先实现本地分支&amp;&amp;远程分支关联。 将本地仓库，以及远程仓库（“中央仓库”）关联起来，可以简化命令，但同样带来了混淆（两面性），你可以根据喜好选择性使用，适合自己的才是最好的。 那么如何将本地仓库，以及远程仓库（“中央仓库”）关联起来呢？？？ 推荐一个用来查看分支关联情况的命令： 1$ git branch -vv 关联方法将本地分支同远程分支进行关联，可以分为以下三种场景(以 dev 分支为例)： 场景一：本地库已创建分支 dev，而远程库没有 1234567# 添加参数：-u$ git push -u origin dev或者# 添加参数：--set-upstream$ git push --set-upstream origin dev 关联思路：推送时实现关联，之后就可以直接使用 git push 进行分支分容的推送了。 场景二：远程库已创建分支 dev，而本地库没有 1234567# 分为两步：## Step1：将远程分支 pull 到本地$ git pull origin dev# Step2：创建本地分支并且进行关联$ git checkout -b dev origin/dev 关联思路：先拉取远程分支到本地，然后本地创建切换分支且进行关联。之后就可以直接使用 git pull 进行远程分支内容拉取了。 场景三：本地库 &amp;&amp; 远程库均已创建分支 dev 事实上，git branch 命令支持直接将 本地当前分支 直接与 远程分支 相关联： 1234567# 添加参数：-u$ git branch -u origin/dev或者# 添加参数：--set-upstream-to$ git branch --set-upstream-to=origin/dev 当然，前提是本地和远程库中均有分支 dev。注意，这里只是以 dev 为例，并不是本地库和远程库必须同名！！！ 撤销关联下面的命令，可以 撤销 本地当前分支 与对应的远程分支 的关联关系： 1$ git branch --unset-upstream Demo这一小节我们来看分支关联的测试实例（以 GitTestProject 为例）： 场景一实例：远程库已创建分支 dev，本地无分支 1）查看需要关联的远程分支名： 1234$ git branch -a * master remotes/origin/dev remotes/origin/master 可以看到，远程也包含了 dev 分支：remotes/origin/dev，而本地是没有的。 2）根据关联方法中的介绍，这里有两种思路，来进行关联： 思路一： 12345678910111213# 本地新建一个和远程分支同名(dev)的分支 $ git checkout -b devSwitched to a new branch 'dev'# 将本地当前分支关联远程分支(dev) GitTestProject $ git branch --set-upstream-to=origin/devBranch 'dev' set up to track remote branch 'dev' from 'origin'.$ git branch -vv FeatureA c07648e Merge conflic test in FeatureA* dev fb50835 [origin/dev] Dealing Merge Conflict featureB 4528426 Add BTest File For featureB master fb50835 [origin/master: ahead 11] Dealing Merge Conflict 思路二： 注意，测试前需要将上面的关联取消掉，然后删除分支，再开始执行下面的命令： 12345678910111213141516# 将远程分支 pull 到本地$ git pull origin devFrom github.com:TheNightIsYoung/GitTestProject * branch dev -&gt; FETCH_HEADAlready up to date.# 创建本地分支并且进行关联(master) GitTestProject $ git checkout -b dev origin/devSwitched to a new branch 'dev'Branch 'dev' set up to track remote branch 'dev' from 'origin'.(dev) GitTestProject $ git branch -vv FeatureA c07648e Merge conflic test in FeatureA* dev fb50835 [origin/dev] Dealing Merge Conflict featureB 4528426 Add BTest File For featureB master fb50835 [origin/master: ahead 11] Dealing Merge Conflict 3）提交测试是否成功关联 123456789101112131415161718192021$ touch assi_demo.txtGitTestProject $ git add assi_demo.txt(dev +) GitTestProject $ git commit -m &quot;Branch assi Test&quot;[dev 3cb60e7] Branch assi Test 1 file changed, 0 insertions(+), 0 deletions(-) create mode 100644 assi_demo.txt(dev) GitTestProject $ git pullAlready up to date.(dev) GitTestProject $ git pushEnumerating objects: 3, done.Counting objects: 100% (3/3), done.Delta compression using up to 12 threadsCompressing objects: 100% (2/2), done.Writing objects: 100% (2/2), 251 bytes | 125.00 KiB/s, done.Total 2 (delta 1), reused 0 (delta 0), pack-reused 0remote: Resolving deltas: 100% (1/1), completed with 1 local object.To github.com:TheNightIsYoung/GitTestProject.git fb50835..3cb60e7 dev -&gt; dev 可以发现，已经成功关联分支，并可以提交代码到远程分支。 场景二实例：本地库已创建分支 dev，远程无分支 为了满足场景二需要，我们需要先删除场景一中的关联关系，并且删除远程的 dev 分支： 123456789$ git branch --unset-upstream$ git push origin --delete devTo github.com:TheNightIsYoung/GitTestProject.git - [deleted] dev$ git branch -a* dev master remotes/origin/master 1）查看当前仓库分支情况： 1234$ git branch -a* dev master remotes/origin/master 可以发现，远程库中只有 master 分支，而本地仓库中包含两个分支：dev &amp;&amp; master。 2）根据关联方法中的介绍，这里有两种思路，来进行关联： 思路一： 1234567891011121314151617181920212223242526272829# 将本地当前分支 推送到 远程库 $ git push origin devEnumerating objects: 30, done.Counting objects: 100% (30/30), done.Delta compression using up to 12 threadsCompressing objects: 100% (26/26), done.Writing objects: 100% (29/29), 2.70 KiB | 345.00 KiB/s, done.Total 29 (delta 16), reused 0 (delta 0), pack-reused 0remote: Resolving deltas: 100% (16/16), done.remote:remote: Create a pull request for 'dev' on GitHub by visiting:remote: https://github.com/TheNightIsYoung/GitTestProject/pull/new/devremote:To github.com:TheNightIsYoung/GitTestProject.git * [new branch] dev -&gt; dev# 查看分支关联情况，发现 dev 分支未关联 (dev) GitTestProject $ git branch -vv* dev 3cb60e7 Branch assi Test master fb50835 [origin/master: ahead 11] Dealing Merge Conflict# 将本地当前分支 与 远程分支进行 关联(dev) GitTestProject $ git branch -u origin/devBranch 'dev' set up to track remote branch 'dev' from 'origin'.# 重新查看分支关联情况，发现本地 dev 分支已和远程关联 (dev) GitTestProject $ git branch -vv* dev 3cb60e7 [origin/dev] Branch assi Test master fb50835 [origin/master: ahead 11] Dealing Merge Conflict 思路二： 注意，测试前需要将上面的关联取消掉，然后删除远程分支，再开始执行下面的命令： 123456789101112131415161718192021# 将本地当前分支 推送到 远程库，同时使用 -u 参数进行关联$ git push -u origin devEnumerating objects: 30, done.Counting objects: 100% (30/30), done.Delta compression using up to 12 threadsCompressing objects: 100% (26/26), done.Writing objects: 100% (29/29), 2.70 KiB | 212.00 KiB/s, done.Total 29 (delta 16), reused 0 (delta 0), pack-reused 0remote: Resolving deltas: 100% (16/16), done.remote:remote: Create a pull request for 'dev' on GitHub by visiting:remote: https://github.com/TheNightIsYoung/GitTestProject/pull/new/devremote:To github.com:TheNightIsYoung/GitTestProject.git * [new branch] dev -&gt; devBranch 'dev' set up to track remote branch 'dev' from 'origin'.# 重新查看分支关联情况，发现本地 dev 分支已和远程关联(dev) GitTestProject $ git branch -vv* dev 3cb60e7 [origin/dev] Branch assi Test master fb50835 [origin/master: ahead 11] Dealing Merge Conflict 如果你还不放心的话，还可以进行一次提交，然后使用 git push 进行推送，自己尝试一下吧~~~ Data Flow In Git前面我们提到过 Git 的三大分区，以及各区之间的数据传递流程图，这里我们已经可以给出 Git 的整体构架图： 工作区（Working Directory），简言之就是你工作的区域。对于 Git 而言，就是的本地工作目录。工作区的内容会包含提交到暂存区和版本库(当前提交点)的内容，同时也包含自己的修改内容。 暂存区（Stage Area, 又称为索引区 Index），是 Git 中一个非常重要的概念。在工作目录下有一个 .git 的目录，里面有个 index 文件，存储着关于暂存区的内容。git add 命令将工作区内容添加到暂存区。 本地仓库（Rocal Repository），版本控制系统的仓库，存在于本地。当执行 git commit 命令后，会将暂存区内容提交到仓库之中。在工作区下面有 .git 的目录，这个目录下的内容不属于工作区，里面便是仓库的数据信息，暂存区相关内容也在其中。这里也可以使用 merge 或 rebase 将远程仓库副本合并到本地仓库。图中的只有 merge，注意这里也可以使用 rebase。 远程版本库（Remote Repository），与本地仓库概念基本一致，不同之处在于一个存在远程，可用于远程协作，一个却是存在于本地。通过 push/pull 可实现本地与远程的交互。 远程仓库副本，可以理解为存在于本地的远程仓库缓存。如需更新，可通过 git fetch/pull 命令获取远程仓库内容。使用 fech 获取时，并未合并到本地仓库，此时可使用 git merge 实现远程仓库副本与本地仓库的合并。git pull 根据配置的不同，可为 git fetch + git merge 或 git fetch + git rebase。 这里引用知乎上，博主波罗学的说法。git pull 和 git fetch 的区别前参加 –&gt; 传送门 Get Branch From RemoteRepo日常的项目开发过程中，更常见的是从既存的远程仓库中拉取代码到本地，然后进行开发任务。前面提到过，会使用 git clone &lt;repo addr&gt; 命令，可以将项目整个克隆到我们的本地仓库。 然而，本地 Clone 仓库默认只会 clone 下 master 分支（clone 到指定目录）： 1234567891011121314# Clone 到指定目录语法：git clone &lt;repo addr&gt; &lt;myDirName&gt;$ git clone git@github.com:TheNightIsYoung/GitTestProject.git MyLocalRepoCloning into 'MyLocalRepo'...remote: Enumerating objects: 59, done.remote: Counting objects: 100% (59/59), done.remote: Compressing objects: 100% (25/25), done.remote: Total 59 (delta 22), reused 58 (delta 21), pack-reused 0Receiving objects: 100% (59/59), 5.00 KiB | 639.00 KiB/s, done.Resolving deltas: 100% (22/22), done.$ ls MyLocalRepo/ATest.txt Client/ git_rm_test.txt Server/BTest.txt dev_function.txt readme.txt$ cd MyLocalRepo/ 倘若远程仓库有多个分支，我们会发现，使用 git branch 查看本地分支时，只有一个 master 分支: 12$ git branch* master 此时，你可以使用 git branch -a 查看都有那些远程分支： 12345$ git branch -a* masterremotes/origin/HEAD -&gt; origin/masterremotes/origin/developremotes/origin/feature 但是，实际上大多数时候我们是需要在其他分支进行工作的，所以我们需要可以灵活的将远程的其它分支拉取下来。比如有时候你只想拉取远程仓库指定的某一个分支，有时候你想拉取远程的所有分支等等。 Pull a specified branch如何 Git 命令拉取远程仓库中指定的某一个分支呢？这里提供三种方法供大家参考： 1 –&gt; git clone -b 命令获取 命令格式： 1$ git clone -b &lt;remote branch name&gt; &lt;remote repo addr&gt; git clone -b &lt;分支名称&gt; &lt;仓库地址&gt; 命令可以将指定的某一个远程分支拉取到我们本地，而且拉取的本地分支自动和远程同名分支建立关联（追踪）关系，并且会将新创建的 HEAD 指向刚拉取下来的分支。 12345678$ git clone -b dev git@github.com:TheNightIsYoung/GitTestProject.git MyLocalRepoCloning into 'MyLocalRepo'...remote: Enumerating objects: 59, done.remote: Counting objects: 100% (59/59), done.remote: Compressing objects: 100% (25/25), done.remote: Total 59 (delta 22), reused 58 (delta 21), pack-reused 0Receiving objects: 100% (59/59), 5.00 KiB | 1023.00 KiB/s, done.Resolving deltas: 100% (22/22), done. 分支拉取结束以后，执行 git branch -a 命令，查看分支情况如下： 123456$ cd MyLocalRepo/(dev) MyLocalRepo $ git branch -a* dev remotes/origin/HEAD -&gt; origin/master remotes/origin/dev remotes/origin/master 当然，这里你也可以根据【关联本地分支&amp;&amp;远程分支】中介绍的方法，同时拉取其它分支进行工作（以 master 为例）： 12345678910111213141516171819$ git pull origin masterFrom github.com:TheNightIsYoung/GitTestProject * branch master -&gt; FETCH_HEADAlready up to date.Jie Guo (dev) MyLocalRepo $ git branch -a* dev remotes/origin/HEAD -&gt; origin/master remotes/origin/dev remotes/origin/master(dev) MyLocalRepo $ git checkout -b master origin/masterSwitched to a new branch 'master'Branch 'master' set up to track remote branch 'master' from 'origin'.(master) MyLocalRepo $ git branch -a dev* master remotes/origin/HEAD -&gt; origin/master remotes/origin/dev remotes/origin/master 2 –&gt; git fetch 命令获取 关于 git fetch 命令说明： 1234567# 1.将某个远程主机的所有更新，全部取回本地副本中，但不会将任何新内容合并到我们最近的工作文件中。$ git fetch &lt;远程主机名&gt;# 或者简写为：$ git fetch# 2.如果只想取回特定分支的更新$ git fetch &lt;远程主机名&gt; &lt;分支名&gt; 开始拉取指定分支 &gt;&gt;&gt;&gt; 12345678910111213141516171819# 1.拉取整个远程代码库$ git clone git@github.com:TheNightIsYoung/GitTestProject.git MyLocalRepoCloning into 'MyLocalRepo'...remote: Enumerating objects: 59, done.remote: Counting objects: 100% (59/59), done.remote: Compressing objects: 100% (25/25), done.remote: Total 59 (delta 22), reused 58 (delta 21), pack-reused 0Receiving objects: 100% (59/59), 5.00 KiB | 1023.00 KiB/s, done.Resolving deltas: 100% (22/22), done.gitWorkS $ cd MyLocalRepo/# 将远程仓库的所有分支拷贝到本地，建立远程库副本(master) MyLocalRepo $ git fetch# 切换到想要拉取的指定某一个分支的本地分支(master) MyLocalRepo $ git checkout devSwitched to a new branch 'dev'Branch 'dev' set up to track remote branch 'dev' from 'origin'. 切换分支后，你就可以看到本地仓库的 dev 开发分支和远程仓库的 dev 开发分支同步了。 这里不好理解的话，你可以在 git fetch 之后，使用 git checkout -b dev origin/dev + git merge origin/dev 实现同样的效果。 3 –&gt; git checkout 命令获取 这一方法你可以先自己思考下，提示需要借助 git pull 命令~~~ 先不要看下面的答案！ 先不要看下面的答案！！ 先不要看下面的答案！！！ 参考下面的详细步骤，是否和你思考的一样？： 123456789101112131415161718192021222324$ git clone git@github.com:TheNightIsYoung/GitTestProject.git MyLocalRepoCloning into 'MyLocalRepo'...remote: Enumerating objects: 59, done.remote: Counting objects: 100% (59/59), done.remote: Compressing objects: 100% (25/25), done.remote: Total 59 (delta 22), reused 58 (delta 21), pack-reused 0Receiving objects: 100% (59/59), 5.00 KiB | 1023.00 KiB/s, done.Resolving deltas: 100% (22/22), done.gitWorkS $ cd MyLocalRepo/(master) MyLocalRepo $ git branch -a* master remotes/origin/HEAD -&gt; origin/master remotes/origin/dev remotes/origin/master(master) MyLocalRepo $ git checkout -b dev origin/devSwitched to a new branch 'dev'Branch 'dev' set up to track remote branch 'dev' from 'origin'.(dev) MyLocalRepo $ git pull origin devFrom github.com:TheNightIsYoung/GitTestProject * branch dev -&gt; FETCH_HEADAlready up to date. 至此，你就可以灵活的实现 从远程仓库拉取指定某一分支，或者拉取指定的某些分支了~~~ Sync remote branch那么，如何一次性同步远程仓库中的所有分支到本地仓库中呢？ 1 –&gt; 跟踪（关联）所有远程分支 12345678910 $ git branch -r | grep -v '\\-&gt;' | while read remote; do git branch --track &quot;${remote#origin/}&quot; &quot;$remote&quot;; doneBranch 'dev' set up to track remote branch 'dev' from 'origin'.fatal: A branch named 'master' already exists.$ git branch -a dev* master remotes/origin/HEAD -&gt; origin/master remotes/origin/dev remotes/origin/master 2 –&gt; 将本地所有分支与远程保持同步 12$ git fetch --allFetching origin 3 –&gt; 拉取所有分支代码 123$ git pull --allFetching originAlready up to date.","link":"/2017/07/04/git-shi-yong-zhi-nan-zhi-fen-zhi-guan-li/"},{"title":"Git 使用指南之初识","text":"在日常项目开发中，我们肯定会或多或少地听说或者使用过 版本管理工具。之前我刚好有幸参与过公司项目版本管理—–SVN 版本控制系统的搭建与管理，再加上项目组日常项目开发使用 SVN，也就没有花费太多精力去学习其它版本管理工具。 初次接触 Git 还是因为常常会从 GitHub clone 一些大佬们开源的深度学习项目以供学习和借鉴，但对 Git 的使用仅限于：git clone XYZ（脸红）。而随着身边越来越多的人开始使用 Git，以及学习和工作需要，才发现：这年头不会点 Git 是真不行啊… 版权说明： 本文思路以及内容主要来自廖雪峰老师的 Git 教程 （强烈推荐膜拜原文），并结合个人使用所作，只作为学习记录使用。如内容有侵权请联系删除，禁止转载！ 更多 Git 相关内容，请关注博主 Git 博文系列： 之一 &gt;&gt;&gt; Git 使用指南之初识 之二 &gt;&gt;&gt; Git 使用指南之时光穿梭机 之三 &gt;&gt;&gt; Git 使用指南之远程仓库 之四 &gt;&gt;&gt; Git 使用指南之分支管理 之五 &gt;&gt;&gt; Git 使用指南之 WorkFlow (工作流) 之六 &gt;&gt;&gt; Git 使用指南之 Git 自定义 之七 &gt;&gt;&gt; Git 使用指南之 HEAD 指针 之八 &gt;&gt;&gt; Git 使用指南之 Git 中的黑魔法 Git 简介和 SVN 类似，Git 也是用于版本控制。Git 是时下最流行的分布式版本控制系统，没有之一。 何为版本控制？我们一直在说版本控制，那么究竟什么是版本控制？ 其实说到版本控制，我总会想到大学毕业写论文时的场景，你电脑上的毕业论文一定也出现过和我一样的场景： 以上就是使用最原始的方式进行版本控制，可以发现 存在着显著缺点： 当保留所有版本文件时，需要为每个版本保存一个文件… 当文档需要多人协同操作时，需要将文件打包发来发去，拿到后还需要修改整合… 容易丢失，被删除意味着永远失去… 为了解决以上版本控制存在问题，应运而生了一批版本控制系统或工具：VSS、CVS、SVN、Git 等，其中 Git 已经成为当前最流行的分布式版本控制系统。通过使用这些版本控制工具，你就结束了手动管理多个 “版本” 的史前时代，进入到版本控制的新世纪。 通过以上样例的解读，下面我们给出关于版本控制更加严格的解读： 版本控制是指对软件开发过程中各种程序代码、配置文件、以及说明文档等文件变更的管理。 通俗来说 &gt;&gt;&gt; 版本控制最主要的功能就是追踪文件的变更。它将什么时候、什么人更改了文件的什么内容等信息忠实地了记录下来。每一次文件的改变，文件的版本号都将增加。这些功能均由版本控制系统帮忙维护。 除了记录版本变更外，版本控制的另一个重要功能是并行开发。软件开发往往是多人协同作业，版本控制可以有效地解决版本的同步以及不同开发者之间的开发通信问题，提高协同开发的效率。 Example &gt;&gt;&gt; 例如使用 Git 版本控制工具我们可以清晰、便捷的管理文档的不同版本，如下图所示： Git 的诞生我们知道，Linux 是开源的代名词，Linux 的系统日益壮大是靠全世界热心的志愿者共同参与的，这么多人在世界各地为 Linux 编写代码，那 Linus（Linux 项目发起者） 的代码是如何管理整合的呢？ 事实是，起初世界各地的志愿者把源代码文件发给 Linus，然后由 Linus 本人通过手工方式合并代码！ 你也许会想，为什么 Linus 不把 Linux 代码放到现有的版本控制系统里呢？不是有 CVS、SVN 这些免费的版本控制系统吗？因为 Linus 坚定地反对 CVS 和 SVN，这些集中式的版本控制系统不但速度慢，而且必须联网才能使用。有一些商用的版本控制系统，虽然比 CVS、SVN 好用，但那是付费的，这和 Linux 的开源精神不符。 不过，随着 Linux 系统的不断发展，代码库之大让 Linus 很难继续通过手工方式管理了，社区的弟兄们也对这种方式表达了强烈不满，于是 Linus 选择了一个商业的版本控制系统 BitKeeper，BitKeeper 的东家 BitMover 公司出于人道主义精神，授权 Linux 社区免费使用这个版本控制系统。 没几年，这种安定团结的大好局面就被打破了。原因是 Linux 社区牛人聚集，不免沾染了一些梁山好汉的江湖习气。开发 Samba 的 Andrew 试图破解 BitKeeper 的协议（这么干的其实也不只他一个），被 BitMover 公司发现了（监控工作做得不错！），于是 BitMover 公司怒了，要收回 Linux 社区的免费使用权。 Linus 可以向 BitMover 公司道个歉，保证以后严格管教弟兄们…… 嗯，这是不可能的。实际情况是这样的：Linus 花了两周时间自己用 C 写了一个分布式版本控制系统，这就是 Git！一个月之内，Linux 系统的源码已经由 Git 管理了！牛是怎么定义的呢？大家可以体会一下。 Git 迅速成为最流行的分布式版本控制系统 。尤其是 GitHub 的上线，它为开源项目免费提供 Git 存储，无数开源项目开始迁移至 GitHub。 GitHub 是一个基于 Git 的远程文件托管平台。Git 本身完全可以做到版本控制，但其所有内容以及版本记录只能保存在本机。如果想要将文件内容以及版本记录同时保存在免费远程服务器，则需要结合 GitHub 来使用。 集中式 VS 分布式Linus 一直痛恨的 CVS、SVN 都是集中式的版本控制系统，而 Git 是分布式版本控制系统，集中式和分布式版本控制系统有什么区别呢？ 集中式版本控制系统先说集中式版本控制系统，都有一个单一的集中管理的中央服务器，保存所有的项目版本库。而协同工作的人们首先都需要通过客户端连到这台中央服务器取出最新的文档版本进行修改，修改完成后需要提交更新给中央服务器完成服务器上的修改。 多年以来，这已成为版本控制系统的标准做法。 集中式版本控制系统缺点在于：中央服务器的单点故障。 如果中央服务器宕机一小时，那么在这一小时内，谁都无法提交更新，也就无法协同工作。 如果中心数据库所在的磁盘发生损坏，又没有做恰当备份，毫无疑问你将丢失所有数据————包括项目的整个变更历史，只剩下人们在各自机器上保留的单独快照。 只要整个项目的历史记录被保存在单一位置，就有丢失所有历史更新记录的风险。 分布式版本控制系统那分布式版本控制系统与集中式版本控制系统有何不同呢？ 首先，分布式版本控制系统根本没有“中央服务器”，每个人的电脑上都是一个完整的版本库。这也导致和集中式版本控制系统相比，分布式版本控制系统的安全性要高很多，因为每个人电脑里都有完整的版本库，某一个人的电脑坏掉了不要紧，随便从其他人那里复制一个就可以了。 既然每个人电脑上都有一个完整的版本库，那多个人如何协作呢？当然可以相互之间进行推送，但在实际使用分布式版本控制系统时通常也有一台充当“中央服务器”的角色（服务器），但这个服务器的作用仅仅是用来方便 “交换” 大家的修改，没有它大家也一样干活，只是交换修改不方便而已。 当然，Git 的优势不单是分布式这么简单，后面我们还会看到 Git 极其强大的分支管理，把 SVN 等远远抛在了后面。 Git Setup最早 Git 是在 Linux 上开发的，很长一段时间内，Git 也只能在 Linux 和 Unix 系统上跑。 目前，Git 已经为 Linux、Unix、Mac 和 Windows 等多平台提供了支持。这一部分我们来看如何在不同平台下完成 Git 的安装： Setup For LinuxLinux 平台下，Centos &amp;&amp; Ubuntu OS 中 Git 的安装过程。 Centos Ubuntu Others Linux OS Centos Setup MethodsCentos 中提供了两种 Git 的安装方法： YUM Method Source Code Method（Recommended） YUM Method For Centos Git Setup Cnetos 中采用 yum 的方法进行 Git 安装的详细过程如下： 推荐使用源码方式进行 Centos 下 Git 的安装，这是由于 Git 的安装版本完全取决于 yum 源中支持的 Git 版本（一般要比最新发布 Git 版本低），你可以选择直接跳至下一部分。 1 -&gt; 检测系统是否安装有 Git 123$ gitThe program 'git' is currently not installed. You can install it by typing:sudo yum install git 如果系统已安装 Git，你可以使用 git --version 查看相应的安装版本，确定是否需要重新安装 Git（一般 Centos 系统 Git 版本较低，以 Centos7 为例为：git version 1.8.3.1）。这里我们给出 GitHub 上的 Git 版本发布界面，你可以查看最新的 Git 版本。 如果未安装有合适版本 Git，则继续执行下面步骤： 2 -&gt; Git 安装 登陆待安装服务器，输入如下命令进行下载安装： 1234567891011121314151617181920212223242526272829303132333435363738$ yum install git##### 日志信息如下：已加载插件：fastestmirror, langpacksgitlab_gitlab-ee/x86_64/signature | 836 B 00:00:00 gitlab_gitlab-ee/x86_64/signature | 1.0 kB 00:00:00 !!! gitlab_gitlab-ee-source/signature | 836 B 00:00:00 gitlab_gitlab-ee-source/signature | 951 B 00:00:00 !!! Loading mirror speeds from cached hostfile * base: centos.ustc.edu.cn * extras: centos.ustc.edu.cn * updates: centos-mirror.rbc.ru正在解决依赖关系--&gt; 正在检查事务---&gt; 软件包 git.x86_64.0.1.8.3.1-14.el7_5 将被 升级--&gt; 正在处理依赖关系 git = 1.8.3.1-14.el7_5，它被软件包 perl-Git-1.8.3.1-14.el7_5.noarch 需要---&gt; 软件包 git.x86_64.0.1.8.3.1-20.el7 将被 更新--&gt; 正在检查事务---&gt; 软件包 perl-Git.noarch.0.1.8.3.1-14.el7_5 将被 升级---&gt; 软件包 perl-Git.noarch.0.1.8.3.1-20.el7 将被 更新--&gt; 解决依赖关系完成依赖关系解决========================================================================================================================================================================================================== Package 架构 版本 源 大小==========================================================================================================================================================================================================正在更新: git x86_64 1.8.3.1-20.el7 updates 4.4 M为依赖而更新: perl-Git noarch 1.8.3.1-20.el7 updates 55 k事务概要==========================================================================================================================================================================================================升级 1 软件包 (+1 依赖软件包)总下载量：4.4 M 接着服务器会询问是否进行安装，输入 y，然后等待安装完成即可（接上）： 1234567891011121314151617181920212223242526272829303132## 日志信息如下：总下载量：4.4 MIs this ok [y/d/N]: yDownloading packages:updates/7/x86_64/prestodelta | 182 kB 00:00:04 Delta RPMs reduced 4.4 M of updates to 2.6 M (41% saved)(1/2): perl-Git-1.8.3.1-14.el7_5_1.8.3.1-20.el7.noarch.drpm | 28 kB 00:00:02 (2/2): git-1.8.3.1-14.el7_5_1.8.3.1-20.el7.x86_64.drpm | 2.6 MB 00:00:18 Finishing delta rebuilds of 1 package(s) (4.4 M)----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------总计 126 kB/s | 2.6 MB 00:00:21 Running transaction checkRunning transaction testTransaction test succeededRunning transaction 正在更新 : git-1.8.3.1-20.el7.x86_64 1/4 正在更新 : perl-Git-1.8.3.1-20.el7.noarch 2/4 清理 : git-1.8.3.1-14.el7_5.x86_64 3/4 清理 : perl-Git-1.8.3.1-14.el7_5.noarch 4/4 验证中 : perl-Git-1.8.3.1-20.el7.noarch 1/4 验证中 : git-1.8.3.1-20.el7.x86_64 2/4 验证中 : git-1.8.3.1-14.el7_5.x86_64 3/4 验证中 : perl-Git-1.8.3.1-14.el7_5.noarch 4/4 更新完毕: git.x86_64 0:1.8.3.1-20.el7 作为依赖被升级: perl-Git.noarch 0:1.8.3.1-20.el7 完毕！ 3 -&gt; 验证安装是否成功 输入命令： git --version，查看安装好的 Git 版本，验证是否安装成功： 12[root@node3 ~]# git --versiongit version 1.8.3.1 接下来来看，Centos 中采用 源码包 的方法进行 Git 安装的详细过程： Source Code Method For Centos Git Setup（Recommended） 我们会发现，使用 yum 安装之后 Git 版本和当前最新版本之间仍然差很多版本号（Git 版本号不太好控制，取决于系统中 yum 源中最新 Git 版本），那么如何解决这个问题？ 除了使用 yum 安装，还可以使用 Git 源码进行编译安装，我们可以根据需要下载相应版本的 Git 源码包进行安装（源码下载请前往：Git 版本发布界面）。下面我将给出 Centos7 下如何通过源码安装 Git v2.20.0： 安装前我们首先需要移除系统原有 Git： 1[root@node3 Download]# yum remove git 1 -&gt; 在目录 Download 中下载相应 Git 版本源码包： 1[root@node3 Download]# wget https://github.com/git/git/archive/v2.20.0.tar.gz 2 -&gt; 解压 v2.20.0.tar.gz 安装包： 12345[root@node3 Download]# tar -zxvf v2.20.0.tar.gz# 查看当前目录，可看到解压文件：[root@node3 Download]# lsgit-2.20.0 v2.20.0.tar.gz 3 -&gt; 准备编译环境，否则后续安装可能发生 Error： 123[root@node3 Download]# yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel gcc perl-ExtUtils-MakeMaker# 等待安装或更新完成即可... 4 -&gt; 进入解压文件目录 git-2.20.0，然后进行 Git 源码的配置、编译以及安装命令，耐心等待即可： 12345678910111213141516171819[root@node3 Download]# cd git-2.20.0# 配置 Git 的安装路径：[root@node3 Download]# ./configure prefix=/usr/local/git/|--------------------------------------------------------------|### 注意此处可能报错：'-bash: ./configure: 没有那个文件或目录'。# 按照如下步骤解决：# 生成 configure：$ make configure $ ./configure prefix=/usr/local/git/# 如果 make configure 的时候报错：/bin/sh: autoconf: command not found$ yum install install autoconf automake libtool|--------------------------------------------------------------|# 编译以及安装 Git 源码：[root@node3 Download]# make &amp;&amp; make install 5 -&gt; 配置环境变量： 1234567# 打开系统配置文件：/etc/profile[root@node3 Download]# vim /etc/profile# 添加如下环境变量：export PATH=$PATH:/usr/local/git/bin# 激活环境变量：$ source /etc/profile 6 -&gt; 验证安装是否成功: 12[root@node3 Download]# git --versiongit version 2.20.0 Ubuntu Setup Methods较新版本的 Debian 或 Ubuntu Linux 系统一般都自带较高版本的 Git。如果没有，直接可通过下列命令就可以完成 Git 的安装: 1$ sudo apt-get install git 老一点的 Debian 或 Ubuntu Linux，要把命令改为: 1$ sudo apt-get install git-core 这是由于：有个软件也叫 GIT（GNU Interactive Tools），结果 Git 就只能叫 git-core 了。由于 Git 名气实在太大，后来就把 GNU Interactive Tools 改成 gnuit，git-core 正式改为 git。 Other Linux OS Setup Methods其它版本 Linux 可以统一采用源码安装，具体安装方法不一一列出，使用时请自行百度。 Setup For Windows这一部分我们来看 Win 平台下如何安装和配置 Git（未提到安装页面选择默认即可）： Setup Tips1 -&gt; 从 Git 官网下载一个 Git For Windows 安装包（官网下载地址，这里我们再提供一个 国内下载站点）： 2 -&gt; 双击安装程序，进入欢迎界面阅读协议，然后点击 【 Next 】： 3 -&gt; 选择 Git 安装位置，点击 【 Next 】： 4 -&gt; 选择安装组件：推荐使用默认选项，然后点击 【 Next 】： 图标组件（Additional icons）：选择是否创建快速启动图标和桌面快捷方式 桌面浏览（Windows Explorer integration）使用 Git Bash 方式、Shell 方式 是否关联 Git 配置文件：该配置文件主要显示文本编辑器样式 是否关联 Shell 脚本文件：是否关联 Bash 命令执行脚本文件 使用 TrueType 编码：在命令行中是否使用 TrueType 编码，该编码是微软和苹果公司制定的通用编码 5 -&gt; 在开始菜单创建快捷方式，然后点击 【 Next 】： 6 -&gt; 选择默认的 Git 编辑器（默认 VIM），然后点击 【 Next 】： 7 -&gt; 设置环境，设置命令行工具（默认配置即可），然后点击 【 Next 】： Git自带：使用 Git 自带的 Git Bash 命令行工具； 系统自带以及第三方软件：使用 windows 系统以及第三方软件命令行工具； Git 自带和 Unix Tools：注意，这样会将 windows 中的 find.exe 和 sort.exe 工具覆盖，如果不懂这些尽量不要选择。 8 -&gt; 选择换行格式，然后点击 【 Next 】： 检查出 Windows 格式转换为 Unix 格式：将 Windows 格式的换行转为 Unix 格式的换行再进行提交; 检查出原来格式转换为 Unix 格式：不管什么格式的，一律转换为 Unix 格式的换行再进行提交； 不进行格式转换：不进行转换，检查出什么格式就提交什么格式。 9 -&gt; 配置 Git bash 终端仿真器（默认即可），然后点击 【 Next 】： 使用 MinTTY 终端 使用 Windows 默认的命令行 10 -&gt; 性能配置，是否启用文件系统缓存（默认即可），然后点击 【 install 】 等待安装完成即可： Git EnvsVar Config有时安装完成以后可能在 Windows CMD 中无法正常使用 Git，可以将 GIT_HOME/bin 添加到系统环境变量 path 中，就可以在 CMD 中正常使用 Git了。 Git Bash Here上面我们已经完成了 Git 的安装以及配置过程，这里我们可以尝试在 Windows 下打开 Git Bash 来看一下： 是不是不同于我们熟悉的 Linux shell 或者 Windows CMD？！！下面给出一种 Git 控制台美化方法： Git 控制台格式以及字体美化 &gt;&gt; 详细优化过程如下： 1 -&gt; 下载必要的配置文件： 12345678910### Git 控制台中 clone 美化配置仓库：$ git clone https://github.com/TheNightIsYoung/Git-Setting.git# 查看项目可以发现有 2 个文件目录：$ ls Git-SettingGit-Bash YaHei-Consolas-Hybrid-1.12# 仓库说明：## 1. Git-Bash ： Linux Shell 样式配置库以及说明## 2. YaHei-Consolas-Hybrid-1.12 ： 字体配置库以及说明 2 -&gt; 配置 Linux Shell 样式以及 YaHei 字体 Linux Shell 样式配置方法如下（操作文件见 Git-Bash 目录）： 1234# 将 git-completion.bash 配置文件 copy 当前用户主目录；# 将 git-prompt.sh 配置文件 copy 当前用户主目录；# 将 bash_profile_course 配置文件 copy 当前用户主目录，如果当前用户主目录中已存在名为 .bash_profile 的文件，则将 bash_profile_course 中的内容复制并粘贴到 .bash_profile 的尾部。如果不存在，通过 mv 命令将 bash_profile_course 重命名为 .bash_profile。 自此，关闭 Git Bash 再重新打开，你会发现其格式已经变为我们熟悉的 Linux Shell 样式： 有一个 Yahei 和 Consolas 的混合字体，相当漂亮，很适合在 Windows 平台下编程使用，我们之前已经从 GitHub 上 clone 了下来。 关于 Yahei 字体的配置使用方法，可见 YaHei-Consolas-Hybrid-1.12 目录中 README.md 说明文件。 后面的同学别睡了，正文开始 …… Git 的安装、配置、优化完成之后，下面正式开始进行 Git 的学习以及使用： 初识 Git Repository前面我们一直在提 Git 分布式系统中的每一个节点（用户设备）都是一个完整的版本库。那什么是版本库呢？！！版本库又名版本仓库（Repository）。 Repository 可以简单理解成一个目录，这个目录里面的所有文件都可以被 Git 管理起来。什么时候、什么人更改了目录下文件的什么内容等信息都能被 Git 忠实地跟踪以及记录下来。以便 Git 任何时刻都可以追踪历史，或者在将来某个时刻可以“还原”。 使用前，你需要明确（重要！重要！重要！）： 所有的版本控制系统，其实 只能跟踪文本文件的改动，比如TXT文件，网页，所有的程序代码等等，Git 也不例外。 版本控制系统可以告诉你文本文件每次的变更，比如在第 5 行加了一个单词 “Linux”，在第 8 行删了一个单词 “Windows”。 而图片、视频这些二进制文件，虽然也能由版本控制系统管理，但没法跟踪文件的变化，只能把二进制文件每次改动串起来，也就是只知道图片从 100KB 改成了 120KB，但到底改了啥，版本控制系统不知道，也没法知道。最初我使用过一个毕设论文示例其实是不恰当的，Microsoft Word 格式是二进制格式，因此 Git 是没法直接跟踪 Word 文件的改动的。 注意，上面我说的是 没法直接，并不是不能！需要使用第三方转化软件的协助 ，才可以进行版本控制。 还有一个很重要的问题就是 文本的编码问题。强烈建议使用标准的 UTF-8 编码，所有语言使用同一种编码，既没有冲突，又被所有平台所支持。 Config User &amp;&amp; E-Mail版本仓库用户以及邮箱设置 –&gt;&gt;&gt; 我们知道，Git 是分布式版本控制系统，所以每个机器都必须自报家门：你的名字和 Email 地址。也就是说在使用之前我们还需要为 Git 中的版本仓库设置用户以及邮箱。 通常我们会面临一种场景：公司工作时，我们一般会参与多个项目开发，而向不同的项目提交变更时，一般请求情况下提供的用户都是同一个，而我们为了方便可能会使用 全局设置 对 Git 进行统一的配置；但当我们处于学习变更自己的学习项目时，我们可能更多地不希望使用公司公用的用户以及邮箱配置，这就涉及到为特定的仓库（项目）进行 单独设置。 模拟场景： 公司参与多个项目：A、B、C、D，用于提交的公司用户名是：”staff_ming”，会使用 Git 全局配置； 个人学习项目：E，用于提交的个人学习用户名是：”Pilot_ming”,会为项目 E 进行单独配置。 全局配置步骤 1）Git Bash 控制台执行： 12345$ git config --global user.name &quot;staff_ming&quot;$ git config --global user.email &quot;staff_ming@xxxx.com&quot;# 使用 git config --list 可查看到 Git 全局配置 2）可在当前用户目录下生成一个 .gitconfig 配置文件，可以查看文件内容中的配置信息： 123[user] name = staff_ming email = staff_ming@163.com 注意 git config 命令的 --global 参数表示：当前机器上所有的 Git 版本仓库都会使用这个配置。 单独配置项目步骤 1）Git Bash 中进入项目所在目录（后续学习后你会知道 Git 管理下的项目目录会产生一个 .git 目录），执行： 12345$ git config user.name &quot;Pilot_ming&quot;$ git config user.email &quot;Pilot_ming@163.com&quot;# 使用 git config --list 可同时查看到 Git 全局以及当前项目配置 2）可在当前项目目录下的 .git 目录中生成一个 config 配置文件，可以查看当前仓库的配置信息。 用户名和邮箱配置之后，简单进行以下 Git 的实操。系列博文实操部分测试均在 Windows10 下完成，Linux 平台下同理。 Manage A New Project假设要新建一个 GitTest 的项目，要使用 Git 进行管理，你有两方面的工作要做： 创建 GitTest 版本库 –&gt;&gt;&gt; GitTestProject； 添加文件到版本库进行版本管理 1 –&gt; How To Create Git Repo 事实上，创建一个全新的 Git 版本库（由 Git 进行版本管理的项目目录）非常简单: 1）创建版本库目录（项目目录）： 123# Windows 系统下，为了避免遇到各种莫名其妙的问题，请确保目录名（包括父目录）不包含中文。$ mkdir GitTestProject$ cd GitTestProject 2）初始化版本库： 12345678910# git init 命令可以将当前目录变成 Git 可以管理的版本库：$ git initInitialized empty Git repository in F:/GitTestProject/.git/# 查看版本库（产生一个 .git 目录）：$ ll -altotal 8drwxr-xr-x 1 staff_ming 197121 0 12月 20 18:55 ./drwxr-xr-x 1 staff_ming 197121 0 12月 20 18:46 ../drwxr-xr-x 1 staff_ming 197121 0 12月 20 18:55 .git/ 注意：初始化后，会在当前目录自动创建 .git 目录（意味着 Git 来跟踪管理版本库的），该文件是 Git 中最重要的文件夹，因为 Git 相关文件以及版本都将保存 .git 中，.git 受损 Git 版本仓库就会被破坏掉。 如何添加文件到版本库中进行版本管理？ –&gt;&gt;&gt; 2 –&gt; How To Add A File To Repo For Vers Management 来看一下，一个简单的文本文件如何能够被 Git 版本库管理： 1234567891011121314151617# 1. 在版本库 GitTestProject 中创建一个用于 Git 管理的新文档：readme.txt，内容如下Git is a version control system.Git is free software.# 2. 创建好 readme.txt 之后并不意味着文档已被版本库所管理，需要告知 Git 把文件添加到仓库：$ git add readme.txt# 执行上面的命令，没有任何显示。Unix 的哲学是“没有消息就是好消息”，说明添加成功。# 3. git add 之后，我们还需要提交操作到仓库（后续我们会做解释）：$ git commit -m &quot;wrote a readme file&quot;# 日志信息如下表示成功：# 1 file changed：1 个文件被改动；2 insertions：插入了两行内容[master (root-commit) c31b827] wrote a readme file 1 file changed, 2 insertions(+) create mode 100644 readme.txt 注意：git commit 命令之后的 -m 参数表示的是：本次向 Git 版本库提交的说明（变更注释）。强烈建议添加变更说明！！！不加 -m 参数 Git 会跳转进入 VIM。 初次使用 git add 命令可能会产生： Warning： LF will be replaced by CRLF in ** 的警告信息，更多请参看：Warning：LF &amp;&amp; CRLF 部分。 事实上，我们更多的时候是需要在非空目录（既有项目）下使用 Git 管理，这也是可以的。 Manage A Existing Project|============================================================== 既存项目目录结构说明： GitTestProject 版本库包含：Server 目录、Client 目录、以及 readme.txt 说明文档。 Server 目录下包含一个名为：service.py 的文件，内容为： 1# This is a Test! Client 目录“看作”是一个空目录（仅包含一个名为 .gitignore 的占位文件，见后文说明）。 readme.txt 文件内容为： 12Git is a version control system.Git is free software. ==============================================================| 假设要使用 Git 管理一个既存的、名为 GitTestProject 的项目，你有两方面的工作要做： 初始化 GitTestProject 为版本库； 添加项目目录中的文件到版本库开启版本管理 1 –&gt; 初始化项目目录（GitTestProject）为版本库 12345678910111213141516# 进入项目目录$ cd GitTestProject# git init 命令可以将当前目录变成 Git 可以管理的版本库：$ git initInitialized empty Git repository in F:/GitTestProject/.git/# 查看版本库（产生一个 .git 目录）：$ ll -altotal 5drwxr-xr-x 1 Jie Guo 197121 0 8月 18 21:59 ./drwxr-xr-x 1 Jie Guo 197121 0 8月 18 16:36 ../drwxr-xr-x 1 Jie Guo 197121 0 8月 18 21:59 .git/drwxr-xr-x 1 Jie Guo 197121 0 8月 18 21:57 Client/-rw-r--r-- 1 Jie Guo 197121 55 8月 18 21:58 readme.txtdrwxr-xr-x 1 Jie Guo 197121 0 8月 18 21:58 Server/ 2 –&gt; 添加项目目录中的文件到版本库开启版本管理 非空目录下创建 Git 版本库，git init 之后版本库目录下的文件其实并没有被 Git 管理，想要将其填加到版本库的话可以： 12345678# git add + dir(目录)会将 dir 以及其下所有文件添加到 Git 版本库：$ git add Server/ Client/# 提交：$ git commit -m 'ADD Project Base'[master d9e0247] ADD Project Base 1 file changed, 1 insertion(+) create mode 100644 Server/service.py 补充：git add . 可以将当前目录下所有文件添加到版本库。 注意，项目中的空文件夹（空目录）不会被管理！！！解决方法：可以在相应目录添加 .gitkeep 或者 .gitignore 占位文件（不起其它作用）。 ================================== 恭喜你，通过 Git 的安装、配置以及简单测试说明，相信你已经对 Git 版本控制有了一定的理解了，后续博文将带你更进一步掌握 Git 版本控制的使用~ Warning：LF &amp;&amp; CRLF初次安装好 Git 之后，使用 git add 命令时，可能会产生警告 Warning： LF will be replaced by CRLF in **&lt;file&gt; 这是由于文本中存在换行符引发的，LF &amp;&amp; CRLF 事实上都是换行符（一行文本的结束）。 1 –&gt; LF（Line Feed）&amp;&amp; CRLF（Carriage Return） LF 代表：“换行”，是 Linux 和 Unix 系统的换行符。CRLF 代表：“回车”，是 Windows 系统的换行符。 2 –&gt; Git 换行符自动转换功能 不同操作系统下换行符规则的差异，给跨平台的协作的项目带来了问题，文件中到底是使用哪个规则呢？Git 中为了解决这个问题，提供了一个 ”换行符自动转换” 的功能，并且这个功能是默认处于”自动模式“即开启状态的。 换行符自动转换功能 会自动将文本（代码）里当前操作系统不相同的换行的方式，转换成当前系统的换行方式（即 LF 和 CRLF 之间的转换）。这样，当提交代码的时候，即使没有修改过某个文件，也被 Git 认为你修改过了，从而提示 LF will be replaced by CRLF in **。 3 –&gt; 解决办法 使用如下命令可以将 Git 的换行符自动转换功能关闭掉（不推荐）： 实际编程中，Warning 级别的警告是可以忽略的，当然你可以选择将自动转换功能关掉（强迫症~），但这里 不推荐关闭！！！ 12345# 仅对当前版本库生效git config core.autocrlf false# 全局有效git config --global core.autocrlf false 选择策略 &gt;&gt;&gt; 如果可以保证你的项目（代码，文档）不会跨平台，你可以设置关掉自动转换的功能。 否则，如果你和你的合作者用不同的系统进行工作时，关掉这个自动转换的功能可能会导致文档显示异常，此时不建议关闭。","link":"/2017/07/01/git-shi-yong-zhi-nan-zhi-chu-shi/"},{"title":"Git 使用指南之时光穿梭机","text":"上一篇博文你已经了解了 Git 版本控制系统的基本概念，不同平台下 Git 的安装以及相关配置，以及 Git 版本库初识。并且在上一篇博文中我们已经成功地演示了如何使用 Git 管理一个既存项目（GitTestProject），下面我们将基于这个版本库为实例继续来看 Git 版本库日常管理的常规操作。 叮咚~~，完成当前博文学习，即可达成 “初步项目版本管理” 成就！！！ 版权说明： 本文思路以及内容主要来自廖雪峰老师的 Git 教程 （强烈推荐膜拜原文），并结合个人使用所作，只作为学习记录使用。如内容有侵权请联系删除，禁止转载！ 更多 Git 相关内容，请关注博主 Git 博文系列： 之一 &gt;&gt;&gt; Git 使用指南之初识 之二 &gt;&gt;&gt; Git 使用指南之时光穿梭机 之三 &gt;&gt;&gt; Git 使用指南之远程仓库 之四 &gt;&gt;&gt; Git 使用指南之分支管理 之五 &gt;&gt;&gt; Git 使用指南之 WorkFlow (工作流) 之六 &gt;&gt;&gt; Git 使用指南之 Git 自定义 之七 &gt;&gt;&gt; Git 使用指南之 HEAD 指针 之八 &gt;&gt;&gt; Git 使用指南之 Git 中的黑魔法 | &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 上篇博文中 GitTestProject 版本库目录结构说明： GitTestProject 版本库包含：Server 目录、Client 目录、以及 readme.txt 说明文档。 Server 目录下包含一个名为：service.py 的文件，其内容为： 1# This is a Test! Client 目录视作是一个仅包含 Git 占位文件（.gitignore）的空目录。 readme.txt 文件内容为： 12Git is a version control system.Git is free software. ==============================================================| 下面一起来看 Git 到底有多神奇： File Modification In Repo来看版本库中的文件修改 &gt;&gt;&gt; 我们知道，Server 目录下包含一个名为：service.py 的文件，其内容如下： 1# This is a Test! 到了工作时间，我们想要接着继续写 service.py 脚本了，我做了如下变更： 123# Git is a distributed version control system.# Git is free software.# This is a Test! 通过上一篇博文知道，文件修改完成之后，想要 GitTestProject 版本库管理，还需要执行：添加（git add）&amp;&amp; 提交（git commit）的操作。 CMD 1 –&gt;&gt;&gt; git status 事实上，在添加、提交变更之前，我们需要关注的是：Git 版本库（GitTestProject）是否已经实时地跟踪到了我们的修改（很慌，要是没有识别到修改怎么办？），这是很重要的！！！当然是可以的，毕竟 Git 就是干这个的。 git status 命令说明： 可以让我们 时刻监控到版本仓库中所有管理文件的当前状态，我们在 Git Bash 中运行查看一下 Git监控信息： 123456789$ git statusOn branch masterChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: Server/service.pyno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 可以看到，Git 告诉我们 modified: Server/service.py（service.py 已经被修改），并且提醒我们 Changes not staged for commit（变更未提交）。 一般，一个文件的状态通常可以分为： 不受版本控制的 untracked 状态 受版本控制并且已修改的 modified 状态 受版本控制已修改并提交到暂存区的 staged 状态 从暂存区已经提交到本地仓库的 committed 状态 提交到本地仓库未修改或者从远程仓库克隆下来的 unmodified 状态 CMD 2 –&gt;&gt;&gt; git diff 上面我们知道，版本库确实检测到了 service.py 文件被变更了！但我们更加关注的是版本库检测到的 service.py 文件的修改，和我们手动修改是否一致？！！这时需要使用 git diff（git different） 命令来查看修改后文件和修改前文件的差异： 12345678910$ git diff Server/service.pydiff --git a/Server/service.py b/Server/service.pyindex 68f5fe0..433af3b 100644--- a/Server/service.py+++ b/Server/service.py@@ -1 +1,3 @@-This is a Test!+# Git is a distributed version control system.+# Git is free software.+# This is a Test! 可以看到 Git 已经跟踪了我们对 service.py 文件的修改，这下舒服了~，将其提交给版本库也就放心了。 CMD 3 –&gt;&gt;&gt; git add &amp;&amp; git commit -m 提交~提交 &gt;&gt;&gt; 12# 添加变更至暂存区（见下文 Git Stage 说明），等待 commit$ git add Server/service.py 执行后同样没有任何输出（成功信号）。在执行 git commit 之前，我们再次运行 git status 查看一下当前仓库的状态（不放心再确认一下）： 123456$ git statusOn branch masterChanges to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) modified: Server/service.py Git 告诉我们将要被提交的修改是：Server/service.py（心里默念一句 NB），确定之后我们直接提交给版本库： 123$ git commit -m 'Add help info'[master 8622ab2] Add help info 1 file changed, 3 insertions(+), 1 deletion(-) 提交完成后，我们再次查看版本库状态： 123$ git statusOn branch masternothing to commit, working tree clean Git 监控信息显示：当前没有需要提交的变更，并且工作目录是干净（working tree clean）的，完美~ Time ShuttleGit 实现时光穿梭（版本回滚） &gt;&gt;&gt; 上述版本库中文件的修改操作，再练习一次，修改 service.py 文件如下： 12345# Git is a distributed version control system.# Git is free software.# This is a Test!print ('Git is very useful!!!') 然后尝试添加 &amp;&amp; 提交： 1234$ git add Server/service.py$ git commit -m 'Add test code'[master dd32d2d] Add test code 1 file changed, 2 insertions(+) 像这样，不断对文件进行修改，然后不断提交变更到版本库里。这就好像游戏存档一样：打通一部分关卡，存档一次，形成不同的存档库。一旦失败的话，可以通过存档回滚到最新的存档。 Git 也是一样，每当你觉得文件修改到一定程度（完成某项功能，或某个版本）的时候，就可以 “保存一个快照”，这个快照在 Git 中被称为一次 commit。一旦你把文件改乱了，或者误删了文件，还可以从最近的一个 commit 恢复（版本回滚），然后继续工作，而不是把几个月的工作成果全部丢失。 变更历史记录在开始讲解 Git 版本库的回滚操作之前，我们先来回顾一下 service.py 一共有多少个 commit（版本、快照）被提交到 Git 仓库里： 明确了有多少、有哪些版本，才可以准确地在版本库中的不同版本间进行回滚 版本 1：ADD Project Base 123# service.py 被提交到 GitTestProject，内容如下：# This is a Test! 版本 2：Add help info 123# Git is a distributed version control system.# Git is free software.# This is a Test! 版本 3：ADD test code 12345# Git is a distributed version control system.# Git is free software.# This is a Test!print ('Git is very useful!!!') 截至目前为止，当前版本库中，我们执行过 3 次 commit 操作，形成了三个不同的版本。 版本 1：ADD Project Base 版本 2：Add help info 版本 3：ADD test code 以上列出的就是当前版本库中的项目的 变更历史记录。 CMD 4 –&gt;&gt;&gt; git log 然后，实际工作中，我们怎么可能记得一个几千行的文件变更了多少次、每次都改了什么内容（不然要版本控制系统干什么，和原始版本控制有何区别？），所以需要版本控制系统可以告诉我们 项目的变更历史记录。 git log 命令就是做这个事的，它会显示出版本库中：从最新到最远的提交日志。 123456789101112131415161718$ git logcommit 47f21abe1449214864c84c2abdf44168ee26df60 (HEAD -&gt; master)Author: staff_ming &lt;staff_ming@xxxx.com&gt;Date: Fri Dec 21 11:20:04 2018 +0800 Add test codecommit 277b8bf5e9d974f73f1ace2dcd20fea2afd0296aAuthor: staff_ming &lt;staff_ming@xxxx.com&gt;Date: Fri Dec 21 11:02:34 2018 +0800 Add help infocommit 6a8c6bab3053e25a64241a22a56083c549bf79f2Author: staff_ming &lt;staff_ming@xxxx.com&gt;Date: Thu Dec 20 19:53:06 2018 +0800 ADD Project Base 如果嫌输出信息太多，看得眼花缭乱的，可以试试加上 --pretty=oneline 参数（清晰了很多）： 1234$ git log --pretty=oneline47f21abe1449214864c84c2abdf44168ee26df60 (HEAD -&gt; master) ADD test code277b8bf5e9d974f73f1ace2dcd20fea2afd0296a Add help info6a8c6bab3053e25a64241a22a56083c549bf79f2 ADD Project Base 当然你也可以 查看单个文件的提交日志： 1$ git log Server/service.py | &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 历史变更记录解析 &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; 你看到的一大串类似 47f21ab... 的是 commit id（版本号），和 SVN 不一样，Git 的 commit id 不是 1，2，3…… 递增的数字，而是一个非常大的数字（十六进制）。 为什么采用这种机制（SHA-1）？因为 Git 是分布式的版本控制系统，后面我们还要研究多人在同一个版本库里工作，如果大家都用 1，2，3…… 作为版本号，很容易就冲突了。 每提交一个新版本，实际上 Git 就会把它们自动串成一条时间线。如果使用可视化工具（Git GUI）查看 Git 历史，就可以更清楚地看到提交历史的时间线： ================================================================| 有了版本库时间线（变更历史记录线），接下来就可以启动时光穿梭机进行版本回滚了… 问题：假设 版本 3：ADD test code 有错误，我们想要将版本库回滚到上一个版本（版本 2：Add help info），怎么办？？！ HEAD 开始回滚前，需要简单介绍一下 HEAD 的基本概念： 我们知道，要想实现版本回滚，Git 必须被指定要回滚到哪个版本。在 Git 中，用 HEAD 关键字表示当前版本，也就是最新的提交 47f21ab...（commit id）。上一个版本表示为：HEAD^，上上一个版本可以表示为:HEAD^^，很多人就要问了那如果要表示往上 90 个版本呢，难道要写 90 个 ^，当然不可能！版本数目较多时可以表示为：HEAD~90。 时空穿梭有了以上的知识储备我们就可以进行版本库的 时光穿梭 了 &gt;&gt;&gt; CMD 5 –&gt;&gt;&gt; git reset –hard Git 版本库中的 “时光穿梭” 使用 git reset（版本库重置） 命令来实现其功能。 1 –&gt; 回到过去 现在我们来看如何从当前版本【 Add test code 】回滚到上一版本【 Add help info 】，即：Add test code -&gt;&gt;&gt; Add help info，指令如下： 12$ git reset --hard HEAD^HEAD is now at 8622ab2 Add help info 这里我们侧重看 git reset 实现功能，参数 --hard 会在后续补充说明，这里你只需知道它是版本指定相关参数即可。回滚后，我们来看 service.py 当前版本内容： 1234$ cat Server/service.py# Git is a distributed version control system.# Git is free software.# This is a Test! 我们发现，果然 service.py 时空倒流到上一个版本了。 2 –&gt; 穿梭到未来 如果你现在想重新回滚到 –&gt;&gt; 版本3：ADD test code 怎么办？ 此时，我们查看一下当前版本库的提交日志信息： 123$ git log --pretty=oneline277b8bf5e9d974f73f1ace2dcd20fea2afd0296a (HEAD -&gt; master) Add help info6a8c6bab3053e25a64241a22a56083c549bf79f2 ADD Project Base 可以发现，之前最新的那个版本 【 ADD test code 】 已经看不到了！就好比你从现在回到了过去，但你又想回到现在（未来），你想通过 git log 察看现在时间节点在时间线上的版本标识，结果发现你已经找不到了。难道只能活在过去了么？ 在给出办法之前你先祈祷吧…之前我们一直使用的 Git Bash 窗口你还没手贱关掉。我们可以找到先前 【 ADD test code 】 的 commit id 是 47f21abe....，这样又找到了回去的时间节点版本标识（确实关闭也不要紧，是不是有点慌，哈哈。2333），下一小节【HEAD &amp;&amp; Commit Id】中我们会给出 commit id 的查询方法）。如果你已经关闭，可以转至下一小节查询一下~ commit id 也可以作为 Git 版本库中时间线上的版本标识，在 Git 项目管理中这要比使用 HEAD 更加合理。 重新回滚到 –&gt;&gt; 版本3：Add test code 的指令如下： 12$ git reset --hard 47f21abeHEAD is now at 47f21abe ADD test code 注意：版本号（commit id）没必要写全，Git 会去自动检索的，当然也不能太少，否则可能无法和其它版本区别。 此时查看 service.py，发现我们已经回到了“未来”： 123456$ cat Server/service.py# Git is a distributed version control system.# Git is free software.# This is a Test!print ('Git is very useful!!!') 重新查看版本库变更历史记录如下： 1234git log --pretty=oneline47f21abe1449214864c84c2abdf44168ee26df60 (HEAD -&gt; master) ADD test code277b8bf5e9d974f73f1ace2dcd20fea2afd0296a Add help info6a8c6bab3053e25a64241a22a56083c549bf79f2 ADD Project Base 至此，你就可以自由地进行版本库的回滚了~ HEAD &amp;&amp; Commit Id区别于 SVN，在进行版本回滚的时候我们发现 Git 的版本回退速度非常快，这是由于 Git 内部的指针机制决定的。 Git 内部有个指向当前版本的指针，就是我们前面说的 Head。当你回滚版本的时候，Git 仅仅是把 HEAD 从指向 【 ADD test code 】 版本的地址： 移动指向 【 Add help info 】： 然后顺便把工作区的文件更新了。所以你让 HEAD 指向哪个版本号，你就把当前版本定位在哪（讲到这里很多人会想到程序设计语言中的指针）。 HEAD 所指向的版本地址就是： commit id。故版本库回滚时可以同时使用 HEAD &amp;&amp; commit id 作为版本标识。 CMD 6 –&gt;&gt;&gt; git reflog “穿越到未来” 中找不到 commit id 的问题解决方法 &gt;&gt;&gt; 前面我们在 穿越到未来 中提到 Git Bash 关掉后，表面看起来找不到最新版本的 commit id。实际上，Git 提供了指令 git reflog 用来记录你的每一次引用日志（HEAD 指针移动记录）： 123456$ git reflog47f21ab (HEAD -&gt; master) HEAD@{0}: reset: moving to 47f21abe14492277b8bf HEAD@{1}: reset: moving to HEAD^47f21ab (HEAD -&gt; master) HEAD@{2}: commit: ADD test code277b8bf HEAD@{3}: commit: Add help info6a8c6ba HEAD@{4}: commit (initial): ADD Project Base 从日志输出可以看出：Add test code 的 commit id 是 47f21ab。 Git StageGit 和其他版本控制系统（如：SVN）的一个很大的不同之处就是有 暂存区（stage） 的概念。 这一小节，我们将从 Git 的本地数据管理入手，深入了解 Git 中引入的暂存区（Stage）的作用。 Git Local Data ManagementGit 本地数据管理，大概可以分为三个区：工作区（Working Directory）、暂存区（Stage）、以及版本库（Repository）。 Working Directory我们将当前程序开发所在目录称为：工作区（Working Directory），也就是我们的项目开发目录（如：GitTestProject）。该区域的文件会有状态的变化且状态由 Git 自动检测，如果程序中文件做任何操作（增、删、改），文件状态均会被检测到（类似于 SVN）。 Repository工作区（GitTestProject）有一个隐藏目录 .git ，这个不算工作区，而是 Git 的 版本库（Repository）。 Git 的版本库里存储了很多东西，其中最重要的就是称为 stage（或者叫：index）的 暂存区；还有 Git 为我们自动创建第一个分支 master，以及指向 master 的一个指针叫 HEAD（分支的概念后续会有专门的博文进行讲解，这里将其理解为版本库中的一条时间线）。 Stage数据暂时存放的区域，可在工作区和版本库之间进行数据的友好交流。 Git 版本控制原理当工作区检测到有文件发生变化时，那么意味着：我们在上一个版本之后再次对项目进行了变更。变更完成之后，我们可以将当前变更当做下一版本进行提交（生成一个新的版本或快照），那么就是执行 git add . 将所有文件提交到暂存区（stage），然后再执行 git commit -m 'another version' 提交到版本库的当前分支。原理图如下： 简单理解为：首先将需要提交的文件修改通通放到暂存区，然后一次性提交暂存区的所有修改即可。 下面我们完成一个实例来深入了解 Git 版本控制原理，详细过程如下所示： 1 -&gt;&gt; 在工作区修改文件 Server/service.py 内容为： 12345678# Git is a distributed version control system.# Git is free software.# This is a Test!print ('Git is very useful!!!')# Git has a mutable index called stage.# Git tracks changes. 2 -&gt;&gt; 在工作区添加文件 Client/request.py（内容随意），然后查看版本库当前状态： 123456789101112$ git statusOn branch masterChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory) modified: Server/service.pyUntracked files: (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed) Client/request.pyno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) Git 非常清楚地告诉我们，Server/service.py 脚本被修改了，而 Client/request.py 还从来没有被添加过，所以它的状态是 Untracked。 3）git add . 将所有修改文件提交到暂存区（stage），然后查看此时版本库状态： 1234567$ git statusOn branch masterChanges to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) new file: Client/request.py modified: Server/service.py 4）git commit 一次性把暂存区的所有修改提交到分支。 1234$ git commit -m 'understand how stage works'[master 847e6ef] understand how stage works 2 files changed, 3 insertions(+) create mode 100644 Client/request.py 5）提交后，如果工作区没有做任何修改，那么工作区就是 “干净” 的： 123$ git statusOn branch masternothing to commit, working tree clean 此时版本库的暂存区（stage）内容会被提交的 master 分支。 看到这里，肯定会有很多看客老爷们会问：为啥要暂存区，通过工作区直接提交到本地仓库不就OK了？暂存区存在有什么作用？ 下文会给出说明： Data Flow In Git根据上文 ，我们给出当开发者通过 git 变更数据时，各区之间可能的数据传递流程示意图： 我们可以通过对比三个区之间的数据差别，来验证以上流程的正确性，这可以借助之前学过的 git diff 命令来实现： 命令 作用 git diff 工作区 vs 暂存区 git diff head 工作区 vs 版本库 git diff –cached 暂存区 vs 版本库 开始实验一 &gt;&gt;&gt;&gt; ： 上一个版本之后未进行任何变更（文件未修改，未 add，未 commit）时，执行 git diff 命令，结果都为空： 命令 结果 （工作区 vs 暂存区）git diff 无输出 （工作区 vs 版本库）git diff head 无输出 （暂存区 vs 版本库）git diff –cached 无输出 此时查看文件内容： 123456789$ cat Server/service.py# Git is a distributed version control system.# Git is free software.# This is a Test!print ('Git is very useful!!!')# Git has a mutable index called stage.# Git tracks changes. 然后对 Server/service.py 进行如下变更，现在工作区内容发生变化，暂存区和版本库内容一致。 12345678910# Git is a distributed version control system.# Git is free software.# This is a Test!print ('Git is very useful!!!')# Git has a mutable index called stage.# Git tracks changes.# Git local data management test. Result 1 &gt;&gt;&gt;&gt;：（工作区 vs 暂存区）git diff 1234567891011$ git diffdiff --git a/Server/service.py b/Server/service.pyindex 6bef824..5127360 100644--- a/Server/service.py+++ b/Server/service.py@@ -6,3 +6,5 @@ print ('Git is very useful!!!') # Git has a mutable index called stage. # Git tracks changes.++# Git local data management test. Result 2 &gt;&gt;&gt;&gt;：（工作区 vs 版本库）git diff head 1234567891011$ git diff headdiff --git a/Server/service.py b/Server/service.pyindex 6bef824..5127360 100644--- a/Server/service.py+++ b/Server/service.py@@ -6,3 +6,5 @@ print ('Git is very useful!!!') # Git has a mutable index called stage. # Git tracks changes.++# Git local data management test. Result 3 &gt;&gt;&gt;&gt;：（暂存区 vs 版本库）git diff –cached 12$ git diff --cached# 无输出 执行 git add 操作后，修改同步到暂存区，现在工作区和暂存区数据一致。 1$ git add Server/service.py Result 1 &gt;&gt;&gt;&gt;：（工作区 vs 暂存区）git diff 12$ git diff# 无输出 Result 2 &gt;&gt;&gt;&gt;：（工作区 vs 版本库）git diff head 1234567891011$ git diff headdiff --git a/Server/service.py b/Server/service.pyindex 6bef824..5127360 100644--- a/Server/service.py+++ b/Server/service.py@@ -6,3 +6,5 @@ print ('Git is very useful!!!') # Git has a mutable index called stage. # Git tracks changes.++# Git local data management test. Result 3 &gt;&gt;&gt;&gt;：（暂存区 vs 版本库）git diff –cached 1234567891011$ git diff --cacheddiff --git a/Server/service.py b/Server/service.pyindex 6bef824..5127360 100644--- a/Server/service.py+++ b/Server/service.py@@ -6,3 +6,5 @@ print ('Git is very useful!!!') # Git has a mutable index called stage. # Git tracks changes.++# Git local data management test. 执行 git commit 操作后，修改已经同步到版本库，三区数据再次保持一致。 命令 结果 （工作区 vs 暂存区）git diff 无输出 （工作区 vs 版本库）git diff head 无输出 （暂存区 vs 版本库）git diff –cached 无输出 开始实验二 &gt;&gt;&gt;&gt; ： 1）对 Server/service.py 进行第一次修改： 12345678# Git is a distributed version control system.# Git is free software.# This is a Test!print ('Git is very useful!!!')# Git has a mutable index called stage.# Git tracks changes. 2）将其添加到暂存区： 1234567$ git add Server/service.py$ git statusOn branch masterChanges to be committed: (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage) modified: Server/service.py 3）对 Server/service.py 进行第二次修改： 12345678# Git is a distributed version control system.# Git is free software.# This is a Test!print ('Git is very useful!!!')# Git has a mutable index called stage.# Git tracks changes of files. 4）提交： 12345678910111213$ git commit -m 'git tracks changes'[master 9046f26] git tracks changes 1 file changed, 1 insertion(+)$ git statusOn branch masterChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: Server/service.pyno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 我们发现还有一次修改未被提交，我们先回顾一下操作过程： 第一次修改 -&gt; git add -&gt; 第二次修改 -&gt; git commit 当你用 git add 命令后，在工作区的第一次修改被放入暂存区，准备提交。但是，在工作区的第二次修改并没有放入暂存区，所以，git commit 只负责把暂存区的修改提交了，也就是第一次的修改被提交了，第二次的修改不会被提交。 Result 1 &gt;&gt;&gt;&gt;：（工作区 vs 暂存区）git diff 1234567891011 $ git diffdiff --git a/Server/service.py b/Server/service.pyindex 6bef824..a17dbf0 100644--- a/Server/service.py+++ b/Server/service.py@@ -5,4 +5,4 @@ print ('Git is very useful!!!') # Git has a mutable index called stage.-# Git tracks changes.+# Git tracks changes of files. 此时，由于第二次修改内容未同步至暂存区，所以工作区和暂存区数据不一致。 Result 2 &gt;&gt;&gt;&gt;：（工作区 vs 版本库）git diff head 1234567891011$ git diff headdiff --git a/Server/service.py b/Server/service.pyindex 6bef824..a17dbf0 100644--- a/Server/service.py+++ b/Server/service.py@@ -5,4 +5,4 @@ print ('Git is very useful!!!') # Git has a mutable index called stage.-# Git tracks changes.+# Git tracks changes of files 可见，第二次修改确实没有被提交。所以：如果不用 git add 到暂存区，那就不会加入到 commit 快照中。 Result 3 &gt;&gt;&gt;&gt;：（暂存区 vs 版本库）git diff –cached 12$ git diff --cached# 无输出 此时，第一次修改的暂存区内容已提交至版本库，所以暂存区和版本库内容是保持一致的。 事实上，Stage 的引入，确实赋予了 Git 更多灵活的特性。 Git Reset –Options前面我们提到过，git reset 版本库重置命令可以根据历史变更记录（HEAD &amp;&amp; Commit ID）来实现 “时光穿梭”（版本库重置）。 上文通过对 Git 本地数据管理的说明，相信你已经对 Git 分区工作原理有了深入的了解。掌握这一小节之后，通过 git reset 不同的参数搭配使用，可以在工作区，暂存区和版本库之间，轻松进行数据的来回切换。 Git Reset 有三种模式（参数）：soft、mixed、hard。 下面分别来看使用上的区别： Mode：hard该模式下，Git 会使用 &lt;HEAD or Commit ID&gt; 所对应的版本重置 Stage 区和工作区（Working Directory）。命令格式： 1$ git reset --hard &lt;HEAD or Commit ID&gt; 命令说明：git reset 后面加了 --hard 参数时，你的 stage区和工作目录里的内容会被完全重置为 &lt;HEAD or Commit ID&gt; 所对应的新位置相同的内容。 简言之：你的没有 commit 的修改会被全部擦掉。 Demo &gt; &gt; &gt; &gt; 例如，上一次 commit 之后又对文件做了一些修改：将修改后的 Server/service.py 文件 add 到 Stage；修改后的 Client/request.py 保留在工作区（未执行 add）。查看此时版本库状态： 12345678910$ git statusOn branch masterChanges to be committed: (use &quot;git restore --staged &lt;file&gt;...&quot; to unstage) modified: Server/service.pyChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory) modified: Client/request.py 然后，查看 git reset --hard 效果： 12$ git reset --hard HEAD^HEAD is now at bf2ead8 Git Local Data Managemant 可以发现，当前版本库的 HEAD 切到上一条 commit 的同时，工作目录里的新改动（Client/request.py）和已经 add 到 stage 区的新改动（Server/service.py）也一起全都消失了： 123$ git statusOn branch masternothing to commit, working tree clean Mode：soft该模式下，Git 会使用 &lt;HEAD or Commit ID&gt; 所对应的版本进行重置，但注意，会保留 Stage 区和工作区（Working Directory）中的内容，并且会把重置 &lt;HEAD or Commit ID&gt; 所带来的新的差异放进暂存区。命令格式： 1$ git reset --soft &lt;HEAD or Commit ID&gt; 命令说明：什么是「重置 HEAD 所带来的新的差异」？由于 HEAD 的移动（A –&gt; C），版本 A 到 版本 C 之间的差异即为重置 HEAD 所带来的新的差异，会将这些由版本版本重置引发的差异放入暂存区。 简言之：保留工作目录和暂存区内容，并把重置 HEAD 所带来的新的差异放进暂存区。 可以想象到，当我们想合并「当前节点」与「reset 目标节点」之间不具太大意义的 commit 记录（可能是阶段性地频繁提交）時，可以考虑使用 Soft Reset 来让 commit 演进线图较为清晰点。 Demo &gt; &gt; &gt; &gt; 例如，上一次 commit 之后又对文件做了一些修改：将修改后的 Server/service.py 文件 add 到 Stage；修改后的 Client/request.py 保留在工作区（未执行 add）。查看此时版本库状态： 12345678910$ git statusOn branch masterChanges to be committed: (use &quot;git restore --staged &lt;file&gt;...&quot; to unstage) modified: Server/service.pyChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory) modified: Client/request.py 假设此时当前 commit 的改动内容是新增了 softtest.txt 文件。如果这时你执行： 123456789101112$ git reset --soft HEAD^$ git statusOn branch masterChanges to be committed: (use &quot;git restore --staged &lt;file&gt;...&quot; to unstage) modified: Server/service.py new file: softtest.txtChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory) modified: Client/request.py 可见，将版本库由 HEAD 重置为 HEAD^，重置 HEAD 所带来的差异为：新增了 softtest.txt 文件，故新增文件被存放到暂存区。 Mode：mixid该模式下（默认，不加参数），Git 会使用 &lt;HEAD or Commit ID&gt; 所对应的版本进行重置，注意，会保留工作区（Working Directory）中的内容，但会清空暂存区（Stage）。命令格式： 123$ git reset --mixed &lt;HEAD or Commit ID&gt;# 或者$ git reset &lt;HEAD or Commit ID&gt; 命令说明：保留工作区（Working Directory）中的内容，但会清空暂存区（Stage）。工作目录的修改、暂存区的内容以及由 reset 所导致的新的文件差异，都会被放进工作目录。 简言之：把所有差异都混合（mixed）放在工作目录中。 Demo &gt; &gt; &gt; &gt; 例如，上一次 commit 之后又对文件做了一些修改：将修改后的 Server/service.py 文件 add 到 Stage；修改后的 Client/request.py 保留在工作区（未执行 add）。查看此时版本库状态： 12345678910$ git statusOn branch masterChanges to be committed: (use &quot;git restore --staged &lt;file&gt;...&quot; to unstage) modified: Server/service.pyChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory) modified: Client/request.py 假设此时当前 commit 的改动内容是新增了 softtest.txt 文件。如果这时你执行不带参数的 reset： 1234567891011 $ git statusOn branch masterChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory) modified: Client/request.py modified: Server/service.pyUntracked files: (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed) softtest.txt 完美~ Undo Edit如何撤销修改？ &gt;&gt;&gt; 3.2 Data Flow In Git 实验二 中我们对 Server/service.py 文件做了两次修改，第一次修改为正确修改已被提交（commit）。第二次修改未提交（add），提交（add）前我们突然发现修改为错误修改： 123456789$ cat Server/service.py# Git is a distributed version control system.# Git is free software.# This is a Test!print ('Git is very useful!!!')# Git has a mutable index called stage.# Git tracks changes of files. 我们能想到的直接的纠正方法是手动把文件恢复到上一个版本的状态。但我们查看此时版本库状态： 123456789$ git statusOn branch masterChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) modified: Server/service.pyno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) CMD 7 –&gt;&gt;&gt; git checkout – file 我们发现，Git 提示可以通过 git checkout -- file 可以丢弃工作区的修改，指令如下： 1$ git checkout -- Server/service.py 命令 git checkout -- Server/service.py 意思是：把 service.py 文件在工作区的修改全部撤销，这里有两种情况： 第一种是 service.py 自修改后还没有被放到暂存区，撤销修改就回到和版本库一模一样的状态； 第二种是 service.py 已经添加到暂存区后又作了修改，撤销修改就回到添加到暂存区后的状态。 简单地说：git checkout -- file 会让文件 file 回到上一次 git commit 或 git add 时的状态。 可以发现，丢弃工作区的修改之后 service.py 文件又恢复到之前的内容了： 123456789$ cat Server/service.py# Git is a distributed version control system.# Git is free software.# This is a Test!print ('Git is very useful!!!')# Git has a mutable index called stage.# Git tracks changes. 注意：git checkout -- file 命令中的参数 -- 很重要，没有 --，就变成了 “切换到另一个分支” 的命令，后面的分支管理中会再次遇到 git checkout 命令。 还能怎么操作可以实现上述功能？！！上一小节介绍的 git reset 也可以实现上述撤消操作。如下： 12$ git reset --hard HEADHEAD is now at 04aee1b git tracks changes 这里我们再来尝试 git checkout -- 的第二种情况（变更已经 add 到暂存区）：将 service.py 文件内容修改为上述中第二次修改内容，如下： 12345678# Git is a distributed version control system.# Git is free software.# This is a Test!print ('Git is very useful!!!')# Git has a mutable index called stage.# Git tracks changes of files. 然后将上述修改添加至暂存区： 1$ git add Server/service.py 添加后再进行修改，内容如下： 12345678910# Git is a distributed version control system.# Git is free software.# This is a Test!print ('Git is very useful!!!')# Git has a mutable index called stage.# Git tracks changes of files.# Git Second tracks changes of files. 随后，查看此时文件状态 12345678910$ git statusOn branch masterChanges to be committed: (use &quot;git restore --staged &lt;file&gt;...&quot; to unstage) modified: Server/service.pyChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory) modified: Server/service.py 此时，我们发现修改有误，需要撤销工作区中文件内容，指令如下： 1$ $ git checkout -- Server/service.py 查看文件内容，发现撤销修改回到添加到暂存区后的状态（仅仅撤销了第二次修改的内容）： 123456789$ cat Server/service.py# Git is a distributed version control system.# Git is free software.# This is a Test!print ('Git is very useful!!!')# Git has a mutable index called stage.# Git tracks changes of files. 事实上，我们第一次已经 add 到 暂存区的内容也是有问题的，怎么办？ git reset HEAD file 可以帮我们直接清楚暂存区内容。 如果你想将当前文件的修改从暂存区移除去，可以做如下操作： 123456789101112git reset HEAD Server/service.pyUnstaged changes after reset:M Server/service.py$ git statusOn branch masterChanges not staged for commit: (use &quot;git add &lt;file&gt;...&quot; to update what will be committed) (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory) modified: Server/service.pyno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 然后，我们对比一下，工作区和暂存区中 Server/service.py 文件差异： 1234567891011$ git diffdiff --git a/Server/service.py b/Server/service.pyindex 6bef824..a17dbf0 100644--- a/Server/service.py+++ b/Server/service.py@@ -5,4 +5,4 @@ print ('Git is very useful!!!') # Git has a mutable index called stage.-# Git tracks changes.+# Git tracks changes of files. 现在，上一小节的第二次修改也不想要了，怎么办？指令如下： 1$ git checkout -- Server/service.py 当然了，使用 git reset 可以很容易实现上述“复杂”的过程，但这里主要是为了引入 git reset HEAD file，掌握这一方法可以很快清空暂存区。 CMD 8 –&gt;&gt;&gt; git switch &amp;&amp; git restore 我们知道，git checkout 命令身兼数职（切换分支、文件撤回…），从 Git 2.23 版本开始引入了两个新的命令来分担 git checkout 功能： git switch：切换分支 git restore：文件撤回（检出） git switch 功能这里不进行详细介绍，在介绍 Git 分支功能时再详解。 git restore 命令详解： git restore file&gt;&gt;&gt; 指令使得在工作空间但是不在暂存区的文件撤销更改(内容恢复到没修改之前的状态)；【另一种说法：用暂存区或者版本库中的文件覆盖本地文件的修改可以达到回退修改的目的】 git restore –staged file&gt;&gt;&gt; 的作用是将暂存区的文件从暂存区撤出，但不会更改文件的内容。【另一种说法：使用版本库中的文件覆盖暂存区的文件，达到回退 git add 命令的目的】 Delete File前面我们接触的修改文件都是新建、修改等。那么，Git 中是如何管理文件删除的？？？ 下面我们通过一个删除实例来看 Git 如何管理删除，先添加一个新文件 git_rm_test.txt 到 Git 并且提交： 123456$ touch git_rm_test.txt$ git add git_rm_test.txt$ git commit -m 'Add git_rm_test.txt'[master 6516e48] Add git_rm_test.txt 1 file changed, 0 insertions(+), 0 deletions(-) create mode 100644 git_rm_test.txt 然后我们删除 git_rm_test.txt 文件。这时 Git 会跟踪删除文件操作，工作区和版本库就不一致了。此时我们来看版本库状态，会发现 Git 已经知道了我们的删除操作： 123456789$ git statusOn branch masterChanges not staged for commit: (use &quot;git add/rm &lt;file&gt;...&quot; to update what will be committed) (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory) deleted: git_rm_test.txtno changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;) 此时我们面临两个选择：一是确实要从版本库中删除该文件；那就用命令 git rm(add) file 删掉，并且 git commit 提交： 1234567$ git rm git_rm_test.txtrm 'git_rm_test.txt' $ git commit -m 'rm git_rm_test.txt'[master 4f15f79] rm git_rm_test.txt 1 file changed, 0 insertions(+), 0 deletions(-) delete mode 100644 git_rm_test.txt 另一种情况是删错了，因为版本库里还有呢，所以可以很轻松地把误删的文件恢复到最新版本： 1$ git checkout -- git_rm_test.txt","link":"/2017/07/02/git-shi-yong-zhi-nan-zhi-shi-guang-chuan-suo-ji/"},{"title":"一文学会 Hexo 轻量级框架的博客搭建【持续更新】","text":"HEXO 是一个快速、简洁且高效的博客框架。支持 GitHub Flavored Markdown 解析文章。并且通过 Node.js 所带来的超快生成速度，可利用靓丽的主题在几秒内瞬间完成静态网页渲染。 写在前面–&gt; 在开始 Hexo 轻量级博客框架搭建之前，首先说明本文所作目的： 其一：本文作为基于 Hexo Frame 搭建个人博客过程记录，方便日后回顾使用； 其二：由于在搭建过程中受益于博客上分享过 Hexo 环境搭建的前辈们（致敬~），故作此以分享给更多的 Hexo 新手小白们。 如文中有表述不恰当的地方，欢迎各位在留言区进行指正，若有转载请注明出处！ 更多 Hexo 博客框架内容，请关注博主 Hexo 博文系列： 一文学会 Hexo 轻量级框架的博客搭建【持续更新】 Hexo 预安装环境部署之 Node.js Git 使用指南之初识 Hello, Hexo World 打造沉浸式写作体验，你需要试试-Markdown-Editor 基于图床的博客图片存储解决方案 稳定快速、高效免费的图床方案-Github-jsDelivr-PicGo Hexo 博客多设备协同管理问题【持续更新】 Getting Started with HexoHexo 是一个快速、简洁且高效的博客框架。支持 GitHub Flavored Markdown 解析文章。并且通过 Node.js 所带来的超快生成速度，可利用靓丽的主题在几秒内瞬间完成静态网页渲染。 注意，在正式开始 Hexo 博客安装以及搭建之前，我们需要预先准备 Hexo 安装环境依赖（预安装环境），这是必须的！否则会影响到后续 Hexo 的安装、搭建过程。所以下面我们需要先来 部署 Hexo 预安装环境： 安装 Node.js前面提过，Hexo 博客需要 Node.js 来进行渲染，才可以完成最终博客静态页面的显示。关于 Node.js 的详细下载以及安装过程说明请参见：Hexo 预安装环境搭建之 Node.js ，这里提供了不同平台下 Node.js 的安装过程。 –&gt;&gt;&gt; 到这里，相信你已经完成了 Node.js 的安装。 安装 Git关于 Git，你可以理解为 Hexo + Git 的搭配方案才可以让互联网内的其他用户可以正常访问我们的博客站点（否者只能本地访问），甚至博客的多平台协同管理（家&amp;公司&amp;学校…多环境博客创作）也要靠 Git 来支持。 Git 的详细下载以及安装过程说明请参见：Git 使用指南之初识 ，这里不仅提供了不同平台下 Git 的安装记录，还包含了 Git 快速入门指南 来帮助你快速了解 Git。 –&gt;&gt;&gt; 到这里，相信你已经完成了 Git 的安装。 维护一个 Github 远程仓库首先通过 Github 官网 ，注册一个 Github 账号并完成登陆。 在 Github 上新建一个 Repository（远程仓库），显示如下： 注意：Repository 名称最好是 Github 账号名（保证唯一，这里我的 Github 账户名是：TheNightIsYoung），并且一定要加 .github.io，所以最终我所创建的 Github 仓库名称为：TheNightIsYoung.github.io。 接着，我们还需要为 Github 和 本地 Git 配置 SSH Key，具体配置过程可以参见 Git 使用指南之远程仓库 中 “GitHub 配置 SSH Key” 章节内容。 维护一个 Gitee 远程仓库首先通过 Gitee 官网 ，注册一个 Citee（码云）账号并完成登陆。 当然，你还可以选择其它 国内远程仓库，这里配置另外一个远程仓库的目的主要是为了解决 Github 的访问速度较慢的问题（不要深究，后续会进行说明）。 例如：如果你是使用过 Coding（腾讯云开发者平台是由腾讯云与 CODING 共同开发的）的用户，非必须使用 Gitee 平台远程仓库，可以直接使用 Coding 平台。两者在使用上几乎没有差异（但这里博主推荐使用 Gitee，一些原因博主感觉 Coding 越来越不友好了….越来越开始向钱看齐了）。 以 Gitee 平台为例，新建一个项目（Repository），如下： 这里注意：和 Github 一样，Repository 名称也要和账户名称一致。同样，我们需要为 Gitee 配置 SSH Key，在账户 Settings 中点击 SSH keys，添加一个 SSH KEY，将之前公钥的内容添加进去。然后测试是否成功连接： 123456C:\\Users\\Jie Guo&gt;ssh -T git@gitee.comThe authenticity of host 'gitee.com (212.64.62.183)' can't be established.ECDSA key fingerprint is SHA256:FQGC9Kn/eye1W8icdBgrQp+KkGYoFgbVr17bmjey0Wc.Are you sure you want to continue connecting (yes/no)? yesWarning: Permanently added 'gitee.com,212.64.62.183' (ECDSA) to the list of known hosts.Hi TheNightIsYoung! You've successfully authenticated, but GITEE.COM does not provide shell access. 预安装环境部署至此就完成了~~~ 下面我们正式开始 Hexo 博客的搭建： Hexo 安装以及初始化NPM 安装 Hexo使用 NPM 管理工具安装 Hexo ↓↓↓↓↓↓ 在预安装环境部署中我们已经成功安装 Node.js，这里无需单独安装 npm（Node.js 中已包含了 npm），打开 Git Bash（桌面点击鼠标右键）运行以下命令安装 Hexo： 1$ npm install -g hexo-cli 回车之后，日志信息输出中可能会出现 WARN 的警告语句，不要担心，等着即可…。过一段时间如果出现hexo 版本号信息输出的语句就代表安装成功了。如下： 123456npm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@1.2.4 (node_modules\\fsevents):npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@1.2.4: wanted {&quot;os&quot;:&quot;darwin&quot;,&quot;arch&quot;:&quot;any&quot;} (current: {&quot;os&quot;:&quot;win32&quot;,&quot;arch&quot;:&quot;x64&quot;})+hexo-cli: 1.1.0audited 4700 packages in 5.05sfound 0 vulnerabilities –&gt; npm install 很慢很慢的问题，请参见博文 1.4 常见问题。 安装完后输入 hexo -v 验证是否安装成功： 123456789101112131415161718$ hexo -vhexo: 3.8.0hexo-cli: 1.1.0os: Windows_NT 10.0.17134 win32 x64http_parser: 2.8.0node: 10.15.0v8: 6.8.275.32-node.45uv: 1.23.2zlib: 1.2.11ares: 1.15.0modules: 64nghttp2: 1.34.0napi: 3openssl: 1.1.0jicu: 62.1unicode: 11.0cldr: 33.1tz: 2018e 初始化 Hexo 博客目录首先在任意一个位置新建一个文件夹，用于存放 Hexo 初始化博客文件，这里我选择 F:/HexoBlogProject ： 12$ cd F:$ mkdir HexoBlogProject 然后在 Git Bash 中依次运行以下命令来 初始化 Hexo 项目： 123$ hexo init &lt;floder&gt;$ cd &lt;floder&gt;$ npm install 实际环境测试如下： 123456789101112131415161718192021222324252627282930313233343536373839$ hexo init HexoBlogProject/INFO Cloning hexo-starter to F:\\HexoBlogProjectCloning into 'F:\\HexoBlogProject'...remote: Enumerating objects: 68, done.remote: Total 68 (delta 0), reused 0 (delta 0), pack-reused 68Unpacking objects: 100% (68/68), done.Submodule 'themes/landscape' (https://github.com/hexojs/hexo-theme-landscape.git) registered for path 'themes/landscape'Cloning into 'F:/HexoBlogProject/themes/landscape'...remote: Enumerating objects: 1, done.remote: Counting objects: 100% (1/1), done.remote: Total 867 (delta 0), reused 0 (delta 0), pack-reused 866Receiving objects: 100% (867/867), 2.55 MiB | 1.64 MiB/s, done.Resolving deltas: 100% (459/459), done.Submodule path 'themes/landscape': checked out '73a23c51f8487cfcd7c6deec96ccc7543960d350'INFO Install dependenciesnpm WARN deprecated titlecase@1.1.2: no longer maintainednpm WARN deprecated postinstall-build@5.0.3: postinstall-build's behavior is now built into npm! You should migrate off of postinstall-build and use the new `prepare` lifecycle script with npm 5.0.0 or greater.&gt; nunjucks@3.1.6 postinstall F:\\HexoBlogProject\\node_modules\\nunjucks&gt; node postinstall-build.js srcnpm notice created a lockfile as package-lock.json. You should commit this file.npm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@1.2.4 (node_modules\\fsevents):npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@1.2.4: wanted {&quot;os&quot;:&quot;darwin&quot;,&quot;arch&quot;:&quot;any&quot;} (current: {&quot;os&quot;:&quot;win32&quot;,&quot;arch&quot;:&quot;x64&quot;})added 422 packages from 501 contributors and audited 4700 packages in 23.449sfound 0 vulnerabilitiesINFO Start blogging with Hexo!$ cd HexoBlogProject/$ npm installnpm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@1.2.4 (node_modules\\fsevents):npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@1.2.4: wanted {&quot;os&quot;:&quot;darwin&quot;,&quot;arch&quot;:&quot;any&quot;} (current: {&quot;os&quot;:&quot;win32&quot;,&quot;arch&quot;:&quot;x64&quot;})audited 4700 packages in 5.05sfound 0 vulnerabilities 看到 INFO Start blogging with Hexo！ 是不很激动！！！此时我们来看一下 Hexo 初始化目录 HexoBlogProject 结构，如下： 123456789HexoBlogProject.├── _config.yml├── package.json├── scaffolds├── source| ├── _drafts| └── _posts└── themes HexoBlogProject 站点目录说明这一小节我们简要介绍一下站点目录结构，这将有助于我们进一步了解 Hexo 博客框架的工作原理。 1）package.json：hexo 框架的参数和所依赖插件： 12345678910111213141516171819{ &quot;name&quot;: &quot;hexo-site&quot;, &quot;version&quot;: &quot;0.0.0&quot;, &quot;private&quot;: true, &quot;hexo&quot;: { &quot;version&quot;: &quot;3.8.0&quot; }, &quot;dependencies&quot;: { &quot;hexo&quot;: &quot;^3.7.0&quot;, &quot;hexo-generator-archive&quot;: &quot;^0.1.5&quot;, &quot;hexo-generator-category&quot;: &quot;^0.1.3&quot;, &quot;hexo-generator-index&quot;: &quot;^0.2.1&quot;, &quot;hexo-generator-tag&quot;: &quot;^0.2.0&quot;, &quot;hexo-renderer-ejs&quot;: &quot;^0.3.1&quot;, &quot;hexo-renderer-stylus&quot;: &quot;^0.3.3&quot;, &quot;hexo-renderer-marked&quot;: &quot;^0.3.2&quot;, &quot;hexo-server&quot;: &quot;^0.3.1&quot; }} 2）scaffolds —&gt; 脚手架、骨架 当我们想要新建一篇文章的时候，hexo 是根据这个目录下的文件进行构建的，基本不用关心。 3）source —&gt; 博文目录 source 目录下包含一个 _posts 目录 ：需要新建的博文都放在 _posts 目录下。 _posts 目录下是一个个 MarkDown 文件。默认情况下有一个 hello-world.md 的文件，博文就在这个文件中编辑。 _posts 目录下的 MarkDown 文件，最终会被编译成 html 文件，放到 public（此文件夹现在应该没有，因为 Blog 项目初始化之后还没有编译过）文件夹下。 4）themes —&gt; 主题目录 themes 为博客网站主题目录，Hexo 有非常好的主题拓展，支持的主题也很丰富，通过更换主题会使得你的博客更加酷炫，后面的博文会教你如何更换 Hexo 主题。 \\themes 目录下每一个子目录就是一个主题，默认情况下子目录如下： 123themes.|-- landscape // 默认主题 当然我们可以下载自己满意的主题到该目录下，hexo主题传送门。 5）_config.yml —&gt; 站点配置文件： 博客站点的很多信息都在这里配置：诸如网站名称、副标题、描述、作者、语言、主题等等参数。这里我们给出 _config.yml 文件中的内容，以及主要参数说明 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081# Hexo Configuration## Docs: https://hexo.io/docs/configuration.html## Source: https://github.com/hexojs/hexo/# Sitetitle: Hexo # 网站标题subtitle: # 网站副标题description: # 网站描述keywords:author: John Doe # 作者language: # 语言timezone: # 网站时区：Hexo 默认使用当前电脑的时区。时区列表，比如说：America/New_York, Japan, 和 UTC 。# URL## If your site is put in a subdirectory, set url as 'http://yoursite.com/child' and root as '/child/'url: http://yoursite.com # 站点的 Urlroot: / # 站点的根目录permalink: :year/:month/:day/:title/ # 文章的“永久链接”格式 permalink_defaults: # 永久链接中各部分的默认值# Directorysource_dir: source # 资源文件夹：用来存放 hexo 内容public_dir: public # 公共文件夹：这个文件夹用于存放生成的站点文件。tag_dir: tags # 标签文件夹archive_dir: archives # 归档文件夹category_dir: categories # 分类文件夹code_dir: downloads/code # Include code 文件夹i18n_dir: :lang # 国际化（i18n）文件夹skip_render: # 跳过指定文件的渲染：可使用 glob 表达式来匹配路径# Writingnew_post_name: :title.md # File name of new posts # 新文章的文件名称default_layout: post # 预设布局titlecase: false # Transform title into titlecase # 把标题转换为 title caseexternal_link: true # Open external links in new tab # 在新标签中打开链接filename_case: 0 # 把文件名称转换为 ‘1’ 小写或 ‘2’ 大写render_drafts: false # 是否显示草稿post_asset_folder: false # 是否启动 Asset 文件夹relative_link: false # 把链接改为与根目录的相对位址 future: true # 显示未来的文章highlight: # 内容中代码块的设置 enable: true line_number: true auto_detect: false tab_replace: # Home page setting# path: Root path for your blogs index page. (default = '')# per_page: Posts displayed per page. (0 = disable pagination)# order_by: Posts order. (Order by date descending by default)index_generator: path: '' per_page: 10 order_by: -date # Category &amp; Tagdefault_category: uncategorizedcategory_map: # 分类别名tag_map: # 标签别名# Date / Time format## Hexo uses Moment.js to parse and display date## You can customize the date format as defined in## http://momentjs.com/docs/#/displaying/format/date_format: YYYY-MM-DD # 日期格式time_format: HH:mm:ss # 时间格式# Pagination## Set per_page to 0 to disable paginationper_page: 10 # 分页数量pagination_dir: page# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: landscape # 主题名称# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: # 部署部分的设置 type: # 类型：常用的是 Git 关于 HexoBlogProject 站点目录配置以及使用，后续我们进行博客配置时会具体说明，这里不再赘述。 Hexo 本地博客上面我们已经完成了 Hexo 本地博客的安装以及搭建，注意只是 本地博客（只可以在你本地运行，其他人在互联网上是看不到的）。现在我们来启动 Hexo 本地服务，进行本地博客预览测试。Git Bash 中运行以下命令： 123$ hexo server （或 hexo s）INFO Start processingINFO Hexo is running at http://localhost:4000 . Press Ctrl+C to stop. 此时，通过浏览器访问 http://localhost:4000/ ，就可以看到 Hexo 的原始博客内容，页面如下所示： 至此，我们已经可以在本地使用 Hexo 博客了。 但其实我们更加关注的是如何将 Hexo 博客发布到 Internet 上供其他人分享交流，下面我将会给出一个解决方案——将我们搭建好的本地 Hexo 博客项目推送到公共代码仓库（远程仓库）以提供公共访问。 Hexo 个人博客实施方案实施方案一：Github·PageGithub·Page 方法是将本地 Hexo 博客推送至 GithubPages 以实现公共访问： 1）首先，安装 hexo-deployer-git 插件，Git bash 下运行下面命令： 12345678910$ npm install hexo-deployer-git --savenpm WARN deprecated swig@1.4.2: This package is no longer maintainednpm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@1.2.4 (node_modules\\fsevents):npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@1.2.4: wanted {&quot;os&quot;:&quot;darwin&quot;,&quot;arch&quot;:&quot;any&quot;} (current: {&quot;os&quot;:&quot;win32&quot;,&quot;arch&quot;:&quot;x64&quot;})+ hexo-deployer-git@0.3.1added 31 packages from 36 contributors and audited 5870 packages in 11.225sfound 1 low severity vulnerability run `npm audit fix` to fix them, or `npm audit` for details 2）然后，修改站点目录下 _config.yml（站点配置文件）。修改文件末尾为： 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: git@github.com:&lt;Your github account name&gt;/&lt;Your github account name&gt;.github.io.git branch: master 实际环境测试： 123456# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy: type: git repo: git@github.com:TheNightIsYoung/TheNightIsYoung.github.io.git branch: master 这里，我的 Github account name（Github 账户名称）为：TheNightIsYoung。 注意：仓库地址最好使用 SSH 访问，不要填写 Http 地址。 3）将本地 Hexo 博客推送至 GithubPages，Git Bash 输入以下命令， 返回 INFO Deploy done: git 即表示成功推送： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182# 生成静态页面：$ hexo generate （或：hexo g）INFO Start processingINFO Files loaded in 272 msINFO Generated: index.htmlINFO Generated: archives/index.htmlINFO Generated: fancybox/blank.gifINFO Generated: fancybox/jquery.fancybox.cssINFO Generated: fancybox/fancybox_loading@2x.gifINFO Generated: fancybox/fancybox_loading.gifINFO Generated: archives/2019/index.htmlINFO Generated: fancybox/fancybox_sprite.pngINFO Generated: fancybox/fancybox_sprite@2x.pngINFO Generated: fancybox/fancybox_overlay.pngINFO Generated: archives/2019/01/index.htmlINFO Generated: js/script.jsINFO Generated: fancybox/helpers/jquery.fancybox-buttons.cssINFO Generated: css/fonts/FontAwesome.otfINFO Generated: fancybox/jquery.fancybox.pack.jsINFO Generated: fancybox/helpers/jquery.fancybox-buttons.jsINFO Generated: css/style.cssINFO Generated: css/fonts/fontawesome-webfont.woffINFO Generated: fancybox/helpers/jquery.fancybox-media.jsINFO Generated: fancybox/helpers/jquery.fancybox-thumbs.jsINFO Generated: fancybox/helpers/fancybox_buttons.pngINFO Generated: css/fonts/fontawesome-webfont.eotINFO Generated: fancybox/helpers/jquery.fancybox-thumbs.cssINFO Generated: css/fonts/fontawesome-webfont.svgINFO Generated: css/fonts/fontawesome-webfont.ttfINFO Generated: 2019/01/07/hello-world/index.htmlINFO Generated: fancybox/jquery.fancybox.jsINFO Generated: css/images/banner.jpgINFO 28 files generated in 650 ms# 部署至 GithubPages：$ hexo deploy （或：hexo d）INFO Deploying: gitINFO Setting up Git deployment...Initialized empty Git repository in F:/HexoBlogProject/.deploy_git/.git/[master (root-commit) 6d469d7] First commit 1 file changed, 0 insertions(+), 0 deletions(-) create mode 100644 placeholderINFO Clearing .deploy_git folder...INFO Copying files from public folder...INFO Copying files from extend dirs...[master c71b7a5] Site updated: 2019-01-08 12:03:08 29 files changed, 5777 insertions(+) create mode 100644 2019/01/07/hello-world/index.html create mode 100644 archives/2019/01/index.html create mode 100644 archives/2019/index.html create mode 100644 archives/index.html create mode 100644 css/fonts/FontAwesome.otf create mode 100644 css/fonts/fontawesome-webfont.eot create mode 100644 css/fonts/fontawesome-webfont.svg create mode 100644 css/fonts/fontawesome-webfont.ttf create mode 100644 css/fonts/fontawesome-webfont.woff create mode 100644 css/images/banner.jpg create mode 100644 css/style.css create mode 100644 fancybox/blank.gif create mode 100644 fancybox/fancybox_loading.gif create mode 100644 fancybox/fancybox_loading@2x.gif create mode 100644 fancybox/fancybox_overlay.png create mode 100644 fancybox/fancybox_sprite.png create mode 100644 fancybox/fancybox_sprite@2x.png create mode 100644 fancybox/helpers/fancybox_buttons.png create mode 100644 fancybox/helpers/jquery.fancybox-buttons.css create mode 100644 fancybox/helpers/jquery.fancybox-buttons.js create mode 100644 fancybox/helpers/jquery.fancybox-media.js create mode 100644 fancybox/helpers/jquery.fancybox-thumbs.css create mode 100644 fancybox/helpers/jquery.fancybox-thumbs.js create mode 100644 fancybox/jquery.fancybox.css create mode 100644 fancybox/jquery.fancybox.js create mode 100644 fancybox/jquery.fancybox.pack.js create mode 100644 index.html create mode 100644 js/script.js delete mode 100644 placeholderBranch 'master' set up to track remote branch 'master' from 'git@github.com:TheNightIsYoung/TheNightIsYoung.github.io.git'.To github.com:TheNightIsYoung/TheNightIsYoung.github.io.git * [new branch] HEAD -&gt; masterINFO Deploy done: git 4）通过浏览器访问网址： https://&lt;Your github account name&gt;.github.io 就可以看到和本地 hexo 博客相同页面。 ================================================= 对比 Hexo 站点目录，观察一下被推送到远程仓库的文件，你是否发现： 远程仓库中的资源文件，其实就是我们的 .../&lt;Hexo 站点目录&gt;/public 目录下的内容（博客静态页面）。简单来说，执行 hexo d 命令会将站点目录下 ：public 目录下的内容推送到远程仓库，而 Hexo 博客项目的配置文件、主题、scaffolds 等等，仍在我们本地储存维护…. 实施方案二：Github·Page + Gitee·Page使用过 Github 都知道，Github 有时候在国内访问较慢，而 Gitee 国内访问较快。故除了添加 Github 仓库外，我们可以在第一种实施方案的基础上配置 Citee·Page。 1）hexo-deployer-git 插件已经安装过，这里可以直接跳过； 2）修改站点目录下 _config.yml（站点配置文件）。修改文件末尾为： 123456789# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy:- type: git repo: git@github.com:&lt;Your github account name&gt;/&lt;Your github account name&gt;.github.io.git branch: master- type: git repo: git@gitee.com:&lt;Your coding account name&gt;/&lt;Your coding account name&gt;.git branch: master 实际环境测试： 123456789# Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy:- type: git repo: git@github.com:TheNightIsYoung/TheNightIsYoung.github.io.git branch: master- type: git repo: git@gitee.com:thenightisyoung/thenightisyoung.git branch: master 这里，我的 gitee account name（Gitee 账户名称）为：thenightisyoung。 3）将本地 Hexo 博客推送至 GiteePages，Git Bash 输入以下命令， 返回 INFO Deploy done: git 即表示成功推送： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657$ hexo g$ hexo dINFO Deploying: gitINFO Setting up Git deployment...Initialized empty Git repository in F:/HexoBlogProject/.deploy_git/.git/[master (root-commit) c9fcced] First commit 1 file changed, 0 insertions(+), 0 deletions(-) create mode 100644 placeholderINFO Clearing .deploy_git folder...INFO Copying files from public folder...INFO Copying files from extend dirs...[master 498e47c] Site updated: 2019-01-08 13:55:57 29 files changed, 5777 insertions(+) create mode 100644 2019/01/07/hello-world/index.html create mode 100644 archives/2019/01/index.html create mode 100644 archives/2019/index.html create mode 100644 archives/index.html create mode 100644 css/fonts/FontAwesome.otf create mode 100644 css/fonts/fontawesome-webfont.eot create mode 100644 css/fonts/fontawesome-webfont.svg create mode 100644 css/fonts/fontawesome-webfont.ttf create mode 100644 css/fonts/fontawesome-webfont.woff create mode 100644 css/images/banner.jpg create mode 100644 css/style.css create mode 100644 fancybox/blank.gif create mode 100644 fancybox/fancybox_loading.gif create mode 100644 fancybox/fancybox_loading@2x.gif create mode 100644 fancybox/fancybox_overlay.png create mode 100644 fancybox/fancybox_sprite.png create mode 100644 fancybox/fancybox_sprite@2x.png create mode 100644 fancybox/helpers/fancybox_buttons.png create mode 100644 fancybox/helpers/jquery.fancybox-buttons.css create mode 100644 fancybox/helpers/jquery.fancybox-buttons.js create mode 100644 fancybox/helpers/jquery.fancybox-media.js create mode 100644 fancybox/helpers/jquery.fancybox-thumbs.css create mode 100644 fancybox/helpers/jquery.fancybox-thumbs.js create mode 100644 fancybox/jquery.fancybox.css create mode 100644 fancybox/jquery.fancybox.js create mode 100644 fancybox/jquery.fancybox.pack.js create mode 100644 index.html create mode 100644 js/script.js delete mode 100644 placeholderBranch 'master' set up to track remote branch 'master' from 'git@gitee.com:TheNightIsYoung/TheNightIsYoung.github.io.git'.git@gitee.com:TheNightIsYoung/TheNightIsYoung.github.io.git + c425509...498e47c HEAD -&gt; master (forced update)INFO Deploy done: gitINFO Deploying: gitINFO Clearing .deploy_git folder...INFO Copying files from public folder...INFO Copying files from extend dirs...On branch masternothing to commit, working tree cleanBranch 'master' set up to track remote branch 'master' from 'git@gitee.com:TheMusicIsLoud/TheMusicIsLoud.git'.To git.dev.tencent.com:TheMusicIsLoud/TheMusicIsLoud.git * [new branch] HEAD -&gt; masterINFO Deploy done: git ４）Gitee 还需要通过 Gitee Pages 服务 ，才能开启静态 Pages 应用（Service –&gt; Gitee Pages）。如下页面显示： 开启成功后界面如下： 5）通过浏览器访问网址： https://&lt;Your coding account name&gt;.gitee.io/ 同样也可以访问到 hexo 博客页面 12# 我的访问链接如下：https://thenightisyoung.gitee.io 实施方案三：Github·Page + Gitee·Page + domain name上面我们已经将 Hexo 个人博客远程托管到 Gihub &amp; Gitee上了。 还能不能再继续优化一下方案？？？ 问题：一方面每一次进行访问时，我们都需要通过 https://&lt;Your coding account name&gt;.coding.me 或者 https://&lt;Your github account name&gt;.gitee.io 一长串的域名来进行访问，显得非常繁琐；另一方面我们有一个闲置的域名，单纯想做域名映射，以达到通过域名即可访问我们的个人博客。 前提：你有一个闲置的自定义域名。这里你可以为 Github·Page 或者 Gitee·Page 配置域名映射，二选其一。Gitee 域名绑定目前只面向企业用户（难受），所以这里我们会将自定义域名绑定到 Github Page（Github 支持 CDN 加速快速访问）。 1）配置 Github·Page 的域名映射 1 –&gt; 域名解析（使用域名的前提）参数： 添加一条 CNAME 记录指向 &lt;Your github account name&gt;.github.io： 12345# 记录类型：选择为 CNAME# 主机记录（即域名前缀）：选择为 www# 解析线路：默认选项即可# 记录值：&lt;Your github account name&gt;.github.io# TTL：默认选项即可 注意：要确认你的域名的解析状态为正常状态！ 2 –&gt; 博客 Github 仓库设置： 首先打开博客仓库设置：https://github.com/&lt;Your github account name&gt;/&lt;Your github account name&gt;.github.io/settings 找到 Custom domain，填写好自定义域名（例如：www.xxxxxx.com），点击 save。 –&gt; 启用 Github Page HTTPS ： 自 2018 年 5 月 1 日，Github 支持自定义域名的 HTTPS 请求了，直接在 Custom domain 下勾选 Enforce HTTPS 即可开启。 配置也相当简单，只需要更新 DNS 配置里的 A 记录，将其指向以下4个 IP 地址中的至少一个。 1234185.199.108.153185.199.109.153185.199.110.153185.199.111.153 HTTPS 让你的网站和网站访客更安全，并且 Github 提供的这些 IP 地址自动将你的站点加入了 CDN，提高了访问速度（真香~）。 3 –&gt; 在 Hexo 站点目录中的 public 目录下创建 CNAME 文件，内容如下： www.xxxxxx.com 部署： 1$ hexo d 4 –&gt; 等待一段时间（域名生效时间，10分钟左右）后，我们发现已经可以通过我们的域名访问到个人博客了。 2）配置 Gitee·Page 的域名映射（Gitee Page Pro） 当前 Gitee Page Pro 是支持自定义域名版本的 Gitee Page，留一个小期待吧，希望码农后续可以支持普通用户的 Gitee·Pages 绑定自定义域名，持续关注 。 未来可期，配置相同 –&gt; 在上述 配置 Github·Page 的域名映射 基础上进行如下设置，即可将域名指向 &lt;Your gitee account name&gt;.gitee.io： 1 –&gt; 域名解析（使用域名的前提）参数： 添加一条 CNAME 记录指向 &lt;Your gitee account name&gt;.gitee.io： 12345# 记录类型：选择为 CNAME# 主机记录（即域名前缀）：选择为 www# 解析线路：默认选项即可# 记录值：&lt;Your gitee account name&gt;.gitee.io# TTL：默认选项即可 注意：要确认域名解析状态为正常状态！ 2 –&gt; 打开 Pages 服务, 进行域名绑定即可。 至此，你就可以通过你的自定义域名进行 Hexo 博客的访问了。 Problem &amp;&amp; Solution1）Github·Page 配置域名绑定问题 问题描述：Github·Page 项目成功绑定了自定义域名之后，可以正常通过域名进行站点访问了。但发现一个现象，在部署上传新的文章后，访问又双叒变成了 404 ？？？ WTF！？在我打算再次重新配置 Github·Page 的时候，我突然发现仓库 Settings 页面绑定域名的那一栏变成空了，是谁动了我的奶酪？？？ 度娘上查到，在为 Github·Page 配置域名绑定之后，会在当前仓库中自动生成一个 CNAME 文件（你可以重新 Save 域名试一下），查看 CNAME 文件内容： 12# 只有一行语句，就是你的域名your domain name 而我们在 hexo d 重新部署之后，发现 CNAME 文件不见了。 你很容易可以想到，hexo d 时，Hexo 会将 public 目录中的文件和目录推送至远端仓库指定分支中，并且完全覆盖该分支下的已有内容。 也即是说，前面我们在 “实施方案一：Github·Page” 配置过程中，由于 public 文件下没有 CNAME 文件，导致远程仓库中的域名绑定相关的 CNAME 文件 被覆盖掉了，≧ ﹏ ≦ 知道了原因，下面我们给出解决方法： 我们知道，站点目录下 public 中的文件是由 source 文件夹的内容生成的。我们尝试一下在 source 目录下添加一个 Github·Page 需要的 CNAME 文件 ，内容如下； 12# 我的域名www.orangeshare.cn 然后执行如下命令，清除以及重新生成静态页面内容： 12$ hexo clean$ hexo g 可以观察到，重新生成的 public 目录下，已经包含 CNAME 文件 了，有点小激动啊~ 再次 hexo d 推送试一下。成功了 O(∩_∩)O 2）Gitee·Page 推送问题 问题描述：Gitee·Page 配置成功之后，可以正常通过 https://&lt;Your coding account name&gt;.gitee.io 进行站点访问了。但发现一个现象，在部署推送新的文章后，访问 Gitee·Page 页面时新推送博文内容没有更新？？？ 这时，你需要进入 Gitee Pages 服务设置页面，重新刷新部署页面（Update），如下（黄色 Update 按钮）： 等待大概 30s 左右部署完成，重新访问页面发现：Gitee·Page 页面已可以查看到新推送的博文~~~","link":"/2017/09/20/yi-wen-xue-hui-hexo-qing-liang-ji-kuang-jia-de-bo-ke-da-jian-chi-xu-geng-xin/"},{"title":"Visual Studio Code (VS Code) 你们都在用吗 ?","text":"Visual Studio Code（VS Code）是由微软推出的，一款同时支持 Windows 、 Linux 和 macOS 等主流操作系统且开源（免费）、强大而且非常好用的源代码编辑器，简称 VS Code，它的插件库中提供了丰富的插件支持，支持 Debug，内置了Git 版本控制，开发环境配置（代码补全、代码片段和代码重构等），远程服务器连接等等。 事实上，不用我安利，很多人都在说 VSCode 是全宇宙最好用的编辑器，无数个大言不惭的攻城狮，一开始尝试就无法“脱坑”。 博主在安装配置使用过程中查阅了网络上很多的相关博文，也遇到过很多问题，为了感谢过程中各位大佬的帮助以及分享给更多的新手使用，以作此文。文中如有表述不正确的地方，望各位大佬指正~~~ 更多 VS Code 相关内容，请关注博主 Visual Studio Code 博文系列： 之一 &gt;&gt;&gt; Visual Studio Code (VS Code) 你们都在用吗 ? 之二 &gt;&gt;&gt; 玩转 VSCode 之配置远程开发环境 VSCode SetupVisual Studio Code（VS Code）除了具有开源、免费，灵活的自定义配置，强大的调试功能以及丰富的插件扩展等特点之外，还提供良好的跨平台支持（Windows &amp; Linux &amp; Mac）： Visual Studio Code（VScode ）官网 Visual Studio Code（VScode ）GitHub 在 2019 年的 Stack Overflow 组织的开发者调研中，VS Code被认为是最受开发者欢迎的开发环境，据调查87317名受访者中有 50.7% 的受访者声称正在使用VS Code。 话不多说，工欲善其事，必先利其器。你可以直接从 VS Code 官网下载站点（传送门）获取到不同平台的安装包，界面如下： 这里，先贴出 VS Code 安装成功之后界面效果： 下面，我们分别给出 Windows &amp; Linux 平台下的 VS Code 的安装方法： For WindowsWindows 平台下 VSCode 的安装方法： Download见上文 VS Code 官网下载页面，Windows 下提供了三种可供下载版本： User Installer：会安装在当前计算机帐户目录，意味着如果使用另一个帐号登陆计算机将无法使用别人安装的 VSCode； System Installer：安装在非用户目录，例如 C 盘根目录，任何帐户都可以使用； .zip：主要使用以上两种安装方式。 VSCode 默认提供的 User Installer 版本，大多数人都是用的这个版本。当然你也可以 System Installer 方式进行安装，安装过程类似。 SetupVSCode 在 Windows 下的安装非常简单，这里主要留意两点（其它默认即可）： 你可以选择将 VSCode 安装到指定的目录； 安装最后关于：添加到 PATH（重启后生效），默认是勾选上，不用配置环境变量，可以直接使用。 For Linux接着我们来看不同 Linux 平台下 VSCode 的安装步骤： For Debian &amp; Ubuntu对于 Debian &amp;&amp; Ubuntu 系统，VS Code 的安装很简单（推荐通过 .deb 包进行安装）。 Go Start &gt;&gt;&gt;&gt; 1 –&gt; Download DEB Package 例如，我的安装包下载目录为：~/Downloads。可以查看到，下载的安装包如下： 12345$ cd Downloads$ ls# 最新 VS Code “.deb” 包装包名称：code_1.38.1-1568209190_amd64.deb 2 –&gt; Begin To Setup Terminal 下执行如下指令： 12345678910111213$ sudo dpkg -i code_1.38.1-1568209190_amd64.deb# 安装输出信息如下：Selecting previously unselected package code.(Reading database ... 227689 files and directories currently installed.)Preparing to unpack code_1.38.1-1568209190_amd64.deb ...Unpacking code (1.38.1-1568209190) ...Setting up code (1.38.1-1568209190) ...Processing triggers for gnome-menus (3.13.3-6ubuntu3.1) ...Processing triggers for desktop-file-utils (0.22-1ubuntu5.2) ...Processing triggers for bamfdaemon (0.5.3~bzr0+16.04.20180209-0ubuntu1) ...Rebuilding /usr/share/applications/bamf-2.index...Processing triggers for mime-support (3.59ubuntu1) ... 3 –&gt; Startup VSCode 上述安装过程完成后，你可以通过在 Terminal 中执行： 1$ code 即可成功打开 VS Code 编辑器窗口。 同样，你也可以通过在 Dash Home（Super）中搜索：VS ，即可查询到 Visual Studio Code 应用程序。 For Red Hat &amp; Fedora &amp; SUSE对于在 Red Hat &amp; Fedora &amp; SUSE（Centos）平台下，VS Code 的安装也非常简单，你可以通过 .rpm 包进行安装。 Go Start &gt;&gt;&gt;&gt; 1 –&gt; Download RPM Package 例如，我的安装包下载目录为：~/Downloads。可以查看到，下载的安装包如下： 12345$ cd Downloads$ ls# 最新 VS Code “.rpm” 包装包名称：code_1.38.1-1568209352.el7.x86_64.rpm 2 –&gt; Begin To Setup Terminal 下执行如下指令： 1234$ sudo yum -ivh install code_1.38.1-1568209352.el7.x86_64.rpm# 安装报错：缺少 libXss.so.1，先安装下面的包，再此尝试安装$ sudo yun install libXScrnSaver 3 –&gt; Test VSCode 在命令窗口，输入：“code –version”，查看已安装 VS Code 版本号： 1234$ code --version1.38.1b37e54c98e1a74ba89e03073e5a3761284e3ffb0x64 4 –&gt; Startup VSCode 上述安装过程完成后，你可以通过在 Terminal 中执行： 1$ code 即可成功打开 VS Code 编辑器窗口。 Extensibility pluginVS Code 并不是一个 IDE，它本质只是一个编辑器，直接使用不利于源代码的编辑。 然而，VS Code 提供了丰富的插件扩展支持，而插件的使用也是 VS Code 能如此流行的一个重要原因。插件扩展可以帮我们实现类似于多语言切换、代码或拼写检查、主题等等功能。 如何安装插件？VSCode 中安装插件方法： 方法一 &gt;&gt; Ctrl + Shift + P 通过快捷键组合 Ctrl + Shift + P 打开 VS Code 命令窗口，搜索关键字 extensions，选择下面的条目： 1Extensions：install Extensions 界面显示如下： 还有一种更简单的插件安装方法 &gt;&gt;&gt; 方法二 &gt;&gt; Ctrl + Shift + X（推荐） 直接通过快捷键组合 Ctrl + Shift + X 可以直接打开插件扩展商店，搜索想要的插件进行安装（如，chinese），界面如下： 每个扩展插件的具体功能都在插件扩展商店中的安装界面有介绍。 ================================== EXTENSIONS ================================= 关于 EXTENSIONS 工作区介绍： EXTENSIONS，提供的下拉列表选项： INSTALLED：列表中包含已下载且安装的功能插件（可关掉，查看时在开启）； ENABLED：列表中包含已安装并且已启用相应功能插件； RECOMMENDED：列表中包含未安装，但推荐安装的插件； DISABLED：列表中包含已安装但未启用相应功能的插件。 在如上插件扩展商店搜索插件 Code Runner，在未安装 Code Runner 插件时条目右下角显示 Install，表示未安装插件。一旦选择安装完成后，Install 会变成设置齿新图标，你可以通过这里设置是否：启用、关闭，甚至卸载插件（你可以通过 Code Runner 插件尝试一下）。 关于 Code Runner 插件的介绍可参见下面【插件合集推荐】。 插件合集推荐官网提供了所有扩展插件的支持列表 &gt;&gt;&gt; 传送门。 下面我会给出一些常见的、基础的可扩展插件列表，所有的插件你都可以在插件扩展商店查看到其详细介绍： 基础配置类插件1 –&gt; Chinese (Simplified) Language Pack for Visual Studio Code 插件名称：中文（简体）语言包 新版 VSCode 的默认语言是英语，你可以通过在插件扩展商店中搜索 Chinese，安装中文（简体）语言包插件来扩展 VSCode 编辑器语言（汉化）： 安装配置好后，VSCode 会提醒你重启以使得配置生效，或者不改变语言（启动但不使用，这时允许的）。 插件安装后，可自由进行语言配置：【Ctrl+Shift+P &gt;&gt;&gt; config &gt;&gt;&gt; Configure Display Language &gt;&gt;&gt; en(英文) 或 zg-cn(中文)】，这样就可以实现中英文自由切换了。 ================================================================== 后续我们还要安装一系列的插件， 但注意：一些插件安装好并且配置之后只有重启 VSCode 才会生效，而有些插件则可以立即生效。 万能方法：根据插件功能描述查看一下相应功能是否生效，否则重启 VSCode！！！ 2 –&gt; Code Runner Code Runner 被称为万能语言运行环境（提供数十种语言支持），Code Runner 插件可以让你一键运行各类代码，甚至时代码片段，非常适合学习或测试各种开发语言。 1# 支持的语言有: C, C++, Java, JavaScript, PHP, Python, Perl, Perl 6, Ruby, Go, Lua, Groovy, PowerShell, BAT/CMD, BASH/SH, F# Script, F# (.NET Core), C# Script, C# (.NET Core), VBScript, TypeScript, CoffeeScript, Scala, Swift, Julia, Crystal, OCaml Script, R, AppleScript, Elixir, Visual Basic .NET, Clojure, Haxe, Objective-C, Rust, Racket, Scheme, AutoHotkey, AutoIt, Kotlin, Dart, Free Pascal, Haskell, Nim, D, Lisp, Kit, V, SCSS, Sass, CUDA, Less, Fortran, Ring, 以及一些自定义命令 你可以通过搜索 Code Runner 进行安装： 还支持通过右键（Alt + Ctrl + N）即可编译运行单源码文件，快捷键 Ctrl + Alt + M 可以直接停止代码运行。 3 –&gt; Vscode-Icons 一个高效、易用的工作区界面对于编码是需要的，故你需要对一些不明了的显示效果做一些优化。 vscode-icons 插件可以实现对各种文件类型的文件前的图标进行显示效果优化。这样，你可以直接通过文件的图标就可以快速直观的知道文件类型，而不用去区别文件后缀。 图标显示效果配置方法：【File &gt;&gt;&gt; Preferences &gt;&gt; File Icon Theme】，可实现项目文件图标显示效果的自由切换。 4 –&gt; KoroFileHeader 优秀的代码除了优秀的性能、规范的格式，注释也是不可或缺的，而且注释也应该有一套标准的注释方法。 KoroFileHeader（Star）能够一键给文件、函数加上注释，提供多种语言支持以及未定义语言的自定义支持等： 文件头部注释快捷键：Alt + Ctrl + I，函数注释快捷键：Alt + Ctrl + T（当然你可以通过 Ctrl + K + S 重新设置快捷键，但要注意不要冲突）。 详细设置方法参考 &gt;&gt;&gt; 传送门 5 –&gt; Code Spell Checker 强烈推荐。对大部分非英语母语又不想写出四不像变量名的程序员来说，正确识记拼写各种单词还是有不小的挑战。 比模棱两可时需要去查在线词典不同的是，这款插件能实时的识别单词拼写是否有误，并给出提示（不少 Bug 都是因为拼写错误导致的）。 6 –&gt; Bracket Pair Colorizer 彩虹花括号插件，能够为圆括号，方括号和大括号提供彩虹色： VSCode 最新已集成彩虹花括号功能 &gt;&gt;&gt;&gt; 目前 VS Code 已经将 Bracket Pair Colorizer 的功能进行了集成，只需要在 settings 中查找 racketPairColorization 进行勾选即可启动相应功能。 7 –&gt; TabOut VSCode 会自动完成在你打左括号（或左引号）的时候自动完成右括号（或右引号），但在这个编辑状态下，却无法像其他编辑器一样通过按 Tab 自动跳出右括号（或右引号）。 这里提供一种 TabOut 插件，安装启动后自动实现上述功能： 8 –&gt; Indent-Rainbow 用四种不同颜色交替着色文本前面的缩进： 9 –&gt; Filesize 在状态栏左下角中显示当前文件大小，点击后还可以看到详细创建、修改时间的插件： 10 –&gt; Path Intellisense 可自动填充文件名的插件： 11 –&gt; Todo Tree 维护时间稍长的代码仓库免不了会有各种 TODO、FIXME 之类的标记 Todo Tree 帮助你快速搜索（使用 ripgrep）你的工作区以获取 TODO 和 FIXME 等注释标记，并在资源管理器窗格的树视图中显示它们。 你可以通过单击树中的 TODO 快速打开文件并将光标移动到包含 TODO 的行上。 12 –&gt; Settings Sync 最好用的配置同步插件，没有之一。 Settings Sync 基于 GitHub Gist 实现 VSCode 用户配置、快捷键配置、已安装插件列表等的备份和恢复功能，配置过程有详细精确的操作步骤文档。 VSCode 最新提供账号设置同步 &gt;&gt;&gt;&gt; 目前 VS Code 已经提供了登录功能（可以替代 Settings Sync 功能），可以使用 Microsoft 或者 Github 账号进行登录，登录账号后提供如下设置同步： 13 –&gt; GitLens GitLens 把 VSCode 结合 Git 的使用体验优化到了极致，能让我们在不离开编辑器，不执行任何命令的情况下知晓光标所在位置代码的修改时间、作者信息等。 14 –&gt; Project Manager Project Manager 对于需要经常切换项目（或者不同语言项目）的场景，可以很容易的实现不同项目之间的快速切换。 15 –&gt; Remote SSH Remote-SSH 允许开发者将容器，远程计算机，或 Windows Subsystem for Linux (WSL) 作为完整的开发环境进行日常开发，调试。 主题类插件长时间的编码，暗色调的编码环境更不容易让视力疲劳，可以让你更加专注。 这一小节来推荐几款经典、优美的主题来优化你的 VSCode 编辑器： 1 –&gt; One Dark Pro Atom 标志性的 One Dark Pro 主题，大概是 VS Code安装量最多的主题。你可以通过搜索 One Dark 进行安装： 2 –&gt; Night Owl 一个非常适合夜猫子的 VS Code 主题，为喜欢深夜编码的人精心设计的。你可以通过搜索 Night Owl 进行安装： 优化类插件1 –&gt; Bachground-cover Bachground-cover 可以为 VSCode 设置透明背景以及背景图片，提示逼格~~~ 安装好之后，你可以从右下角找到 switch background image 按钮进行图像以及透明度设置，还支持自动轮换背景图片等功能。 2 –&gt; Rainbow Fart Rainbow Fart 提醒您：你的女朋友来了~ 萌妹音彩虹屁，还需要鼓励师作甚？ 在 VSCode 的菜单栏中找到 【查看 –&gt; 命令面板】，或使用快捷键 Ctrl + Shift + P。 在 【命令面板】 中输入 &gt; 【Enable Rainbow Fart】 &gt; 【Enter】。 此时会弹出一个消息通知，点击通知上的 【Open】 按钮。 在打开的页面上点击授权。 安装成功，有着鼓励师优美的声音，代码敲的飞起不是梦！ 3 –&gt; Power Mode Power Mode 插件可以让你编写代码更加炫酷，尝试一下吧~ 多平台配置多重开发环境我们知道，VSCode 事实上只是一个编辑器，并不是 IDE（集成开发环境），自身是不含编译器（解释器）以及许多其它集成功能等。但 VSCode 提供丰富的插件扩展支持，通过插件安装可以极大提高你的编程效率。 故，配置 VSCode 多重开发环境就是组合安装配置多种语言相关插件以及相关工具库 的过程。 VSCode SettingsVSCode 通过 用户（User） 和 工作区（Workspace） 设置来实现高度可配置化，你可以打开 VSCode 的 【Settings】（或者直接使用快捷键 ctrl + ,） 查看一下，可以发现 【Settings】 中包含 settings &amp;&amp; Workspace 两种设置。 用户设置（User）是应用于所有 VSCode 实例的全局性设置，而工作区设置（Workspace）是应用于特定文件夹（或项目）的局部设置。工作区设置（Workspace）给 VSCode 提供了极大的灵活性，工作区设置以 json 格式保存在项目目录下 .vscode 文件夹中。 想要深入了解 VSCode 中的文件管理机制、工作区等概念，推荐查看极客教程（墙裂推荐）： VS Code 是如何管理文件和文件夹 VS Code 资源管理器 VSCode 多文件夹工作区 后续配置多重开发环境方法使用的就是 VS Code 资源管理器 中的 单文件夹工作区管理 的方式。 下面我们来看如何使用 VSCode 配置多重开发环境（C/C++ &amp; Python &amp; Java …）： For C/C++我们先来配置 C/C++ 开发调试环境（Windows &amp;&amp; Linux）： Extensions Setup首先，需要安装 VSCode 中 C/C++ 开发过程中可能会用到的插件 &gt;&gt;&gt;&gt; 1 –&gt; 必须安装的扩展： C/C++：实际上就是指 cpptools，提供 C/C++ 语言支持，包括智能提示和调试功能等。 推荐安装插件：C/C++ Extension Pack –&gt; Popular extensions for C++ development in Visual Studio Code（插件合集包，包含了所有 C/C++ 开发中可能用的流行插件）. 2 –&gt; 其他可选扩展： Include Autocomplete：提供 C/C++ 头文件名字的补全功能； C/C++ Snippets：提供 C/C++ 重用代码块（Snippets）支持（最新 VSCode 中已集成有 Snippets 支持）。 3 –&gt; 不建议/不需要装的扩展： GBKtoUTF8：把 GBK 编码的文档转换成 UTF8 编码的。此扩展可能有严重的 Bug； C++ Intellisense：使用全局 GUN 工具为 C/C++ 提供智能提示； 创建工程文件夹VScode 是以文件夹的形式来组织管理工程项目的。 故，首先你需要创建一个用来存放整个工程代码的文件夹也被称为 【工作目录】，这里我的为：CppProjectWSC。 注意：工作目录路径中不能含有中文和空格和引号。 然后通过 VSCode 打开该文件夹【File –&gt; Open Floder 或使用快捷键 Ctrl + K + O】，选择刚才创建的那个文件夹即可。 事实上，此时你就可以将 VSCode 作为编辑器进行 C/C++ 源码学习和编写了。 Reffs Configuration打起精神，重点来了…. 如果你只是将 VSCode 作为一个编辑器使用，那么上述就够了，当然这不是我们的目的。 再一次重申：VS Code 只是一个编辑器，并不是 IDE。 我们的目的是：想要在 VSCode 中直接使用 Code Runner 进行 C/C++ 代码的编写测试或者完成代码的 Debug（断点测试）功能，那么你还需要进行额外的配置。 需要配置那些？？？ 配置一个 C/C++ 编译器：你需要确定当前系统环境下确保有一个可以用来编译 C/C++ 的编译器； 配置工程文件夹：你需要使用 VSCode 设置规则在工程文件夹中进行一些配置，以可以帮助我们完成一键构建（编译、链接等）、运行…… 但由于编译器以及 VSCode 中的配置，在不同平台下（Windows &amp; Linux）的具体细节存在一定的差异，下面将分为两部分内容分别介绍： For Windows For Linux 你可以直接选择你关注平台的配置，这两部分内容是独立完整的。 For Windows先进行 Windows 平台下 C/C++ 编译器的选择，安装以及配置： 1 –&gt; 配置 C/C++ 编译器：MinGW-w64 MinGW-w64 的全称是：Minimalist GNU on Windows-win64bit，是 GCC 的 Windows 64bit 版本，可以编译生成 64bit 或 32bit 可执行程序。并且 MinGW-w64 是稳定可靠的、持续更新的 C/C++ 编译器，值得信赖！ 所以，这里选择安装以及配置 MinGW-w64 作为 Window 平台下 C/C++ 的编译器。 1.1 –&gt; Download 这里先给出 MinGW-w64 的托管网站，通过这里 –&gt; 传送门 你可以获得其安装包。 这里提供两种安装方式： 在线安装器方式安装：MinGW-W64 Online Installer 某版本的现成安装包方式安装：例如，x86_64-posix-seh，版本选择可参看下文 1.2.1 中版本选择说明。 下载过程中可能由于网络问题导致安装包无法下载，例如，下载页面已经跳转但没有跳出下载安装包保存窗口，这时你可以尝试： 等待网络变好后，重新刷新网页； 寻找 【mirror】 或者 【Probloms Downloading？】 选择一个较近的镜像网站，可能会获得较高（无法保证）的下载速度； 基于上述两种尝试，两种安装方式对应的安装链接都尝试下 1.2 –&gt; Setup 分别来看两种安装方式： 1.2.1 –&gt; 在线安装器方式进行安装 安装选项： 选项说明： 名称 解释 可选项 说明 选择建议 Version 版本号 无需求选择最新 Architecture 架构 i686, x86_64 64位系统选择 x86_64, 32位系统选择 i686 x86_64 Threads 线程模式 posix, win32 Windows 平台选 win32, 其它选 posix win32 Exception 异常处理 x86_64:sjlj,seh; i686:sjlj,dwarf sjlj同时支持32bit &amp; 64bit，稳定性好；seh 和 dwarf 只分别支持 64bit，32bit，但性能好 seh Build revision 构建版本号 0 【Next】 之后，你可以自定义 MinGW-w64 的安装目录。 下面来看第二种安装方式 &gt;&gt;&gt;&gt; 1.2.2 –&gt; 某版本的现成安装包方式安装 下载相应的安装包，具体版本选择可参考上表，选择合适位置解压（保证路径中没有空格的目录）即可。 1.3 –&gt; Config Envs-var MinGW-w64 安装好之后，需要检查是否已添加环境变量。 你可以尝试如下命令判断是否已经自动添加了环境变量（DOS）： 1$ g++ --version 如果没有 g++ 的版本输出信息，说明需要添加环境变量： 将 MinGW-w64 安装包目录下的 bin 文件夹添加至 path 添加后查看（g++ &amp;&amp; gcc）： 1234567891011&gt; g++ --versiong++ (x86_64-posix-seh-rev0, Built by MinGW-W64 project) 8.1.0Copyright (C) 2018 Free Software Foundation, Inc.This is free software; see the source for copying conditions. There is NOwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.&gt; gcc --versiongcc (x86_64-posix-seh-rev0, Built by MinGW-W64 project) 8.1.0Copyright (C) 2018 Free Software Foundation, Inc.This is free software; see the source for copying conditions. There is NOwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 至此，C/C++ 编译器：MinGW-w64 的安装以及配置已经完成了~~~ 解决了编译器的问题后，接着看如何完成后续的 VSCode 配置： &gt;&gt;&gt;&gt; 2 –&gt; 配置工程文件夹 前面提到过，需要使用 VSCode 设置规则在工程文件夹中进行一些配置，以可以帮助我们完成一键构建（编译、链接等）、运行…… 事实上，这总共会涉及到 4 个配置文件： 1234567891011# launch.json# tasks.json# settings.json# c_cpp_properties.json&gt;&gt;&gt; 注意：# VSCode 单次运行一个脚本视为一个 task，相应任务的配置文件为 tasks.json；# settings.json 为上面我们创建的工程文件夹（工作区，CppProjectWSC）的配置文件；# launch.json 是调试环境的配置文件；# c_cpp_properties.json 主要是用来配置 C/C++ 引用库路径的。 在开始 【launch.json &amp; tasks.json &amp; settings.json &amp; c_cpp_properties.json】 配置之前，你应该知道： 你可以选择直接在当前工程文件夹（CppProjectWSC）下创建一个 .vscode 文件夹，作为工程文件夹的环境配置目录，随后直接创建空白的上述四个文件，然后贴入你的配置内容，这是允许的。 但我们 不建议采用这种直接创建的方式，VSCode 直接提供了自动生成的方法，自动生成后你只需要修改或者添加一些你需要的配置就可以了。 2.1 –&gt; Go Start 我们将从 VSCode 中的 Debug（爬虫）功能入手，来完成整个配置过程。并且熟悉 VSCode 中 C/C++ 代码的编译、运行以及断点调试。 首先，点击“爬虫”按钮（或 Ctrl + Shift + D），打开 VSCode 中的 Debug（C/C++ 编译调试）界面观察一下： 下面正式开始配置 gcc 和 g++ 分别用于编译 C 和 C++: 2.1.1 –&gt; C 语言配置 开始配置之前，先给出一个 C 的实例代码方便后续的配置以及环境测试。在工程文件夹 CppProjectWSC 下创建一个名为 cTest.c 的 C 源码文件，内容为: 1234567891011121314151617181920212223/* * @Description: * @Author: TheNightIsYoung * @E-Mail: guojie0213_iit@163.com * @Date: 2017-09-26 11:07:21 * @LastEditors: TheNightIsYoung * @LastEditTime: 2019-09-26 11:20:28 */#include &lt;stdio.h&gt;int main(int argc, char const *argv[]){ /** * @Description: * @Func: VS Code Test * @Param: * @return: */ printf(&quot;Welcome to use VS Code.\\n&quot;); printf(&quot;This is a debug test.\\n&quot;); return 0;} 此时由于安装配置了编译器的原因，其实已经可以使用 Code Runner （Ctrl + Alt + N）运行 C 的代码了： 123[Running] cd &quot;e:\\VSCodeWorkS\\CPPProjectWSC\\&quot; &amp;&amp; gcc cTest.c -o cTest &amp;&amp; &quot;e:\\VSCodeWorkS\\CPPProjectWSC\\&quot;cTestWelcome to use VS Code.[Done] exited with code=0 in 0.684 seconds 完美~~~ 继续 ↓↓↓↓↓ 2.1.1-1 –&gt; 配置调试设置 【Ctrl + Shift + D】 –&gt; F5（启动 Debug 调试功能），跳转出一个小命令框选择 【C++ (GDB/LLDB)】，然后你可以看到： 然后，我们选择：【gcc build and debug active file】，此时 VSCode 会自动在工作区中创建 .vscode，并且在 .vscode 目录下生成配置文件：launch.json，用来配置调试的相关信息。内容如下： 123456789101112131415161718192021222324252627282930313233343536{ // Use IntelliSense to learn about possible attributes. // Hover to view descriptions of existing attributes. // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387 &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ /* ------ GCC Launch For C ------ */ { &quot;name&quot;: &quot;(gdb) Launch&quot;, &quot;type&quot;: &quot;cppdbg&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;program&quot;: &quot;${fileDirname}\\\\${fileBasenameNoExtension}.exe&quot;, &quot;args&quot;: [], &quot;stopAtEntry&quot;: true, &quot;cwd&quot;: &quot;${workspaceFolder}&quot;, &quot;environment&quot;: [], &quot;externalConsole&quot;: false, &quot;MIMode&quot;: &quot;gdb&quot;, &quot;miDebuggerPath&quot;: &quot;F:\\\\MinWG64\\\\mingw64\\\\bin\\\\gdb.exe&quot;, &quot;setupCommands&quot;: [ { &quot;description&quot;: &quot;Enable pretty-printing for gdb&quot;, &quot;text&quot;: &quot;-enable-pretty-printing&quot;, &quot;ignoreFailures&quot;: true }, { &quot;description&quot;: &quot;Set Disassembly Flavor to Intel&quot;, &quot;text&quot;: &quot;-gdb-set disassembly-flavor intel&quot;, &quot;ignoreFailures&quot;: true } ], &quot;preLaunchTask&quot;: &quot;gcc build active file&quot; } ]} 可以检查默认生成 launch.json 内容是否和上述一样，否则新手需要保证一致（当然，miDebuggerPath 需要配置你自己的 gdb.exe 路径）。 配置好 launch.json 文件后（用来启动调试任务），此时你可以查看 .vscode 目录下是否生成 tasks.json ？ 如果有直接跳过这里开始后续配置，否则重新 –&gt; F5（启动 Debug 调试功能）此时可能会弹出窗口显示（很大可能）： 1Could not find the task 'gcc build active file' 提示你找不到 task gcc build active file，这时因为 task.json 文件不存在。 2.1.1-2 –&gt; 配置构建任务 此时菜单栏选择 【Terminal –&gt; Configure Task –&gt; Create task.json file from template –&gt; others】 便会自动完成 tasks.json 的创建，默认内容如下： 123456789101112{ // See https://go.microsoft.com/fwlink/?LinkId=733558 // for the documentation about the tasks.json format &quot;version&quot;: &quot;2.0.0&quot;, &quot;tasks&quot;: [ { &quot;label&quot;: &quot;echo&quot;, &quot;type&quot;: &quot;shell&quot;, &quot;command&quot;: &quot;echo Hello&quot; } ]} 此时需要我们来重新配置 tasks.json 文件，配置内容如下： 注意 command 要修改为你本地的 gcc.exe 路径；【options -&gt; cwd】 也需要修改为你本地的 MinWG64/bin 路径。 123456789101112131415161718192021222324252627282930{ // See https://go.microsoft.com/fwlink/?LinkId=733558 // for the documentation about the tasks.json format &quot;version&quot;: &quot;2.0.0&quot;, &quot;tasks&quot;: [ /* ------ Configure GCC Compiler For C ------ */ { &quot;label&quot;: &quot;gcc build active file&quot;, &quot;type&quot;: &quot;shell&quot;, &quot;command&quot;: &quot;F:\\\\MinWG64\\\\mingw64\\\\bin\\\\gcc.exe&quot;, &quot;args&quot;: [ &quot;-g&quot;, &quot;${file}&quot;, &quot;-o&quot;, &quot;${fileDirname}\\\\${fileBasenameNoExtension}.exe&quot; ], &quot;options&quot;: { &quot;cwd&quot;: &quot;F:\\\\MinWG64\\\\mingw64\\\\bin&quot; }, &quot;problemMatcher&quot;:[ &quot;$gcc&quot; ], &quot;group&quot;: { &quot;kind&quot;: &quot;build&quot;, &quot;isDefault&quot;: true } } ]} 对于 tasks.json 文件，是为了方便在 VScode 里编译 C/C++ 代码，可以将类似 g++ -g main.cpp 等 gcc/g++ 命令写入 VScode 的任务系统。 ======================================================================== 再来总结一下： launch.json 用来启动断点调试程序，其中有一个 ”preLaunchTask“=”gcc build active file&quot; ，也就是添加一个 launch（启动）的任务，任务名为 gcc build active file，这 gcc build active file 就是我们在 tasks.json 中设置的 lable（个人理解：也就是说 launch 通过 preLaunchTask 去 tasks.json 查找具体的编译任务，然后完成编译，链接，运行….）。 ======================================================================== 事实上，如果你仅仅编写 C 语言，到此 VS Code 已经能够满足你的要求。你可以尝试一下对上述给出的 C 源码进行断点调试（F5）。调试的两个快捷键与 Visual Studio 相同，F10 逐过程，F11 逐语句。 2.1.2 —&gt; C++ 语言配置 我们再来创建一个 C++ 源码文件（c++Test.py）用于完成后续 C++ 语言的配置与测试： 12345678910111213141516171819202122232425/* * @Description: * @Author: TheNightIsYoung * @E-Mail: * @Date: 2017-09-20 13:26:01 * @LastEditors: TheNightIsYoung * @LastEditTime: 2019-09-20 13:29:54 */#include &lt;iostream&gt;using namespace std;int main(int argc, char const *argv[]){ /** * @Description: * @Func: VSCode Test * @Param: * @return: */ cout &lt;&lt; &quot;Welcome to use VS Code.&quot; &lt;&lt; endl; return 0;} 此时由于安装配置了编译器的原因，其实已经可以使用 Code Runner （Ctrl + Alt + N）运行 C++ 的代码了： 1234[Running] cd &quot;e:\\VSCodeWorkS\\CPPProjectWSC\\&quot; &amp;&amp; g++ c++Test.cpp -o c++Test &amp;&amp; &quot;e:\\VSCodeWorkS\\CPPProjectWSC\\&quot;c++TestWelcome to use VS Code.[Done] exited with code=0 in 0.515 seconds 完美~~~ 继续 ↓↓↓↓↓ 2.1.2-1 –&gt; 配置调试设置 继续配置 C++ 的断点调试，参照前面已经生成的 C 的配置： 先来打开之前配置 C 语言的 launch.json，点击页面右下角的【Add Configuration】，选择【（gdb）launch】，可以看到为我们生成的一个新的调试方式: 123456789101112131415161718192021222324252627&quot;configurations&quot;: [ { &quot;name&quot;: &quot;(gdb) Launch&quot;, &quot;type&quot;: &quot;cppdbg&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;program&quot;: &quot;enter program name, for example ${workspaceFolder}/a.exe&quot;, &quot;args&quot;: [], &quot;stopAtEntry&quot;: false, &quot;cwd&quot;: &quot;${fileDirname}&quot;, &quot;environment&quot;: [], &quot;externalConsole&quot;: false, &quot;MIMode&quot;: &quot;gdb&quot;, &quot;miDebuggerPath&quot;: &quot;/path/to/gdb&quot;, &quot;setupCommands&quot;: [ { &quot;description&quot;: &quot;Enable pretty-printing for gdb&quot;, &quot;text&quot;: &quot;-enable-pretty-printing&quot;, &quot;ignoreFailures&quot;: true }, { &quot;description&quot;: &quot;Set Disassembly Flavor to Intel&quot;, &quot;text&quot;: &quot;-gdb-set disassembly-flavor intel&quot;, &quot;ignoreFailures&quot;: true } ] }, 对比着之前的 gcc 调试方式，我们需要修改一点细节，从之前生成的信息复制过来修改 launch.json，主要修改这几个选项： –&gt; 1] program 1${fileDirname}\\\\${fileBasenameNoExtension}.exe –&gt; 2] miDebuggerPath 1复制之前的路径 –&gt; 3] stopAtEntry 1true –&gt; 4] 添加 preLaunchTask 1&quot;preLaunchTask&quot;: &quot;g++ build active file&quot;, 然后，修改一下两个启动器名称（name 重复了），完成后的 launch.json 变为如下： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980{ // Use IntelliSense to learn about possible attributes. // Hover to view descriptions of existing attributes. // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387 &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ /* ------ G++ Launch For C/C++ ------ */ { &quot;name&quot;: &quot;(G++) Launch&quot;, // 配置名称：将会在启动配置的下拉菜单中显示; &quot;type&quot;: &quot;cppdbg&quot;, // 配置类型: 使用 GDB 或 LLDB 时只能是 cppdbg； &quot;request&quot;: &quot;launch&quot;, // 请求配置类型: 可以设置为 launch（启动）或 attach（附加）； &quot;program&quot;: &quot;${fileDirname}/${fileBasenameNoExtension}.exe&quot;, // 设置将要进行调试的程序的路径； &quot;args&quot;: [], // 程序调试时传递给程序的命令行参数，一般设为空即可； &quot;stopAtEntry&quot;: false, // 设为 true 时，程序将暂停在程序入口处，一般设置为 false； &quot;cwd&quot;: &quot;${workspaceFolder}&quot;, // 调试程序时的工作目录：一般设置为 ${workspaceRoot}，即代码所在目录（工作区）； &quot;environment&quot;: [], // 设置调试时添加到程序环境中的环境变量，例如: [ { &quot;name&quot;: &quot;squid&quot;, &quot;value&quot;: &quot;clam&quot; } ]； &quot;externalConsole&quot;: false, // 调试时是否显示控制台窗口：一般设置为 true，显示控制台； &quot;windows&quot;: { // For Windows &quot;MIMode&quot;: &quot;gdb&quot;, // 指定连接的调试器：可以为 gdb 或 lldb（但目前 lldb 在 Windows下没有预编译好的版本）； &quot;miDebuggerPath&quot;: &quot;F:/MinWG64/mingw64/bin/gdb.exe&quot; // 调试器（miDebugger）路径，注意 Windows 下这里要与 MinGw 的路径对应； }, &quot;linux&quot;: { // For Linux &quot;MIMode&quot;: &quot;gdb&quot;, // 指定连接的调试器：可以为 gdb 或 lldb（但目前 lldb 在 Windows下没有预编译好的版本）； &quot;miDebuggerPath&quot;: &quot;/usr/bin/gdb&quot; // 调试器（miDebugger）路径，注意 Windows 下这里要与 MinGw 的路径对应； }, &quot;setupCommands&quot;: [ // 执行下面的命令数组以设置 GDB 或 LLDB { &quot;description&quot;: &quot;Enable pretty-printing for gdb&quot;, &quot;text&quot;: &quot;-enable-pretty-printing&quot;, &quot;ignoreFailures&quot;: true }, { &quot;description&quot;: &quot;Set Disassembly Flavor to Intel&quot;, &quot;text&quot;: &quot;-gdb-set disassembly-flavor intel&quot;, &quot;ignoreFailures&quot;: true } ], &quot;logging&quot;: { // 用于设置：将哪些类型的消息记录到调试控制台。 &quot;exceptions&quot;: true, // 是否应将异常消息记录到调试控制台,默认为 true； &quot;moduleLoad&quot;: true, // 是否应将模块加载事件记录到调试控制台，默认为 true； &quot;programOutput&quot;: true, // 是否应将程序输出记录到调试控制台的可选标志，默认为 true； &quot;engineLogging&quot;: false, // 是否应将诊断引擎日志记录到调试控制台，默认为 false； &quot;trace&quot;: false, // 是否将诊断适配器命令跟踪记录到调试控制台，默认为 false； &quot;traceResponse&quot;: false // 是否将诊断适配器命令和响应跟踪记录到调试控制台，默认为 false。 }, &quot;preLaunchTask&quot;: &quot;g++ build active file&quot; // 设置调试会话开始前将执行的任务：一般为编译程序（例如 C++：g++.exe, C：gcc.exe），与 tasks.json 的 label 相对应; }, /* ------ GCC Launch For C ------ */ { &quot;name&quot;: &quot;(GCC) Launch&quot;, &quot;type&quot;: &quot;cppdbg&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;program&quot;: &quot;${fileDirname}/${fileBasenameNoExtension}.exe&quot;, &quot;args&quot;: [], &quot;stopAtEntry&quot;: true, &quot;cwd&quot;: &quot;${workspaceFolder}&quot;, &quot;environment&quot;: [], &quot;externalConsole&quot;: false, &quot;MIMode&quot;: &quot;gdb&quot;, &quot;miDebuggerPath&quot;: &quot;F:/MinWG64/mingw64/bin/gdb.exe&quot;, &quot;setupCommands&quot;: [ { &quot;description&quot;: &quot;Enable pretty-printing for gdb&quot;, &quot;text&quot;: &quot;-enable-pretty-printing&quot;, &quot;ignoreFailures&quot;: true }, { &quot;description&quot;: &quot;Set Disassembly Flavor to Intel&quot;, &quot;text&quot;: &quot;-gdb-set disassembly-flavor intel&quot;, &quot;ignoreFailures&quot;: true } ], &quot;preLaunchTask&quot;: &quot;gcc build active file&quot; } ]} 2.1.1-2 –&gt; 配置构建任务 然后我们打开 task.json，按照之前生成的 gcc 编译命令，添加 g++ 编译命令。只需将之前的复制过来一份更改以下项目就行: –&gt; 1] label 1将 gcc build active file 改为：g++ build active file –&gt; 2] command 1将之前的调试编译器由 &quot;gcc&quot; 改为：&quot;g++&quot; 完成后的 task.json 配置文件： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253{ // See https://go.microsoft.com/fwlink/?LinkId=733558 // for the documentation about the tasks.json format &quot;version&quot;: &quot;2.0.0&quot;, &quot;tasks&quot;: [ /* ------ Configure G++ Compiler For C ------ */ { &quot;label&quot;: &quot;g++ build active file&quot;, // 任务名称：被启动器 Launch 调用，与 launch.json 的 preLaunchTask 设置项相对应； &quot;type&quot;: &quot;shell&quot;, // { shell | process } &quot;command&quot;: &quot;F:/MinWG64/mingw64/bin/g++.exe&quot;, // 设置调试时使用的编译器： 这里设置为 G++，用于编译 C++ 语言； &quot;args&quot;: [ &quot;-g&quot;, // 生成和调试有关的信息; &quot;${file}&quot;, &quot;-o&quot;, // 设置编译后输出的文件名：默认输出 a.exe; &quot;${fileDirname}/${fileBasenameNoExtension}.exe&quot; ], &quot;options&quot;: { &quot;cwd&quot;: &quot;F:/MinWG64/mingw64/bin&quot; }, &quot;problemMatcher&quot;:[ &quot;$gcc&quot; ], &quot;group&quot;: { // 用于定义此任务属于的执行组 &quot;kind&quot;: &quot;build&quot;, // { build | test } &quot;isDefault&quot;: true // { true | false } } }, /* ------ Configure GCC Compiler For C ------ */ { &quot;label&quot;: &quot;gcc build active file&quot;, &quot;type&quot;: &quot;shell&quot;, &quot;command&quot;: &quot;F:/MinWG64/mingw64/bin/gcc.exe&quot;, &quot;args&quot;: [ &quot;-g&quot;, &quot;${file}&quot;, &quot;-o&quot;, &quot;${fileDirname}/${fileBasenameNoExtension}.exe&quot; ], &quot;options&quot;: { &quot;cwd&quot;: &quot;F:/MinWG64/mingw64/bin&quot; }, &quot;problemMatcher&quot;:[ &quot;$gcc&quot; ], &quot;group&quot;: { &quot;kind&quot;: &quot;build&quot;, &quot;isDefault&quot;: true } } ]} 至此，回到我们的调试界面（Debug），已经可以看到启动条目里面具有 g++/gcc 调试选项，你可以再尝试一下对上述给出的 C++ 源码进行断点调试（F5）。 好了，你的 VS Code（Windows）已经可以同时编译调试 C/C++ ~ 你应该还没忘了之前说过的有 4 个文件进行配置吧？余下的两个配置文件与 C/C++（库引用、C 标准等）以及一些工作区设置相关。 话不多说，开始配置： 2.1.1-3 –&gt; 配置单文件夹工作区设置（settings.json） VSCode 通过 用户（User） 和 工作区（Workspace） 设置来实现高度可配置化。用户设置是全局的，但单文件夹的工作区的设置（.vscode/settings.json）是针对项目进行独立设置的，它会覆盖用户设置，你可以在其中进行当前项目的个性化设置。 换句话说，你可以在 settings.json 中针对当前工程项目类别（C++ or Java？）进行远超符合你代码书写习惯的设置，例如配置 Tab 空格数、自动保存、自动格式化等等。 如何自动生成 settings.json 文件？？？ &gt;&gt;&gt;&gt;&gt; 打开 VSCode 设置页面（Ctrl + ,），切换到 Workspace，在配置项中随便找一个 Edit in settings.json 打开，即可在 .vscode 下自动生成 settings.json 文件。如果你已经针对工作区进行过配置，settings.json 是不为空的，否则应该是一个空白的文件。 这里给一个样例配置（你可以根据个人需要进行设置）： 1234567891011121314151617181920212223242526272829303132{ &quot;files.autoSave&quot;: &quot;onWindowChange&quot;, // 文件自动保存选项；参数说明：onFocusChange =&gt; 当前文件失去焦点后自动保存; onWindowChange =&gt; 需要当前 VScode 窗口失去焦点才会自动保存 &quot;files.autoSaveDelay&quot;: 3000, // 间隔多少毫秒自动保存，默认「1000毫秒」;如果配置了保存格式化代码，这个配置下自动保存不会格式化代码 &quot;editor.tabSize&quot;: 4, // 配置 Tab 空格数 &quot;editor.formatOnSave&quot;: false, // 保存自动格式化代码 &quot;editor.formatOnPaste&quot;: true, // 粘贴自动格式化 &quot;code-runner.runInTerminal&quot;: false, // 设置成 false 会在 “output” 中进行输出，无法输入； &quot;code-runner.executorMap&quot;: { &quot;c&quot;: &quot;cd $dir &amp;&amp; gcc $fileName -o $fileNameWithoutExt &amp;&amp; $dir$fileNameWithoutExt&quot;, &quot;cpp&quot;: &quot;cd $dir &amp;&amp; g++ $fileName -o $fileNameWithoutExt &amp;&amp; $dir$fileNameWithoutExt&quot; }, &quot;code-runner.saveFileBeforeRun&quot;: true, // Run Code 前保存； &quot;code-runner.preserveFocus&quot;: true, // 若为 false，Run code 后光标会聚焦到终端上。如果需要频繁输入数据可设为 false； &quot;code-runner.clearPreviousOutput&quot;: true, // 每次 Run code 前清空终端中属于之前 Code runner 的日志消息； &quot;C_Cpp.clang_format_sortIncludes&quot;: true, // 格式化时调整 include 的顺序（按字母排序）; &quot;C_Cpp.intelliSenseEngine&quot;: &quot;Default&quot;, // 可以为 Default 或 Tag Parser，后者较老，功能较简单。具体差别参考 cpptools 扩展文档； &quot;C_Cpp.errorSquiggles&quot;: &quot;Disabled&quot;, &quot;C_Cpp.autocomplete&quot;: &quot;Default&quot;, &quot;files.associations&quot;: { &quot;iostream&quot;: &quot;cpp&quot;, &quot;exit-thread.h&quot;: &quot;c&quot;, &quot;ldsodefs.h&quot;: &quot;c&quot;, &quot;random&quot;: &quot;cpp&quot;, &quot;tls.h&quot;: &quot;c&quot;, &quot;dl-osinfo.h&quot;: &quot;c&quot;, &quot;stdio.h&quot;: &quot;c&quot; }} 2.1.1-4 –&gt; 配置 C/C++ 引用库路径（c_cpp_properties.json） Ctrl + Shift + P 调出命令控制窗口，再输入 edit 或者 configuration，选择 &quot;C/C++:Edit Configurations(JSON)&quot;，然后这个文件就出来了，默认配置如下： 1234567891011121314151617181920{ &quot;configurations&quot;: [ { &quot;name&quot;: &quot;Win32&quot;, &quot;includePath&quot;: [ &quot;${workspaceFolder}/**&quot; ], &quot;defines&quot;: [ &quot;_DEBUG&quot;, &quot;UNICODE&quot;, &quot;_UNICODE&quot; ], &quot;compilerPath&quot;: &quot;F:\\\\MinWG64\\\\mingw64\\\\bin\\\\gcc.exe&quot;, &quot;cStandard&quot;: &quot;gnu17&quot;, &quot;cppStandard&quot;: &quot;gnu++14&quot;, &quot;intelliSenseMode&quot;: &quot;windows-gcc-x64&quot; } ], &quot;version&quot;: 4} 注意，该配置文件中不允许有注释!!! 你需要将 C/C++ 开发可能用到的引用库路径设置进来，添加到 includePath 选项中即可。 支持自动查询，includePath 中需要添加的路径获取方法：cmd ——&gt; gcc -v -E -x c++ -，搜索结果如下： 给出 c_cpp_properties.json 最终的配置内容（注意 brower 选项）: 123456789101112131415161718192021222324252627282930313233343536373839404142{ &quot;configurations&quot;: [ { &quot;name&quot;: &quot;Win32&quot;, &quot;includePath&quot;: [ &quot;${workspaceFolder}/**&quot;, &quot;F:/MinWG64/mingw64/include&quot;, &quot;F:/MinWG64/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++&quot;, &quot;F:/MinWG64/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/x86_64-w64-mingw32&quot;, &quot;F:/MinWG64/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/backward&quot;, &quot;F:/MinWG64/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/8.1.0/include&quot;, &quot;F:/MinWG64/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/8.1.0/include-fixed&quot;, &quot;F:/MinWG64/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/8.1.0/../../../../x86_64-w64-mingw32/include&quot; ], &quot;defines&quot;: [ &quot;_DEBUG&quot;, &quot;UNICODE&quot;, &quot;_UNICODE&quot; ], &quot;compilerPath&quot;: &quot;F:\\\\MinWG64\\\\mingw64\\\\bin\\\\gcc.exe&quot;, &quot;cStandard&quot;: &quot;gnu17&quot;, &quot;cppStandard&quot;: &quot;gnu++14&quot;, &quot;intelliSenseMode&quot;: &quot;windows-gcc-x64&quot;, &quot;browse&quot;: { &quot;limitSymbolsToIncludedHeaders&quot;: true, &quot;databaseFilename&quot;: &quot;&quot;, &quot;path&quot;: [ &quot;${workspaceFolder}/**&quot;, &quot;F:/MinWG64/mingw64/include&quot;, &quot;F:/MinWG64/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++&quot;, &quot;F:/MinWG64/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/x86_64-w64-mingw32&quot;, &quot;F:/MinWG64/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/8.1.0/include/c++/backward&quot;, &quot;F:/MinWG64/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/8.1.0/include&quot;, &quot;F:/MinWG64/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/8.1.0/include-fixed&quot;, &quot;F:/MinWG64/mingw64/bin/../lib/gcc/x86_64-w64-mingw32/8.1.0/../../../../x86_64-w64-mingw32/include&quot; ] } } ], &quot;version&quot;: 4} For Linux接下来，来看 Linux 平台下 C/C++ 编译器的选择，安装以及配置（大同小异）： 1 –&gt; 配置 C/C++ 编译器：gcc &amp;&amp; g++ 对于 Centos（ Centos7.2）而言，安装后可能是没有 C 语言和 C++ 编译环境的，故需要手动安装（yum）GCC/g++（安装前你可以通过 gcc/g++ --version 测试一下是否已安装过）： 1234# GCC$ yum -y install gcc# g++$ yum -y install gcc-c++ 而对于 Ubuntu（ Ubuntu16.04 Check），系统中默认已安装有 GCC/g++，你可以查看当前版本： 1234567891011deeplearning@ThinkCentre-M910s-N000:~/DeepLearning$ gcc --versiongcc (Ubuntu 5.4.0-6ubuntu1~16.04.11) 5.4.0 20160609Copyright (C) 2015 Free Software Foundation, Inc.This is free software; see the source for copying conditions. There is NOwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.deeplearning@ThinkCentre-M910s-N000:~/DeepLearning$ g++ --versiong++ (Ubuntu 5.4.0-6ubuntu1~16.04.11) 5.4.0 20160609Copyright (C) 2015 Free Software Foundation, Inc.This is free software; see the source for copying conditions. There is NOwarranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 解决了编译器的问题后，接着看如何完成后续的 VSCode 配置： &gt;&gt;&gt;&gt; 2 –&gt; 配置工程文件夹 前面提到过，需要使用 VSCode 设置规则在工程文件夹中进行一些配置，以可以帮助我们完成一键构建（编译、链接等）、运行…… 事实上，这总共会涉及到 4 个配置文件： 1234567891011# launch.json# tasks.json# settings.json# c_cpp_properties.json&gt;&gt;&gt; 注意：# VSCode 单次运行一个脚本视为一个 task，相应任务的配置文件为 tasks.json；# settings.json 为上面我们创建的工程文件夹（工作区，CppProjectWSC）的配置文件；# launch.json 是调试环境的配置文件；# c_cpp_properties.json 主要是用来配置 C/C++ 引用库路径的。 在开始 【launch.json &amp; tasks.json &amp; settings.json &amp; c_cpp_properties.json】 配置之前，你应该知道： 你可以选择直接在当前工程文件夹（CppProjectWSC）下创建一个 .vscode 文件夹，作为工程文件夹的环境配置目录，随后直接创建空白的上述四个文件，然后贴入你的配置内容，这是允许的。 但我们 不建议采用这种直接创建的方式，VSCode 直接提供了自动生成的方法，自动生成后你只需要修改或者添加一些你需要的配置就可以了。 2.1 –&gt; Go Start 我们将从 VSCode 中的 Debug（爬虫）功能入手，来完成整个配置过程。并且熟悉 VSCode 中 C/C++ 代码的编译、运行以及断点调试。 首先，点击“爬虫”按钮（或 Ctrl + Shift + D），打开 VSCode 中的 Debug（C/C++ 编译调试）界面观察一下： 下面正式开始配置 gcc 和 g++ 分别用于编译 C 和 C++: 2.1.1 –&gt; C 语言配置 开始配置之前，先给出一个 C 的实例代码方便后续的配置以及环境测试。在工程文件夹 CppProjectWSC 下创建一个名为 cTest.c 的 C 源码文件，内容为: 1234567891011121314151617181920212223/* * @Description: * @Author: TheNightIsYoung * @E-Mail: guojie0213_iit@163.com * @Date: 2017-09-26 11:07:21 * @LastEditors: TheNightIsYoung * @LastEditTime: 2019-09-26 11:20:28 */#include &lt;stdio.h&gt;int main(int argc, char const *argv[]){ /** * @Description: * @Func: VS Code Test * @Param: * @return: */ printf(&quot;Welcome to use VS Code.\\n&quot;); printf(&quot;This is a debug test.\\n&quot;); return 0;} 此时由于安装配置了编译器的原因，其实已经可以使用 Code Runner （Ctrl + Alt + N）运行 C 的代码了： 1Welcome to use VS Code. 完美~~~ 继续 ↓↓↓↓↓ 2.1.1-1 –&gt; 配置调试设置 【Ctrl + Shift + D】 –&gt; F5（启动 Debug 调试功能），跳转出一个小命令框选择 【C++ (GDB/LLDB)】，然后你可以看到： 然后，我们选择：【gcc build and debug active file】，此时 VSCode 会自动在工作区中创建 .vscode，并且在 .vscode 目录下生成配置文件：launch.json，用来配置调试的相关信息。内容如下： 123456789101112131415161718192021222324252627282930{ // Use IntelliSense to learn about possible attributes. // Hover to view descriptions of existing attributes. // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387 &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ /* ------ GCC Launch For C ------ */ { &quot;name&quot;: &quot;gcc build and debug active file&quot;, &quot;type&quot;: &quot;cppdbg&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;program&quot;: &quot;${fileDirname}/${fileBasenameNoExtension}.out&quot;, &quot;args&quot;: [], &quot;stopAtEntry&quot;: true, &quot;cwd&quot;: &quot;${workspaceFolder}&quot;, &quot;environment&quot;: [], &quot;externalConsole&quot;: false, &quot;MIMode&quot;: &quot;gdb&quot;, &quot;setupCommands&quot;: [ { &quot;description&quot;: &quot;Enable pretty-printing for gdb&quot;, &quot;text&quot;: &quot;-enable-pretty-printing&quot;, &quot;ignoreFailures&quot;: true } ], &quot;preLaunchTask&quot;: &quot;gcc build active file&quot;, &quot;miDebuggerPath&quot;: &quot;/usr/bin/gdb&quot; } ]} 可以检查默认生成 launch.json 内容是否和上述一样，否则新手需要保证一致（当然，miDebuggerPath 需要配置你自己的 gdb 路径）。 配置好 launch.json 文件后（用来启动调试任务），此时你可以查看 .vscode 目录下是否生成 tasks.json？ 如果有直接跳过这里开始后续配置，否则重新 –&gt; F5（启动 Debug 调试功能）此时可能会弹出窗口显示（很大可能）： 1Could not find the task 'gcc build active file' 提示你找不到 task gcc build active file，这时因为 task.json 文件不存在。 2.1.1-2 –&gt; 配置构建任务 此时菜单栏选择 【Terminal –&gt; Configure Task –&gt; Create task.json file from template –&gt; others】 便会自动完成 tasks.json 的创建，默认内容如下： 123456789101112{ // See https://go.microsoft.com/fwlink/?LinkId=733558 // for the documentation about the tasks.json format &quot;version&quot;: &quot;2.0.0&quot;, &quot;tasks&quot;: [ { &quot;label&quot;: &quot;echo&quot;, &quot;type&quot;: &quot;shell&quot;, &quot;command&quot;: &quot;echo Hello&quot; } ]} 此时需要我们来重新配置 tasks.json 文件，配置内容如下： 注意 command 要修改为你本地的 gcc 路径；【options -&gt; cwd】 也需要修改为你本地的 gcc/bin 路径。 123456789101112131415161718192021222324{ &quot;tasks&quot;: [ /* ------ Configure GCC Compiler For C ------ */ { &quot;type&quot;: &quot;shell&quot;, &quot;label&quot;: &quot;gcc build active file&quot;, &quot;command&quot;: &quot;/usr/bin/gcc&quot;, &quot;args&quot;: [ &quot;-g&quot;, &quot;${file}&quot;, &quot;-o&quot;, &quot;${fileDirname}/${fileBasenameNoExtension}.out&quot; ], &quot;options&quot;: { &quot;cwd&quot;: &quot;/usr/bin&quot; }, &quot;group&quot;: { &quot;kind&quot;: &quot;build&quot;, &quot;isDefault&quot;: true } } ], &quot;version&quot;: &quot;2.0.0&quot;} 对于 tasks.json 文件，是为了方便在 VScode 里编译 C/C++ 代码，可以将类似 g++ -g main.cpp 等 gcc/g++ 命令写入 VScode 的任务系统。 ======================================================================== 再来总结一下： launch.json 用来启动断点调试程序，其中有一个 ”preLaunchTask“=”gcc build active file&quot; ，也就是添加一个 launch（启动）的任务，任务名为 gcc build active file，这 gcc build active file 就是我们在 tasks.json 中设置的 lable（个人理解：也就是说 launch 通过 preLaunchTask 去 tasks.json 查找具体的编译任务，然后完成编译，链接，运行….）。 ======================================================================== 事实上，如果你仅仅编写 C 语言，到此 VS Code 已经能够满足你的要求。你可以尝试一下对上述给出的 C 源码进行断点调试（F5）。调试的两个快捷键与 Visual Studio 相同，F10 逐过程，F11 逐语句。 2.1.2 —&gt; C++ 语言配置 我们再来创建一个 C++ 源码文件（c++Test.py）用于完成后续 C++ 语言的配置与测试： 12345678910111213141516171819202122232425/* * @Description: * @Author: TheNightIsYoung * @E-Mail: * @Date: 2017-09-20 13:26:01 * @LastEditors: TheNightIsYoung * @LastEditTime: 2019-09-20 13:29:54 */#include &lt;iostream&gt;using namespace std;int main(int argc, char const *argv[]){ /** * @Description: * @Func: VSCode Test * @Param: * @return: */ cout &lt;&lt; &quot;Welcome to use VS Code.&quot; &lt;&lt; endl; return 0;} 此时由于安装配置了编译器的原因，其实已经可以使用 Code Runner （Ctrl + Alt + N）运行 C++ 的代码了： 1Welcome to use VS Code. 完美~~~ 继续 ↓↓↓↓↓ 2.1.2-1 –&gt; 配置调试设置 继续配置 C++ 的断点调试，参照前面已经生成的 C 的配置： 先来打开之前配置 C 语言的 launch.json，点击页面右下角的【Add Configuration】，选择【（gdb）launch】，可以看到为我们生成的一个新的调试方式: 1234567891011121314151617181920&quot;configurations&quot;: [ { &quot;name&quot;: &quot;(gdb) Launch&quot;, &quot;type&quot;: &quot;cppdbg&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;program&quot;: &quot;enter program name, for example ${workspaceFolder}/a.out&quot;, &quot;args&quot;: [], &quot;stopAtEntry&quot;: false, &quot;cwd&quot;: &quot;${workspaceFolder}&quot;, &quot;environment&quot;: [], &quot;externalConsole&quot;: false, &quot;MIMode&quot;: &quot;gdb&quot;, &quot;setupCommands&quot;: [ { &quot;description&quot;: &quot;Enable pretty-printing for gdb&quot;, &quot;text&quot;: &quot;-enable-pretty-printing&quot;, &quot;ignoreFailures&quot;: true } ] } 对比着之前的 gcc 调试方式，我们需要修改一点细节，从之前生成的信息复制过来修改 launch.json，主要修改这几个选项： –&gt; 1] program 1${fileDirname}/${fileBasenameNoExtension}.o –&gt; 2] miDebuggerPath 1复制之前的路径 –&gt; 3] stopAtEntry 1true –&gt; 4] 添加 preLaunchTask 1&quot;preLaunchTask&quot;: &quot;g++ build active file&quot;, 然后，修改一下两个启动器名称（name 重复了），完成后的 launch.json 变为如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970{ // Use IntelliSense to learn about possible attributes. // Hover to view descriptions of existing attributes. // For more information, visit: https://go.microsoft.com/fwlink/?linkid=830387 &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ /* ------ G++ Launch For C/C++ ------ */ { &quot;name&quot;: &quot;(G++) Launch&quot;, // 配置名称：将会在启动配置的下拉菜单中显示; &quot;type&quot;: &quot;cppdbg&quot;, // 配置类型: 使用 GDB 或 LLDB 时只能是 cppdbg； &quot;request&quot;: &quot;launch&quot;, // 请求配置类型: 可以设置为 launch（启动）或 attach（附加）； &quot;program&quot;: &quot;${fileDirname}/${fileBasenameNoExtension}.out&quot;, // 设置将要进行调试的程序的路径； &quot;args&quot;: [], // 程序调试时传递给程序的命令行参数，一般设为空即可； &quot;stopAtEntry&quot;: true, // 设为 true 时，程序将暂停在程序入口处，一般设置为 false； &quot;cwd&quot;: &quot;${workspaceFolder}&quot;, // 调试程序时的工作目录：一般设置为 ${workspaceRoot}，即代码所在目录（工作区）； &quot;environment&quot;: [], // 设置调试时添加到程序环境中的环境变量，例如: [ { &quot;name&quot;: &quot;squid&quot;, &quot;value&quot;: &quot;clam&quot; } ]； &quot;externalConsole&quot;: false, // 调试时是否显示控制台窗口：一般设置为 true，显示控制台； &quot;windows&quot;: { // For Windows &quot;MIMode&quot;: &quot;gdb&quot;, // 指定连接的调试器：可以为 gdb 或 lldb（但目前 lldb 在 Windows下没有预编译好的版本）； &quot;miDebuggerPath&quot;: &quot;D:\\\\...&quot;, // 调试器（miDebugger）路径，注意 Windows 下这里要与 MinGw 的路径对应； }, &quot;linux&quot;: { // For Linux &quot;MIMode&quot;: &quot;gdb&quot;, // 指定连接的调试器：可以为 gdb 或 lldb（但目前 lldb 在 Windows下没有预编译好的版本）； &quot;miDebuggerPath&quot;: &quot;/usr/bin/gdb&quot;, // 调试器（miDebugger）路径，注意 Windows 下这里要与 MinGw 的路径对应； }, &quot;setupCommands&quot;: [ // 执行下面的命令数组以设置 GDB 或 LLDB { &quot;description&quot;: &quot;Enable pretty-printing for gdb&quot;, &quot;text&quot;: &quot;-enable-pretty-printing&quot;, &quot;ignoreFailures&quot;: true } ], &quot;logging&quot;: { // 用于设置：将哪些类型的消息记录到调试控制台。 &quot;exceptions&quot;: true, // 是否应将异常消息记录到调试控制台,默认为 true； &quot;moduleLoad&quot;: false, // 是否应将模块加载事件记录到调试控制台，默认为 true； &quot;programOutput&quot;: true, // 是否应将程序输出记录到调试控制台的可选标志，默认为 true； &quot;engineLogging&quot;: false, // 是否应将诊断引擎日志记录到调试控制台，默认为 false； &quot;trace&quot;: false, // 是否将诊断适配器命令跟踪记录到调试控制台，默认为 false； &quot;traceResponse&quot;: false // 是否将诊断适配器命令和响应跟踪记录到调试控制台，默认为 false。 }, &quot;preLaunchTask&quot;: &quot;g++ build active file&quot; // 设置调试会话开始前将执行的任务：一般为编译程序（例如 C++：g++.exe, C：gcc.exe），与 tasks.json 的 label 相对应; }, /* ------ GCC Launch For C ------ */ { &quot;name&quot;: &quot;(GCC) Launch&quot;, &quot;type&quot;: &quot;cppdbg&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;program&quot;: &quot;${fileDirname}/${fileBasenameNoExtension}.out&quot;, &quot;args&quot;: [], &quot;stopAtEntry&quot;: true, &quot;cwd&quot;: &quot;${workspaceFolder}&quot;, &quot;environment&quot;: [], &quot;externalConsole&quot;: false, &quot;MIMode&quot;: &quot;gdb&quot;, &quot;setupCommands&quot;: [ { &quot;description&quot;: &quot;Enable pretty-printing for gdb&quot;, &quot;text&quot;: &quot;-enable-pretty-printing&quot;, &quot;ignoreFailures&quot;: true } ], &quot;preLaunchTask&quot;: &quot;gcc build active file&quot;, &quot;miDebuggerPath&quot;: &quot;/usr/bin/gdb&quot; } ]} 2.1.1-2 –&gt; 配置构建任务 然后我们打开 task.json，按照之前生成的 gcc 编译命令，添加 g++ 编译命令。只需将之前的复制过来一份更改以下项目就行: –&gt; 1] label 1将 gcc build active file 改为：g++ build active file –&gt; 2] command 1将之前的调试编译器由 &quot;gcc&quot; 改为：&quot;g++&quot; 完成后的 task.json 配置文件： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647{ &quot;tasks&quot;: [ /* ------ Configure G++ Compiler For C/C++ ------ */ { &quot;type&quot;: &quot;shell&quot;, // { shell | process } &quot;label&quot;: &quot;g++ build active file&quot;, // 任务名称：被启动器 Launch 调用，与 launch.json 的 preLaunchTask 设置项相对应； &quot;command&quot;: &quot;/usr/bin/g++&quot;, // 设置调试时使用的编译器： 这里设置为 GCC，用于编译 C 语言； /**编译命令参数设置：*/ &quot;args&quot;: [ &quot;-g&quot;, // 生成和调试有关的信息; &quot;${file}&quot;, &quot;-o&quot;, // 设置编译后输出的文件名：默认输出 a.o; &quot;${fileDirname}/${fileBasenameNoExtension}.out&quot; ], &quot;options&quot;: { &quot;cwd&quot;: &quot;/usr/bin&quot; }, &quot;group&quot;: { // 用于定义此任务属于的执行组 &quot;kind&quot;: &quot;build&quot;, // { build | test } &quot;isDefault&quot;: true // { true | false } } }, /* ------ Configure GCC Compiler For C ------ */ { &quot;type&quot;: &quot;shell&quot;, &quot;label&quot;: &quot;gcc build active file&quot;, &quot;command&quot;: &quot;/usr/bin/gcc&quot;, &quot;args&quot;: [ &quot;-g&quot;, &quot;${file}&quot;, &quot;-o&quot;, &quot;${fileDirname}/${fileBasenameNoExtension}.out&quot; ], &quot;options&quot;: { &quot;cwd&quot;: &quot;/usr/bin&quot; }, &quot;group&quot;: { &quot;kind&quot;: &quot;build&quot;, &quot;isDefault&quot;: true } } ], &quot;version&quot;: &quot;2.0.0&quot;} 至此，回到我们的调试界面（Debug），已经可以看到启动条目里面具有 g++/gcc 调试选项，你可以再尝试一下对上述给出的 C++ 源码进行断点调试（F5）。 好了，你的 VS Code（Linux）已经可以同时编译调试 C/C++ ~ 如果后续笔者需要其他语言开发环境的时候，笔者再进行相应的记录并分享出来。 首先先创建一个文件夹，用来存放代码。此处建议不同的编程语言采用不同的文件夹，因为VSCode打开文件夹（称作工作目录）之后，如果进行一定的配置之后，会在该文件夹下产生一个叫”.vscode”的文件夹，该文件夹中存放的是一些.json的配置文件，这些配置文件是对工作目录中的代码文件产生作用的。所以以后需要相同开发环境的时候，不用每次都去创建配置文件并进行相关配置，直接拷贝.vscode文件夹即可，但是第一次还是需要手动配置出自己所需的环境。","link":"/2017/08/01/visual-studio-code-vs-code-ni-men-du-zai-yong-ma/"}],"tags":[{"name":"Eclipse","slug":"Eclipse","link":"/tags/Eclipse/"},{"name":"Git","slug":"Git","link":"/tags/Git/"},{"name":"Github","slug":"Github","link":"/tags/Github/"},{"name":"Blog","slug":"Blog","link":"/tags/Blog/"},{"name":"Node.js","slug":"Node-js","link":"/tags/Node-js/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"Java Modifier","slug":"Java-Modifier","link":"/tags/Java-Modifier/"},{"name":"DataType","slug":"DataType","link":"/tags/DataType/"},{"name":"Variable","slug":"Variable","link":"/tags/Variable/"},{"name":"PyVers-Management","slug":"PyVers-Management","link":"/tags/PyVers-Management/"},{"name":"virtualenv","slug":"virtualenv","link":"/tags/virtualenv/"},{"name":"conda","slug":"conda","link":"/tags/conda/"},{"name":"Python","slug":"Python","link":"/tags/Python/"},{"name":"anaconda","slug":"anaconda","link":"/tags/anaconda/"},{"name":"Picture bed","slug":"Picture-bed","link":"/tags/Picture-bed/"},{"name":"Operator","slug":"Operator","link":"/tags/Operator/"},{"name":"prefix","slug":"prefix","link":"/tags/prefix/"},{"name":"IDE","slug":"IDE","link":"/tags/IDE/"}],"categories":[{"name":"Java","slug":"Java","link":"/categories/Java/"},{"name":"Git","slug":"Git","link":"/categories/Git/"},{"name":"Hexo","slug":"Hexo","link":"/categories/Hexo/"},{"name":"Markdown","slug":"Markdown","link":"/categories/Markdown/"},{"name":"Python","slug":"Python","link":"/categories/Python/"},{"name":"Anaconda","slug":"Anaconda","link":"/categories/Anaconda/"},{"name":"VSCode","slug":"VSCode","link":"/categories/VSCode/"}]}
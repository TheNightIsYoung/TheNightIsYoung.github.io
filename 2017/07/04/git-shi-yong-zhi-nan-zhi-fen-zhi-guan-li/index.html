<!doctype html>
<html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Git 使用指南之分支管理 - When Art Meets Tech</title><link rel="manifest" href="/manifest.json"><meta name="application-name" content="When Art Meets Tech"><meta name="msapplication-TileImage" content="/img/favicon.svg"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="When Art Meets Tech"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta description="Git 的分支管理。使用过 SVN 等其它版本控制系统的童鞋可能会说：“SVN 也有分支管理啊”。但由于创建和切换分支慢的一批…那么，Git 分支管理功能有性能提升吗？”。 当然有！Git 的分支是与众不同的。无论创建、切换和删除分支，Git 都能在 1 秒钟 之内就能完成！无论你的版本库是 1 个文件还是 1 万个文件。这种跟版本库大小无关的特性，到底是怎么做到的？？！。"><meta property="og:type" content="blog"><meta property="og:title" content="Git 使用指南之分支管理"><meta property="og:url" content="https://www.orangeshare.cn/2017/07/04/git-shi-yong-zhi-nan-zhi-fen-zhi-guan-li/"><meta property="og:site_name" content="When Art Meets Tech"><meta property="og:description" content="Git 的分支管理。使用过 SVN 等其它版本控制系统的童鞋可能会说：“SVN 也有分支管理啊”。但由于创建和切换分支慢的一批…那么，Git 分支管理功能有性能提升吗？”。 当然有！Git 的分支是与众不同的。无论创建、切换和删除分支，Git 都能在 1 秒钟 之内就能完成！无论你的版本库是 1 个文件还是 1 万个文件。这种跟版本库大小无关的特性，到底是怎么做到的？？！。"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/TheNightIsYoung/HexoImageBed0/Img/git_branch_imageDemo.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/TheNightIsYoung/HexoImageBed0/Img/git_branch_head.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/TheNightIsYoung/HexoImageBed0/Img/git_branch_diagram_all.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/TheNightIsYoung/HexoImageBed0/Img/git_branch_diagram0.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/TheNightIsYoung/HexoImageBed0/Img/git_branch_diagram1.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/TheNightIsYoung/HexoImageBed0/Img/git_branch_diagram2.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/TheNightIsYoung/HexoImageBed0/Img/git_branch_diagram3.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/TheNightIsYoung/HexoImageBed0/Img/git_branch_diagram4.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/TheNightIsYoung/HexoImageBed0/Img/git_branch_fast_forward.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/TheNightIsYoung/HexoImageBed0/Img/git_branch_fast_forward1.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/TheNightIsYoung/HexoImageBed0/Img/git_branch_recursive_strategy.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/TheNightIsYoung/HexoImageBed0/Img/git_branch_recursive_strategy1.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/TheNightIsYoung/HexoImageBed0/Img/git_branch_fast_forward2.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/TheNightIsYoung/HexoImageBed0/Img/git_branch_recursive_strategy2.png"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/TheNightIsYoung/HexoImageBed0/Img/git_quanliucheng_diagram.png"><meta property="article:published_time" content="2017-07-04T08:18:00.000Z"><meta property="article:modified_time" content="2022-03-08T05:42:20.235Z"><meta property="article:author" content="Waldeinsamkeit"><meta property="article:tag" content="Git"><meta property="article:tag" content="Github"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="https://cdn.jsdelivr.net/gh/TheNightIsYoung/HexoImageBed0/Img/git_branch_imageDemo.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.orangeshare.cn/2017/07/04/git-shi-yong-zhi-nan-zhi-fen-zhi-guan-li/"},"headline":"When Art Meets Tech","image":["https://cdn.jsdelivr.net/gh/TheNightIsYoung/HexoImageBed0/Img/git_branch_imageDemo.png","https://cdn.jsdelivr.net/gh/TheNightIsYoung/HexoImageBed0/Img/git_branch_head.png","https://cdn.jsdelivr.net/gh/TheNightIsYoung/HexoImageBed0/Img/git_branch_diagram_all.png","https://cdn.jsdelivr.net/gh/TheNightIsYoung/HexoImageBed0/Img/git_branch_diagram0.png","https://cdn.jsdelivr.net/gh/TheNightIsYoung/HexoImageBed0/Img/git_branch_diagram1.png","https://cdn.jsdelivr.net/gh/TheNightIsYoung/HexoImageBed0/Img/git_branch_diagram2.png","https://cdn.jsdelivr.net/gh/TheNightIsYoung/HexoImageBed0/Img/git_branch_diagram3.png","https://cdn.jsdelivr.net/gh/TheNightIsYoung/HexoImageBed0/Img/git_branch_diagram4.png","https://cdn.jsdelivr.net/gh/TheNightIsYoung/HexoImageBed0/Img/git_branch_fast_forward.png","https://cdn.jsdelivr.net/gh/TheNightIsYoung/HexoImageBed0/Img/git_branch_fast_forward1.png","https://cdn.jsdelivr.net/gh/TheNightIsYoung/HexoImageBed0/Img/git_branch_recursive_strategy.png","https://cdn.jsdelivr.net/gh/TheNightIsYoung/HexoImageBed0/Img/git_branch_recursive_strategy1.png","https://cdn.jsdelivr.net/gh/TheNightIsYoung/HexoImageBed0/Img/git_branch_fast_forward2.png","https://cdn.jsdelivr.net/gh/TheNightIsYoung/HexoImageBed0/Img/git_branch_recursive_strategy2.png","https://cdn.jsdelivr.net/gh/TheNightIsYoung/HexoImageBed0/Img/git_quanliucheng_diagram.png"],"datePublished":"2017-07-04T08:18:00.000Z","dateModified":"2022-03-08T05:42:20.235Z","author":{"@type":"Person","name":"Waldeinsamkeit"},"description":"Git 的分支管理。使用过 SVN 等其它版本控制系统的童鞋可能会说：“SVN 也有分支管理啊”。但由于创建和切换分支慢的一批…那么，Git 分支管理功能有性能提升吗？”。 当然有！Git 的分支是与众不同的。无论创建、切换和删除分支，Git 都能在 1 秒钟 之内就能完成！无论你的版本库是 1 个文件还是 1 万个文件。这种跟版本库大小无关的特性，到底是怎么做到的？？！。"}</script><link rel="canonical" href="https://www.orangeshare.cn/2017/07/04/git-shi-yong-zhi-nan-zhi-fen-zhi-guan-li/"><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/font-awesome/5.12.0/css/all.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/highlight.js/9.12.0/styles/atom-one-light.min.css"><link rel="stylesheet" href="https://fonts.loli.net/css2?family=Oxanium:wght@300;400;600&amp;family=Roboto+Mono"><link rel="stylesheet" href="/css/cyberpunk.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/cookieconsent/3.1.1/cookieconsent.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/css/justifiedGallery.min.css"><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/pace/1.0.2/pace.min.js"></script><!--!--><!--!--><meta name="generator" content="Hexo 5.2.0"></head>    <body class="is-3-column">    <nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="When Art Meets Tech" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Hexo Search" href="https://hexo.io/zh-cn/"><i class="fab fa-hotjar"></i></a><a class="navbar-item is-hidden-tablet catalogue" title="Catalogue" href="javascript:;"><i class="fas fa-list-ul"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-9-widescreen"><div class="card"><article class="card-content article" role="article"><h1 class="title is-size-3 is-size-4-mobile has-text-weight-normal"><i class="fas fa-angle-double-right"></i>Git 使用指南之分支管理</h1><div class="article-meta is-size-7 is-uppercase level is-mobile"><div class="level-left"><span class="level-item"><i class="far fa-calendar-alt"> </i><time dateTime="${date_xml(page.date)}" title="${date_xml(page.date)}">2017-07-04</time></span><span class="level-item is-hidden-mobile"><i class="far fa-calendar-check"> </i><time dateTime="${date_xml(page.updated)}" title="${date_xml(page.updated)}">2022-03-08</time></span><span class="level-item"><a class="link-muted" href="/categories/Git/">Git</a></span><span class="level-item">an hour read (About 10060 words)</span></div></div><div class="content"><p><strong>Git 的分支管理</strong>。使用过 SVN 等其它版本控制系统的童鞋可能会说：“SVN 也有分支管理啊”。但由于创建和切换分支慢的一批…那么，Git 分支管理功能有性能提升吗？”。</p>
<p>当然有！Git 的分支是与众不同的。无论创建、切换和删除分支，Git 都能在 <strong>1 秒钟</strong> 之内就能完成！无论你的版本库是 1 个文件还是 1 万个文件。这种跟版本库大小无关的特性，到底是怎么做到的？？！。 </p>
<a id="more"></a>

<blockquote>
<p><strong>版权说明：</strong> 本文思路以及内容主要来自廖雪峰老师的 <a target="_blank" rel="noopener" href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000">Git 教程</a> （强烈推荐膜拜原文），并结合个人使用所作，只作为学习记录使用。如内容有侵权请联系删除，禁止转载！</p>
</blockquote>
<p>更多 Git 相关内容，请关注博主 Git 博文系列：</p>
<p><a href="https://www.orangeshare.cn/2017/07/01/git-shi-yong-zhi-nan-zhi-chu-shi/">之一 &gt;&gt;&gt; Git 使用指南之初识</a></p>
<p><a href="https://www.orangeshare.cn/2017/07/02/git-shi-yong-zhi-nan-zhi-shi-guang-chuan-suo-ji/">之二 &gt;&gt;&gt; Git 使用指南之时光穿梭机</a></p>
<p><a href="https://www.orangeshare.cn/2017/07/03/git-shi-yong-zhi-nan-zhi-yuan-cheng-cang-ku/">之三 &gt;&gt;&gt; Git 使用指南之远程仓库</a></p>
<p><a href="https://www.orangeshare.cn/2017/07/04/git-shi-yong-zhi-nan-zhi-fen-zhi-guan-li/">之四 &gt;&gt;&gt; Git 使用指南之分支管理</a></p>
<p><a href="https://www.orangeshare.cn/2017/07/05/git-shi-yong-zhi-nan-zhi-workflow-gong-zuo-liu/">之五 &gt;&gt;&gt; Git 使用指南之 WorkFlow (工作流)</a></p>
<p><a href="https://www.orangeshare.cn/2017/07/05/git-shi-yong-zhi-nan-zhi-git-zi-ding-yi/">之六 &gt;&gt;&gt; Git 使用指南之 Git 自定义</a></p>
<p><a href="https://www.orangeshare.cn/2017/07/06/git-shi-yong-zhi-nan-zhi-head-zhi-zhen/">之七 &gt;&gt;&gt; Git 使用指南之 HEAD 指针</a></p>
<p><a href="https://www.orangeshare.cn/2017/07/07/git-shi-yong-zhi-nan-zhi-git-zhong-de-hei-mo-fa/">之八 &gt;&gt;&gt; Git 使用指南之 Git 中的黑魔法</a></p>
<hr>
<h2 id="Meet-Branchs-Management"><a href="#Meet-Branchs-Management" class="headerlink" title="Meet Branchs Management"></a>Meet Branchs Management</h2><p>从使用场景上解释，是这么个概念：</p>
<p><strong>【场景模拟】</strong> ↓↓↓↓</p>
<p>参与一个项目开发任务，需要为在线平台增加一个新功能，半个月过去了，开发任务按照预期完成了 50%，就在此时在线平台突然出现 BUG ……</p>
<p>如果立刻提交，由于代码还未完成，不完整的代码库会影响项目内其他人工作；如果等代码全部写完再一次提交，又存在丢失工作进度的巨大风险。</p>
<p><strong>【解决思路】</strong> &gt;&gt;&gt;&gt; 使用 <strong>Git 分支管理</strong> 可以帮助你完美解决上述问题~~~ </p>
<p>借用一句话就是：分支就像是科幻电影里面的平行宇宙，当你正在电脑前努力学习 Git 的时候，另一个你正在另一个平行宇宙里努力学习 SVN。如果两个平行宇宙（两条平行的时间线）互不干扰，那对现在的你也没啥影响。并且如果在某个时间点，两个平行宇宙合并了，结果你既学会了 Git 又学会了 SVN！</p>
<div align=center> <img src='https://cdn.jsdelivr.net/gh/TheNightIsYoung/HexoImageBed0/Img/git_branch_imageDemo.png'></div>


<blockquote>
<p>有了分支管理，你可以创建一个属于你自己的分支，项目内其他人是无法看到的，还继续在原来的分支（master）上正常工作。而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，既安全，又不影响别人工作。</p>
</blockquote>
<hr>
<h3 id="Branch-指针"><a href="#Branch-指针" class="headerlink" title="Branch 指针"></a>Branch 指针</h3><p>深入一点理解分支的（<strong>本质</strong>）话，是这么个概念：</p>
<p>Git 中的分支，本质上仅仅是 <strong>指向提交对象（Commit objects）的可变指针，指向当前的最新提交（Commit，也称为：快照）。</strong></p>
<p>在介绍版本回滚时，我们曾提到过：每次提交，Git 都把它们串成一条时间线，这条时间线就是一个分支，指针指向时间线上的最新时间点（commit）。</p>
<p>实际上，当我们起初使用 Git 的时候，就已经使用到分支了，因为 Git 的默认分支名字是 <code>master</code>，如果你有心的话，会发现执行 <code>git init</code> 后，命令行的输出头部已经默认在 <code>master</code> 分支了。 但是这个时候，还并未创建 <code>master</code> 分支，<strong>只有当有一个提交的时候，才会创建 <code>master</code> 分支。原因在于，分支的指针要指向提交的呀。</strong></p>
<hr>
<p>这里需要重新认识一下 HEAD 指针，你才能更深入的了解 Branch 的使用：</p>
<h3 id="HEAD-指针"><a href="#HEAD-指针" class="headerlink" title="HEAD 指针"></a>HEAD 指针</h3><p>前面，我们介绍过 <strong>HEAD 指针是一个特别的指针，用于记录当前工作的位置（当前版本库所处的分支，以及当前分支的提交点）</strong>。</p>
<p>严格来说，一般情况（默认）下 HEAD 指针不是直接指向 <code>commit</code> 的，而是指向 <code>branch</code> 的，<code>branch</code> 才是指向提交的！！！</p>
<div align=center> <img src='https://cdn.jsdelivr.net/gh/TheNightIsYoung/HexoImageBed0/Img/git_branch_head.png'></div>

<p>事实上，HEAD 指针除了可以指向 <code>branch</code> 也可以移动 HEAD 指针指向快照（commit），但当 HEAD 指向 branch 时且执行提交操作（git add）后会和 branch 指针一起向后移动；当 HEAD 不指向 branch（指向分支上的某一个 commit）时且执行提交（git add）后会使得 HEAD 指针处于特殊的 <strong>detached（[dɪˈtætʃt]，游离）状态</strong>，关于 HEAD 指针在 detached 状态的说明可参加系列博文。</p>
<blockquote>
<p>通俗来讲，分支（Branch）代表着不同的基于主时空（master branch）的平行时空，无干预时互不影响。HEAD 指针等同于处于不同平行宇宙时间线下的 <strong>你自己</strong>：你在哪儿（时间点），指针就在哪；你在哪个分支（时间线），HEAD 指针就指向哪个分支的指针。</p>
</blockquote>
<hr>
<h3 id="Branch-Working-Principle-Diagram"><a href="#Branch-Working-Principle-Diagram" class="headerlink" title="Branch Working Principle Diagram"></a>Branch Working Principle Diagram</h3><p>这一小节，我们通过图解的方式来简单分析一下： Git 分支管理的工作机制，来增强对 Git 分支的认识。</p>
<p><img src="https://cdn.jsdelivr.net/gh/TheNightIsYoung/HexoImageBed0/Img/git_branch_diagram_all.png"></p>
<p>我们知道，一开始的时候，Git 默认创建的 <code>master</code> 分支是一条线，Git 用 <code>master</code> 指向最新的提交，再用 <code>HEAD</code> 指向 <code>master</code>，就能确定当前分支，以及当前分支的提交点。</p>
<p><strong>master</strong> 分支上，每一次提交，<code>master</code> 分支都会向前移动一步，随着你不断提交，<code>master</code> 分支的线也就越来越长：</p>
<p><img src="https://cdn.jsdelivr.net/gh/TheNightIsYoung/HexoImageBed0/Img/git_branch_diagram0.png"></p>
<p>创建并切换分支时（以 <code>develop</code> 分支为例），Git 将新建一个指针 <code>develop</code>，并将 <code>develop</code> 指针指向 <code>master</code> 相同的提交，然后再将 <code>HEAD</code> 指向 <code>develop</code>。表示当前分支在 <code>develop</code> 上：</p>
<p><img src="https://cdn.jsdelivr.net/gh/TheNightIsYoung/HexoImageBed0/Img/git_branch_diagram1.png"></p>
<p>这也可以看出，为什么 Git 创建分支会如此之快，工作区的文件都没有任何变化，并且只是增加了一个 <code>develop</code> 指针以及改变了 <code>HEAD</code> 的指向，此后对工作区的修改和提交就是针对 <code>develop</code> 分支了。</p>
<p>比如新提交一次后，<code>develop</code> 指针往前移动一步，而 <code>master</code> 指针不变：</p>
<p><img src="https://cdn.jsdelivr.net/gh/TheNightIsYoung/HexoImageBed0/Img/git_branch_diagram2.png"></p>
<p>一段时间后，我们成功在 <code>develop</code> 分支上完成新功能的开发，此时我们想把新功能整合到在线平台，也就是想把 <code>develop</code> 合并到 <code>master</code> 上，Git 如何实现呢？最简单的方法，就是直接把 <code>master</code> 指向 <code>develop</code> 的当前提交，就完成了合并：</p>
<p><img src="https://cdn.jsdelivr.net/gh/TheNightIsYoung/HexoImageBed0/Img/git_branch_diagram3.png"></p>
<p>可以看出，Git 合并分支也很快！就改改指针，工作区内容也不变！合并完分支后，甚至可以删除 <code>develop</code> 分支。删除 <code>develop</code> 分支就是把 <code>develop</code> 指针给删掉，删掉后，我们就剩下了一条 <code>master</code> 分支：</p>
<p><img src="https://cdn.jsdelivr.net/gh/TheNightIsYoung/HexoImageBed0/Img/git_branch_diagram4.png"></p>
<hr>
<p>通过上面的学习，相信你已经对 Git 的分支管理有了相对深入的认识，下面正式开始 <strong>Git 分支管理的学习</strong>：</p>
<h2 id="玩转-Branch-必备技能"><a href="#玩转-Branch-必备技能" class="headerlink" title="玩转 Branch 必备技能"></a>玩转 Branch 必备技能</h2><p>有关分支的命令不多，无非是换着花样的增删改查，掌握好以下基本的命令，以后就可以在 Branch 的草原上策马奔腾潇潇洒洒啦~~~</p>
<blockquote>
<p>重要的分支操作命令格式：<strong>CMD 13 –&gt;&gt;&gt; git branch &lt;options&gt;</strong></p>
</blockquote>
<h3 id="创建分支"><a href="#创建分支" class="headerlink" title="创建分支"></a>创建分支</h3><p>创建分支的命令非常简单，命令格式如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch &lt;branch name&gt;</span></span><br></pre></td></tr></table></figure>

<p>使用起来非常简单，似乎简单到你只需要想个分支的名字就好了。但是在创建分支的时候，要想下：是否要从当前分支的内容基础上去开辟一条新分支？？？</p>
<hr>
<h3 id="查看分支"><a href="#查看分支" class="headerlink" title="查看分支"></a>查看分支</h3><p>如何查看本地仓库以及远程库中的分支情况呢？三个命令，让你想看什么分支就看什么分支：</p>
<p><strong>1 –&gt; 如何查看本地分支：</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch</span></span><br></pre></td></tr></table></figure>

<p><strong>2 –&gt; 如何查看远程分支：</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch -r</span></span><br></pre></td></tr></table></figure>

<p><strong>3 –&gt; 如何查看本地和远程的所有分支：</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch -a</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="重命名分支"><a href="#重命名分支" class="headerlink" title="重命名分支"></a>重命名分支</h3><p>实际项目开发过程中，有时会涉及到 <strong>分支的重命名</strong>：</p>
<p><strong>【场景一】：重命名本地分支</strong></p>
<p>当本地的开发分支还没有推送到远程分支的时候，会在本地进行分支的重命名。</p>
<ol>
<li>在当前分支时:</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch -m &lt;new branch name&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>不在当前分支时:</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch -m &lt;old branch name&gt; &lt;new branch name&gt;</span></span><br></pre></td></tr></table></figure>

<p>======================================================================</p>
<p>如果是已经推送到远端，应该怎么做呢？</p>
<p><strong>【场景二】：重命名远程库分支</strong></p>
<blockquote>
<p>假设是在当前分支，并且远端分支与本地分支名是一致的。</p>
</blockquote>
<ol>
<li>重命名本地分支</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch -m &lt;new branch name&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>删除远程分支</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push origin --delete &lt;old branch name&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>上传新命名的本地分支</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push origin &lt;new branch name&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="4">
<li>关联修改后的本地分支与远程分支</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch --set-upstream-to origin/&lt;new branch name&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="检出-切换分支"><a href="#检出-切换分支" class="headerlink" title="检出/切换分支"></a>检出/切换分支</h3><p>检出分支的 “<strong>检出</strong>” 二字，算是个关于 Git 分支的专业术语了,可以理解为切换当前分支。</p>
<p><strong>CMD 14 –&gt;&gt;&gt; git checkout &lt;-b&gt; &lt;branch name&gt;</strong></p>
<p>当 <strong>checkout</strong> 表征 “<strong>检出</strong>” 含义时，<code>checkout</code> 操作是移动 HEAD 指针，将 HEAD 指针指向要切换的分支的指针处。</p>
<p>使用场景有两个：</p>
<ol>
<li>已经存在的分支，现在要切换过去。</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout &lt;branch name&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>创建一个新分支，且切换到新分支，这个一步到位的话需要 <code>-b</code> 参数</li>
</ol>
<p>以当前分支为基础，创建一个新分支：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout -b &lt;branch name&gt;</span></span><br></pre></td></tr></table></figure>

<p>以指定的某一个提交，创建一个新分支：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git checkout -b &lt;branch name&gt; &lt;Commit-ID(SHA1)&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<p><strong>CMD 15 –&gt;&gt;&gt; git switch &lt;-c&gt; &lt;branch name&gt;</strong></p>
<p>记忆力好的看官可能想到，前面撤销修改操作使用过 <code>git checkout -- &lt;file&gt;</code>，太迷惑了……事实上，Git提供了新的 <code>git switch</code> 命令来专门处理分支切换。</p>
<p>对应 <strong>checkout</strong> 的两种使用场景：</p>
<ol>
<li>已经存在的分支，现在要切换过去。</li>
</ol>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git switch &lt;branch name&gt;</span></span><br></pre></td></tr></table></figure>

<ol start="2">
<li>创建一个新分支，且切换到新分支，这个一步到位的话需要 <code>-b</code> 参数</li>
</ol>
<p>以当前分支为基础，创建一个新分支：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git switch -c &lt;branch name&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h3><p>分支生命周期完成后，我们就可以放心删除了：</p>
<p>当本地分支删除后，推动到远程仓库后，远程仓库并不能自动删除对应的远程分支。意味着，分支的完全删除是分两个部分的：</p>
<ol>
<li>本地分支的删除</li>
<li>远程分支的删除。</li>
</ol>
<p><strong>1 –&gt; 删除本地分支：</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 1. 一般删除：删除前会检查 merge 状态，只有满足删除条件才会执行删除操作</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -d &lt;lacal branch name&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># 2. 强制删除：会直接执行删除操作</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果要丢弃一个没有被合并过的分支，可以通过-D 强行删除</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -D &lt;<span class="built_in">local</span> branch name&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>参数 <code>-D</code> 比 <code>-d</code> 要粗暴一点。当被删除分支有新内容没有被合并的时候，使用 <code>-D</code>，会直接删除；使用 <code>-d</code>，会提示该分支有新内容没有被合并，不执行删除。删除需谨慎，建议非特殊情况下，使用温柔的 <code>-d</code> 要好一点，以免小手一抖，/(ㄒoㄒ)/~~</p>
</blockquote>
<p><strong>2 –&gt; 删除远程分支：</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git push origin --delete &lt;remote branch name&gt;</span></span><br></pre></td></tr></table></figure>

<hr>
<p>以上，是分支的增删改查独立操作，但是 Git 创造这个分支，并不只是为了让它们自个儿和自个儿玩的，还需要它们之间的相互协作和配合。 </p>
<p>就像日常项目开发过程中，分好开发任务，你和你的小伙伴新建了两个分支，你写你的 Butter，他写他的 Fly,到开发完成之后，肯定要合在一起，才能成就 Butterfly。合的这个动作，就涉及到了分支合并的概念。</p>
<h2 id="Branch-合并大事记"><a href="#Branch-合并大事记" class="headerlink" title="Branch 合并大事记"></a>Branch 合并大事记</h2><p><strong>合并指定分支到当前分支</strong>的命令格式为：<strong>CMD 16 –&gt;&gt;&gt; git merge &lt;branch name&gt;</strong></p>
<blockquote>
<p>git merge 命令可以加 <code>-m &quot;message&quot;</code> 参数添加合并提交日志。</p>
</blockquote>
<p>Git 中分支的合并是非常智能的，目前有两种模式。两种模式的选择，不需要我们参与，而是 <strong>Git 根据分支情况不同，自行判断选择最适合的 Merge 模式。</strong></p>
<blockquote>
<p>个人在使用 Git 的过程中，执行分支合并时：有时需要输入提交信息，有时不需要，起初作为小白的我懵的不知所以然，后来才知道，原来是合并模式的问题啊！！！</p>
</blockquote>
<p>两种合并模式是：</p>
<ol>
<li>Fast-Forward（快进式）</li>
<li>Recursive Strategy Merge（递归策略合并式，也称为三方合并式）</li>
</ol>
<hr>
<h3 id="Fast-Forward"><a href="#Fast-Forward" class="headerlink" title="Fast-Forward"></a>Fast-Forward</h3><p><img src="https://cdn.jsdelivr.net/gh/TheNightIsYoung/HexoImageBed0/Img/git_branch_fast_forward.png"></p>
<p>如图，有两个分支，master 分支和 feature 分支。当这两个分支处于上面的关系时，当进行合并操作时，就会出现 <strong>fast-forward</strong>。</p>
<p><strong>【说明】</strong>：由于当前 master 分支所指向的提交是 feature 分支的直接上游，所以 Git 只是简单的将指针向前移动。换句话说，当你试图合并两个分支时，如果顺着一个分支走下去能够到达另一个分支，那么 Git 在合并两者的时候，只会简单的将指针向前推进（指针右移）—-&gt;这就叫做 “快进（fast-forward）”。</p>
<p>合并后的分支指针位置如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/TheNightIsYoung/HexoImageBed0/Img/git_branch_fast_forward1.png"></p>
<hr>
<h3 id="Recursive-Strategy-Merge"><a href="#Recursive-Strategy-Merge" class="headerlink" title="Recursive Strategy Merge"></a>Recursive Strategy Merge</h3><p>这个合并方式，是为补充 fast-forward 而出现的。</p>
<p>因为你知道，在项目开发过程中，很多人开发的情况下，出现 fast-forward 的情况并不是很多，很多是类似下面这种。提交历史是分叉的，无法满足执行 fast-forward 的条件：</p>
<p><img src="https://cdn.jsdelivr.net/gh/TheNightIsYoung/HexoImageBed0/Img/git_branch_recursive_strategy.png"></p>
<p><strong>【说明】</strong>：，master 分支所在提交并不是 feature 分支所在提交的直接上游（祖先），Git 不得不做一些额外的工作。 出现这种情况的时候，Git 会使用两个分支的末端所指的快照（C4 和 C5）以及这两个分支的工作祖先（C3），做一个简单的三方合并,生成一个新的提交（C6）。</p>
<p><img src="https://cdn.jsdelivr.net/gh/TheNightIsYoung/HexoImageBed0/Img/git_branch_recursive_strategy1.png"></p>
<hr>
<h3 id="Branch-Demo"><a href="#Branch-Demo" class="headerlink" title="Branch Demo"></a>Branch Demo</h3><p>【2.玩转 Branch 必备技能】 &amp;&amp; 【3.Branch 合并大事记】，说起来就是一堆理论，这一小节我们基于 <strong>GitTestProject</strong> 来实操一下：</p>
<p><strong>1）从 master 分支末尾，创建并切换 featureA 分支，并创建一个提交：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout -b featureA</span><br><span class="line">$ touch ATest.txt</span><br><span class="line">$ git add .</span><br><span class="line">$ git commit -m <span class="string">&quot;Add ATest File For featureA&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>2）从 master 分支末尾，创建并切换 featureB 分支，并创建一个提交：</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">$ git checkout -b featureB</span><br><span class="line">$ touch BTest.txt</span><br><span class="line">$ git add .</span><br><span class="line">$ git commit -m <span class="string">&quot;Add BTest File For featureB&quot;</span></span><br></pre></td></tr></table></figure>

<p><strong>3) 切换回 master 分支</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git switch master</span><br></pre></td></tr></table></figure>

<p>测试分支 featureA &amp;&amp; featureB 完成后，就可以开始尝试分支的合并功能了：</p>
<p><strong>4) Fast-Forward 合并</strong></p>
<p>master 分支合并 featureA 时，是快进式合并：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ git merge featureA</span><br><span class="line">Updating 79c3a2c..fc2702b</span><br><span class="line">Fast-forward</span><br><span class="line"> ATest.txt | 0</span><br><span class="line"> 1 file changed, 0 insertions(+), 0 deletions(-)</span><br><span class="line"> create mode 100644 ATest.txt</span><br></pre></td></tr></table></figure>

<p>图例如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/TheNightIsYoung/HexoImageBed0/Img/git_branch_fast_forward2.png"></p>
<p><strong>5) Recursive Strategy Merge 合并</strong></p>
<p>master 分支合并 featureA 后， 再合并 featureB 时，已经不满足快进式条件了，此时合并会触发一个三方合并，产生一个新的提交。</p>
<p>执行合并 featureB 命令，会跳到一个 VIM 页面，让我们编辑这个新提交的提交信息，你可以看到默认的提交信息是 “Merge branch ‘branch name’”。此时，按 <code>i</code> 进入编辑模式可编写提交信息, 编写好后，通过 <code>：</code> + <code>wq</code> 保存并退出 VIM 页面即可完成合并。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ git merge featureB</span><br><span class="line">Merge made by the <span class="string">&#x27;recursive&#x27;</span> strategy.</span><br><span class="line"> BTest.txt | 0</span><br><span class="line"> 1 file changed, 0 insertions(+), 0 deletions(-)</span><br><span class="line"> create mode 100644 BTest.txt</span><br></pre></td></tr></table></figure>

<p>图例如下：</p>
<p><img src="https://cdn.jsdelivr.net/gh/TheNightIsYoung/HexoImageBed0/Img/git_branch_recursive_strategy2.png"></p>
<hr>
<p>最后再提供一下用来查看分支合并图的命令：</p>
<p><strong>CMD 16 –&gt;&gt;&gt; git log –graph –pretty=oneline –abbrev-commit</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> $ git <span class="built_in">log</span> --graph --pretty=oneline --abbrev-commit</span><br><span class="line">*   5f264b1 (HEAD -&gt; master) Merge branch <span class="string">&#x27;featureB&#x27;</span></span><br><span class="line">|\</span><br><span class="line">| * 4528426 (featureB) Add BTest File For featureB</span><br><span class="line">* | fc2702b (featureA) Add ATest File For</span><br><span class="line">|/</span><br><span class="line">* 79c3a2c (origin/master) Add git_rm_test.txt</span><br><span class="line">* fe3235b git tracks changes</span><br><span class="line">* d6ddc31 Git <span class="built_in">local</span> data management <span class="built_in">test</span></span><br><span class="line">* 0f5a696 understand how stage works</span><br><span class="line">* ebba382 Add <span class="built_in">test</span> code</span><br><span class="line">* da1fadc Add <span class="built_in">help</span> info</span><br><span class="line">* 65586b3 ADD Project Base</span><br></pre></td></tr></table></figure>

<p>其中，<code>--pretty=oneline</code> 参数表示提交以单行显示，<code>--abbrev-commit</code> 参数表示减少头部数据（缩短 SHA1 数值）。</p>
<hr>
<h3 id="No-Fast-Forward"><a href="#No-Fast-Forward" class="headerlink" title="No Fast Forward"></a>No Fast Forward</h3><p>Fast Forward 意为 “快进模式”。主要使用在多分支合并的情况下。即：当前分支合并另一个分支的时候（如果合并的过程中没有 Conflict 冲突的时候，关于 Conflict 的说明见下一小节，这里不用深究），则会通过直接移动两个分支的指针，来达到合并的过程，这个过程就叫做 Fast Forward。</p>
<p>那么，何为 <strong>No Fast Forward</strong>？？？No Fast Forward 指的是，<strong>合并时禁用 fast forward 模式，采用 Recursive Strategy Merge 模式进行合并。</strong></p>
<p>为什么要禁用 Fast Forward 模式，这就不得不提到 Fast Forward 的弊端了：</p>
<p><strong>1 –&gt; Fast Forward 弊端</strong></p>
<p>在 Fast Forward 模式下，当我们 merge 合并后，将会删除无用的分支。即：<strong>删除分支后，会丢掉分支的所有信息。</strong></p>
<p>什么是丢掉分支信息呢？看下面的例子 &gt;&gt;&gt;</p>
<p>假设，新建一个名为 <code>dev</code> 的分支，在分支上进行了两次操作：1.Func-Add User；2.Func-Add Permission，然后切换至 master 主分支，使用 Fast Forward 模式进行合并分支，查看日志信息如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git merge dev</span></span><br><span class="line">Updating 5f264b1..8a39810</span><br><span class="line">Fast-forward</span><br><span class="line"> dev_function.txt | 2 ++</span><br><span class="line"> 1 file changed, 2 insertions(+)</span><br><span class="line"> create mode 100644 dev_function.txt</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> --graph --pretty=oneline --abbrev-commit</span></span><br><span class="line">* 8a39810 (HEAD -&gt; master, dev) Func-Add Permission</span><br><span class="line">* 3d6d64d Func-Add User</span><br><span class="line">* ebba382 Add test code</span><br><span class="line">* da1fadc Add help info</span><br><span class="line">* 65586b3 ADD Project Base</span><br></pre></td></tr></table></figure>

<p>可以看到，对于功能 Func-Add User &amp;&amp; Func-Add Permission，无法判断是 master 分支还是 dev 分支提交的。</p>
<p>怎么办？？？</p>
<hr>
<p><strong>2 –&gt; No Fast Forward(–no-ff)</strong></p>
<p>如果要强制禁用 Fast Forward 模式，Git 就会在 merge 时生成一个新的 commit，这样，从分支历史上就可以看出分支信息。命令格式如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git merge --no-ff -m <span class="string">&quot;message&quot;</span> &lt;branch name&gt;</span></span><br></pre></td></tr></table></figure>

<p>对比一下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git switch master</span></span><br><span class="line">Switched to branch &#x27;master&#x27;</span><br><span class="line">Your branch is ahead of &#x27;origin/master&#x27; by 5 commits.</span><br><span class="line">  (use &quot;git push&quot; to publish your local commits)</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> git merge --no-ff -m <span class="string">&quot;Merge with no-ff&quot;</span> dev</span></span><br><span class="line">Merge made by the &#x27;recursive&#x27; strategy.</span><br><span class="line"> dev_function.txt | 3 +++</span><br><span class="line"> 1 file changed, 3 insertions(+)</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> --graph --pretty=oneline --abbrev-commit</span></span><br><span class="line">*   28157d9 (HEAD -&gt; master) Merge with no-ff</span><br><span class="line">|\</span><br><span class="line">| * 02636d0 (dev) Func-Add Permission(no-ff)</span><br><span class="line">| * b324182 Func-Add User(no-ff)</span><br><span class="line">|/</span><br><span class="line">* ================= Shortcut Line ================</span><br><span class="line">* 8a39810 Func-Add Permission</span><br><span class="line">* 3d6d64d Func-Add User</span><br><span class="line">......</span><br><span class="line">* ebba382 Add test code</span><br><span class="line">* da1fadc Add help info</span><br><span class="line">* 65586b3 ADD Project Base</span><br></pre></td></tr></table></figure>

<p>可以看到，使用 <code>no-ff</code> 合并的方式可以保留分支信息。</p>
<p>如果合并分支之后，将 dev 分支删除了，你就找不到 dev 分支了，但在分支示意图上仍然可以看到分支结构：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch -d dev</span></span><br><span class="line">Deleted branch dev (was 02636d0).</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">log</span> --graph --pretty=oneline --abbrev-commit</span></span><br><span class="line">*   28157d9 (HEAD -&gt; master) Merge with no-ff</span><br><span class="line">|\</span><br><span class="line">| * 02636d0 Func-Add Permission(no-ff)</span><br><span class="line">| * b324182 Func-Add User(no-ff)</span><br><span class="line">|/</span><br><span class="line">* ================= Shortcut Line ================</span><br><span class="line">* 8a39810 Func-Add Permission</span><br><span class="line">* 3d6d64d Func-Add User</span><br><span class="line">*</span><br><span class="line">......</span><br><span class="line">* ebba382 Add test code</span><br><span class="line">* da1fadc Add help info</span><br><span class="line">* 65586b3 ADD Project Base</span><br></pre></td></tr></table></figure>

<p>|————————————————————</p>
<p><strong>友情提示：</strong></p>
<p>我们知道 Git 创建、合并和删除分支都非常快（操作指针）。所以，Git 鼓励用户使用分支完成某个任务，合并后再删掉分支，这和直接在 <code>master</code> 分支上工作效果是一样的，但过程更安全。</p>
<p>————————————————————|</p>
<hr>
<h2 id="和平解决-Branch-合并冲突"><a href="#和平解决-Branch-合并冲突" class="headerlink" title="和平解决 Branch 合并冲突"></a>和平解决 Branch 合并冲突</h2><p>有人在的地方就有江湖，有分支在的地方，就有冲突~~~</p>
<p>很多时候，合并操作不会如此顺利。 如果你在两个不同的分支中，对同一个文件的同一个部分进行了不同的修改，Git 就没法干净的合并它们，于是就会发生冲突。</p>
<p>例如，分别在 master 和 featureA 下，在 ATest.txt 文件添加一行任意内容，然后两个分支合并，就会发生冲突。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git merge featureA</span></span><br><span class="line">Auto-merging ATest.txt</span><br><span class="line">CONFLICT (content): Merge conflict in ATest.txt</span><br><span class="line">Automatic merge failed; fix conflicts and then commit the result.</span><br></pre></td></tr></table></figure>

<p>这是，可以通过 <code>git status</code>，查看冲突的详细信息。冲突提示信息中，指明冲突文件为： ATest.txt。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">(master *+|MERGING) GitTestProject $ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is ahead of &#x27;origin/master&#x27; by 9 commits.</span><br><span class="line">  (use &quot;git push&quot; to publish your local commits)</span><br><span class="line"></span><br><span class="line">You have unmerged paths.</span><br><span class="line">  (fix conflicts and run &quot;git commit&quot;)</span><br><span class="line">  (use &quot;git merge --abort&quot; to abort the merge)</span><br><span class="line"></span><br><span class="line">Unmerged paths:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to mark resolution)</span><br><span class="line">        both modified:   ATest.txt</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and/or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure>

<p>需要说明的是：如果遇到冲突的话，git 就无法自动合并了，接下来要靠我们自己手动解决冲突，方法是：</p>
<ol>
<li>查看造成冲突的文件，修改冲突部分;</li>
<li>对修改后冲突文件，执行 git add 操作;</li>
<li>创建一个修改冲突的提交。</li>
</ol>
<hr>
<p>先了解一下发现冲突的解决思路，接下来，一步一步仔细看～</p>
<p><strong>1 –&gt; 查看造成冲突的文件，修改冲突部分</strong></p>
<p>冲突文件 ATest.txt 内容如下（Git 虽然无法解决冲突， 但是使用简单的三个符号，标明了冲突的地方，以及冲突的两个分支在该地方发生冲突时的内容）：</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line"># This <span class="keyword">is</span> <span class="keyword">a</span> test about merge conflict.</span><br><span class="line">=======</span><br><span class="line"># This <span class="keyword">ia</span> <span class="keyword">a</span> test about merge conflict.</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; featureA</span><br><span class="line">~</span><br><span class="line">~</span><br></pre></td></tr></table></figure>

<p>符号说明如下：</p>
<table>
<thead>
<tr>
<th>符号</th>
<th>分隔符</th>
</tr>
</thead>
<tbody><tr>
<td>=======</td>
<td>分隔符</td>
</tr>
<tr>
<td>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD 至 =======</td>
<td>master 分支中该地方的内容</td>
</tr>
<tr>
<td>======= 至 &gt;&gt;&gt;&gt;&gt;&gt;&gt; featureA</td>
<td>featureA 分支中该地方为内容</td>
</tr>
</tbody></table>
<p>接下来编辑 ATest.txt 文件，根据功能需要完成合并，确认之后，把 Git 冲突标识符号给删除掉即可。</p>
<p><strong>2 &amp; 3 –&gt; 修改后冲突文件，add &amp;&amp; commit</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git add ATest.txt</span></span><br><span class="line"></span><br><span class="line">(master +|MERGING) GitTestProject $ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is ahead of &#x27;origin/master&#x27; by 9 commits.</span><br><span class="line">  (use &quot;git push&quot; to publish your local commits)</span><br><span class="line"></span><br><span class="line">All conflicts fixed but you are still merging.</span><br><span class="line">  (use &quot;git commit&quot; to conclude merge)</span><br><span class="line"></span><br><span class="line">Changes to be committed:</span><br><span class="line">        modified:   ATest.txt</span><br><span class="line"></span><br><span class="line">(master +|MERGING) GitTestProject $ git commit -m &quot;Dealing Merge Conflict&quot;</span><br><span class="line">[master fb50835] Dealing Merge Conflict</span><br><span class="line"></span><br><span class="line">(master) GitTestProject $ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is ahead of &#x27;origin/master&#x27; by 11 commits.</span><br><span class="line">  (use &quot;git push&quot; to publish your local commits)</span><br><span class="line"></span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="关联本地分支-amp-amp-远程分支"><a href="#关联本地分支-amp-amp-远程分支" class="headerlink" title="关联本地分支&amp;&amp;远程分支"></a>关联本地分支&amp;&amp;远程分支</h2><p>学习了分支的概念后，你应该意识到：多人协作项目中，为了保证本地分支和远程库中分支保持数据同步，团队中的每一个 Partner 使用 <code>git pull</code> 或者 <code>git push</code> 拉取（或推送）最新分支内容时，需要明确指定从本地的哪个分支 <strong>拉取/推送</strong> 到远程的哪个分支，这是重要的！！！</p>
<h3 id="Git-Pull-amp-amp-Git-Push-参数详解"><a href="#Git-Pull-amp-amp-Git-Push-参数详解" class="headerlink" title="Git Pull &amp;&amp; Git Push 参数详解"></a>Git Pull &amp;&amp; Git Push 参数详解</h3><p>补充说明在远程仓库中提到的：<strong>CMD 10 –&gt;&gt;&gt; git push &amp;&amp; git pull</strong></p>
<p><strong>1 –&gt; git push</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.将本地当前分支 推送到 与本地当前分支同名的远程分支上（使用前提：本地分支&amp;&amp;远程分支实现关联）</span><br><span class="line"><span class="meta">$</span><span class="bash"> git push</span></span><br><span class="line"></span><br><span class="line">2.将本地当前分支 推送到 与本地当前分支同名的远程分支上</span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin &lt;<span class="built_in">local</span> current branch name&gt;</span></span><br><span class="line"></span><br><span class="line">3.将本地当前分支 推送到 远程指定分支上</span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin &lt;<span class="built_in">local</span> current branch name&gt;:&lt;remote brance name&gt;</span></span><br><span class="line"></span><br><span class="line">推荐使用第二种！！！</span><br></pre></td></tr></table></figure>

<p><strong>2 –&gt; git pull</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">1.将与本地当前分支同名的远程分支 拉取到 本地当前分支上（使用前提：本地分支&amp;&amp;远程分支实现关联）</span><br><span class="line"><span class="meta">$</span><span class="bash"> git pull</span></span><br><span class="line"></span><br><span class="line">2.将远程指定分支 拉取到 本地当前分支上</span><br><span class="line"><span class="meta">$</span><span class="bash"> git pull origin &lt;remote branch name&gt;</span></span><br><span class="line"></span><br><span class="line">3.将远程指定分支 拉取到 本地指定分支上</span><br><span class="line"><span class="meta">$</span><span class="bash"> git pull origin &lt;remote brance name&gt;:&lt;<span class="built_in">local</span> current branch name&gt;</span></span><br><span class="line"></span><br><span class="line">推荐使用第二种！！！</span><br></pre></td></tr></table></figure>

<blockquote>
<p>注意：pull or push 自身的动作，决定了后面跟随最近的仓库是远程的还是本地的。pull From –&gt; remote brance name；push To –&gt; local branch name。</p>
</blockquote>
<hr>
<p>实际中，上面推荐使用的第二种（可以直接使用）和第一种语法都常使用，然而第一种的使用前提是：需要先<strong>实现本地分支&amp;&amp;远程分支关联</strong>。</p>
<p>将本地仓库，以及远程仓库（“中央仓库”）关联起来，可以简化命令，但同样带来了混淆（两面性），你可以根据喜好选择性使用，适合自己的才是最好的。</p>
<p>那么如何将本地仓库，以及远程仓库（“中央仓库”）关联起来呢？？？</p>
<p>推荐一个用来查看分支关联情况的命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch -vv</span></span><br></pre></td></tr></table></figure>

<h3 id="关联方法"><a href="#关联方法" class="headerlink" title="关联方法"></a>关联方法</h3><p>将本地分支同远程分支进行关联，可以分为以下三种场景(以 dev 分支为例)：</p>
<p><strong>场景一：本地库已创建分支 dev，而远程库没有</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 添加参数：-u</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push -u origin dev</span></span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加参数：--set-upstream</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push --set-upstream origin dev</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>关联思路：推送时实现关联，之后就可以直接使用 <code>git push</code> 进行分支分容的推送了。</p>
</blockquote>
<p><strong>场景二：远程库已创建分支 dev，而本地库没有</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 分为两步：</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment"># Step1：将远程分支 pull 到本地</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git pull origin dev</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Step2：创建本地分支并且进行关联</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git checkout -b dev origin/dev</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>关联思路：先拉取远程分支到本地，然后本地创建切换分支且进行关联。之后就可以直接使用 <code>git pull</code> 进行远程分支内容拉取了。</p>
</blockquote>
<p><strong>场景三：本地库 &amp;&amp; 远程库均已创建分支 dev</strong></p>
<p>事实上，<code>git branch</code> 命令支持直接将 <strong>本地当前分支</strong> 直接与  <strong>远程分支</strong> 相关联：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 添加参数：-u</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -u origin/dev</span></span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 添加参数：--set-upstream-to</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch --set-upstream-to=origin/dev</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>当然，前提是本地和远程库中均有分支 dev。注意，这里只是以 dev 为例，并不是本地库和远程库必须同名！！！</p>
</blockquote>
<hr>
<h3 id="撤销关联"><a href="#撤销关联" class="headerlink" title="撤销关联"></a>撤销关联</h3><p>下面的命令，可以 <strong>撤销 本地当前分支 与对应的远程分支 的关联关系</strong>：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch --unset-upstream</span></span><br></pre></td></tr></table></figure>

<hr>
<h3 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h3><p>这一小节我们来看分支关联的测试实例（以 GitTestProject 为例）：</p>
<p><strong>场景一实例：远程库已创建分支 dev，本地无分支</strong></p>
<p>1）查看需要关联的远程分支名：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch -a</span></span><br><span class="line">	* master</span><br><span class="line">	  remotes/origin/dev</span><br><span class="line">	  remotes/origin/master</span><br></pre></td></tr></table></figure>

<p>可以看到，远程也包含了 dev 分支：<code>remotes/origin/dev</code>，而本地是没有的。</p>
<p>2）根据关联方法中的介绍，这里有两种思路，来进行关联：</p>
<p><strong>思路一：</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 本地新建一个和远程分支同名(dev)的分支</span></span><br><span class="line"><span class="meta"> $</span><span class="bash"> git checkout -b dev</span></span><br><span class="line">Switched to a new branch &#x27;dev&#x27;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将本地当前分支关联远程分支</span></span><br><span class="line">(dev) GitTestProject $ git branch --set-upstream-to=origin/dev</span><br><span class="line">Branch &#x27;dev&#x27; set up to track remote branch &#x27;dev&#x27; from &#x27;origin&#x27;.</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -vv</span></span><br><span class="line">  FeatureA c07648e Merge conflic test in FeatureA</span><br><span class="line">* dev      fb50835 [origin/dev] Dealing Merge Conflict</span><br><span class="line">  featureB 4528426 Add BTest File For featureB</span><br><span class="line">  master   fb50835 [origin/master: ahead 11] Dealing Merge Conflict</span><br></pre></td></tr></table></figure>

<p><strong>思路二：</strong></p>
<p>注意，测试前需要将上面的关联取消掉，然后删除分支，再开始执行下面的命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 将远程分支 pull 到本地</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git pull origin dev</span></span><br><span class="line">From github.com:TheNightIsYoung/GitTestProject</span><br><span class="line"> * branch            dev        -&gt; FETCH_HEAD</span><br><span class="line">Already up to date.</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建本地分支并且进行关联</span></span><br><span class="line">(master) GitTestProject $ git checkout -b dev origin/dev</span><br><span class="line">Switched to a new branch &#x27;dev&#x27;</span><br><span class="line">Branch &#x27;dev&#x27; set up to track remote branch &#x27;dev&#x27; from &#x27;origin&#x27;.</span><br><span class="line"></span><br><span class="line">(dev) GitTestProject $ git branch -vv</span><br><span class="line">  FeatureA c07648e Merge conflic test in FeatureA</span><br><span class="line">* dev      fb50835 [origin/dev] Dealing Merge Conflict</span><br><span class="line">  featureB 4528426 Add BTest File For featureB</span><br><span class="line">  master   fb50835 [origin/master: ahead 11] Dealing Merge Conflict</span><br></pre></td></tr></table></figure>

<p>3）提交测试是否成功关联</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> touch assi_demo.txt</span></span><br><span class="line"></span><br><span class="line">GitTestProject $ git add assi_demo.txt</span><br><span class="line">(dev +) GitTestProject $ git commit -m &quot;Branch assi Test&quot;</span><br><span class="line">[dev 3cb60e7] Branch assi Test</span><br><span class="line"> 1 file changed, 0 insertions(+), 0 deletions(-)</span><br><span class="line"> create mode 100644 assi_demo.txt</span><br><span class="line"></span><br><span class="line">(dev) GitTestProject $ git pull</span><br><span class="line">Already up to date.</span><br><span class="line"></span><br><span class="line">(dev) GitTestProject $ git push</span><br><span class="line">Enumerating objects: 3, done.</span><br><span class="line">Counting objects: 100% (3/3), done.</span><br><span class="line">Delta compression using up to 12 threads</span><br><span class="line">Compressing objects: 100% (2/2), done.</span><br><span class="line">Writing objects: 100% (2/2), 251 bytes | 125.00 KiB/s, done.</span><br><span class="line">Total 2 (delta 1), reused 0 (delta 0), pack-reused 0</span><br><span class="line">remote: Resolving deltas: 100% (1/1), completed with 1 local object.</span><br><span class="line">To github.com:TheNightIsYoung/GitTestProject.git</span><br><span class="line">   fb50835..3cb60e7  dev -&gt; dev</span><br></pre></td></tr></table></figure>

<p>可以发现，已经成功关联分支，并可以提交代码到远程分支。</p>
<hr>
<p><strong>场景二实例：本地库已创建分支 dev，远程无分支</strong></p>
<p>为了满足场景二需要，我们需要先删除场景一中的关联关系，并且删除远程的 dev 分支：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch --unset-upstream</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin --delete dev</span></span><br><span class="line">To github.com:TheNightIsYoung/GitTestProject.git</span><br><span class="line"> - [deleted]         dev</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -a</span></span><br><span class="line">* dev</span><br><span class="line">  master</span><br><span class="line">  remotes/origin/master</span><br></pre></td></tr></table></figure>

<p>1）查看当前仓库分支情况：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch -a</span></span><br><span class="line">* dev</span><br><span class="line">  master</span><br><span class="line">  remotes/origin/master</span><br></pre></td></tr></table></figure>

<p>可以发现，远程库中只有 master 分支，而本地仓库中包含两个分支：dev &amp;&amp; master。</p>
<p>2）根据关联方法中的介绍，这里有两种思路，来进行关联：</p>
<p><strong>思路一：</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 将本地当前分支 推送到 远程库</span> </span><br><span class="line"><span class="meta">$</span><span class="bash"> git push origin dev</span></span><br><span class="line">Enumerating objects: 30, done.</span><br><span class="line">Counting objects: 100% (30/30), done.</span><br><span class="line">Delta compression using up to 12 threads</span><br><span class="line">Compressing objects: 100% (26/26), done.</span><br><span class="line">Writing objects: 100% (29/29), 2.70 KiB | 345.00 KiB/s, done.</span><br><span class="line">Total 29 (delta 16), reused 0 (delta 0), pack-reused 0</span><br><span class="line">remote: Resolving deltas: 100% (16/16), done.</span><br><span class="line">remote:</span><br><span class="line">remote: Create a pull request for &#x27;dev&#x27; on GitHub by visiting:</span><br><span class="line">remote:      https://github.com/TheNightIsYoung/GitTestProject/pull/new/dev</span><br><span class="line">remote:</span><br><span class="line">To github.com:TheNightIsYoung/GitTestProject.git</span><br><span class="line"> * [new branch]      dev -&gt; dev</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 查看分支关联情况，发现 dev 分支未关联</span> </span><br><span class="line">(dev) GitTestProject $ git branch -vv</span><br><span class="line">* dev      3cb60e7 Branch assi Test</span><br><span class="line">  master   fb50835 [origin/master: ahead 11] Dealing Merge Conflict</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将本地当前分支 与 远程分支进行 关联</span></span><br><span class="line">(dev) GitTestProject $ git branch -u origin/dev</span><br><span class="line">Branch &#x27;dev&#x27; set up to track remote branch &#x27;dev&#x27; from &#x27;origin&#x27;.</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重新查看分支关联情况，发现本地 dev 分支已和远程关联</span> </span><br><span class="line">(dev) GitTestProject $ git branch -vv</span><br><span class="line">* dev      3cb60e7 [origin/dev] Branch assi Test</span><br><span class="line">  master   fb50835 [origin/master: ahead 11] Dealing Merge Conflict</span><br></pre></td></tr></table></figure>

<p><strong>思路二：</strong></p>
<p>注意，测试前需要将上面的关联取消掉，然后删除远程分支，再开始执行下面的命令：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 将本地当前分支 推送到 远程库，同时使用 -u 参数进行关联</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git push -u origin dev</span></span><br><span class="line">Enumerating objects: 30, done.</span><br><span class="line">Counting objects: 100% (30/30), done.</span><br><span class="line">Delta compression using up to 12 threads</span><br><span class="line">Compressing objects: 100% (26/26), done.</span><br><span class="line">Writing objects: 100% (29/29), 2.70 KiB | 212.00 KiB/s, done.</span><br><span class="line">Total 29 (delta 16), reused 0 (delta 0), pack-reused 0</span><br><span class="line">remote: Resolving deltas: 100% (16/16), done.</span><br><span class="line">remote:</span><br><span class="line">remote: Create a pull request for &#x27;dev&#x27; on GitHub by visiting:</span><br><span class="line">remote:      https://github.com/TheNightIsYoung/GitTestProject/pull/new/dev</span><br><span class="line">remote:</span><br><span class="line">To github.com:TheNightIsYoung/GitTestProject.git</span><br><span class="line"> * [new branch]      dev -&gt; dev</span><br><span class="line">Branch &#x27;dev&#x27; set up to track remote branch &#x27;dev&#x27; from &#x27;origin&#x27;.</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重新查看分支关联情况，发现本地 dev 分支已和远程关联</span></span><br><span class="line">(dev) GitTestProject $ git branch -vv</span><br><span class="line">* dev      3cb60e7 [origin/dev] Branch assi Test</span><br><span class="line">  master   fb50835 [origin/master: ahead 11] Dealing Merge Conflict</span><br></pre></td></tr></table></figure>

<p>如果你还不放心的话，还可以进行一次提交，然后使用 <code>git push</code> 进行推送，自己尝试一下吧~~~</p>
<hr>
<h2 id="Data-Flow-In-Git"><a href="#Data-Flow-In-Git" class="headerlink" title="Data Flow In Git"></a>Data Flow In Git</h2><p>前面我们提到过 Git 的三大分区，以及各区之间的数据传递流程图，这里我们已经可以给出 Git 的整体构架图：</p>
<p><img src="https://cdn.jsdelivr.net/gh/TheNightIsYoung/HexoImageBed0/Img/git_quanliucheng_diagram.png"></p>
<p><strong>工作区（Working Directory）</strong>，简言之就是你工作的区域。对于 Git 而言，就是的本地工作目录。工作区的内容会包含提交到暂存区和版本库(当前提交点)的内容，同时也包含自己的修改内容。</p>
<p><strong>暂存区（Stage Area, 又称为索引区 Index）</strong>，是 Git 中一个非常重要的概念。在工作目录下有一个 <code>.git</code> 的目录，里面有个 <code>index</code> 文件，存储着关于暂存区的内容。git add 命令将工作区内容添加到暂存区。</p>
<p><strong>本地仓库（Rocal Repository）</strong>，版本控制系统的仓库，存在于本地。当执行 git commit 命令后，会将暂存区内容提交到仓库之中。在工作区下面有 <code>.git</code> 的目录，这个目录下的内容不属于工作区，里面便是仓库的数据信息，暂存区相关内容也在其中。这里也可以使用 merge 或 rebase 将远程仓库副本合并到本地仓库。图中的只有 merge，注意这里也可以使用 rebase。</p>
<p><strong>远程版本库（Remote Repository）</strong>，与本地仓库概念基本一致，不同之处在于一个存在远程，可用于远程协作，一个却是存在于本地。通过 push/pull 可实现本地与远程的交互。</p>
<p><strong>远程仓库副本</strong>，可以理解为存在于本地的远程仓库缓存。如需更新，可通过 git fetch/pull 命令获取远程仓库内容。使用 fech 获取时，并未合并到本地仓库，此时可使用 git merge 实现远程仓库副本与本地仓库的合并。git pull 根据配置的不同，可为 git fetch + git merge 或 git fetch + git rebase。</p>
<blockquote>
<p>这里引用知乎上，博主波罗学的说法。git pull 和 git fetch 的区别前参加 –&gt; <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/123370920">传送门</a> </p>
</blockquote>
<hr>
<h2 id="Get-Branch-From-RemoteRepo"><a href="#Get-Branch-From-RemoteRepo" class="headerlink" title="Get Branch From RemoteRepo"></a>Get Branch From RemoteRepo</h2><p>日常的项目开发过程中，更常见的是从既存的远程仓库中拉取代码到本地，然后进行开发任务。前面提到过，会使用 <code>git clone &lt;repo addr&gt;</code> 命令，可以将项目整个克隆到我们的本地仓库。</p>
<p>然而，本地 Clone 仓库默认只会 clone 下 master 分支（clone 到指定目录）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Clone 到指定目录语法：git <span class="built_in">clone</span> &lt;repo addr&gt; &lt;myDirName&gt;</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> git@github.com:TheNightIsYoung/GitTestProject.git MyLocalRepo</span></span><br><span class="line">Cloning into &#x27;MyLocalRepo&#x27;...</span><br><span class="line">remote: Enumerating objects: 59, done.</span><br><span class="line">remote: Counting objects: 100% (59/59), done.</span><br><span class="line">remote: Compressing objects: 100% (25/25), done.</span><br><span class="line">remote: Total 59 (delta 22), reused 58 (delta 21), pack-reused 0</span><br><span class="line">Receiving objects: 100% (59/59), 5.00 KiB | 639.00 KiB/s, done.</span><br><span class="line">Resolving deltas: 100% (22/22), done.</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> ls MyLocalRepo/</span></span><br><span class="line">ATest.txt  Client/           git_rm_test.txt  Server/</span><br><span class="line">BTest.txt  dev_function.txt  readme.txt</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> MyLocalRepo/</span></span><br></pre></td></tr></table></figure>

<p>倘若远程仓库有多个分支，我们会发现，使用 <code>git branch</code> 查看本地分支时，只有一个 <code>master</code> 分支:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch</span></span><br><span class="line">* master</span><br></pre></td></tr></table></figure>

<p>此时，你可以使用 <code>git branch -a</code> 查看都有那些远程分支：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git branch -a</span></span><br><span class="line">* master</span><br><span class="line">remotes/origin/HEAD -&gt; origin/master</span><br><span class="line">remotes/origin/develop</span><br><span class="line">remotes/origin/feature</span><br></pre></td></tr></table></figure>

<hr>
<p>但是，实际上大多数时候我们是需要在其他分支进行工作的，所以我们需要可以灵活的将远程的其它分支拉取下来。比如有时候你只想拉取远程仓库指定的某一个分支，有时候你想拉取远程的所有分支等等。</p>
<h3 id="Pull-a-specified-branch"><a href="#Pull-a-specified-branch" class="headerlink" title="Pull a specified branch"></a>Pull a specified branch</h3><p>如何 Git 命令拉取远程仓库中指定的某一个分支呢？这里提供三种方法供大家参考：</p>
<p><strong>1 –&gt; git clone -b 命令获取</strong></p>
<p>命令格式：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> -b &lt;remote branch name&gt; &lt;remote repo addr&gt;</span> </span><br></pre></td></tr></table></figure>

<p><strong>git clone -b &lt;分支名称&gt; &lt;仓库地址&gt;</strong> 命令可以将指定的某一个远程分支拉取到我们本地，而且拉取的本地分支自动和远程同名分支建立关联（追踪）关系，并且会将新创建的 HEAD 指向刚拉取下来的分支。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> -b dev git@github.com:TheNightIsYoung/GitTestProject.git MyLocalRepo</span></span><br><span class="line">Cloning into &#x27;MyLocalRepo&#x27;...</span><br><span class="line">remote: Enumerating objects: 59, done.</span><br><span class="line">remote: Counting objects: 100% (59/59), done.</span><br><span class="line">remote: Compressing objects: 100% (25/25), done.</span><br><span class="line">remote: Total 59 (delta 22), reused 58 (delta 21), pack-reused 0</span><br><span class="line">Receiving objects: 100% (59/59), 5.00 KiB | 1023.00 KiB/s, done.</span><br><span class="line">Resolving deltas: 100% (22/22), done.</span><br></pre></td></tr></table></figure>

<p>分支拉取结束以后，执行 git branch -a 命令，查看分支情况如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">cd</span> MyLocalRepo/</span></span><br><span class="line">(dev) MyLocalRepo $ git branch -a</span><br><span class="line">* dev</span><br><span class="line">  remotes/origin/HEAD -&gt; origin/master</span><br><span class="line">  remotes/origin/dev</span><br><span class="line">  remotes/origin/master </span><br></pre></td></tr></table></figure>

<p>当然，这里你也可以根据【关联本地分支&amp;&amp;远程分支】中介绍的方法，同时拉取其它分支进行工作（以 master 为例）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git pull origin master</span></span><br><span class="line">From github.com:TheNightIsYoung/GitTestProject</span><br><span class="line"> * branch            master     -&gt; FETCH_HEAD</span><br><span class="line">Already up to date.</span><br><span class="line">Jie Guo (dev) MyLocalRepo $ git branch -a</span><br><span class="line">* dev</span><br><span class="line">  remotes/origin/HEAD -&gt; origin/master</span><br><span class="line">  remotes/origin/dev</span><br><span class="line">  remotes/origin/master</span><br><span class="line"></span><br><span class="line">(dev) MyLocalRepo $ git checkout -b master origin/master</span><br><span class="line">Switched to a new branch &#x27;master&#x27;</span><br><span class="line">Branch &#x27;master&#x27; set up to track remote branch &#x27;master&#x27; from &#x27;origin&#x27;.</span><br><span class="line">(master) MyLocalRepo $ git branch -a</span><br><span class="line">  dev</span><br><span class="line">* master</span><br><span class="line">  remotes/origin/HEAD -&gt; origin/master</span><br><span class="line">  remotes/origin/dev</span><br><span class="line">  remotes/origin/master</span><br></pre></td></tr></table></figure>

<hr>
<p><strong>2 –&gt; git fetch 命令获取</strong></p>
<p>关于 git fetch 命令说明：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1.将某个远程主机的所有更新，全部取回本地副本中，但不会将任何新内容合并到我们最近的工作文件中。</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git fetch &lt;远程主机名&gt;</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 或者简写为：</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git fetch</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 2.如果只想取回特定分支的更新</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git fetch &lt;远程主机名&gt; &lt;分支名&gt;</span></span><br></pre></td></tr></table></figure>

<p>开始拉取指定分支 &gt;&gt;&gt;&gt;</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 1.拉取整个远程代码库</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> git@github.com:TheNightIsYoung/GitTestProject.git MyLocalRepo</span></span><br><span class="line">Cloning into &#x27;MyLocalRepo&#x27;...</span><br><span class="line">remote: Enumerating objects: 59, done.</span><br><span class="line">remote: Counting objects: 100% (59/59), done.</span><br><span class="line">remote: Compressing objects: 100% (25/25), done.</span><br><span class="line">remote: Total 59 (delta 22), reused 58 (delta 21), pack-reused 0</span><br><span class="line">Receiving objects: 100% (59/59), 5.00 KiB | 1023.00 KiB/s, done.</span><br><span class="line">Resolving deltas: 100% (22/22), done.</span><br><span class="line"></span><br><span class="line">gitWorkS $ cd MyLocalRepo/</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 将远程仓库的所有分支拷贝到本地，建立远程库副本</span></span><br><span class="line">(master) MyLocalRepo $ git fetch</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 切换到想要拉取的指定某一个分支的本地分支</span></span><br><span class="line">(master) MyLocalRepo $ git checkout dev</span><br><span class="line">Switched to a new branch &#x27;dev&#x27;</span><br><span class="line">Branch &#x27;dev&#x27; set up to track remote branch &#x27;dev&#x27; from &#x27;origin&#x27;.</span><br></pre></td></tr></table></figure>

<p>切换分支后，你就可以看到本地仓库的 dev 开发分支和远程仓库的 dev 开发分支同步了。</p>
<blockquote>
<p>这里不好理解的话，你可以在 git fetch 之后，使用 <code>git checkout -b dev origin/dev</code> + <code>git merge origin/dev</code> 实现同样的效果。</p>
</blockquote>
<hr>
<p><strong>3 –&gt; git checkout 命令获取</strong></p>
<p>这一方法你可以先自己思考下，提示需要借助 <code>git pull</code> 命令~~~</p>
<p>先不要看下面的答案！</p>
<p>先不要看下面的答案！！</p>
<p>先不要看下面的答案！！！</p>
<p>参考下面的详细步骤，是否和你思考的一样？：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git <span class="built_in">clone</span> git@github.com:TheNightIsYoung/GitTestProject.git MyLocalRepo</span></span><br><span class="line">Cloning into &#x27;MyLocalRepo&#x27;...</span><br><span class="line">remote: Enumerating objects: 59, done.</span><br><span class="line">remote: Counting objects: 100% (59/59), done.</span><br><span class="line">remote: Compressing objects: 100% (25/25), done.</span><br><span class="line">remote: Total 59 (delta 22), reused 58 (delta 21), pack-reused 0</span><br><span class="line">Receiving objects: 100% (59/59), 5.00 KiB | 1023.00 KiB/s, done.</span><br><span class="line">Resolving deltas: 100% (22/22), done.</span><br><span class="line"></span><br><span class="line">gitWorkS $ cd MyLocalRepo/</span><br><span class="line">(master) MyLocalRepo $ git branch -a</span><br><span class="line">* master</span><br><span class="line">  remotes/origin/HEAD -&gt; origin/master</span><br><span class="line">  remotes/origin/dev</span><br><span class="line">  remotes/origin/master</span><br><span class="line"></span><br><span class="line">(master) MyLocalRepo $ git checkout -b dev origin/dev</span><br><span class="line">Switched to a new branch &#x27;dev&#x27;</span><br><span class="line">Branch &#x27;dev&#x27; set up to track remote branch &#x27;dev&#x27; from &#x27;origin&#x27;.</span><br><span class="line"></span><br><span class="line">(dev) MyLocalRepo $ git pull origin dev</span><br><span class="line">From github.com:TheNightIsYoung/GitTestProject</span><br><span class="line"> * branch            dev        -&gt; FETCH_HEAD</span><br><span class="line">Already up to date.</span><br></pre></td></tr></table></figure>

<p>至此，你就可以灵活的实现 从远程仓库拉取指定某一分支，或者拉取指定的某些分支了~~~</p>
<hr>
<h3 id="Sync-remote-branch"><a href="#Sync-remote-branch" class="headerlink" title="Sync remote branch"></a>Sync remote branch</h3><p>那么，如何一次性同步远程仓库中的所有分支到本地仓库中呢？</p>
<p><strong>1 –&gt; 跟踪（关联）所有远程分支</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"> $</span><span class="bash"> git branch -r | grep -v <span class="string">&#x27;\-&gt;&#x27;</span> | <span class="keyword">while</span> <span class="built_in">read</span> remote; <span class="keyword">do</span> git branch --track <span class="string">&quot;<span class="variable">$&#123;remote#origin/&#125;</span>&quot;</span> <span class="string">&quot;<span class="variable">$remote</span>&quot;</span>; <span class="keyword">done</span></span></span><br><span class="line">Branch &#x27;dev&#x27; set up to track remote branch &#x27;dev&#x27; from &#x27;origin&#x27;.</span><br><span class="line">fatal: A branch named &#x27;master&#x27; already exists.</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash"> git branch -a</span></span><br><span class="line">  dev</span><br><span class="line">* master</span><br><span class="line">  remotes/origin/HEAD -&gt; origin/master</span><br><span class="line">  remotes/origin/dev</span><br><span class="line">  remotes/origin/master</span><br></pre></td></tr></table></figure>

<p><strong>2 –&gt; 将本地所有分支与远程保持同步</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git fetch --all</span></span><br><span class="line">Fetching origin</span><br></pre></td></tr></table></figure>

<p><strong>3 –&gt; 拉取所有分支代码</strong></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> git pull --all</span></span><br><span class="line">Fetching origin</span><br><span class="line">Already up to date.</span><br></pre></td></tr></table></figure>

<hr>
</div><div class="article-licensing box"><div class="licensing-title"><p>Git 使用指南之分支管理</p><p><a href="https://www.orangeshare.cn/2017/07/04/git-shi-yong-zhi-nan-zhi-fen-zhi-guan-li/">https://www.orangeshare.cn/2017/07/04/git-shi-yong-zhi-nan-zhi-fen-zhi-guan-li/</a></p></div><div class="licensing-meta level is-mobile"><div class="level-left"><div class="level-item is-narrow"><div><h6>Author</h6><p>Waldeinsamkeit</p></div></div><div class="level-item is-narrow"><div><h6>Posted on</h6><p>2017-07-04</p></div></div><div class="level-item is-narrow"><div><h6>Updated on</h6><p>2022-03-08</p></div></div><div class="level-item is-narrow"><div><h6>Licensed under</h6><p><a class="icon" rel="noopener" target="_blank" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a><a class="icon" rel="noopener" target="_blank" title="Attribution" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a><a class="icon" rel="noopener" target="_blank" title="Noncommercial" href="https://creativecommons.org/licenses/by-nc/4.0/"><i class="fab fa-creative-commons-nc"></i></a></p></div></div></div></div></div><div class="article-tags is-size-7 mb-4"><span class="mr-2">#</span><a class="link-muted mr-2" rel="tag" href="/tags/Git/">Git</a><a class="link-muted mr-2" rel="tag" href="/tags/Github/">Github</a></div><div class="notification is-danger">You need to set <code>install_url</code> to use ShareThis. Please set it in <code>_config.yml</code>.</div></article></div><div class="card"><div class="card-content"><h3 class="menu-label has-text-centered">Like this article? Support the author with</h3><div class="buttons is-centered"><a class="button donate" data-type="alipay"><span class="icon is-small"><i class="fab fa-alipay"></i></span><span>Alipay</span><span class="qrcode"><img src="/" alt="Alipay"></span></a><a class="button donate" data-type="wechat"><span class="icon is-small"><i class="fab fa-weixin"></i></span><span>Wechat</span><span class="qrcode"><img src="/" alt="Wechat"></span></a></div></div></div><nav class="post-navigation mt-4 level is-mobile"><div class="level-start"><a class="article-nav-prev level level-item link-muted" href="/2017/07/05/git-shi-yong-zhi-nan-zhi-workflow-gong-zuo-liu/"><i class="level-item fas fa-chevron-left"></i><span class="level-item">Git 使用指南之 WorkFlow (工作流)</span></a></div><div class="level-end"><a class="article-nav-next level level-item link-muted" href="/2017/07/03/git-shi-yong-zhi-nan-zhi-yuan-cheng-cang-ku/"><span class="level-item">Git 使用指南之远程仓库</span><i class="level-item fas fa-chevron-right"></i></a></div></nav><div class="card"><div class="card-content"><h3 class="title is-5">Comments</h3><div class="notification is-danger">You forgot to set the <code>shortname</code> for Disqus. Please set it in <code>_config.yml</code>.</div></div></div></div><!--!--><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen  order-3 is-sticky"><div class="card widget" data-type="profile"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="Waldeinsamkeit"></figure><p class="title is-size-4 is-block" style="line-height:inherit;">Waldeinsamkeit</p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">88</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">10</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">39</p></a></div></div></nav></div></div><div class="card widget" id="toc" data-type="toc"><div class="card-content"><div class="menu"><h3 class="menu-label">Catalogue</h3><ul class="menu-list"><li><a class="level is-mobile" href="#Meet-Branchs-Management"><span class="level-left"><span class="level-item">1</span><span class="level-item">Meet Branchs Management</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Branch-指针"><span class="level-left"><span class="level-item">1.1</span><span class="level-item">Branch 指针</span></span></a></li><li><a class="level is-mobile" href="#HEAD-指针"><span class="level-left"><span class="level-item">1.2</span><span class="level-item">HEAD 指针</span></span></a></li><li><a class="level is-mobile" href="#Branch-Working-Principle-Diagram"><span class="level-left"><span class="level-item">1.3</span><span class="level-item">Branch Working Principle Diagram</span></span></a></li></ul></li><li><a class="level is-mobile" href="#玩转-Branch-必备技能"><span class="level-left"><span class="level-item">2</span><span class="level-item">玩转 Branch 必备技能</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#创建分支"><span class="level-left"><span class="level-item">2.1</span><span class="level-item">创建分支</span></span></a></li><li><a class="level is-mobile" href="#查看分支"><span class="level-left"><span class="level-item">2.2</span><span class="level-item">查看分支</span></span></a></li><li><a class="level is-mobile" href="#重命名分支"><span class="level-left"><span class="level-item">2.3</span><span class="level-item">重命名分支</span></span></a></li><li><a class="level is-mobile" href="#检出-切换分支"><span class="level-left"><span class="level-item">2.4</span><span class="level-item">检出/切换分支</span></span></a></li><li><a class="level is-mobile" href="#删除分支"><span class="level-left"><span class="level-item">2.5</span><span class="level-item">删除分支</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Branch-合并大事记"><span class="level-left"><span class="level-item">3</span><span class="level-item">Branch 合并大事记</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Fast-Forward"><span class="level-left"><span class="level-item">3.1</span><span class="level-item">Fast-Forward</span></span></a></li><li><a class="level is-mobile" href="#Recursive-Strategy-Merge"><span class="level-left"><span class="level-item">3.2</span><span class="level-item">Recursive Strategy Merge</span></span></a></li><li><a class="level is-mobile" href="#Branch-Demo"><span class="level-left"><span class="level-item">3.3</span><span class="level-item">Branch Demo</span></span></a></li><li><a class="level is-mobile" href="#No-Fast-Forward"><span class="level-left"><span class="level-item">3.4</span><span class="level-item">No Fast Forward</span></span></a></li></ul></li><li><a class="level is-mobile" href="#和平解决-Branch-合并冲突"><span class="level-left"><span class="level-item">4</span><span class="level-item">和平解决 Branch 合并冲突</span></span></a></li><li><a class="level is-mobile" href="#关联本地分支-amp-amp-远程分支"><span class="level-left"><span class="level-item">5</span><span class="level-item">关联本地分支&amp;&amp;远程分支</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Git-Pull-amp-amp-Git-Push-参数详解"><span class="level-left"><span class="level-item">5.1</span><span class="level-item">Git Pull &amp;&amp; Git Push 参数详解</span></span></a></li><li><a class="level is-mobile" href="#关联方法"><span class="level-left"><span class="level-item">5.2</span><span class="level-item">关联方法</span></span></a></li><li><a class="level is-mobile" href="#撤销关联"><span class="level-left"><span class="level-item">5.3</span><span class="level-item">撤销关联</span></span></a></li><li><a class="level is-mobile" href="#Demo"><span class="level-left"><span class="level-item">5.4</span><span class="level-item">Demo</span></span></a></li></ul></li><li><a class="level is-mobile" href="#Data-Flow-In-Git"><span class="level-left"><span class="level-item">6</span><span class="level-item">Data Flow In Git</span></span></a></li><li><a class="level is-mobile" href="#Get-Branch-From-RemoteRepo"><span class="level-left"><span class="level-item">7</span><span class="level-item">Get Branch From RemoteRepo</span></span></a><ul class="menu-list"><li><a class="level is-mobile" href="#Pull-a-specified-branch"><span class="level-left"><span class="level-item">7.1</span><span class="level-item">Pull a specified branch</span></span></a></li><li><a class="level is-mobile" href="#Sync-remote-branch"><span class="level-left"><span class="level-item">7.2</span><span class="level-item">Sync remote branch</span></span></a></li></ul></li></ul></div></div><style>#toc .menu-list > li > a.is-active + .menu-list { display: block; }#toc .menu-list > li > a + .menu-list { display: none; }</style><script src="/js/toc.js" defer></script></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="When Art Meets Tech" height="28"></a><p class="is-size-7"><span>&copy; 2023 Waldeinsamkeit</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p></div></div></div></div></footer><script src="https://cdnjs.loli.net/ajax/libs/jquery/3.3.1/jquery.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/moment.js/2.22.2/moment-with-locales.min.js"></script><script src="https://cdnjs.loli.net/ajax/libs/clipboard.js/2.0.4/clipboard.min.js" async></script><script>moment.locale("en");</script><script>var IcarusThemeSettings = {
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="/js/column.js"></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><!--!--><script src="https://cdnjs.loli.net/ajax/libs/cookieconsent/3.1.1/cookieconsent.min.js" defer></script><script>window.addEventListener("load", () => {
      window.cookieconsent.initialise({
        type: "info",
        theme: "edgeless",
        static: false,
        position: "bottom-left",
        content: {
          message: "This website uses cookies to improve your experience.",
          dismiss: "Got it!",
          allow: "Allow cookies",
          deny: "Decline",
          link: "Learn more",
          policy: "Cookie Policy",
          href: "https://www.cookiesandyou.com/",
        },
        palette: {
          popup: {
            background: "#edeff5",
            text: "#838391"
          },
          button: {
            background: "#4b81e8"
          },
        },
      });
    });</script><script src="https://cdnjs.loli.net/ajax/libs/lightgallery/1.6.8/js/lightgallery.min.js" defer></script><script src="https://cdnjs.loli.net/ajax/libs/justifiedGallery/3.7.0/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><!--!--><!--!--><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>